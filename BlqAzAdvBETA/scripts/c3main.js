import "./../box2d.wasm.js";
// Generated by Construct, the game and animation creation tool
// Visit: https://www.construct.net

var __create = Object.create, __defProp = Object.defineProperty, __getOwnPropDesc = Object.getOwnPropertyDescriptor, __getOwnPropNames = Object.getOwnPropertyNames, __getProtoOf = Object.getPrototypeOf, __hasOwnProp = Object.prototype.hasOwnProperty, __commonJS = (t, e) => function() {
    return e || (0, t[__getOwnPropNames(t)[0]])((e = {
        exports: {}
    }).exports, e), e.exports;
}, __copyProps = (e, s, i, r) => {
    if (s && "object" == typeof s || "function" == typeof s) for (let t of __getOwnPropNames(s)) __hasOwnProp.call(e, t) || t === i || __defProp(e, t, {
        get: () => s[t],
        enumerable: !(r = __getOwnPropDesc(s, t)) || r.enumerable
    });
    return e;
}, __toESM = (t, e, s) => (s = null != t ? __create(__getProtoOf(t)) : {}, __copyProps(!e && t && t.__esModule ? s : __defProp(s, "default", {
    value: t,
    enumerable: !0
}), t)), require_c3runtime = __commonJS({
    "file-map:scripts/c3runtime.js"(exports, module) {
        {
            let setMatrixArrayType2 = function(t) {
                ARRAY_TYPE = t;
            }, toRadian2 = function(t) {
                return t * degree;
            }, equals$92 = function(t, e) {
                return Math.abs(t - e) <= EPSILON * Math.max(1, Math.abs(t), Math.abs(e));
            }, create$82 = function() {
                var t = new ARRAY_TYPE(4);
                return ARRAY_TYPE != Float32Array && (t[1] = 0, t[2] = 0), t[0] = 1, 
                t[3] = 1, t;
            }, clone$82 = function(t) {
                var e = new ARRAY_TYPE(4);
                return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e;
            }, copy$82 = function(t, e) {
                return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t;
            }, identity$52 = function(t) {
                return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 1, t;
            }, fromValues$82 = function(t, e, s, i) {
                var r = new ARRAY_TYPE(4);
                return r[0] = t, r[1] = e, r[2] = s, r[3] = i, r;
            }, set$82 = function(t, e, s, i, r) {
                return t[0] = e, t[1] = s, t[2] = i, t[3] = r, t;
            }, transpose$22 = function(t, e) {
                var s;
                return t === e ? (s = e[1], t[1] = e[2], t[2] = s) : (t[0] = e[0], 
                t[1] = e[2], t[2] = e[1], t[3] = e[3]), t;
            }, invert$52 = function(t, e) {
                var s = e[0], i = e[1], r = e[2], n = s * (e = e[3]) - r * i;
                return n ? (t[0] = e * (n = 1 / n), t[1] = -i * n, t[2] = -r * n, 
                t[3] = s * n, t) : null;
            }, adjoint$22 = function(t, e) {
                var s = e[0];
                return t[0] = e[3], t[1] = -e[1], t[2] = -e[2], t[3] = s, t;
            }, determinant$32 = function(t) {
                return t[0] * t[3] - t[2] * t[1];
            }, multiply$82 = function(t, e, s) {
                var i = e[0], r = e[1], n = e[2], e = e[3], h = s[0], o = s[1], a = s[2], s = s[3];
                return t[0] = i * h + n * o, t[1] = r * h + e * o, t[2] = i * a + n * s, 
                t[3] = r * a + e * s, t;
            }, rotate$42 = function(t, e, s) {
                var i = e[0], r = e[1], n = e[2], e = e[3], h = Math.sin(s), s = Math.cos(s);
                return t[0] = i * s + n * h, t[1] = r * s + e * h, t[2] = i * -h + n * s, 
                t[3] = r * -h + e * s, t;
            }, scale$82 = function(t, e, s) {
                var i = e[0], r = e[1], n = e[2], e = e[3], h = s[0], s = s[1];
                return t[0] = i * h, t[1] = r * h, t[2] = n * s, t[3] = e * s, t;
            }, fromRotation$42 = function(t, e) {
                var s = Math.sin(e), e = Math.cos(e);
                return t[0] = e, t[1] = s, t[2] = -s, t[3] = e, t;
            }, fromScaling$32 = function(t, e) {
                return t[0] = e[0], t[1] = 0, t[2] = 0, t[3] = e[1], t;
            }, str$82 = function(t) {
                return "mat2(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ")";
            }, frob$32 = function(t) {
                return Math.hypot(t[0], t[1], t[2], t[3]);
            }, LDU2 = function(t, e, s, i) {
                return t[2] = i[2] / i[0], s[0] = i[0], s[1] = i[1], s[3] = i[3] - t[2] * s[1], 
                [ t, e, s ];
            }, add$82 = function(t, e, s) {
                return t[0] = e[0] + s[0], t[1] = e[1] + s[1], t[2] = e[2] + s[2], 
                t[3] = e[3] + s[3], t;
            }, subtract$62 = function(t, e, s) {
                return t[0] = e[0] - s[0], t[1] = e[1] - s[1], t[2] = e[2] - s[2], 
                t[3] = e[3] - s[3], t;
            }, exactEquals$82 = function(t, e) {
                return t[0] === e[0] && t[1] === e[1] && t[2] === e[2] && t[3] === e[3];
            }, equals$82 = function(t, e) {
                var s = t[0], i = t[1], r = t[2], t = t[3], n = e[0], h = e[1], o = e[2], e = e[3];
                return Math.abs(s - n) <= EPSILON * Math.max(1, Math.abs(s), Math.abs(n)) && Math.abs(i - h) <= EPSILON * Math.max(1, Math.abs(i), Math.abs(h)) && Math.abs(r - o) <= EPSILON * Math.max(1, Math.abs(r), Math.abs(o)) && Math.abs(t - e) <= EPSILON * Math.max(1, Math.abs(t), Math.abs(e));
            }, multiplyScalar$32 = function(t, e, s) {
                return t[0] = e[0] * s, t[1] = e[1] * s, t[2] = e[2] * s, t[3] = e[3] * s, 
                t;
            }, multiplyScalarAndAdd$32 = function(t, e, s, i) {
                return t[0] = e[0] + s[0] * i, t[1] = e[1] + s[1] * i, t[2] = e[2] + s[2] * i, 
                t[3] = e[3] + s[3] * i, t;
            }, create$72 = function() {
                var t = new ARRAY_TYPE(6);
                return ARRAY_TYPE != Float32Array && (t[1] = 0, t[2] = 0, t[4] = 0, 
                t[5] = 0), t[0] = 1, t[3] = 1, t;
            }, clone$72 = function(t) {
                var e = new ARRAY_TYPE(6);
                return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], 
                e[5] = t[5], e;
            }, copy$72 = function(t, e) {
                return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], 
                t[5] = e[5], t;
            }, identity$42 = function(t) {
                return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = 0, t[5] = 0, 
                t;
            }, fromValues$72 = function(t, e, s, i, r, n) {
                var h = new ARRAY_TYPE(6);
                return h[0] = t, h[1] = e, h[2] = s, h[3] = i, h[4] = r, h[5] = n, 
                h;
            }, set$72 = function(t, e, s, i, r, n, h) {
                return t[0] = e, t[1] = s, t[2] = i, t[3] = r, t[4] = n, t[5] = h, 
                t;
            }, invert$42 = function(t, e) {
                var s = e[0], i = e[1], r = e[2], n = e[3], h = e[4], e = e[5], o = s * n - i * r;
                return o ? (t[0] = n * (o = 1 / o), t[1] = -i * o, t[2] = -r * o, 
                t[3] = s * o, t[4] = (r * e - n * h) * o, t[5] = (i * h - s * e) * o, 
                t) : null;
            }, determinant$22 = function(t) {
                return t[0] * t[3] - t[1] * t[2];
            }, multiply$72 = function(t, e, s) {
                var i = e[0], r = e[1], n = e[2], h = e[3], o = e[4], e = e[5], a = s[0], l = s[1], u = s[2], c = s[3], f = s[4], s = s[5];
                return t[0] = i * a + n * l, t[1] = r * a + h * l, t[2] = i * u + n * c, 
                t[3] = r * u + h * c, t[4] = i * f + n * s + o, t[5] = r * f + h * s + e, 
                t;
            }, rotate$32 = function(t, e, s) {
                var i = e[0], r = e[1], n = e[2], h = e[3], o = e[4], e = e[5], a = Math.sin(s), s = Math.cos(s);
                return t[0] = i * s + n * a, t[1] = r * s + h * a, t[2] = i * -a + n * s, 
                t[3] = r * -a + h * s, t[4] = o, t[5] = e, t;
            }, scale$72 = function(t, e, s) {
                var i = e[0], r = e[1], n = e[2], h = e[3], o = e[4], e = e[5], a = s[0], s = s[1];
                return t[0] = i * a, t[1] = r * a, t[2] = n * s, t[3] = h * s, t[4] = o, 
                t[5] = e, t;
            }, translate$32 = function(t, e, s) {
                var i = e[0], r = e[1], n = e[2], h = e[3], o = e[4], e = e[5], a = s[0], s = s[1];
                return t[0] = i, t[1] = r, t[2] = n, t[3] = h, t[4] = i * a + n * s + o, 
                t[5] = r * a + h * s + e, t;
            }, fromRotation$32 = function(t, e) {
                var s = Math.sin(e), e = Math.cos(e);
                return t[0] = e, t[1] = s, t[2] = -s, t[3] = e, t[4] = 0, t[5] = 0, 
                t;
            }, fromScaling$22 = function(t, e) {
                return t[0] = e[0], t[1] = 0, t[2] = 0, t[3] = e[1], t[4] = 0, t[5] = 0, 
                t;
            }, fromTranslation$32 = function(t, e) {
                return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = e[0], t[5] = e[1], 
                t;
            }, str$72 = function(t) {
                return "mat2d(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ", " + t[4] + ", " + t[5] + ")";
            }, frob$22 = function(t) {
                return Math.hypot(t[0], t[1], t[2], t[3], t[4], t[5], 1);
            }, add$72 = function(t, e, s) {
                return t[0] = e[0] + s[0], t[1] = e[1] + s[1], t[2] = e[2] + s[2], 
                t[3] = e[3] + s[3], t[4] = e[4] + s[4], t[5] = e[5] + s[5], t;
            }, subtract$52 = function(t, e, s) {
                return t[0] = e[0] - s[0], t[1] = e[1] - s[1], t[2] = e[2] - s[2], 
                t[3] = e[3] - s[3], t[4] = e[4] - s[4], t[5] = e[5] - s[5], t;
            }, multiplyScalar$22 = function(t, e, s) {
                return t[0] = e[0] * s, t[1] = e[1] * s, t[2] = e[2] * s, t[3] = e[3] * s, 
                t[4] = e[4] * s, t[5] = e[5] * s, t;
            }, multiplyScalarAndAdd$22 = function(t, e, s, i) {
                return t[0] = e[0] + s[0] * i, t[1] = e[1] + s[1] * i, t[2] = e[2] + s[2] * i, 
                t[3] = e[3] + s[3] * i, t[4] = e[4] + s[4] * i, t[5] = e[5] + s[5] * i, 
                t;
            }, exactEquals$72 = function(t, e) {
                return t[0] === e[0] && t[1] === e[1] && t[2] === e[2] && t[3] === e[3] && t[4] === e[4] && t[5] === e[5];
            }, equals$72 = function(t, e) {
                var s = t[0], i = t[1], r = t[2], n = t[3], h = t[4], t = t[5], o = e[0], a = e[1], l = e[2], u = e[3], c = e[4], e = e[5];
                return Math.abs(s - o) <= EPSILON * Math.max(1, Math.abs(s), Math.abs(o)) && Math.abs(i - a) <= EPSILON * Math.max(1, Math.abs(i), Math.abs(a)) && Math.abs(r - l) <= EPSILON * Math.max(1, Math.abs(r), Math.abs(l)) && Math.abs(n - u) <= EPSILON * Math.max(1, Math.abs(n), Math.abs(u)) && Math.abs(h - c) <= EPSILON * Math.max(1, Math.abs(h), Math.abs(c)) && Math.abs(t - e) <= EPSILON * Math.max(1, Math.abs(t), Math.abs(e));
            }, create$62 = function() {
                var t = new ARRAY_TYPE(9);
                return ARRAY_TYPE != Float32Array && (t[1] = 0, t[2] = 0, t[3] = 0, 
                t[5] = 0, t[6] = 0, t[7] = 0), t[0] = 1, t[4] = 1, t[8] = 1, t;
            }, fromMat4$12 = function(t, e) {
                return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[4], t[4] = e[5], 
                t[5] = e[6], t[6] = e[8], t[7] = e[9], t[8] = e[10], t;
            }, clone$62 = function(t) {
                var e = new ARRAY_TYPE(9);
                return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], 
                e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e;
            }, copy$62 = function(t, e) {
                return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], 
                t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t;
            }, fromValues$62 = function(t, e, s, i, r, n, h, o, a) {
                var l = new ARRAY_TYPE(9);
                return l[0] = t, l[1] = e, l[2] = s, l[3] = i, l[4] = r, l[5] = n, 
                l[6] = h, l[7] = o, l[8] = a, l;
            }, set$62 = function(t, e, s, i, r, n, h, o, a, l) {
                return t[0] = e, t[1] = s, t[2] = i, t[3] = r, t[4] = n, t[5] = h, 
                t[6] = o, t[7] = a, t[8] = l, t;
            }, identity$32 = function(t) {
                return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 1, t[5] = 0, 
                t[6] = 0, t[7] = 0, t[8] = 1, t;
            }, transpose$12 = function(t, e) {
                var s, i, r;
                return t === e ? (s = e[1], i = e[2], r = e[5], t[1] = e[3], t[2] = e[6], 
                t[3] = s, t[5] = e[7], t[6] = i, t[7] = r) : (t[0] = e[0], t[1] = e[3], 
                t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], 
                t[7] = e[5], t[8] = e[8]), t;
            }, invert$32 = function(t, e) {
                var s = e[0], i = e[1], r = e[2], n = e[3], h = e[4], o = e[5], a = e[6], l = e[7], u = (e = e[8]) * h - o * l, c = -e * n + o * a, f = l * n - h * a, d = s * u + i * c + r * f;
                return d ? (t[0] = u * (d = 1 / d), t[1] = (-e * i + r * l) * d, 
                t[2] = (o * i - r * h) * d, t[3] = c * d, t[4] = (e * s - r * a) * d, 
                t[5] = (-o * s + r * n) * d, t[6] = f * d, t[7] = (-l * s + i * a) * d, 
                t[8] = (h * s - i * n) * d, t) : null;
            }, adjoint$12 = function(t, e) {
                var s = e[0], i = e[1], r = e[2], n = e[3], h = e[4], o = e[5], a = e[6], l = e[7], e = e[8];
                return t[0] = h * e - o * l, t[1] = r * l - i * e, t[2] = i * o - r * h, 
                t[3] = o * a - n * e, t[4] = s * e - r * a, t[5] = r * n - s * o, 
                t[6] = n * l - h * a, t[7] = i * a - s * l, t[8] = s * h - i * n, 
                t;
            }, determinant$12 = function(t) {
                var e = t[0], s = t[3], i = t[4], r = t[5], n = t[6], h = t[7], o = t[8];
                return e * (o * i - r * h) + t[1] * (-o * s + r * n) + t[2] * (h * s - i * n);
            }, multiply$62 = function(t, e, s) {
                var i = e[0], r = e[1], n = e[2], h = e[3], o = e[4], a = e[5], l = e[6], u = e[7], e = e[8], c = s[0], f = s[1], d = s[2], p = s[3], m = s[4], C = s[5], g = s[6], S = s[7], s = s[8];
                return t[0] = c * i + f * h + d * l, t[1] = c * r + f * o + d * u, 
                t[2] = c * n + f * a + d * e, t[3] = p * i + m * h + C * l, t[4] = p * r + m * o + C * u, 
                t[5] = p * n + m * a + C * e, t[6] = g * i + S * h + s * l, t[7] = g * r + S * o + s * u, 
                t[8] = g * n + S * a + s * e, t;
            }, translate$22 = function(t, e, s) {
                var i = e[0], r = e[1], n = e[2], h = e[3], o = e[4], a = e[5], l = e[6], u = e[7], e = e[8], c = s[0], s = s[1];
                return t[0] = i, t[1] = r, t[2] = n, t[3] = h, t[4] = o, t[5] = a, 
                t[6] = c * i + s * h + l, t[7] = c * r + s * o + u, t[8] = c * n + s * a + e, 
                t;
            }, rotate$22 = function(t, e, s) {
                var i = e[0], r = e[1], n = e[2], h = e[3], o = e[4], a = e[5], l = e[6], u = e[7], e = e[8], c = Math.sin(s), s = Math.cos(s);
                return t[0] = s * i + c * h, t[1] = s * r + c * o, t[2] = s * n + c * a, 
                t[3] = s * h - c * i, t[4] = s * o - c * r, t[5] = s * a - c * n, 
                t[6] = l, t[7] = u, t[8] = e, t;
            }, scale$62 = function(t, e, s) {
                var i = s[0], s = s[1];
                return t[0] = i * e[0], t[1] = i * e[1], t[2] = i * e[2], t[3] = s * e[3], 
                t[4] = s * e[4], t[5] = s * e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], 
                t;
            }, fromTranslation$22 = function(t, e) {
                return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 1, t[5] = 0, 
                t[6] = e[0], t[7] = e[1], t[8] = 1, t;
            }, fromRotation$22 = function(t, e) {
                var s = Math.sin(e), e = Math.cos(e);
                return t[0] = e, t[1] = s, t[2] = 0, t[3] = -s, t[4] = e, t[5] = 0, 
                t[6] = 0, t[7] = 0, t[8] = 1, t;
            }, fromScaling$12 = function(t, e) {
                return t[0] = e[0], t[1] = 0, t[2] = 0, t[3] = 0, t[4] = e[1], t[5] = 0, 
                t[6] = 0, t[7] = 0, t[8] = 1, t;
            }, fromMat2d2 = function(t, e) {
                return t[0] = e[0], t[1] = e[1], t[2] = 0, t[3] = e[2], t[4] = e[3], 
                t[5] = 0, t[6] = e[4], t[7] = e[5], t[8] = 1, t;
            }, fromQuat$12 = function(t, e) {
                var s = e[0], i = e[2], r = i + i, s = s * (l = s + s), n = (h = e[1]) * l, h = h * (u = h + h), o = i * l, a = i * u, l = (e = e[3]) * l, u = e * u, e = e * r;
                return t[0] = 1 - h - (i = i * r), t[3] = n - e, t[6] = o + u, t[1] = n + e, 
                t[4] = 1 - s - i, t[7] = a - l, t[2] = o - u, t[5] = a + l, t[8] = 1 - s - h, 
                t;
            }, normalFromMat42 = function(t, e) {
                var s = e[0], i = e[1], r = e[2], n = e[3], h = e[4], o = e[5], a = e[6], l = e[7], u = e[8], c = e[9], f = e[10], d = e[11], p = e[12], m = e[13], C = e[14], g = s * o - i * h, S = s * a - r * h, _ = s * l - n * h, T = i * a - r * o, y = i * l - n * o, E = r * l - n * a, A = u * m - c * p, I = u * C - f * p, M = c * C - f * m;
                return (d = g * (f = f * (e = e[15]) - d * C) - S * (c = c * e - d * m) + _ * M + T * (u = u * e - d * p) - y * I + E * A) ? (t[0] = (o * f - a * c + l * M) * (d = 1 / d), 
                t[1] = (a * u - h * f - l * I) * d, t[2] = (h * c - o * u + l * A) * d, 
                t[3] = (r * c - i * f - n * M) * d, t[4] = (s * f - r * u + n * I) * d, 
                t[5] = (i * u - s * c - n * A) * d, t[6] = (m * E - C * y + e * T) * d, 
                t[7] = (C * _ - p * E - e * S) * d, t[8] = (p * y - m * _ + e * g) * d, 
                t) : null;
            }, projection2 = function(t, e, s) {
                return t[0] = 2 / e, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = -2 / s, 
                t[5] = 0, t[6] = -1, t[7] = 1, t[8] = 1, t;
            }, str$62 = function(t) {
                return "mat3(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ", " + t[4] + ", " + t[5] + ", " + t[6] + ", " + t[7] + ", " + t[8] + ")";
            }, frob$12 = function(t) {
                return Math.hypot(t[0], t[1], t[2], t[3], t[4], t[5], t[6], t[7], t[8]);
            }, add$62 = function(t, e, s) {
                return t[0] = e[0] + s[0], t[1] = e[1] + s[1], t[2] = e[2] + s[2], 
                t[3] = e[3] + s[3], t[4] = e[4] + s[4], t[5] = e[5] + s[5], t[6] = e[6] + s[6], 
                t[7] = e[7] + s[7], t[8] = e[8] + s[8], t;
            }, subtract$42 = function(t, e, s) {
                return t[0] = e[0] - s[0], t[1] = e[1] - s[1], t[2] = e[2] - s[2], 
                t[3] = e[3] - s[3], t[4] = e[4] - s[4], t[5] = e[5] - s[5], t[6] = e[6] - s[6], 
                t[7] = e[7] - s[7], t[8] = e[8] - s[8], t;
            }, multiplyScalar$12 = function(t, e, s) {
                return t[0] = e[0] * s, t[1] = e[1] * s, t[2] = e[2] * s, t[3] = e[3] * s, 
                t[4] = e[4] * s, t[5] = e[5] * s, t[6] = e[6] * s, t[7] = e[7] * s, 
                t[8] = e[8] * s, t;
            }, multiplyScalarAndAdd$12 = function(t, e, s, i) {
                return t[0] = e[0] + s[0] * i, t[1] = e[1] + s[1] * i, t[2] = e[2] + s[2] * i, 
                t[3] = e[3] + s[3] * i, t[4] = e[4] + s[4] * i, t[5] = e[5] + s[5] * i, 
                t[6] = e[6] + s[6] * i, t[7] = e[7] + s[7] * i, t[8] = e[8] + s[8] * i, 
                t;
            }, exactEquals$62 = function(t, e) {
                return t[0] === e[0] && t[1] === e[1] && t[2] === e[2] && t[3] === e[3] && t[4] === e[4] && t[5] === e[5] && t[6] === e[6] && t[7] === e[7] && t[8] === e[8];
            }, equals$62 = function(t, e) {
                var s = t[0], i = t[1], r = t[2], n = t[3], h = t[4], o = t[5], a = t[6], l = t[7], t = t[8], u = e[0], c = e[1], f = e[2], d = e[3], p = e[4], m = e[5], C = e[6], g = e[7], e = e[8];
                return Math.abs(s - u) <= EPSILON * Math.max(1, Math.abs(s), Math.abs(u)) && Math.abs(i - c) <= EPSILON * Math.max(1, Math.abs(i), Math.abs(c)) && Math.abs(r - f) <= EPSILON * Math.max(1, Math.abs(r), Math.abs(f)) && Math.abs(n - d) <= EPSILON * Math.max(1, Math.abs(n), Math.abs(d)) && Math.abs(h - p) <= EPSILON * Math.max(1, Math.abs(h), Math.abs(p)) && Math.abs(o - m) <= EPSILON * Math.max(1, Math.abs(o), Math.abs(m)) && Math.abs(a - C) <= EPSILON * Math.max(1, Math.abs(a), Math.abs(C)) && Math.abs(l - g) <= EPSILON * Math.max(1, Math.abs(l), Math.abs(g)) && Math.abs(t - e) <= EPSILON * Math.max(1, Math.abs(t), Math.abs(e));
            }, create$52 = function() {
                var t = new ARRAY_TYPE(16);
                return ARRAY_TYPE != Float32Array && (t[1] = 0, t[2] = 0, t[3] = 0, 
                t[4] = 0, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[11] = 0, t[12] = 0, 
                t[13] = 0, t[14] = 0), t[0] = 1, t[5] = 1, t[10] = 1, t[15] = 1, 
                t;
            }, clone$52 = function(t) {
                var e = new ARRAY_TYPE(16);
                return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], 
                e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e[9] = t[9], 
                e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], 
                e[15] = t[15], e;
            }, copy$52 = function(t, e) {
                return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], 
                t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t[9] = e[9], 
                t[10] = e[10], t[11] = e[11], t[12] = e[12], t[13] = e[13], t[14] = e[14], 
                t[15] = e[15], t;
            }, fromValues$52 = function(t, e, s, i, r, n, h, o, a, l, u, c, f, d, p, m) {
                var C = new ARRAY_TYPE(16);
                return C[0] = t, C[1] = e, C[2] = s, C[3] = i, C[4] = r, C[5] = n, 
                C[6] = h, C[7] = o, C[8] = a, C[9] = l, C[10] = u, C[11] = c, C[12] = f, 
                C[13] = d, C[14] = p, C[15] = m, C;
            }, set$52 = function(t, e, s, i, r, n, h, o, a, l, u, c, f, d, p, m, C) {
                return t[0] = e, t[1] = s, t[2] = i, t[3] = r, t[4] = n, t[5] = h, 
                t[6] = o, t[7] = a, t[8] = l, t[9] = u, t[10] = c, t[11] = f, t[12] = d, 
                t[13] = p, t[14] = m, t[15] = C, t;
            }, identity$22 = function(t) {
                return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, 
                t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, 
                t[13] = 0, t[14] = 0, t[15] = 1, t;
            }, transpose2 = function(t, e) {
                var s, i, r, n, h, o;
                return t === e ? (s = e[1], i = e[2], r = e[3], n = e[6], h = e[7], 
                o = e[11], t[1] = e[4], t[2] = e[8], t[3] = e[12], t[4] = s, t[6] = e[9], 
                t[7] = e[13], t[8] = i, t[9] = n, t[11] = e[14], t[12] = r, t[13] = h, 
                t[14] = o) : (t[0] = e[0], t[1] = e[4], t[2] = e[8], t[3] = e[12], 
                t[4] = e[1], t[5] = e[5], t[6] = e[9], t[7] = e[13], t[8] = e[2], 
                t[9] = e[6], t[10] = e[10], t[11] = e[14], t[12] = e[3], t[13] = e[7], 
                t[14] = e[11], t[15] = e[15]), t;
            }, invert$22 = function(t, e) {
                var s = e[0], i = e[1], r = e[2], n = e[3], h = e[4], o = e[5], a = e[6], l = e[7], u = e[8], c = e[9], f = e[10], d = e[11], p = e[12], m = e[13], C = e[14], g = s * o - i * h, S = s * a - r * h, _ = s * l - n * h, T = i * a - r * o, y = i * l - n * o, E = r * l - n * a, A = u * m - c * p, I = u * C - f * p, M = u * (e = e[15]) - d * p, w = c * C - f * m, v = c * e - d * m, R = f * e - d * C, b = g * R - S * v + _ * w + T * M - y * I + E * A;
                return b ? (t[0] = (o * R - a * v + l * w) * (b = 1 / b), t[1] = (r * v - i * R - n * w) * b, 
                t[2] = (m * E - C * y + e * T) * b, t[3] = (f * y - c * E - d * T) * b, 
                t[4] = (a * M - h * R - l * I) * b, t[5] = (s * R - r * M + n * I) * b, 
                t[6] = (C * _ - p * E - e * S) * b, t[7] = (u * E - f * _ + d * S) * b, 
                t[8] = (h * v - o * M + l * A) * b, t[9] = (i * M - s * v - n * A) * b, 
                t[10] = (p * y - m * _ + e * g) * b, t[11] = (c * _ - u * y - d * g) * b, 
                t[12] = (o * I - h * w - a * A) * b, t[13] = (s * w - i * I + r * A) * b, 
                t[14] = (m * S - p * T - C * g) * b, t[15] = (u * T - c * S + f * g) * b, 
                t) : null;
            }, adjoint2 = function(t, e) {
                var s = e[0], i = e[1], r = e[2], n = e[3], h = e[4], o = e[5], a = e[6], l = e[7], u = e[8], c = e[9], f = e[10], d = e[11], p = e[12], m = e[13], C = e[14], g = s * o - i * h, S = s * a - r * h, _ = s * l - n * h, T = i * a - r * o, y = i * l - n * o, E = r * l - n * a, A = u * m - c * p, I = u * C - f * p, M = u * (e = e[15]) - d * p, w = c * C - f * m, v = c * e - d * m, R = f * e - d * C;
                return t[0] = o * R - a * v + l * w, t[1] = r * v - i * R - n * w, 
                t[2] = m * E - C * y + e * T, t[3] = f * y - c * E - d * T, t[4] = a * M - h * R - l * I, 
                t[5] = s * R - r * M + n * I, t[6] = C * _ - p * E - e * S, t[7] = u * E - f * _ + d * S, 
                t[8] = h * v - o * M + l * A, t[9] = i * M - s * v - n * A, t[10] = p * y - m * _ + e * g, 
                t[11] = c * _ - u * y - d * g, t[12] = o * I - h * w - a * A, t[13] = s * w - i * I + r * A, 
                t[14] = m * S - p * T - C * g, t[15] = u * T - c * S + f * g, t;
            }, determinant2 = function(t) {
                var e = t[0], s = t[1], i = t[2], r = t[4], n = t[5], h = t[6], o = t[8], a = t[9], l = t[10], u = t[12], c = t[13], f = t[14], d = e * n - s * r, p = e * h - i * r, m = s * h - i * n, C = o * c - a * u, g = o * f - l * u, S = a * f - l * c;
                return t[7] * (e * S - s * g + i * C) - t[3] * (r * S - n * g + h * C) + t[15] * (o * m - a * p + l * d) - t[11] * (u * m - c * p + f * d);
            }, multiply$52 = function(t, e, s) {
                var i = e[0], r = e[1], n = e[2], h = e[3], o = e[4], a = e[5], l = e[6], u = e[7], c = e[8], f = e[9], d = e[10], p = e[11], m = e[12], C = e[13], g = e[14], e = e[15], S = s[0], _ = s[1], T = s[2], y = s[3];
                return t[0] = S * i + _ * o + T * c + y * m, t[1] = S * r + _ * a + T * f + y * C, 
                t[2] = S * n + _ * l + T * d + y * g, t[3] = S * h + _ * u + T * p + y * e, 
                t[4] = (S = s[4]) * i + (_ = s[5]) * o + (T = s[6]) * c + (y = s[7]) * m, 
                t[5] = S * r + _ * a + T * f + y * C, t[6] = S * n + _ * l + T * d + y * g, 
                t[7] = S * h + _ * u + T * p + y * e, t[8] = (S = s[8]) * i + (_ = s[9]) * o + (T = s[10]) * c + (y = s[11]) * m, 
                t[9] = S * r + _ * a + T * f + y * C, t[10] = S * n + _ * l + T * d + y * g, 
                t[11] = S * h + _ * u + T * p + y * e, t[12] = (S = s[12]) * i + (_ = s[13]) * o + (T = s[14]) * c + (y = s[15]) * m, 
                t[13] = S * r + _ * a + T * f + y * C, t[14] = S * n + _ * l + T * d + y * g, 
                t[15] = S * h + _ * u + T * p + y * e, t;
            }, translate$12 = function(t, e, s) {
                var i, r, n, h, o, a, l, u, c, f, d, p, m = s[0], C = s[1], s = s[2];
                return e === t ? (t[12] = e[0] * m + e[4] * C + e[8] * s + e[12], 
                t[13] = e[1] * m + e[5] * C + e[9] * s + e[13], t[14] = e[2] * m + e[6] * C + e[10] * s + e[14], 
                t[15] = e[3] * m + e[7] * C + e[11] * s + e[15]) : (i = e[0], r = e[1], 
                n = e[2], h = e[3], o = e[4], a = e[5], l = e[6], u = e[7], c = e[8], 
                f = e[9], d = e[10], p = e[11], t[0] = i, t[1] = r, t[2] = n, t[3] = h, 
                t[4] = o, t[5] = a, t[6] = l, t[7] = u, t[8] = c, t[9] = f, t[10] = d, 
                t[11] = p, t[12] = i * m + o * C + c * s + e[12], t[13] = r * m + a * C + f * s + e[13], 
                t[14] = n * m + l * C + d * s + e[14], t[15] = h * m + u * C + p * s + e[15]), 
                t;
            }, scale$52 = function(t, e, s) {
                var i = s[0], r = s[1], s = s[2];
                return t[0] = e[0] * i, t[1] = e[1] * i, t[2] = e[2] * i, t[3] = e[3] * i, 
                t[4] = e[4] * r, t[5] = e[5] * r, t[6] = e[6] * r, t[7] = e[7] * r, 
                t[8] = e[8] * s, t[9] = e[9] * s, t[10] = e[10] * s, t[11] = e[11] * s, 
                t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15], t;
            }, rotate$12 = function(t, e, s, i) {
                var r, n, h, o, a, l, u, c, f, d, p, m, C, g, S, _, T, y, E, A, I = i[0], M = i[1], i = i[2], w = Math.hypot(I, M, i);
                return w < EPSILON ? null : (I *= w = 1 / w, M *= w, i *= w, w = Math.sin(s), 
                s = Math.cos(s), n = e[0], h = e[1], o = e[2], a = e[3], u = e[5], 
                c = e[6], f = e[7], p = e[9], m = e[10], C = e[11], S = I * M * (r = 1 - s) - i * w, 
                _ = M * M * r + s, T = i * M * r + I * w, y = I * i * r + M * w, 
                E = M * i * r - I * w, A = i * i * r + s, t[0] = n * (s = I * I * r + s) + (l = e[4]) * (g = M * I * r + i * w) + (d = e[8]) * (i = i * I * r - M * w), 
                t[1] = h * s + u * g + p * i, t[2] = o * s + c * g + m * i, t[3] = a * s + f * g + C * i, 
                t[4] = n * S + l * _ + d * T, t[5] = h * S + u * _ + p * T, t[6] = o * S + c * _ + m * T, 
                t[7] = a * S + f * _ + C * T, t[8] = n * y + l * E + d * A, t[9] = h * y + u * E + p * A, 
                t[10] = o * y + c * E + m * A, t[11] = a * y + f * E + C * A, e !== t && (t[12] = e[12], 
                t[13] = e[13], t[14] = e[14], t[15] = e[15]), t);
            }, rotateX$32 = function(t, e, s) {
                var i = Math.sin(s), s = Math.cos(s), r = e[4], n = e[5], h = e[6], o = e[7], a = e[8], l = e[9], u = e[10], c = e[11];
                return e !== t && (t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], 
                t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t[4] = r * s + a * i, 
                t[5] = n * s + l * i, t[6] = h * s + u * i, t[7] = o * s + c * i, 
                t[8] = a * s - r * i, t[9] = l * s - n * i, t[10] = u * s - h * i, 
                t[11] = c * s - o * i, t;
            }, rotateY$32 = function(t, e, s) {
                var i = Math.sin(s), s = Math.cos(s), r = e[0], n = e[1], h = e[2], o = e[3], a = e[8], l = e[9], u = e[10], c = e[11];
                return e !== t && (t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], 
                t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t[0] = r * s - a * i, 
                t[1] = n * s - l * i, t[2] = h * s - u * i, t[3] = o * s - c * i, 
                t[8] = r * i + a * s, t[9] = n * i + l * s, t[10] = h * i + u * s, 
                t[11] = o * i + c * s, t;
            }, rotateZ$32 = function(t, e, s) {
                var i = Math.sin(s), s = Math.cos(s), r = e[0], n = e[1], h = e[2], o = e[3], a = e[4], l = e[5], u = e[6], c = e[7];
                return e !== t && (t[8] = e[8], t[9] = e[9], t[10] = e[10], t[11] = e[11], 
                t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t[0] = r * s + a * i, 
                t[1] = n * s + l * i, t[2] = h * s + u * i, t[3] = o * s + c * i, 
                t[4] = a * s - r * i, t[5] = l * s - n * i, t[6] = u * s - h * i, 
                t[7] = c * s - o * i, t;
            }, fromTranslation$12 = function(t, e) {
                return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, 
                t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = e[0], 
                t[13] = e[1], t[14] = e[2], t[15] = 1, t;
            }, fromScaling2 = function(t, e) {
                return t[0] = e[0], t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = e[1], 
                t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = e[2], t[11] = 0, 
                t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;
            }, fromRotation$12 = function(t, e, s) {
                var i, r = s[0], n = s[1], s = s[2], h = Math.hypot(r, n, s);
                return h < EPSILON ? null : (r *= h = 1 / h, n *= h, s *= h, h = Math.sin(e), 
                e = Math.cos(e), t[0] = r * r * (i = 1 - e) + e, t[1] = n * r * i + s * h, 
                t[2] = s * r * i - n * h, t[3] = 0, t[4] = r * n * i - s * h, t[5] = n * n * i + e, 
                t[6] = s * n * i + r * h, t[7] = 0, t[8] = r * s * i + n * h, t[9] = n * s * i - r * h, 
                t[10] = s * s * i + e, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, 
                t[15] = 1, t);
            }, fromXRotation2 = function(t, e) {
                var s = Math.sin(e), e = Math.cos(e);
                return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = e, 
                t[6] = s, t[7] = 0, t[8] = 0, t[9] = -s, t[10] = e, t[11] = 0, t[12] = 0, 
                t[13] = 0, t[14] = 0, t[15] = 1, t;
            }, fromYRotation2 = function(t, e) {
                var s = Math.sin(e), e = Math.cos(e);
                return t[0] = e, t[1] = 0, t[2] = -s, t[3] = 0, t[4] = 0, t[5] = 1, 
                t[6] = 0, t[7] = 0, t[8] = s, t[9] = 0, t[10] = e, t[11] = 0, t[12] = 0, 
                t[13] = 0, t[14] = 0, t[15] = 1, t;
            }, fromZRotation2 = function(t, e) {
                var s = Math.sin(e), e = Math.cos(e);
                return t[0] = e, t[1] = s, t[2] = 0, t[3] = 0, t[4] = -s, t[5] = e, 
                t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, 
                t[13] = 0, t[14] = 0, t[15] = 1, t;
            }, fromRotationTranslation$12 = function(t, e, s) {
                var i = e[0], r = e[2], n = r + r, h = i * (u = i + i), o = i * (c = (l = e[1]) + l), i = i * n, a = l * c, l = l * n, u = (e = e[3]) * u, c = e * c, e = e * n;
                return t[0] = 1 - (a + (r = r * n)), t[1] = o + e, t[2] = i - c, 
                t[3] = 0, t[4] = o - e, t[5] = 1 - (h + r), t[6] = l + u, t[7] = 0, 
                t[8] = i + c, t[9] = l - u, t[10] = 1 - (h + a), t[11] = 0, t[12] = s[0], 
                t[13] = s[1], t[14] = s[2], t[15] = 1, t;
            }, fromQuat22 = function(t, e) {
                var s = new ARRAY_TYPE(3), i = -e[0], r = -e[1], n = -e[2], h = e[3], o = e[4], a = e[5], l = e[6], u = e[7], c = i * i + r * r + n * n + h * h;
                return 0 < c ? (s[0] = 2 * (o * h + u * i + a * n - l * r) / c, 
                s[1] = 2 * (a * h + u * r + l * i - o * n) / c, s[2] = 2 * (l * h + u * n + o * r - a * i) / c) : (s[0] = 2 * (o * h + u * i + a * n - l * r), 
                s[1] = 2 * (a * h + u * r + l * i - o * n), s[2] = 2 * (l * h + u * n + o * r - a * i)), 
                fromRotationTranslation$12(t, e, s), t;
            }, getTranslation$12 = function(t, e) {
                return t[0] = e[12], t[1] = e[13], t[2] = e[14], t;
            }, getScaling2 = function(t, e) {
                var s = e[0], i = e[4], r = e[5], n = e[6], h = e[8], o = e[9], a = e[10];
                return t[0] = Math.hypot(s, e[1], e[2]), t[1] = Math.hypot(i, r, n), 
                t[2] = Math.hypot(h, o, a), t;
            }, getRotation2 = function(t, e) {
                var s = new ARRAY_TYPE(3), i = (getScaling2(s, e), 1 / s[0]), r = 1 / s[1], s = 1 / s[2], n = e[0] * i, h = e[1] * r, o = e[2] * s, a = e[4] * i, l = e[5] * r, u = e[6] * s, i = e[8] * i, r = e[9] * r, c = 0;
                return 0 < (s = n + l + (e = e[10] * s)) ? (c = 2 * Math.sqrt(1 + s), 
                t[3] = .25 * c, t[0] = (u - r) / c, t[1] = (i - o) / c, t[2] = (h - a) / c) : l < n && e < n ? (c = 2 * Math.sqrt(1 + n - l - e), 
                t[3] = (u - r) / c, t[0] = .25 * c, t[1] = (h + a) / c, t[2] = (i + o) / c) : e < l ? (c = 2 * Math.sqrt(1 + l - n - e), 
                t[3] = (i - o) / c, t[0] = (h + a) / c, t[1] = .25 * c, t[2] = (u + r) / c) : (c = 2 * Math.sqrt(1 + e - n - l), 
                t[3] = (h - a) / c, t[0] = (i + o) / c, t[1] = (u + r) / c, t[2] = .25 * c), 
                t;
            }, decompose2 = function(t, e, s, i) {
                e[0] = i[12], e[1] = i[13], e[2] = i[14];
                var e = i[0], r = i[1], n = i[2], h = i[4], o = i[5], a = i[6], l = i[8], u = i[9], i = i[10], c = (s[0] = Math.hypot(e, r, n), 
                s[1] = Math.hypot(h, o, a), s[2] = Math.hypot(l, u, i), 1 / s[0]), f = 1 / s[1], e = e * c, r = r * f, n = n * (s = 1 / s[2]), h = h * c, a = a * s, l = l * c, c = u * f, u = i * s, i = 0;
                return 0 < (f = e + (o = o * f) + u) ? (i = 2 * Math.sqrt(1 + f), 
                t[3] = .25 * i, t[0] = (a - c) / i, t[1] = (l - n) / i, t[2] = (r - h) / i) : o < e && u < e ? (i = 2 * Math.sqrt(1 + e - o - u), 
                t[3] = (a - c) / i, t[0] = .25 * i, t[1] = (r + h) / i, t[2] = (l + n) / i) : u < o ? (i = 2 * Math.sqrt(1 + o - e - u), 
                t[3] = (l - n) / i, t[0] = (r + h) / i, t[1] = .25 * i, t[2] = (a + c) / i) : (i = 2 * Math.sqrt(1 + u - e - o), 
                t[3] = (r - h) / i, t[0] = (l + n) / i, t[1] = (a + c) / i, t[2] = .25 * i), 
                t;
            }, fromRotationTranslationScale2 = function(t, e, s, i) {
                var r = (h = e[0]) * (u = h + h), n = h * (c = (a = e[1]) + a), h = h * (f = (l = e[2]) + l), o = a * c, a = a * f, l = l * f, u = (e = e[3]) * u, c = e * c, e = e * f, f = i[0], d = i[1], i = i[2];
                return t[0] = (1 - (o + l)) * f, t[1] = (n + e) * f, t[2] = (h - c) * f, 
                t[3] = 0, t[4] = (n - e) * d, t[5] = (1 - (r + l)) * d, t[6] = (a + u) * d, 
                t[7] = 0, t[8] = (h + c) * i, t[9] = (a - u) * i, t[10] = (1 - (r + o)) * i, 
                t[11] = 0, t[12] = s[0], t[13] = s[1], t[14] = s[2], t[15] = 1, 
                t;
            }, fromRotationTranslationScaleOrigin2 = function(t, e, s, i, r) {
                var n = (o = e[0]) * (c = o + o), h = o * (f = (l = e[1]) + l), o = o * (d = (u = e[2]) + u), a = l * f, l = l * d, u = u * d, c = (e = e[3]) * c, f = e * f, e = e * d, d = i[0], p = i[1], i = i[2], m = r[0], C = r[1], r = r[2], g = (1 - (a + u)) * d, S = (h + e) * d, d = (o - f) * d, h = (h - e) * p, e = (1 - (n + u)) * p, u = (l + c) * p, p = (o + f) * i, o = (l - c) * i, f = (1 - (n + a)) * i;
                return t[0] = g, t[1] = S, t[2] = d, t[3] = 0, t[4] = h, t[5] = e, 
                t[6] = u, t[7] = 0, t[8] = p, t[9] = o, t[10] = f, t[11] = 0, t[12] = s[0] + m - (g * m + h * C + p * r), 
                t[13] = s[1] + C - (S * m + e * C + o * r), t[14] = s[2] + r - (d * m + u * C + f * r), 
                t[15] = 1, t;
            }, fromQuat3 = function(t, e) {
                var s = e[0], i = e[2], r = i + i, s = s * (l = s + s), n = (h = e[1]) * l, h = h * (u = h + h), o = i * l, a = i * u, l = (e = e[3]) * l, u = e * u, e = e * r;
                return t[0] = 1 - h - (i = i * r), t[1] = n + e, t[2] = o - u, t[3] = 0, 
                t[4] = n - e, t[5] = 1 - s - i, t[6] = a + l, t[7] = 0, t[8] = o + u, 
                t[9] = a - l, t[10] = 1 - s - h, t[11] = 0, t[12] = 0, t[13] = 0, 
                t[14] = 0, t[15] = 1, t;
            }, frustum2 = function(t, e, s, i, r, n, h) {
                var o = 1 / (s - e), a = 1 / (r - i), l = 1 / (n - h);
                return t[0] = 2 * n * o, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, 
                t[5] = 2 * n * a, t[6] = 0, t[7] = 0, t[8] = (s + e) * o, t[9] = (r + i) * a, 
                t[10] = (h + n) * l, t[11] = -1, t[12] = 0, t[13] = 0, t[14] = h * n * 2 * l, 
                t[15] = 0, t;
            }, perspectiveNO2 = function(t, e, s, i, r) {
                return e = 1 / Math.tan(e / 2), t[0] = e / s, t[1] = 0, t[2] = 0, 
                t[3] = 0, t[4] = 0, t[5] = e, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, 
                t[11] = -1, t[12] = 0, t[13] = 0, t[15] = 0, null != r && r !== 1 / 0 ? (t[10] = (r + i) * (s = 1 / (i - r)), 
                t[14] = 2 * r * i * s) : (t[10] = -1, t[14] = -2 * i), t;
            }, perspectiveZO2 = function(t, e, s, i, r) {
                return e = 1 / Math.tan(e / 2), t[0] = e / s, t[1] = 0, t[2] = 0, 
                t[3] = 0, t[4] = 0, t[5] = e, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, 
                t[11] = -1, t[12] = 0, t[13] = 0, t[15] = 0, null != r && r !== 1 / 0 ? (t[10] = r * (s = 1 / (i - r)), 
                t[14] = r * i * s) : (t[10] = -1, t[14] = -i), t;
            }, perspectiveFromFieldOfView2 = function(t, e, s, i) {
                var r = Math.tan(e.upDegrees * Math.PI / 180), n = Math.tan(e.downDegrees * Math.PI / 180), h = Math.tan(e.leftDegrees * Math.PI / 180), o = 2 / (h + (e = Math.tan(e.rightDegrees * Math.PI / 180))), a = 2 / (r + n);
                return t[0] = o, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = a, 
                t[6] = 0, t[7] = 0, t[8] = -(h - e) * o * .5, t[9] = (r - n) * a * .5, 
                t[10] = i / (s - i), t[11] = -1, t[12] = 0, t[13] = 0, t[14] = i * s / (s - i), 
                t[15] = 0, t;
            }, orthoNO2 = function(t, e, s, i, r, n, h) {
                var o = 1 / (e - s), a = 1 / (i - r), l = 1 / (n - h);
                return t[0] = -2 * o, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = -2 * a, 
                t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 2 * l, t[11] = 0, 
                t[12] = (e + s) * o, t[13] = (r + i) * a, t[14] = (h + n) * l, t[15] = 1, 
                t;
            }, orthoZO2 = function(t, e, s, i, r, n, h) {
                var o = 1 / (e - s), a = 1 / (i - r), h = 1 / (n - h);
                return t[0] = -2 * o, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = -2 * a, 
                t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = h, t[11] = 0, t[12] = (e + s) * o, 
                t[13] = (r + i) * a, t[14] = n * h, t[15] = 1, t;
            }, lookAt2 = function(t, e, s, i) {
                var r, n, h, o, a = e[0], l = e[1], e = e[2], u = i[0], c = i[1], i = i[2], f = s[0], d = s[1], s = s[2];
                return Math.abs(a - f) < EPSILON && Math.abs(l - d) < EPSILON && Math.abs(e - s) < EPSILON ? identity$22(t) : (f = a - f, 
                d = l - d, s = e - s, r = c * (s *= o = 1 / Math.hypot(f, d, s)) - i * (d *= o), 
                i = i * (f *= o) - u * s, u = u * d - c * f, (o = Math.hypot(r, i, u)) ? (r *= o = 1 / o, 
                i *= o, u *= o) : u = i = r = 0, c = d * u - s * i, n = s * r - f * u, 
                h = f * i - d * r, (o = Math.hypot(c, n, h)) ? (c *= o = 1 / o, 
                n *= o, h *= o) : h = n = c = 0, t[0] = r, t[1] = c, t[2] = f, t[3] = 0, 
                t[4] = i, t[5] = n, t[6] = d, t[7] = 0, t[8] = u, t[9] = h, t[10] = s, 
                t[11] = 0, t[12] = -(r * a + i * l + u * e), t[13] = -(c * a + n * l + h * e), 
                t[14] = -(f * a + d * l + s * e), t[15] = 1, t);
            }, targetTo2 = function(t, e, s, i) {
                var r = e[0], n = e[1], e = e[2], h = i[0], o = i[1], i = i[2], a = r - s[0], l = n - s[1], u = a * a + l * l + (s = e - s[2]) * s, c = (0 < u && (a *= u = 1 / Math.sqrt(u), 
                l *= u, s *= u), o * s - i * l);
                return 0 < (u = c * c + (i = i * a - h * s) * i + (h = h * l - o * a) * h) && (c *= u = 1 / Math.sqrt(u), 
                i *= u, h *= u), t[0] = c, t[1] = i, t[2] = h, t[3] = 0, t[4] = l * h - s * i, 
                t[5] = s * c - a * h, t[6] = a * i - l * c, t[7] = 0, t[8] = a, 
                t[9] = l, t[10] = s, t[11] = 0, t[12] = r, t[13] = n, t[14] = e, 
                t[15] = 1, t;
            }, str$52 = function(t) {
                return "mat4(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ", " + t[4] + ", " + t[5] + ", " + t[6] + ", " + t[7] + ", " + t[8] + ", " + t[9] + ", " + t[10] + ", " + t[11] + ", " + t[12] + ", " + t[13] + ", " + t[14] + ", " + t[15] + ")";
            }, frob2 = function(t) {
                return Math.hypot(t[0], t[1], t[2], t[3], t[4], t[5], t[6], t[7], t[8], t[9], t[10], t[11], t[12], t[13], t[14], t[15]);
            }, add$52 = function(t, e, s) {
                return t[0] = e[0] + s[0], t[1] = e[1] + s[1], t[2] = e[2] + s[2], 
                t[3] = e[3] + s[3], t[4] = e[4] + s[4], t[5] = e[5] + s[5], t[6] = e[6] + s[6], 
                t[7] = e[7] + s[7], t[8] = e[8] + s[8], t[9] = e[9] + s[9], t[10] = e[10] + s[10], 
                t[11] = e[11] + s[11], t[12] = e[12] + s[12], t[13] = e[13] + s[13], 
                t[14] = e[14] + s[14], t[15] = e[15] + s[15], t;
            }, subtract$32 = function(t, e, s) {
                return t[0] = e[0] - s[0], t[1] = e[1] - s[1], t[2] = e[2] - s[2], 
                t[3] = e[3] - s[3], t[4] = e[4] - s[4], t[5] = e[5] - s[5], t[6] = e[6] - s[6], 
                t[7] = e[7] - s[7], t[8] = e[8] - s[8], t[9] = e[9] - s[9], t[10] = e[10] - s[10], 
                t[11] = e[11] - s[11], t[12] = e[12] - s[12], t[13] = e[13] - s[13], 
                t[14] = e[14] - s[14], t[15] = e[15] - s[15], t;
            }, multiplyScalar2 = function(t, e, s) {
                return t[0] = e[0] * s, t[1] = e[1] * s, t[2] = e[2] * s, t[3] = e[3] * s, 
                t[4] = e[4] * s, t[5] = e[5] * s, t[6] = e[6] * s, t[7] = e[7] * s, 
                t[8] = e[8] * s, t[9] = e[9] * s, t[10] = e[10] * s, t[11] = e[11] * s, 
                t[12] = e[12] * s, t[13] = e[13] * s, t[14] = e[14] * s, t[15] = e[15] * s, 
                t;
            }, multiplyScalarAndAdd2 = function(t, e, s, i) {
                return t[0] = e[0] + s[0] * i, t[1] = e[1] + s[1] * i, t[2] = e[2] + s[2] * i, 
                t[3] = e[3] + s[3] * i, t[4] = e[4] + s[4] * i, t[5] = e[5] + s[5] * i, 
                t[6] = e[6] + s[6] * i, t[7] = e[7] + s[7] * i, t[8] = e[8] + s[8] * i, 
                t[9] = e[9] + s[9] * i, t[10] = e[10] + s[10] * i, t[11] = e[11] + s[11] * i, 
                t[12] = e[12] + s[12] * i, t[13] = e[13] + s[13] * i, t[14] = e[14] + s[14] * i, 
                t[15] = e[15] + s[15] * i, t;
            }, exactEquals$52 = function(t, e) {
                return t[0] === e[0] && t[1] === e[1] && t[2] === e[2] && t[3] === e[3] && t[4] === e[4] && t[5] === e[5] && t[6] === e[6] && t[7] === e[7] && t[8] === e[8] && t[9] === e[9] && t[10] === e[10] && t[11] === e[11] && t[12] === e[12] && t[13] === e[13] && t[14] === e[14] && t[15] === e[15];
            }, equals$52 = function(t, e) {
                var s = t[0], i = t[1], r = t[2], n = t[3], h = t[4], o = t[5], a = t[6], l = t[7], u = t[8], c = t[9], f = t[10], d = t[11], p = t[12], m = t[13], C = t[14], t = t[15], g = e[0], S = e[1], _ = e[2], T = e[3], y = e[4], E = e[5], A = e[6], I = e[7], M = e[8], w = e[9], v = e[10], R = e[11], b = e[12], G = e[13], x = e[14], e = e[15];
                return Math.abs(s - g) <= EPSILON * Math.max(1, Math.abs(s), Math.abs(g)) && Math.abs(i - S) <= EPSILON * Math.max(1, Math.abs(i), Math.abs(S)) && Math.abs(r - _) <= EPSILON * Math.max(1, Math.abs(r), Math.abs(_)) && Math.abs(n - T) <= EPSILON * Math.max(1, Math.abs(n), Math.abs(T)) && Math.abs(h - y) <= EPSILON * Math.max(1, Math.abs(h), Math.abs(y)) && Math.abs(o - E) <= EPSILON * Math.max(1, Math.abs(o), Math.abs(E)) && Math.abs(a - A) <= EPSILON * Math.max(1, Math.abs(a), Math.abs(A)) && Math.abs(l - I) <= EPSILON * Math.max(1, Math.abs(l), Math.abs(I)) && Math.abs(u - M) <= EPSILON * Math.max(1, Math.abs(u), Math.abs(M)) && Math.abs(c - w) <= EPSILON * Math.max(1, Math.abs(c), Math.abs(w)) && Math.abs(f - v) <= EPSILON * Math.max(1, Math.abs(f), Math.abs(v)) && Math.abs(d - R) <= EPSILON * Math.max(1, Math.abs(d), Math.abs(R)) && Math.abs(p - b) <= EPSILON * Math.max(1, Math.abs(p), Math.abs(b)) && Math.abs(m - G) <= EPSILON * Math.max(1, Math.abs(m), Math.abs(G)) && Math.abs(C - x) <= EPSILON * Math.max(1, Math.abs(C), Math.abs(x)) && Math.abs(t - e) <= EPSILON * Math.max(1, Math.abs(t), Math.abs(e));
            }, create$42 = function() {
                var t = new ARRAY_TYPE(3);
                return ARRAY_TYPE != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0), 
                t;
            }, clone$42 = function(t) {
                var e = new ARRAY_TYPE(3);
                return e[0] = t[0], e[1] = t[1], e[2] = t[2], e;
            }, length$42 = function(t) {
                var e = t[0];
                return Math.hypot(e, t[1], t[2]);
            }, fromValues$42 = function(t, e, s) {
                var i = new ARRAY_TYPE(3);
                return i[0] = t, i[1] = e, i[2] = s, i;
            }, copy$42 = function(t, e) {
                return t[0] = e[0], t[1] = e[1], t[2] = e[2], t;
            }, set$42 = function(t, e, s, i) {
                return t[0] = e, t[1] = s, t[2] = i, t;
            }, add$42 = function(t, e, s) {
                return t[0] = e[0] + s[0], t[1] = e[1] + s[1], t[2] = e[2] + s[2], 
                t;
            }, subtract$22 = function(t, e, s) {
                return t[0] = e[0] - s[0], t[1] = e[1] - s[1], t[2] = e[2] - s[2], 
                t;
            }, multiply$42 = function(t, e, s) {
                return t[0] = e[0] * s[0], t[1] = e[1] * s[1], t[2] = e[2] * s[2], 
                t;
            }, divide$22 = function(t, e, s) {
                return t[0] = e[0] / s[0], t[1] = e[1] / s[1], t[2] = e[2] / s[2], 
                t;
            }, ceil$22 = function(t, e) {
                return t[0] = Math.ceil(e[0]), t[1] = Math.ceil(e[1]), t[2] = Math.ceil(e[2]), 
                t;
            }, floor$22 = function(t, e) {
                return t[0] = Math.floor(e[0]), t[1] = Math.floor(e[1]), t[2] = Math.floor(e[2]), 
                t;
            }, min$22 = function(t, e, s) {
                return t[0] = Math.min(e[0], s[0]), t[1] = Math.min(e[1], s[1]), 
                t[2] = Math.min(e[2], s[2]), t;
            }, max$22 = function(t, e, s) {
                return t[0] = Math.max(e[0], s[0]), t[1] = Math.max(e[1], s[1]), 
                t[2] = Math.max(e[2], s[2]), t;
            }, round$22 = function(t, e) {
                return t[0] = Math.round(e[0]), t[1] = Math.round(e[1]), t[2] = Math.round(e[2]), 
                t;
            }, scale$42 = function(t, e, s) {
                return t[0] = e[0] * s, t[1] = e[1] * s, t[2] = e[2] * s, t;
            }, scaleAndAdd$22 = function(t, e, s, i) {
                return t[0] = e[0] + s[0] * i, t[1] = e[1] + s[1] * i, t[2] = e[2] + s[2] * i, 
                t;
            }, distance$22 = function(t, e) {
                var s = e[0] - t[0];
                return Math.hypot(s, e[1] - t[1], e[2] - t[2]);
            }, squaredDistance$22 = function(t, e) {
                var s = e[0] - t[0], i = e[1] - t[1];
                return s * s + i * i + (e = e[2] - t[2]) * e;
            }, squaredLength$42 = function(t) {
                var e = t[0], s = t[1];
                return e * e + s * s + (t = t[2]) * t;
            }, negate$22 = function(t, e) {
                return t[0] = -e[0], t[1] = -e[1], t[2] = -e[2], t;
            }, inverse$22 = function(t, e) {
                return t[0] = 1 / e[0], t[1] = 1 / e[1], t[2] = 1 / e[2], t;
            }, normalize$42 = function(t, e) {
                var s = e[0], i = e[1], r = e[2];
                return 0 < (s = s * s + i * i + r * r) && (s = 1 / Math.sqrt(s)), 
                t[0] = e[0] * s, t[1] = e[1] * s, t[2] = e[2] * s, t;
            }, dot$42 = function(t, e) {
                return t[0] * e[0] + t[1] * e[1] + t[2] * e[2];
            }, cross$22 = function(t, e, s) {
                var i = e[0], r = e[1], e = e[2], n = s[0], h = s[1], s = s[2];
                return t[0] = r * s - e * h, t[1] = e * n - i * s, t[2] = i * h - r * n, 
                t;
            }, lerp$42 = function(t, e, s, i) {
                var r = e[0], n = e[1], e = e[2];
                return t[0] = r + i * (s[0] - r), t[1] = n + i * (s[1] - n), t[2] = e + i * (s[2] - e), 
                t;
            }, slerp$12 = function(t, e, s, i) {
                var r = Math.acos(Math.min(Math.max(dot$42(e, s), -1), 1)), n = Math.sin(r), h = Math.sin((1 - i) * r) / n, i = Math.sin(i * r) / n;
                return t[0] = h * e[0] + i * s[0], t[1] = h * e[1] + i * s[1], t[2] = h * e[2] + i * s[2], 
                t;
            }, hermite2 = function(t, e, s, i, r, n) {
                var h = n * n, o = h * (2 * n - 3) + 1, a = h * (n - 2) + n, l = h * (n - 1);
                return t[0] = e[0] * o + s[0] * a + i[0] * l + r[0] * (h = h * (3 - 2 * n)), 
                t[1] = e[1] * o + s[1] * a + i[1] * l + r[1] * h, t[2] = e[2] * o + s[2] * a + i[2] * l + r[2] * h, 
                t;
            }, bezier2 = function(t, e, s, i, r, n) {
                var h = 1 - n, o = h * h, a = n * n, l = o * h;
                return t[0] = e[0] * l + s[0] * (o = 3 * n * o) + i[0] * (h = 3 * a * h) + r[0] * (a = a * n), 
                t[1] = e[1] * l + s[1] * o + i[1] * h + r[1] * a, t[2] = e[2] * l + s[2] * o + i[2] * h + r[2] * a, 
                t;
            }, random$32 = function(t, e) {
                e = e || 1;
                var s = 2 * RANDOM() * Math.PI, i = 2 * RANDOM() - 1, r = Math.sqrt(1 - i * i) * e;
                return t[0] = Math.cos(s) * r, t[1] = Math.sin(s) * r, t[2] = i * e, 
                t;
            }, transformMat4$22 = function(t, e, s) {
                var i = e[0], r = e[1], e = e[2], n = s[3] * i + s[7] * r + s[11] * e + s[15];
                return t[0] = (s[0] * i + s[4] * r + s[8] * e + s[12]) / (n = n || 1), 
                t[1] = (s[1] * i + s[5] * r + s[9] * e + s[13]) / n, t[2] = (s[2] * i + s[6] * r + s[10] * e + s[14]) / n, 
                t;
            }, transformMat3$12 = function(t, e, s) {
                var i = e[0], r = e[1], e = e[2];
                return t[0] = i * s[0] + r * s[3] + e * s[6], t[1] = i * s[1] + r * s[4] + e * s[7], 
                t[2] = i * s[2] + r * s[5] + e * s[8], t;
            }, transformQuat$12 = function(t, e, s) {
                var i = s[0], r = s[1], n = e[0], h = e[1], o = r * (e = e[2]) - (c = s[2]) * h, a = c * n - i * e, l = i * h - r * n, u = r * l - c * a, c = c * o - i * l, i = i * a - r * o;
                return a *= r = 2 * s[3], l *= r, c *= 2, i *= 2, t[0] = n + (o *= r) + (u *= 2), 
                t[1] = h + a + c, t[2] = e + l + i, t;
            }, rotateX$22 = function(t, e, s, i) {
                var r = [], n = [];
                return r[0] = e[0] - s[0], r[1] = e[1] - s[1], r[2] = e[2] - s[2], 
                n[0] = r[0], n[1] = r[1] * Math.cos(i) - r[2] * Math.sin(i), n[2] = r[1] * Math.sin(i) + r[2] * Math.cos(i), 
                t[0] = n[0] + s[0], t[1] = n[1] + s[1], t[2] = n[2] + s[2], t;
            }, rotateY$22 = function(t, e, s, i) {
                var r = [], n = [];
                return r[0] = e[0] - s[0], r[1] = e[1] - s[1], r[2] = e[2] - s[2], 
                n[0] = r[2] * Math.sin(i) + r[0] * Math.cos(i), n[1] = r[1], n[2] = r[2] * Math.cos(i) - r[0] * Math.sin(i), 
                t[0] = n[0] + s[0], t[1] = n[1] + s[1], t[2] = n[2] + s[2], t;
            }, rotateZ$22 = function(t, e, s, i) {
                var r = [], n = [];
                return r[0] = e[0] - s[0], r[1] = e[1] - s[1], r[2] = e[2] - s[2], 
                n[0] = r[0] * Math.cos(i) - r[1] * Math.sin(i), n[1] = r[0] * Math.sin(i) + r[1] * Math.cos(i), 
                n[2] = r[2], t[0] = n[0] + s[0], t[1] = n[1] + s[1], t[2] = n[2] + s[2], 
                t;
            }, angle$12 = function(t, e) {
                var s = t[0], i = t[1], r = t[2], n = e[0], h = e[1], o = e[2], i = (s = Math.sqrt((s * s + i * i + r * r) * (n * n + h * h + o * o))) && dot$42(t, e) / s;
                return Math.acos(Math.min(Math.max(i, -1), 1));
            }, zero$22 = function(t) {
                return t[0] = 0, t[1] = 0, t[2] = 0, t;
            }, str$42 = function(t) {
                return "vec3(" + t[0] + ", " + t[1] + ", " + t[2] + ")";
            }, exactEquals$42 = function(t, e) {
                return t[0] === e[0] && t[1] === e[1] && t[2] === e[2];
            }, equals$42 = function(t, e) {
                var s = t[0], i = t[1], t = t[2], r = e[0], n = e[1], e = e[2];
                return Math.abs(s - r) <= EPSILON * Math.max(1, Math.abs(s), Math.abs(r)) && Math.abs(i - n) <= EPSILON * Math.max(1, Math.abs(i), Math.abs(n)) && Math.abs(t - e) <= EPSILON * Math.max(1, Math.abs(t), Math.abs(e));
            }, create$32 = function() {
                var t = new ARRAY_TYPE(4);
                return ARRAY_TYPE != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0, 
                t[3] = 0), t;
            }, clone$32 = function(t) {
                var e = new ARRAY_TYPE(4);
                return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e;
            }, fromValues$32 = function(t, e, s, i) {
                var r = new ARRAY_TYPE(4);
                return r[0] = t, r[1] = e, r[2] = s, r[3] = i, r;
            }, copy$32 = function(t, e) {
                return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t;
            }, set$32 = function(t, e, s, i, r) {
                return t[0] = e, t[1] = s, t[2] = i, t[3] = r, t;
            }, add$32 = function(t, e, s) {
                return t[0] = e[0] + s[0], t[1] = e[1] + s[1], t[2] = e[2] + s[2], 
                t[3] = e[3] + s[3], t;
            }, subtract$12 = function(t, e, s) {
                return t[0] = e[0] - s[0], t[1] = e[1] - s[1], t[2] = e[2] - s[2], 
                t[3] = e[3] - s[3], t;
            }, multiply$32 = function(t, e, s) {
                return t[0] = e[0] * s[0], t[1] = e[1] * s[1], t[2] = e[2] * s[2], 
                t[3] = e[3] * s[3], t;
            }, divide$12 = function(t, e, s) {
                return t[0] = e[0] / s[0], t[1] = e[1] / s[1], t[2] = e[2] / s[2], 
                t[3] = e[3] / s[3], t;
            }, ceil$12 = function(t, e) {
                return t[0] = Math.ceil(e[0]), t[1] = Math.ceil(e[1]), t[2] = Math.ceil(e[2]), 
                t[3] = Math.ceil(e[3]), t;
            }, floor$12 = function(t, e) {
                return t[0] = Math.floor(e[0]), t[1] = Math.floor(e[1]), t[2] = Math.floor(e[2]), 
                t[3] = Math.floor(e[3]), t;
            }, min$12 = function(t, e, s) {
                return t[0] = Math.min(e[0], s[0]), t[1] = Math.min(e[1], s[1]), 
                t[2] = Math.min(e[2], s[2]), t[3] = Math.min(e[3], s[3]), t;
            }, max$12 = function(t, e, s) {
                return t[0] = Math.max(e[0], s[0]), t[1] = Math.max(e[1], s[1]), 
                t[2] = Math.max(e[2], s[2]), t[3] = Math.max(e[3], s[3]), t;
            }, round$12 = function(t, e) {
                return t[0] = Math.round(e[0]), t[1] = Math.round(e[1]), t[2] = Math.round(e[2]), 
                t[3] = Math.round(e[3]), t;
            }, scale$32 = function(t, e, s) {
                return t[0] = e[0] * s, t[1] = e[1] * s, t[2] = e[2] * s, t[3] = e[3] * s, 
                t;
            }, scaleAndAdd$12 = function(t, e, s, i) {
                return t[0] = e[0] + s[0] * i, t[1] = e[1] + s[1] * i, t[2] = e[2] + s[2] * i, 
                t[3] = e[3] + s[3] * i, t;
            }, distance$12 = function(t, e) {
                var s = e[0] - t[0];
                return Math.hypot(s, e[1] - t[1], e[2] - t[2], e[3] - t[3]);
            }, squaredDistance$12 = function(t, e) {
                var s = e[0] - t[0], i = e[1] - t[1], r = e[2] - t[2];
                return s * s + i * i + r * r + (e = e[3] - t[3]) * e;
            }, length$32 = function(t) {
                var e = t[0];
                return Math.hypot(e, t[1], t[2], t[3]);
            }, squaredLength$32 = function(t) {
                var e = t[0], s = t[1], i = t[2];
                return e * e + s * s + i * i + (t = t[3]) * t;
            }, negate$12 = function(t, e) {
                return t[0] = -e[0], t[1] = -e[1], t[2] = -e[2], t[3] = -e[3], t;
            }, inverse$12 = function(t, e) {
                return t[0] = 1 / e[0], t[1] = 1 / e[1], t[2] = 1 / e[2], t[3] = 1 / e[3], 
                t;
            }, normalize$32 = function(t, e) {
                var s = e[0], i = e[1], r = e[2], n = s * s + i * i + r * r + (e = e[3]) * e;
                return 0 < n && (n = 1 / Math.sqrt(n)), t[0] = s * n, t[1] = i * n, 
                t[2] = r * n, t[3] = e * n, t;
            }, dot$32 = function(t, e) {
                return t[0] * e[0] + t[1] * e[1] + t[2] * e[2] + t[3] * e[3];
            }, cross$12 = function(t, e, s, i) {
                var r = s[0] * i[1] - s[1] * i[0], n = s[0] * i[2] - s[2] * i[0], h = s[0] * i[3] - s[3] * i[0], o = s[1] * i[2] - s[2] * i[1], a = s[1] * i[3] - s[3] * i[1], s = s[2] * i[3] - s[3] * i[2], i = e[0], l = e[1], u = e[2], e = e[3];
                return t[0] = l * s - u * a + e * o, t[1] = -i * s + u * h - e * n, 
                t[2] = i * a - l * h + e * r, t[3] = -i * o + l * n - u * r, t;
            }, lerp$32 = function(t, e, s, i) {
                var r = e[0], n = e[1], h = e[2], e = e[3];
                return t[0] = r + i * (s[0] - r), t[1] = n + i * (s[1] - n), t[2] = h + i * (s[2] - h), 
                t[3] = e + i * (s[3] - e), t;
            }, random$22 = function(t, e) {
                var s, i, r, n, h, o;
                for (e = e || 1; 1 <= (h = (s = 2 * RANDOM() - 1) * s + (i = 2 * RANDOM() - 1) * i); );
                for (;1 <= (o = (r = 2 * RANDOM() - 1) * r + (n = 2 * RANDOM() - 1) * n); );
                var a = Math.sqrt((1 - h) / o);
                return t[0] = e * s, t[1] = e * i, t[2] = e * r * a, t[3] = e * n * a, 
                t;
            }, transformMat4$12 = function(t, e, s) {
                var i = e[0], r = e[1], n = e[2], e = e[3];
                return t[0] = s[0] * i + s[4] * r + s[8] * n + s[12] * e, t[1] = s[1] * i + s[5] * r + s[9] * n + s[13] * e, 
                t[2] = s[2] * i + s[6] * r + s[10] * n + s[14] * e, t[3] = s[3] * i + s[7] * r + s[11] * n + s[15] * e, 
                t;
            }, transformQuat2 = function(t, e, s) {
                var i = e[0], r = e[1], n = e[2], h = s[0], o = s[1], a = s[2], l = (s = s[3]) * i + o * n - a * r, u = s * r + a * i - h * n, c = s * n + h * r - o * i;
                return t[0] = l * s + (i = -h * i - o * r - a * n) * -h + u * -a - c * -o, 
                t[1] = u * s + i * -o + c * -h - l * -a, t[2] = c * s + i * -a + l * -o - u * -h, 
                t[3] = e[3], t;
            }, zero$12 = function(t) {
                return t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 0, t;
            }, str$32 = function(t) {
                return "vec4(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ")";
            }, exactEquals$32 = function(t, e) {
                return t[0] === e[0] && t[1] === e[1] && t[2] === e[2] && t[3] === e[3];
            }, equals$32 = function(t, e) {
                var s = t[0], i = t[1], r = t[2], t = t[3], n = e[0], h = e[1], o = e[2], e = e[3];
                return Math.abs(s - n) <= EPSILON * Math.max(1, Math.abs(s), Math.abs(n)) && Math.abs(i - h) <= EPSILON * Math.max(1, Math.abs(i), Math.abs(h)) && Math.abs(r - o) <= EPSILON * Math.max(1, Math.abs(r), Math.abs(o)) && Math.abs(t - e) <= EPSILON * Math.max(1, Math.abs(t), Math.abs(e));
            }, create$22 = function() {
                var t = new ARRAY_TYPE(4);
                return ARRAY_TYPE != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0), 
                t[3] = 1, t;
            }, identity$12 = function(t) {
                return t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 1, t;
            }, setAxisAngle2 = function(t, e, s) {
                s *= .5;
                var i = Math.sin(s);
                return t[0] = i * e[0], t[1] = i * e[1], t[2] = i * e[2], t[3] = Math.cos(s), 
                t;
            }, getAxisAngle2 = function(t, e) {
                var s = 2 * Math.acos(e[3]), i = Math.sin(s / 2);
                return EPSILON < i ? (t[0] = e[0] / i, t[1] = e[1] / i, t[2] = e[2] / i) : (t[0] = 1, 
                t[1] = 0, t[2] = 0), s;
            }, getAngle2 = function(t, e) {
                return t = dot$2(t, e), Math.acos(2 * t * t - 1);
            }, multiply$22 = function(t, e, s) {
                var i = e[0], r = e[1], n = e[2], e = e[3], h = s[0], o = s[1], a = s[2], s = s[3];
                return t[0] = i * s + e * h + r * a - n * o, t[1] = r * s + e * o + n * h - i * a, 
                t[2] = n * s + e * a + i * o - r * h, t[3] = e * s - i * h - r * o - n * a, 
                t;
            }, rotateX$12 = function(t, e, s) {
                s *= .5;
                var i = e[0], r = e[1], n = e[2], e = e[3], h = Math.sin(s), s = Math.cos(s);
                return t[0] = i * s + e * h, t[1] = r * s + n * h, t[2] = n * s - r * h, 
                t[3] = e * s - i * h, t;
            }, rotateY$12 = function(t, e, s) {
                s *= .5;
                var i = e[0], r = e[1], n = e[2], e = e[3], h = Math.sin(s), s = Math.cos(s);
                return t[0] = i * s - n * h, t[1] = r * s + e * h, t[2] = n * s + i * h, 
                t[3] = e * s - r * h, t;
            }, rotateZ$12 = function(t, e, s) {
                s *= .5;
                var i = e[0], r = e[1], n = e[2], e = e[3], h = Math.sin(s), s = Math.cos(s);
                return t[0] = i * s + r * h, t[1] = r * s - i * h, t[2] = n * s + e * h, 
                t[3] = e * s - n * h, t;
            }, calculateW2 = function(t, e) {
                var s = e[0], i = e[1], e = e[2];
                return t[0] = s, t[1] = i, t[2] = e, t[3] = Math.sqrt(Math.abs(1 - s * s - i * i - e * e)), 
                t;
            }, exp2 = function(t, e) {
                var s = e[0], i = e[1], r = e[2], e = e[3], n = Math.sqrt(s * s + i * i + r * r), e = Math.exp(e), h = 0 < n ? e * Math.sin(n) / n : 0;
                return t[0] = s * h, t[1] = i * h, t[2] = r * h, t[3] = e * Math.cos(n), 
                t;
            }, ln2 = function(t, e) {
                var s = e[0], i = e[1], r = e[2], e = e[3], n = 0 < (n = Math.sqrt(s * s + i * i + r * r)) ? Math.atan2(n, e) / n : 0;
                return t[0] = s * n, t[1] = i * n, t[2] = r * n, t[3] = .5 * Math.log(s * s + i * i + r * r + e * e), 
                t;
            }, pow2 = function(t, e, s) {
                return ln2(t, e), scale$2(t, t, s), exp2(t, t), t;
            }, slerp2 = function(t, e, s, i) {
                var r, n, h = e[0], o = e[1], a = e[2], e = e[3], l = s[0], u = s[1], c = s[2], f = h * l + o * u + a * c + e * (s = s[3]);
                return f < 0 && (f = -f, l = -l, u = -u, c = -c, s = -s), f = EPSILON < 1 - f ? (f = Math.acos(f), 
                r = Math.sin(f), n = Math.sin((1 - i) * f) / r, Math.sin(i * f) / r) : (n = 1 - i, 
                i), t[0] = n * h + f * l, t[1] = n * o + f * u, t[2] = n * a + f * c, 
                t[3] = n * e + f * s, t;
            }, random$12 = function(t) {
                var e = RANDOM(), s = RANDOM(), i = RANDOM(), r = Math.sqrt(1 - e), e = Math.sqrt(e);
                return t[0] = r * Math.sin(2 * Math.PI * s), t[1] = r * Math.cos(2 * Math.PI * s), 
                t[2] = e * Math.sin(2 * Math.PI * i), t[3] = e * Math.cos(2 * Math.PI * i), 
                t;
            }, invert$12 = function(t, e) {
                var s = e[0], i = e[1], r = e[2], n = s * s + i * i + r * r + (e = e[3]) * e;
                return t[0] = -s * (n = n ? 1 / n : 0), t[1] = -i * n, t[2] = -r * n, 
                t[3] = e * n, t;
            }, conjugate$12 = function(t, e) {
                return t[0] = -e[0], t[1] = -e[1], t[2] = -e[2], t[3] = e[3], t;
            }, fromMat32 = function(t, e) {
                var s, i, r, n = e[0] + e[4] + e[8];
                return 0 < n ? (r = Math.sqrt(n + 1), t[3] = .5 * r, t[0] = (e[5] - e[7]) * (r = .5 / r), 
                t[1] = (e[6] - e[2]) * r, t[2] = (e[1] - e[3]) * r) : (s = (1 + (n = e[3 * (n = e[4] > e[0] ? 1 : 0) + n] < e[8] ? 2 : n)) % 3, 
                i = (2 + n) % 3, r = Math.sqrt(e[3 * n + n] - e[3 * s + s] - e[3 * i + i] + 1), 
                t[n] = .5 * r, t[3] = (e[3 * s + i] - e[3 * i + s]) * (r = .5 / r), 
                t[s] = (e[3 * s + n] + e[3 * n + s]) * r, t[i] = (e[3 * i + n] + e[3 * n + i]) * r), 
                t;
            }, fromEuler2 = function(t, e, s, i) {
                var r = 4 < arguments.length && void 0 !== arguments[4] ? arguments[4] : ANGLE_ORDER, n = Math.PI / 360, h = (i *= n, 
                s *= n, Math.sin(e *= n)), o = Math.cos(e), a = Math.sin(s), l = Math.cos(s), u = Math.sin(i), c = Math.cos(i);
                switch (r) {
                  case "xyz":
                    t[0] = h * l * c + o * a * u, t[1] = o * a * c - h * l * u, 
                    t[2] = o * l * u + h * a * c, t[3] = o * l * c - h * a * u;
                    break;

                  case "xzy":
                    t[0] = h * l * c - o * a * u, t[1] = o * a * c - h * l * u, 
                    t[2] = o * l * u + h * a * c, t[3] = o * l * c + h * a * u;
                    break;

                  case "yxz":
                    t[0] = h * l * c + o * a * u, t[1] = o * a * c - h * l * u, 
                    t[2] = o * l * u - h * a * c, t[3] = o * l * c + h * a * u;
                    break;

                  case "yzx":
                    t[0] = h * l * c + o * a * u, t[1] = o * a * c + h * l * u, 
                    t[2] = o * l * u - h * a * c, t[3] = o * l * c - h * a * u;
                    break;

                  case "zxy":
                    t[0] = h * l * c - o * a * u, t[1] = o * a * c + h * l * u, 
                    t[2] = o * l * u + h * a * c, t[3] = o * l * c - h * a * u;
                    break;

                  case "zyx":
                    t[0] = h * l * c - o * a * u, t[1] = o * a * c + h * l * u, 
                    t[2] = o * l * u - h * a * c, t[3] = o * l * c + h * a * u;
                    break;

                  default:
                    throw new Error("Unknown angle order " + r);
                }
                return t;
            }, str$22 = function(t) {
                return "quat(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ")";
            }, equals$22 = function(t, e) {
                return Math.abs(dot$32(t, e)) >= 1 - EPSILON;
            }, create$12 = function() {
                var t = new ARRAY_TYPE(8);
                return ARRAY_TYPE != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0, 
                t[4] = 0, t[5] = 0, t[6] = 0, t[7] = 0), t[3] = 1, t;
            }, clone$12 = function(t) {
                var e = new ARRAY_TYPE(8);
                return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], 
                e[5] = t[5], e[6] = t[6], e[7] = t[7], e;
            }, fromValues$12 = function(t, e, s, i, r, n, h, o) {
                var a = new ARRAY_TYPE(8);
                return a[0] = t, a[1] = e, a[2] = s, a[3] = i, a[4] = r, a[5] = n, 
                a[6] = h, a[7] = o, a;
            }, fromRotationTranslationValues2 = function(t, e, s, i, r, n, h) {
                var o = new ARRAY_TYPE(8), r = (o[0] = t, o[1] = e, o[2] = s, o[3] = i, 
                .5 * r), n = .5 * n, h = .5 * h;
                return o[4] = r * i + n * s - h * e, o[5] = n * i + h * t - r * s, 
                o[6] = h * i + r * e - n * t, o[7] = -r * t - n * e - h * s, o;
            }, fromRotationTranslation2 = function(t, e, s) {
                var i = .5 * s[0], r = .5 * s[1], s = .5 * s[2], n = e[0], h = e[1], o = e[2], e = e[3];
                return t[0] = n, t[1] = h, t[2] = o, t[3] = e, t[4] = i * e + r * o - s * h, 
                t[5] = r * e + s * n - i * o, t[6] = s * e + i * h - r * n, t[7] = -i * n - r * h - s * o, 
                t;
            }, fromTranslation2 = function(t, e) {
                return t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = .5 * e[0], 
                t[5] = .5 * e[1], t[6] = .5 * e[2], t[7] = 0, t;
            }, fromRotation2 = function(t, e) {
                return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = 0, 
                t[5] = 0, t[6] = 0, t[7] = 0, t;
            }, fromMat42 = function(t, e) {
                var s = create$22(), i = (getRotation2(s, e), new ARRAY_TYPE(3));
                return getTranslation$12(i, e), fromRotationTranslation2(t, s, i), 
                t;
            }, copy$12 = function(t, e) {
                return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], 
                t[5] = e[5], t[6] = e[6], t[7] = e[7], t;
            }, identity2 = function(t) {
                return t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = 0, t[5] = 0, 
                t[6] = 0, t[7] = 0, t;
            }, set$12 = function(t, e, s, i, r, n, h, o, a) {
                return t[0] = e, t[1] = s, t[2] = i, t[3] = r, t[4] = n, t[5] = h, 
                t[6] = o, t[7] = a, t;
            }, getDual2 = function(t, e) {
                return t[0] = e[4], t[1] = e[5], t[2] = e[6], t[3] = e[7], t;
            }, setDual2 = function(t, e) {
                return t[4] = e[0], t[5] = e[1], t[6] = e[2], t[7] = e[3], t;
            }, getTranslation2 = function(t, e) {
                var s = e[4], i = e[5], r = e[6], n = e[7], h = -e[0], o = -e[1], a = -e[2], e = e[3];
                return t[0] = 2 * (s * e + n * h + i * a - r * o), t[1] = 2 * (i * e + n * o + r * h - s * a), 
                t[2] = 2 * (r * e + n * a + s * o - i * h), t;
            }, translate2 = function(t, e, s) {
                var i = e[0], r = e[1], n = e[2], h = e[3], o = .5 * s[0], a = .5 * s[1], s = .5 * s[2], l = e[4], u = e[5], c = e[6], e = e[7];
                return t[0] = i, t[1] = r, t[2] = n, t[3] = h, t[4] = h * o + r * s - n * a + l, 
                t[5] = h * a + n * o - i * s + u, t[6] = h * s + i * a - r * o + c, 
                t[7] = -i * o - r * a - n * s + e, t;
            }, rotateX2 = function(t, e, s) {
                var i = -e[0], r = -e[1], n = -e[2], h = e[3], o = e[4], a = e[5], l = e[6], u = o * h + (d = e[7]) * i + a * n - l * r, c = a * h + d * r + l * i - o * n, f = l * h + d * n + o * r - a * i, d = d * h - o * i - a * r - l * n;
                return rotateX$12(t, e, s), i = t[0], t[4] = u * (h = t[3]) + d * i + c * (n = t[2]) - f * (r = t[1]), 
                t[5] = c * h + d * r + f * i - u * n, t[6] = f * h + d * n + u * r - c * i, 
                t[7] = d * h - u * i - c * r - f * n, t;
            }, rotateY2 = function(t, e, s) {
                var i = -e[0], r = -e[1], n = -e[2], h = e[3], o = e[4], a = e[5], l = e[6], u = o * h + (d = e[7]) * i + a * n - l * r, c = a * h + d * r + l * i - o * n, f = l * h + d * n + o * r - a * i, d = d * h - o * i - a * r - l * n;
                return rotateY$12(t, e, s), i = t[0], t[4] = u * (h = t[3]) + d * i + c * (n = t[2]) - f * (r = t[1]), 
                t[5] = c * h + d * r + f * i - u * n, t[6] = f * h + d * n + u * r - c * i, 
                t[7] = d * h - u * i - c * r - f * n, t;
            }, rotateZ2 = function(t, e, s) {
                var i = -e[0], r = -e[1], n = -e[2], h = e[3], o = e[4], a = e[5], l = e[6], u = o * h + (d = e[7]) * i + a * n - l * r, c = a * h + d * r + l * i - o * n, f = l * h + d * n + o * r - a * i, d = d * h - o * i - a * r - l * n;
                return rotateZ$12(t, e, s), i = t[0], t[4] = u * (h = t[3]) + d * i + c * (n = t[2]) - f * (r = t[1]), 
                t[5] = c * h + d * r + f * i - u * n, t[6] = f * h + d * n + u * r - c * i, 
                t[7] = d * h - u * i - c * r - f * n, t;
            }, rotateByQuatAppend2 = function(t, e, s) {
                var i = s[0], r = s[1], n = s[2], s = s[3], h = e[0], o = e[1], a = e[2], l = e[3];
                return t[0] = h * s + l * i + o * n - a * r, t[1] = o * s + l * r + a * i - h * n, 
                t[2] = a * s + l * n + h * r - o * i, t[3] = l * s - h * i - o * r - a * n, 
                t[4] = (h = e[4]) * s + (l = e[7]) * i + (o = e[5]) * n - (a = e[6]) * r, 
                t[5] = o * s + l * r + a * i - h * n, t[6] = a * s + l * n + h * r - o * i, 
                t[7] = l * s - h * i - o * r - a * n, t;
            }, rotateByQuatPrepend2 = function(t, e, s) {
                var i = e[0], r = e[1], n = e[2], e = e[3], h = s[0], o = s[1], a = s[2], l = s[3];
                return t[0] = i * l + e * h + r * a - n * o, t[1] = r * l + e * o + n * h - i * a, 
                t[2] = n * l + e * a + i * o - r * h, t[3] = e * l - i * h - r * o - n * a, 
                t[4] = i * (l = s[7]) + e * (h = s[4]) + r * (a = s[6]) - n * (o = s[5]), 
                t[5] = r * l + e * o + n * h - i * a, t[6] = n * l + e * a + i * o - r * h, 
                t[7] = e * l - i * h - r * o - n * a, t;
            }, rotateAroundAxis2 = function(t, e, s, i) {
                var r, n, h, o, a, l;
                return Math.abs(i) < EPSILON ? copy$12(t, e) : (l = Math.hypot(s[0], s[1], s[2]), 
                i *= .5, r = (h = Math.sin(i)) * s[0] / l, n = h * s[1] / l, h = h * s[2] / l, 
                s = Math.cos(i), l = e[0], t[0] = l * s + (i = e[3]) * r + (o = e[1]) * h - (a = e[2]) * n, 
                t[1] = o * s + i * n + a * r - l * h, t[2] = a * s + i * h + l * n - o * r, 
                t[3] = i * s - l * r - o * n - a * h, t[4] = (i = e[4]) * s + (l = e[7]) * r + (o = e[5]) * h - (a = e[6]) * n, 
                t[5] = o * s + l * n + a * r - i * h, t[6] = a * s + l * h + i * n - o * r, 
                t[7] = l * s - i * r - o * n - a * h, t);
            }, add$12 = function(t, e, s) {
                return t[0] = e[0] + s[0], t[1] = e[1] + s[1], t[2] = e[2] + s[2], 
                t[3] = e[3] + s[3], t[4] = e[4] + s[4], t[5] = e[5] + s[5], t[6] = e[6] + s[6], 
                t[7] = e[7] + s[7], t;
            }, multiply$12 = function(t, e, s) {
                var i = e[0], r = e[1], n = e[2], h = e[3], o = s[4], a = s[5], l = s[6], u = s[7], c = e[4], f = e[5], d = e[6], e = e[7], p = s[0], m = s[1], C = s[2], s = s[3];
                return t[0] = i * s + h * p + r * C - n * m, t[1] = r * s + h * m + n * p - i * C, 
                t[2] = n * s + h * C + i * m - r * p, t[3] = h * s - i * p - r * m - n * C, 
                t[4] = i * u + h * o + r * l - n * a + c * s + e * p + f * C - d * m, 
                t[5] = r * u + h * a + n * o - i * l + f * s + e * m + d * p - c * C, 
                t[6] = n * u + h * l + i * a - r * o + d * s + e * C + c * m - f * p, 
                t[7] = h * u - i * o - r * a - n * l + e * s - c * p - f * m - d * C, 
                t;
            }, scale$12 = function(t, e, s) {
                return t[0] = e[0] * s, t[1] = e[1] * s, t[2] = e[2] * s, t[3] = e[3] * s, 
                t[4] = e[4] * s, t[5] = e[5] * s, t[6] = e[6] * s, t[7] = e[7] * s, 
                t;
            }, lerp$12 = function(t, e, s, i) {
                var r = 1 - i;
                return dot$1(e, s) < 0 && (i = -i), t[0] = e[0] * r + s[0] * i, 
                t[1] = e[1] * r + s[1] * i, t[2] = e[2] * r + s[2] * i, t[3] = e[3] * r + s[3] * i, 
                t[4] = e[4] * r + s[4] * i, t[5] = e[5] * r + s[5] * i, t[6] = e[6] * r + s[6] * i, 
                t[7] = e[7] * r + s[7] * i, t;
            }, invert2 = function(t, e) {
                var s = squaredLength$1(e);
                return t[0] = -e[0] / s, t[1] = -e[1] / s, t[2] = -e[2] / s, t[3] = e[3] / s, 
                t[4] = -e[4] / s, t[5] = -e[5] / s, t[6] = -e[6] / s, t[7] = e[7] / s, 
                t;
            }, conjugate2 = function(t, e) {
                return t[0] = -e[0], t[1] = -e[1], t[2] = -e[2], t[3] = e[3], t[4] = -e[4], 
                t[5] = -e[5], t[6] = -e[6], t[7] = e[7], t;
            }, normalize$12 = function(t, e) {
                var s, i, r, n, h, o, a, l, u = squaredLength$1(e);
                return 0 < u && (u = Math.sqrt(u), l = (s = e[0] / u) * (h = e[4]) + (i = e[1] / u) * (o = e[5]) + (r = e[2] / u) * (a = e[6]) + (n = e[3] / u) * (e = e[7]), 
                t[0] = s, t[1] = i, t[2] = r, t[3] = n, t[4] = (h - s * l) / u, 
                t[5] = (o - i * l) / u, t[6] = (a - r * l) / u, t[7] = (e - n * l) / u), 
                t;
            }, str$12 = function(t) {
                return "quat2(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ", " + t[4] + ", " + t[5] + ", " + t[6] + ", " + t[7] + ")";
            }, exactEquals$12 = function(t, e) {
                return t[0] === e[0] && t[1] === e[1] && t[2] === e[2] && t[3] === e[3] && t[4] === e[4] && t[5] === e[5] && t[6] === e[6] && t[7] === e[7];
            }, equals$12 = function(t, e) {
                var s = t[0], i = t[1], r = t[2], n = t[3], h = t[4], o = t[5], a = t[6], t = t[7], l = e[0], u = e[1], c = e[2], f = e[3], d = e[4], p = e[5], m = e[6], e = e[7];
                return Math.abs(s - l) <= EPSILON * Math.max(1, Math.abs(s), Math.abs(l)) && Math.abs(i - u) <= EPSILON * Math.max(1, Math.abs(i), Math.abs(u)) && Math.abs(r - c) <= EPSILON * Math.max(1, Math.abs(r), Math.abs(c)) && Math.abs(n - f) <= EPSILON * Math.max(1, Math.abs(n), Math.abs(f)) && Math.abs(h - d) <= EPSILON * Math.max(1, Math.abs(h), Math.abs(d)) && Math.abs(o - p) <= EPSILON * Math.max(1, Math.abs(o), Math.abs(p)) && Math.abs(a - m) <= EPSILON * Math.max(1, Math.abs(a), Math.abs(m)) && Math.abs(t - e) <= EPSILON * Math.max(1, Math.abs(t), Math.abs(e));
            }, create2 = function() {
                var t = new ARRAY_TYPE(2);
                return ARRAY_TYPE != Float32Array && (t[0] = 0, t[1] = 0), t;
            }, clone2 = function(t) {
                var e = new ARRAY_TYPE(2);
                return e[0] = t[0], e[1] = t[1], e;
            }, fromValues2 = function(t, e) {
                var s = new ARRAY_TYPE(2);
                return s[0] = t, s[1] = e, s;
            }, copy2 = function(t, e) {
                return t[0] = e[0], t[1] = e[1], t;
            }, set2 = function(t, e, s) {
                return t[0] = e, t[1] = s, t;
            }, add2 = function(t, e, s) {
                return t[0] = e[0] + s[0], t[1] = e[1] + s[1], t;
            }, subtract2 = function(t, e, s) {
                return t[0] = e[0] - s[0], t[1] = e[1] - s[1], t;
            }, multiply2 = function(t, e, s) {
                return t[0] = e[0] * s[0], t[1] = e[1] * s[1], t;
            }, divide2 = function(t, e, s) {
                return t[0] = e[0] / s[0], t[1] = e[1] / s[1], t;
            }, ceil2 = function(t, e) {
                return t[0] = Math.ceil(e[0]), t[1] = Math.ceil(e[1]), t;
            }, floor2 = function(t, e) {
                return t[0] = Math.floor(e[0]), t[1] = Math.floor(e[1]), t;
            }, min2 = function(t, e, s) {
                return t[0] = Math.min(e[0], s[0]), t[1] = Math.min(e[1], s[1]), 
                t;
            }, max2 = function(t, e, s) {
                return t[0] = Math.max(e[0], s[0]), t[1] = Math.max(e[1], s[1]), 
                t;
            }, round2 = function(t, e) {
                return t[0] = Math.round(e[0]), t[1] = Math.round(e[1]), t;
            }, scale2 = function(t, e, s) {
                return t[0] = e[0] * s, t[1] = e[1] * s, t;
            }, scaleAndAdd2 = function(t, e, s, i) {
                return t[0] = e[0] + s[0] * i, t[1] = e[1] + s[1] * i, t;
            }, distance2 = function(t, e) {
                var s = e[0] - t[0];
                return Math.hypot(s, e[1] - t[1]);
            }, squaredDistance2 = function(t, e) {
                var s = e[0] - t[0];
                return s * s + (e = e[1] - t[1]) * e;
            }, length2 = function(t) {
                var e = t[0];
                return Math.hypot(e, t[1]);
            }, squaredLength2 = function(t) {
                var e = t[0];
                return e * e + (t = t[1]) * t;
            }, negate2 = function(t, e) {
                return t[0] = -e[0], t[1] = -e[1], t;
            }, inverse2 = function(t, e) {
                return t[0] = 1 / e[0], t[1] = 1 / e[1], t;
            }, normalize2 = function(t, e) {
                var s = e[0], i = e[1];
                return 0 < (s = s * s + i * i) && (s = 1 / Math.sqrt(s)), t[0] = e[0] * s, 
                t[1] = e[1] * s, t;
            }, dot2 = function(t, e) {
                return t[0] * e[0] + t[1] * e[1];
            }, cross2 = function(t, e, s) {
                return e = e[0] * s[1] - e[1] * s[0], t[0] = t[1] = 0, t[2] = e, 
                t;
            }, lerp2 = function(t, e, s, i) {
                var r = e[0], e = e[1];
                return t[0] = r + i * (s[0] - r), t[1] = e + i * (s[1] - e), t;
            }, random2 = function(t, e) {
                e = e || 1;
                var s = 2 * RANDOM() * Math.PI;
                return t[0] = Math.cos(s) * e, t[1] = Math.sin(s) * e, t;
            }, transformMat22 = function(t, e, s) {
                var i = e[0], e = e[1];
                return t[0] = s[0] * i + s[2] * e, t[1] = s[1] * i + s[3] * e, t;
            }, transformMat2d2 = function(t, e, s) {
                var i = e[0], e = e[1];
                return t[0] = s[0] * i + s[2] * e + s[4], t[1] = s[1] * i + s[3] * e + s[5], 
                t;
            }, transformMat32 = function(t, e, s) {
                var i = e[0], e = e[1];
                return t[0] = s[0] * i + s[3] * e + s[6], t[1] = s[1] * i + s[4] * e + s[7], 
                t;
            }, transformMat42 = function(t, e, s) {
                var i = e[0], e = e[1];
                return t[0] = s[0] * i + s[4] * e + s[12], t[1] = s[1] * i + s[5] * e + s[13], 
                t;
            }, rotate2 = function(t, e, s, i) {
                var r = e[0] - s[0], e = e[1] - s[1], n = Math.sin(i), i = Math.cos(i);
                return t[0] = r * i - e * n + s[0], t[1] = r * n + e * i + s[1], 
                t;
            }, angle2 = function(t, e) {
                var s = t[0], t = t[1], i = e[0], e = e[1], r = Math.sqrt((s * s + t * t) * (i * i + e * e));
                return Math.acos(Math.min(Math.max(r && (s * i + t * e) / r, -1), 1));
            }, zero2 = function(t) {
                return t[0] = 0, t[1] = 0, t;
            }, str2 = function(t) {
                return "vec2(" + t[0] + ", " + t[1] + ")";
            }, exactEquals2 = function(t, e) {
                return t[0] === e[0] && t[1] === e[1];
            }, equals2 = function(t, e) {
                var s = t[0], t = t[1], i = e[0], e = e[1];
                return Math.abs(s - i) <= EPSILON * Math.max(1, Math.abs(s), Math.abs(i)) && Math.abs(t - e) <= EPSILON * Math.max(1, Math.abs(t), Math.abs(e));
            };
            setMatrixArrayType = setMatrixArrayType2, toRadian = toRadian2, equals$9 = equals$92, 
            create$8 = create$82, clone$8 = clone$82, copy$8 = copy$82, identity$5 = identity$52, 
            fromValues$8 = fromValues$82, set$8 = set$82, transpose$2 = transpose$22, 
            invert$5 = invert$52, adjoint$2 = adjoint$22, determinant$3 = determinant$32, 
            multiply$8 = multiply$82, rotate$4 = rotate$42, scale$8 = scale$82, 
            fromRotation$4 = fromRotation$42, fromScaling$3 = fromScaling$32, str$8 = str$82, 
            frob$3 = frob$32, LDU = LDU2, add$8 = add$82, subtract$6 = subtract$62, 
            exactEquals$8 = exactEquals$82, equals$8 = equals$82, multiplyScalar$3 = multiplyScalar$32, 
            multiplyScalarAndAdd$3 = multiplyScalarAndAdd$32, create$7 = create$72, 
            clone$7 = clone$72, copy$7 = copy$72, identity$4 = identity$42, fromValues$7 = fromValues$72, 
            set$7 = set$72, invert$4 = invert$42, determinant$2 = determinant$22, 
            multiply$7 = multiply$72, rotate$3 = rotate$32, scale$7 = scale$72, 
            translate$3 = translate$32, fromRotation$3 = fromRotation$32, fromScaling$2 = fromScaling$22, 
            fromTranslation$3 = fromTranslation$32, str$7 = str$72, frob$2 = frob$22, 
            add$7 = add$72, subtract$5 = subtract$52, multiplyScalar$2 = multiplyScalar$22, 
            multiplyScalarAndAdd$2 = multiplyScalarAndAdd$22, exactEquals$7 = exactEquals$72, 
            equals$7 = equals$72, create$6 = create$62, fromMat4$1 = fromMat4$12, 
            clone$6 = clone$62, copy$6 = copy$62, fromValues$6 = fromValues$62, 
            set$6 = set$62, identity$3 = identity$32, transpose$1 = transpose$12, 
            invert$3 = invert$32, adjoint$1 = adjoint$12, determinant$1 = determinant$12, 
            multiply$6 = multiply$62, translate$2 = translate$22, rotate$2 = rotate$22, 
            scale$6 = scale$62, fromTranslation$2 = fromTranslation$22, fromRotation$2 = fromRotation$22, 
            fromScaling$1 = fromScaling$12, fromMat2d = fromMat2d2, fromQuat$1 = fromQuat$12, 
            normalFromMat4 = normalFromMat42, projection = projection2, str$6 = str$62, 
            frob$1 = frob$12, add$6 = add$62, subtract$4 = subtract$42, multiplyScalar$1 = multiplyScalar$12, 
            multiplyScalarAndAdd$1 = multiplyScalarAndAdd$12, exactEquals$6 = exactEquals$62, 
            equals$6 = equals$62, create$5 = create$52, clone$5 = clone$52, copy$5 = copy$52, 
            fromValues$5 = fromValues$52, set$5 = set$52, identity$2 = identity$22, 
            transpose = transpose2, invert$2 = invert$22, adjoint = adjoint2, determinant = determinant2, 
            multiply$5 = multiply$52, translate$1 = translate$12, scale$5 = scale$52, 
            rotate$1 = rotate$12, rotateX$3 = rotateX$32, rotateY$3 = rotateY$32, 
            rotateZ$3 = rotateZ$32, fromTranslation$1 = fromTranslation$12, fromScaling = fromScaling2, 
            fromRotation$1 = fromRotation$12, fromXRotation = fromXRotation2, fromYRotation = fromYRotation2, 
            fromZRotation = fromZRotation2, fromRotationTranslation$1 = fromRotationTranslation$12, 
            fromQuat2 = fromQuat22, getTranslation$1 = getTranslation$12, getScaling = getScaling2, 
            getRotation = getRotation2, decompose = decompose2, fromRotationTranslationScale = fromRotationTranslationScale2, 
            fromRotationTranslationScaleOrigin = fromRotationTranslationScaleOrigin2, 
            fromQuat = fromQuat3, frustum = frustum2, perspectiveNO = perspectiveNO2, 
            perspectiveZO = perspectiveZO2, perspectiveFromFieldOfView = perspectiveFromFieldOfView2, 
            orthoNO = orthoNO2, orthoZO = orthoZO2, lookAt = lookAt2, targetTo = targetTo2, 
            str$5 = str$52, frob = frob2, add$5 = add$52, subtract$3 = subtract$32, 
            multiplyScalar = multiplyScalar2, multiplyScalarAndAdd = multiplyScalarAndAdd2, 
            exactEquals$5 = exactEquals$52, equals$5 = equals$52, create$4 = create$42, 
            clone$4 = clone$42, length$4 = length$42, fromValues$4 = fromValues$42, 
            copy$4 = copy$42, set$4 = set$42, add$4 = add$42, subtract$2 = subtract$22, 
            multiply$4 = multiply$42, divide$2 = divide$22, ceil$2 = ceil$22, floor$2 = floor$22, 
            min$2 = min$22, max$2 = max$22, round$2 = round$22, scale$4 = scale$42, 
            scaleAndAdd$2 = scaleAndAdd$22, distance$2 = distance$22, squaredDistance$2 = squaredDistance$22, 
            squaredLength$4 = squaredLength$42, negate$2 = negate$22, inverse$2 = inverse$22, 
            normalize$4 = normalize$42, dot$4 = dot$42, cross$2 = cross$22, lerp$4 = lerp$42, 
            slerp$1 = slerp$12, hermite = hermite2, bezier = bezier2, random$3 = random$32, 
            transformMat4$2 = transformMat4$22, transformMat3$1 = transformMat3$12, 
            transformQuat$1 = transformQuat$12, rotateX$2 = rotateX$22, rotateY$2 = rotateY$22, 
            rotateZ$2 = rotateZ$22, angle$1 = angle$12, zero$2 = zero$22, str$4 = str$42, 
            exactEquals$4 = exactEquals$42, equals$4 = equals$42, create$3 = create$32, 
            clone$3 = clone$32, fromValues$3 = fromValues$32, copy$3 = copy$32, 
            set$3 = set$32, add$3 = add$32, subtract$1 = subtract$12, multiply$3 = multiply$32, 
            divide$1 = divide$12, ceil$1 = ceil$12, floor$1 = floor$12, min$1 = min$12, 
            max$1 = max$12, round$1 = round$12, scale$3 = scale$32, scaleAndAdd$1 = scaleAndAdd$12, 
            distance$1 = distance$12, squaredDistance$1 = squaredDistance$12, length$3 = length$32, 
            squaredLength$3 = squaredLength$32, negate$1 = negate$12, inverse$1 = inverse$12, 
            normalize$3 = normalize$32, dot$3 = dot$32, cross$1 = cross$12, lerp$3 = lerp$32, 
            random$2 = random$22, transformMat4$1 = transformMat4$12, transformQuat = transformQuat2, 
            zero$1 = zero$12, str$3 = str$32, exactEquals$3 = exactEquals$32, equals$3 = equals$32, 
            create$2 = create$22, identity$1 = identity$12, setAxisAngle = setAxisAngle2, 
            getAxisAngle = getAxisAngle2, getAngle = getAngle2, multiply$2 = multiply$22, 
            rotateX$1 = rotateX$12, rotateY$1 = rotateY$12, rotateZ$1 = rotateZ$12, 
            calculateW = calculateW2, exp = exp2, ln = ln2, pow = pow2, slerp = slerp2, 
            random$1 = random$12, invert$1 = invert$12, conjugate$1 = conjugate$12, 
            fromMat3 = fromMat32, fromEuler = fromEuler2, str$2 = str$22, equals$2 = equals$22, 
            create$1 = create$12, clone$1 = clone$12, fromValues$1 = fromValues$12, 
            fromRotationTranslationValues = fromRotationTranslationValues2, fromRotationTranslation = fromRotationTranslation2, 
            fromTranslation = fromTranslation2, fromRotation = fromRotation2, fromMat4 = fromMat42, 
            copy$1 = copy$12, identity = identity2, set$1 = set$12, getDual = getDual2, 
            setDual = setDual2, getTranslation = getTranslation2, translate = translate2, 
            rotateX = rotateX2, rotateY = rotateY2, rotateZ = rotateZ2, rotateByQuatAppend = rotateByQuatAppend2, 
            rotateByQuatPrepend = rotateByQuatPrepend2, rotateAroundAxis = rotateAroundAxis2, 
            add$1 = add$12, multiply$1 = multiply$12, scale$1 = scale$12, lerp$1 = lerp$12, 
            invert = invert2, conjugate = conjugate2, normalize$1 = normalize$12, 
            str$1 = str$12, exactEquals$1 = exactEquals$12, equals$1 = equals$12, 
            create = create2, clone = clone2, fromValues = fromValues2, copy = copy2, 
            set = set2, add = add2, subtract = subtract2, multiply = multiply2, 
            divide = divide2, ceil = ceil2, floor = floor2, min = min2, max = max2, 
            round = round2, scale = scale2, scaleAndAdd = scaleAndAdd2, distance = distance2, 
            squaredDistance = squaredDistance2, length = length2, squaredLength = squaredLength2, 
            negate = negate2, inverse = inverse2, normalize = normalize2, dot = dot2, 
            cross = cross2, lerp = lerp2, random = random2, transformMat2 = transformMat22, 
            transformMat2d = transformMat2d2, transformMat3 = transformMat32, transformMat4 = transformMat42, 
            rotate = rotate2, angle = angle2, zero = zero2, str = str2, exactEquals = exactEquals2, 
            equals = equals2, EPSILON = 1e-6, ARRAY_TYPE = "undefined" != typeof Float32Array ? Float32Array : Array, 
            RANDOM = Math.random, ANGLE_ORDER = "zyx", degree = Math.PI / 180, Math.hypot || (Math.hypot = function() {
                for (var t = 0, e = arguments.length; e--; ) t += arguments[e] * arguments[e];
                return Math.sqrt(t);
            }), common = {
                __proto__: null,
                EPSILON: EPSILON,
                get _$ARRAY_TYPE$_() {
                    return ARRAY_TYPE;
                },
                _$RANDOM$_: RANDOM,
                _$ANGLE_ORDER$_: ANGLE_ORDER,
                _$setMatrixArrayType$_: setMatrixArrayType2,
                _$toRadian$_: toRadian2,
                equals: equals$92
            }, mul$8 = multiply$82, sub$6 = subtract$62, mat2 = Object.freeze({
                __proto__: null,
                create: create$82,
                clone: clone$82,
                _$copy$_: copy$82,
                identity: identity$52,
                _$fromValues$_: fromValues$82,
                set: set$82,
                _$transpose$_: transpose$22,
                _$invert$_: invert$52,
                _$adjoint$_: adjoint$22,
                _$determinant$_: determinant$32,
                multiply: multiply$82,
                rotate: rotate$42,
                scale: scale$82,
                _$fromRotation$_: fromRotation$42,
                _$fromScaling$_: fromScaling$32,
                _$str$_: str$82,
                _$frob$_: frob$32,
                _$LDU$_: LDU2,
                add: add$82,
                _$subtract$_: subtract$62,
                _$exactEquals$_: exactEquals$82,
                equals: equals$82,
                _$multiplyScalar$_: multiplyScalar$32,
                _$multiplyScalarAndAdd$_: multiplyScalarAndAdd$32,
                mul: mul$8,
                sub: sub$6
            }), mul$7 = multiply$72, sub$5 = subtract$52, mat2d = Object.freeze({
                __proto__: null,
                create: create$72,
                clone: clone$72,
                _$copy$_: copy$72,
                identity: identity$42,
                _$fromValues$_: fromValues$72,
                set: set$72,
                _$invert$_: invert$42,
                _$determinant$_: determinant$22,
                multiply: multiply$72,
                rotate: rotate$32,
                scale: scale$72,
                translate: translate$32,
                _$fromRotation$_: fromRotation$32,
                _$fromScaling$_: fromScaling$22,
                _$fromTranslation$_: fromTranslation$32,
                _$str$_: str$72,
                _$frob$_: frob$22,
                add: add$72,
                _$subtract$_: subtract$52,
                _$multiplyScalar$_: multiplyScalar$22,
                _$multiplyScalarAndAdd$_: multiplyScalarAndAdd$22,
                _$exactEquals$_: exactEquals$72,
                equals: equals$72,
                mul: mul$7,
                sub: sub$5
            }), mul$6 = multiply$62, sub$4 = subtract$42, mat3 = Object.freeze({
                __proto__: null,
                create: create$62,
                _$fromMat4$_: fromMat4$12,
                clone: clone$62,
                _$copy$_: copy$62,
                _$fromValues$_: fromValues$62,
                set: set$62,
                identity: identity$32,
                _$transpose$_: transpose$12,
                _$invert$_: invert$32,
                _$adjoint$_: adjoint$12,
                _$determinant$_: determinant$12,
                multiply: multiply$62,
                translate: translate$22,
                rotate: rotate$22,
                scale: scale$62,
                _$fromTranslation$_: fromTranslation$22,
                _$fromRotation$_: fromRotation$22,
                _$fromScaling$_: fromScaling$12,
                _$fromMat2d$_: fromMat2d2,
                _$fromQuat$_: fromQuat$12,
                _$normalFromMat4$_: normalFromMat42,
                _$projection$_: projection2,
                _$str$_: str$62,
                _$frob$_: frob$12,
                add: add$62,
                _$subtract$_: subtract$42,
                _$multiplyScalar$_: multiplyScalar$12,
                _$multiplyScalarAndAdd$_: multiplyScalarAndAdd$12,
                _$exactEquals$_: exactEquals$62,
                equals: equals$62,
                mul: mul$6,
                sub: sub$4
            }), perspective = perspectiveNO2, ortho = orthoNO2, mul$5 = multiply$52, 
            sub$3 = subtract$32, mat4 = Object.freeze({
                __proto__: null,
                create: create$52,
                clone: clone$52,
                _$copy$_: copy$52,
                _$fromValues$_: fromValues$52,
                set: set$52,
                identity: identity$22,
                _$transpose$_: transpose2,
                _$invert$_: invert$22,
                _$adjoint$_: adjoint2,
                _$determinant$_: determinant2,
                multiply: multiply$52,
                translate: translate$12,
                scale: scale$52,
                rotate: rotate$12,
                _$rotateX$_: rotateX$32,
                _$rotateY$_: rotateY$32,
                _$rotateZ$_: rotateZ$32,
                _$fromTranslation$_: fromTranslation$12,
                _$fromScaling$_: fromScaling2,
                _$fromRotation$_: fromRotation$12,
                _$fromXRotation$_: fromXRotation2,
                _$fromYRotation$_: fromYRotation2,
                _$fromZRotation$_: fromZRotation2,
                _$fromRotationTranslation$_: fromRotationTranslation$12,
                _$fromQuat2$_: fromQuat22,
                _$getTranslation$_: getTranslation$12,
                _$getScaling$_: getScaling2,
                _$getRotation$_: getRotation2,
                _$decompose$_: decompose2,
                _$fromRotationTranslationScale$_: fromRotationTranslationScale2,
                _$fromRotationTranslationScaleOrigin$_: fromRotationTranslationScaleOrigin2,
                _$fromQuat$_: fromQuat3,
                _$frustum$_: frustum2,
                _$perspectiveNO$_: perspectiveNO2,
                perspective: perspective,
                _$perspectiveZO$_: perspectiveZO2,
                _$perspectiveFromFieldOfView$_: perspectiveFromFieldOfView2,
                _$orthoNO$_: orthoNO2,
                ortho: ortho,
                _$orthoZO$_: orthoZO2,
                _$lookAt$_: lookAt2,
                _$targetTo$_: targetTo2,
                _$str$_: str$52,
                _$frob$_: frob2,
                add: add$52,
                _$subtract$_: subtract$32,
                _$multiplyScalar$_: multiplyScalar2,
                _$multiplyScalarAndAdd$_: multiplyScalarAndAdd2,
                _$exactEquals$_: exactEquals$52,
                equals: equals$52,
                mul: mul$5,
                sub: sub$3
            }), sub$2 = subtract$22, mul$4 = multiply$42, div$2 = divide$22, dist$2 = distance$22, 
            sqrDist$2 = squaredDistance$22, len$4 = length$42, sqrLen$4 = squaredLength$42, 
            forEach$2 = (() => {
                var a = create$42();
                return function(t, e, s, i, r, n) {
                    var h, o;
                    for (e = e || 3, s = s || 0, o = i ? Math.min(i * e + s, t.length) : t.length, 
                    h = s; h < o; h += e) a[0] = t[h], a[1] = t[h + 1], a[2] = t[h + 2], 
                    r(a, a, n), t[h] = a[0], t[h + 1] = a[1], t[h + 2] = a[2];
                    return t;
                };
            })(), vec3 = Object.freeze({
                __proto__: null,
                create: create$42,
                clone: clone$42,
                length: length$42,
                _$fromValues$_: fromValues$42,
                _$copy$_: copy$42,
                set: set$42,
                add: add$42,
                _$subtract$_: subtract$22,
                multiply: multiply$42,
                _$divide$_: divide$22,
                ceil: ceil$22,
                floor: floor$22,
                min: min$22,
                max: max$22,
                round: round$22,
                scale: scale$42,
                _$scaleAndAdd$_: scaleAndAdd$22,
                _$distance$_: distance$22,
                _$squaredDistance$_: squaredDistance$22,
                _$squaredLength$_: squaredLength$42,
                _$negate$_: negate$22,
                inverse: inverse$22,
                normalize: normalize$42,
                _$dot$_: dot$42,
                _$cross$_: cross$22,
                _$lerp$_: lerp$42,
                _$slerp$_: slerp$12,
                _$hermite$_: hermite2,
                _$bezier$_: bezier2,
                random: random$32,
                _$transformMat4$_: transformMat4$22,
                _$transformMat3$_: transformMat3$12,
                _$transformQuat$_: transformQuat$12,
                _$rotateX$_: rotateX$22,
                _$rotateY$_: rotateY$22,
                _$rotateZ$_: rotateZ$22,
                angle: angle$12,
                _$zero$_: zero$22,
                _$str$_: str$42,
                _$exactEquals$_: exactEquals$42,
                equals: equals$42,
                sub: sub$2,
                mul: mul$4,
                div: div$2,
                _$dist$_: dist$2,
                _$sqrDist$_: sqrDist$2,
                _$len$_: len$4,
                _$sqrLen$_: sqrLen$4,
                forEach: forEach$2
            }), sub$1 = subtract$12, mul$3 = multiply$32, div$1 = divide$12, dist$1 = distance$12, 
            sqrDist$1 = squaredDistance$12, len$3 = length$32, sqrLen$3 = squaredLength$32, 
            forEach$1 = (() => {
                var a = create$32();
                return function(t, e, s, i, r, n) {
                    var h, o;
                    for (e = e || 4, s = s || 0, o = i ? Math.min(i * e + s, t.length) : t.length, 
                    h = s; h < o; h += e) a[0] = t[h], a[1] = t[h + 1], a[2] = t[h + 2], 
                    a[3] = t[h + 3], r(a, a, n), t[h] = a[0], t[h + 1] = a[1], t[h + 2] = a[2], 
                    t[h + 3] = a[3];
                    return t;
                };
            })(), vec4 = Object.freeze({
                __proto__: null,
                create: create$32,
                clone: clone$32,
                _$fromValues$_: fromValues$32,
                _$copy$_: copy$32,
                set: set$32,
                add: add$32,
                _$subtract$_: subtract$12,
                multiply: multiply$32,
                _$divide$_: divide$12,
                ceil: ceil$12,
                floor: floor$12,
                min: min$12,
                max: max$12,
                round: round$12,
                scale: scale$32,
                _$scaleAndAdd$_: scaleAndAdd$12,
                _$distance$_: distance$12,
                _$squaredDistance$_: squaredDistance$12,
                length: length$32,
                _$squaredLength$_: squaredLength$32,
                _$negate$_: negate$12,
                inverse: inverse$12,
                normalize: normalize$32,
                _$dot$_: dot$32,
                _$cross$_: cross$12,
                _$lerp$_: lerp$32,
                random: random$22,
                _$transformMat4$_: transformMat4$12,
                _$transformQuat$_: transformQuat2,
                _$zero$_: zero$12,
                _$str$_: str$32,
                _$exactEquals$_: exactEquals$32,
                equals: equals$32,
                sub: sub$1,
                mul: mul$3,
                div: div$1,
                _$dist$_: dist$1,
                _$sqrDist$_: sqrDist$1,
                _$len$_: len$3,
                _$sqrLen$_: sqrLen$3,
                forEach: forEach$1
            }), clone$2 = clone$32, fromValues$2 = fromValues$32, copy$2 = copy$32, 
            set$2 = set$32, add$2 = add$32, mul$2 = multiply$22, scale$2 = scale$32, 
            dot$2 = dot$32, lerp$2 = lerp$32, length$2 = length$32, len$2 = length$2, 
            squaredLength$2 = squaredLength$32, sqrLen$2 = squaredLength$2, normalize$2 = normalize$32, 
            exactEquals$2 = exactEquals$32, rotationTo = (() => {
                var r = create$42(), n = fromValues$42(1, 0, 0), h = fromValues$42(0, 1, 0);
                return function(t, e, s) {
                    var i = dot$42(e, s);
                    return i < -.999999 ? (cross$22(r, n, e), len$4(r) < 1e-6 && cross$22(r, h, e), 
                    normalize$42(r, r), setAxisAngle2(t, r, Math.PI), t) : .999999 < i ? (t[0] = 0, 
                    t[1] = 0, t[2] = 0, t[3] = 1, t) : (cross$22(r, e, s), t[0] = r[0], 
                    t[1] = r[1], t[2] = r[2], t[3] = 1 + i, normalize$2(t, t));
                };
            })(), sqlerp = (() => {
                var h = create$22(), o = create$22();
                return function(t, e, s, i, r, n) {
                    return slerp2(h, e, r, n), slerp2(o, s, i, n), slerp2(t, h, o, 2 * n * (1 - n)), 
                    t;
                };
            })(), setAxes = (() => {
                var r = create$62();
                return function(t, e, s, i) {
                    return r[0] = s[0], r[3] = s[1], r[6] = s[2], r[1] = i[0], r[4] = i[1], 
                    r[7] = i[2], r[2] = -e[0], r[5] = -e[1], r[8] = -e[2], normalize$2(t, fromMat32(t, r));
                };
            })(), quat = Object.freeze({
                __proto__: null,
                create: create$22,
                identity: identity$12,
                _$setAxisAngle$_: setAxisAngle2,
                _$getAxisAngle$_: getAxisAngle2,
                _$getAngle$_: getAngle2,
                multiply: multiply$22,
                _$rotateX$_: rotateX$12,
                _$rotateY$_: rotateY$12,
                _$rotateZ$_: rotateZ$12,
                _$calculateW$_: calculateW2,
                exp: exp2,
                _$ln$_: ln2,
                pow: pow2,
                _$slerp$_: slerp2,
                random: random$12,
                _$invert$_: invert$12,
                _$conjugate$_: conjugate$12,
                _$fromMat3$_: fromMat32,
                _$fromEuler$_: fromEuler2,
                _$str$_: str$22,
                clone: clone$2,
                _$fromValues$_: fromValues$2,
                _$copy$_: copy$2,
                set: set$2,
                add: add$2,
                mul: mul$2,
                scale: scale$2,
                _$dot$_: dot$2,
                _$lerp$_: lerp$2,
                length: length$2,
                _$len$_: len$2,
                _$squaredLength$_: squaredLength$2,
                _$sqrLen$_: sqrLen$2,
                normalize: normalize$2,
                _$exactEquals$_: exactEquals$2,
                equals: equals$22,
                _$rotationTo$_: rotationTo,
                _$sqlerp$_: sqlerp,
                _$setAxes$_: setAxes
            }), getReal = copy$2, setReal = copy$2, mul$1 = multiply$12, dot$1 = dot$2, 
            length$1 = length$2, len$1 = length$1, squaredLength$1 = squaredLength$2, 
            sqrLen$1 = squaredLength$1, quat2 = Object.freeze({
                __proto__: null,
                create: create$12,
                clone: clone$12,
                _$fromValues$_: fromValues$12,
                _$fromRotationTranslationValues$_: fromRotationTranslationValues2,
                _$fromRotationTranslation$_: fromRotationTranslation2,
                _$fromTranslation$_: fromTranslation2,
                _$fromRotation$_: fromRotation2,
                _$fromMat4$_: fromMat42,
                _$copy$_: copy$12,
                identity: identity2,
                set: set$12,
                _$getReal$_: getReal,
                _$getDual$_: getDual2,
                _$setReal$_: setReal,
                _$setDual$_: setDual2,
                _$getTranslation$_: getTranslation2,
                translate: translate2,
                _$rotateX$_: rotateX2,
                _$rotateY$_: rotateY2,
                _$rotateZ$_: rotateZ2,
                _$rotateByQuatAppend$_: rotateByQuatAppend2,
                _$rotateByQuatPrepend$_: rotateByQuatPrepend2,
                _$rotateAroundAxis$_: rotateAroundAxis2,
                add: add$12,
                multiply: multiply$12,
                mul: mul$1,
                scale: scale$12,
                _$dot$_: dot$1,
                _$lerp$_: lerp$12,
                _$invert$_: invert2,
                _$conjugate$_: conjugate2,
                length: length$1,
                _$len$_: len$1,
                _$squaredLength$_: squaredLength$1,
                _$sqrLen$_: sqrLen$1,
                normalize: normalize$12,
                _$str$_: str$12,
                _$exactEquals$_: exactEquals$12,
                equals: equals$12
            }), len = length2, sub = subtract2, mul = multiply2, div = divide2, 
            dist = distance2, sqrDist = squaredDistance2, sqrLen = squaredLength2, 
            forEach = (() => {
                var a = create2();
                return function(t, e, s, i, r, n) {
                    var h, o;
                    for (e = e || 2, s = s || 0, o = i ? Math.min(i * e + s, t.length) : t.length, 
                    h = s; h < o; h += e) a[0] = t[h], a[1] = t[h + 1], r(a, a, n), 
                    t[h] = a[0], t[h + 1] = a[1];
                    return t;
                };
            })(), vec2 = Object.freeze({
                __proto__: null,
                create: create2,
                clone: clone2,
                _$fromValues$_: fromValues2,
                _$copy$_: copy2,
                set: set2,
                add: add2,
                _$subtract$_: subtract2,
                multiply: multiply2,
                _$divide$_: divide2,
                ceil: ceil2,
                floor: floor2,
                min: min2,
                max: max2,
                round: round2,
                scale: scale2,
                _$scaleAndAdd$_: scaleAndAdd2,
                _$distance$_: distance2,
                _$squaredDistance$_: squaredDistance2,
                length: length2,
                _$squaredLength$_: squaredLength2,
                _$negate$_: negate2,
                inverse: inverse2,
                normalize: normalize2,
                _$dot$_: dot2,
                _$cross$_: cross2,
                _$lerp$_: lerp2,
                random: random2,
                _$transformMat2$_: transformMat22,
                _$transformMat2d$_: transformMat2d2,
                _$transformMat3$_: transformMat32,
                _$transformMat4$_: transformMat42,
                rotate: rotate2,
                angle: angle2,
                _$zero$_: zero2,
                _$str$_: str2,
                _$exactEquals$_: exactEquals2,
                equals: equals2,
                _$len$_: len,
                sub: sub,
                mul: mul,
                div: div,
                _$dist$_: dist,
                _$sqrDist$_: sqrDist,
                _$sqrLen$_: sqrLen,
                forEach: forEach
            }), globalThis._$glMatrix$_ = common, globalThis._$glMatrix$_._$mat2$_ = mat2, 
            globalThis._$glMatrix$_._$mat2d$_ = mat2d, globalThis._$glMatrix$_._$mat3$_ = mat3, 
            globalThis._$glMatrix$_._$mat4$_ = mat4, globalThis._$glMatrix$_._$quat$_ = quat, 
            globalThis._$glMatrix$_._$quat2$_ = quat2, globalThis._$glMatrix$_._$vec2$_ = vec2, 
            globalThis._$glMatrix$_._$vec3$_ = vec3, globalThis._$glMatrix$_._$vec4$_ = vec4;
        }
        var EPSILON, ARRAY_TYPE, RANDOM, ANGLE_ORDER, degree, common, mul$8, sub$6, mat2, mul$7, sub$5, mat2d, mul$6, sub$4, mat3, perspective, ortho, mul$5, sub$3, mat4, sub$2, mul$4, div$2, dist$2, sqrDist$2, len$4, sqrLen$4, forEach$2, vec3, sub$1, mul$3, div$1, dist$1, sqrDist$1, len$3, sqrLen$3, forEach$1, vec4, clone$2, fromValues$2, copy$2, set$2, add$2, mul$2, scale$2, dot$2, lerp$2, length$2, len$2, squaredLength$2, sqrLen$2, normalize$2, exactEquals$2, rotationTo, sqlerp, setAxes, quat, getReal, setReal, mul$1, dot$1, length$1, len$1, squaredLength$1, sqrLen$1, quat2, len, sub, mul, div, dist, sqrDist, sqrLen, forEach, vec2, setMatrixArrayType, toRadian, equals$9, create$8, clone$8, copy$8, identity$5, fromValues$8, set$8, transpose$2, invert$5, adjoint$2, determinant$3, multiply$8, rotate$4, scale$8, fromRotation$4, fromScaling$3, str$8, frob$3, LDU, add$8, subtract$6, exactEquals$8, equals$8, multiplyScalar$3, multiplyScalarAndAdd$3, create$7, clone$7, copy$7, identity$4, fromValues$7, set$7, invert$4, determinant$2, multiply$7, rotate$3, scale$7, translate$3, fromRotation$3, fromScaling$2, fromTranslation$3, str$7, frob$2, add$7, subtract$5, multiplyScalar$2, multiplyScalarAndAdd$2, exactEquals$7, equals$7, create$6, fromMat4$1, clone$6, copy$6, fromValues$6, set$6, identity$3, transpose$1, invert$3, adjoint$1, determinant$1, multiply$6, translate$2, rotate$2, scale$6, fromTranslation$2, fromRotation$2, fromScaling$1, fromMat2d, fromQuat$1, normalFromMat4, projection, str$6, frob$1, add$6, subtract$4, multiplyScalar$1, multiplyScalarAndAdd$1, exactEquals$6, equals$6, create$5, clone$5, copy$5, fromValues$5, set$5, identity$2, transpose, invert$2, adjoint, determinant, multiply$5, translate$1, scale$5, rotate$1, rotateX$3, rotateY$3, rotateZ$3, fromTranslation$1, fromScaling, fromRotation$1, fromXRotation, fromYRotation, fromZRotation, fromRotationTranslation$1, fromQuat2, getTranslation$1, getScaling, getRotation, decompose, fromRotationTranslationScale, fromRotationTranslationScaleOrigin, fromQuat, frustum, perspectiveNO, perspectiveZO, perspectiveFromFieldOfView, orthoNO, orthoZO, lookAt, targetTo, str$5, frob, add$5, subtract$3, multiplyScalar, multiplyScalarAndAdd, exactEquals$5, equals$5, create$4, clone$4, length$4, fromValues$4, copy$4, set$4, add$4, subtract$2, multiply$4, divide$2, ceil$2, floor$2, min$2, max$2, round$2, scale$4, scaleAndAdd$2, distance$2, squaredDistance$2, squaredLength$4, negate$2, inverse$2, normalize$4, dot$4, cross$2, lerp$4, slerp$1, hermite, bezier, random$3, transformMat4$2, transformMat3$1, transformQuat$1, rotateX$2, rotateY$2, rotateZ$2, angle$1, zero$2, str$4, exactEquals$4, equals$4, create$3, clone$3, fromValues$3, copy$3, set$3, add$3, subtract$1, multiply$3, divide$1, ceil$1, floor$1, min$1, max$1, round$1, scale$3, scaleAndAdd$1, distance$1, squaredDistance$1, length$3, squaredLength$3, negate$1, inverse$1, normalize$3, dot$3, cross$1, lerp$3, random$2, transformMat4$1, transformQuat, zero$1, str$3, exactEquals$3, equals$3, create$2, identity$1, setAxisAngle, getAxisAngle, getAngle, multiply$2, rotateX$1, rotateY$1, rotateZ$1, calculateW, exp, ln, pow, slerp, random$1, invert$1, conjugate$1, fromMat3, fromEuler, str$2, equals$2, create$1, clone$1, fromValues$1, fromRotationTranslationValues, fromRotationTranslation, fromTranslation, fromRotation, fromMat4, copy$1, identity, set$1, getDual, setDual, getTranslation, translate, rotateX, rotateY, rotateZ, rotateByQuatAppend, rotateByQuatPrepend, rotateAroundAxis, add$1, multiply$1, scale$1, lerp$1, invert, conjugate, normalize$1, str$1, exactEquals$1, equals$1, create, clone, fromValues, copy, set, add, subtract, multiply, divide, ceil, floor, min, max, round, scale, scaleAndAdd, distance, squaredDistance, length, squaredLength, negate, inverse, normalize, dot, cross, lerp, random, transformMat2, transformMat2d, transformMat3, transformMat4, rotate, angle, zero, str, exactEquals, equals, tmpPoint1, tmpPoint2, tmpLine1, tmpLine2, lineInt, lineSegmentsIntersect, triangleArea, isLeft, isLeftOn, isRight, isRightOn, collinear, sqdist, polygonAt, polygonClear, polygonAppend, polygonMakeCCW, polygonReverse, polygonIsReflex, polygonCanSee, polygonCanSee2, polygonCopy, polygonGetCutEdges, polygonDecomp, polygonSlice, polygonIsSimple, getIntersectionPoint, polygonQuickDecomp, polygonRemoveCollinearPoints, polygonRemoveDuplicatePoints, scalar_eq, points_eq, ReadBrandList, RunTest, GetWindowsNTVersionName, asyncifyRequest, asyncifyTransaction, openReadOnlyTransaction, openWriteTransaction, lazyOpenDatabase, RequireString, getEntriesFromCursor, NOT_IMPLEMENTED, DISALLOW_CALLBACK, StructuredClone, arrayFlat, assertFail, isValidTypeChange, logDefendedObjectWarning, CheckDefendedObjectsUsedCorrectly, getObjectPropertySet, VerifyObjectPropertiesConsistent, isNegativeZero, padTwoDigits, hueToRGB, RequireStringOrNumber, SetNewCallback, DoAsyncifiedWork, DoNextAsyncifiedJob, ClearTimeCache, CheckActiveIdleTimeouts, lookupHtmlEntity, bbToHtmlReplacerFunc, IsWordBreakWhiteSpace, IsOpeningCJKPunctiationChar, IsContinuingCJKPunctuationChar, WordBreakTrimEnd, IsNewline, PlaneFromPoints, IsInFrontOfPlane, IsPointInFrontOfPlane, interpolateQuad, GetFormatSpecifiers, fillOrStrokeRect, ptToPx, getOffsetParam, CheckPendingPolls, DebugLog, UpdateLayoutEndValues, makeNullFilledArray, SortZOrderList, GetDispatcher, MakeIWorldInstanceClass, GetDispatcher, GetTimelineState, GetTimelineState, GetTweenState, getActual, GetTypeFromFileExtension, AddScript, SortByInstLastCachedZIndex, SortByInstLastCachedZIndex, SortByInstZElevation, vec3EqualsXYZ, MaybePrepareLayerDraw, SortSolArray, IsSolArrayIdentical, NoActions, WrapIndex, GetExpressionFunc, EvalParams, EvalParams, GetInst, GetWorldInfo, GetInst_SDKv2, GetWorldInfo_SDKv2, GetObjectClass, GetLayer, CollMemory_Add, CollMemory_Remove, CollMemory_RemoveInstance, CollMemory_Get, DoOverlapCondition, FinishCollisionConditionPicking, FinishCollisionCondition, PickByUID_Normal, PickByUID_Inverted, GetNextParamMap, ValidateInternalAPIToken, ForEachOrdered_SortInstances, SortZOrderList, SortInstancesByValue, GetMouseSdkInstance, GetKeyboardSdkInstance, StringFromCharCode, getOffsetParam, normalizeCssColorString, GetTouchSdkInstance, WrapModeToStr, CloneDrawable, RunLengthDecode, IsExpressionType, SortFacesToDrawByDist, sqDistanceTo3D, distanceTo3D, lerp3d, lerp3d2, GetAudioSdkInstance, GetAudioDOMInterface, GetTCInst, GetTimelineParameter, ValidateTags, GetSdkInstance, ModeToDCType, InterpNetValue, MaybeCloseImageBitmap, accelerate, getIndexForEase, ValidateTags, SetObjectTypeCollisionsEnabled, UnwrapIWorldInstance, CloneVec2, SplitConvexPolysOver8Points, SplitConvexPoly, unaryminus, bothNumbers, add, subtract, multiply, divide, mod, pow, and, or;
        {
            let lineInt2 = function(t, e, s) {
                var i = [ 0, 0 ], r = t[1][1] - t[0][1], n = t[0][0] - t[1][0], t = r * t[0][0] + n * t[0][1], h = e[1][1] - e[0][1], o = e[0][0] - e[1][0], e = h * e[0][0] + o * e[0][1], a = r * o - h * n;
                return scalar_eq2(a, 0, s = s || 0) || (i[0] = (o * t - n * e) / a, 
                i[1] = (r * e - h * t) / a), i;
            }, lineSegmentsIntersect2 = function(t, e, s, i) {
                var r, n = e[0] - t[0], e = e[1] - t[1], h = i[0] - s[0];
                return h * e - (i = i[1] - s[1]) * n != 0 && (r = (h * (t[1] - s[1]) + i * (s[0] - t[0])) / (i * n - h * e), 
                0 <= (t = (n * (s[1] - t[1]) + e * (t[0] - s[0])) / (h * e - i * n))) && t <= 1 && 0 <= r && r <= 1;
            }, triangleArea2 = function(t, e, s) {
                return (e[0] - t[0]) * (s[1] - t[1]) - (s[0] - t[0]) * (e[1] - t[1]);
            }, isLeft2 = function(t, e, s) {
                return 0 < triangleArea2(t, e, s);
            }, isLeftOn2 = function(t, e, s) {
                return 0 <= triangleArea2(t, e, s);
            }, isRight2 = function(t, e, s) {
                return triangleArea2(t, e, s) < 0;
            }, isRightOn2 = function(t, e, s) {
                return triangleArea2(t, e, s) <= 0;
            }, collinear2 = function(t, e, s, i) {
                var r, n, h;
                return i ? (h = tmpPoint2, (n = tmpPoint1)[0] = e[0] - t[0], n[1] = e[1] - t[1], 
                h[0] = s[0] - e[0], h[1] = s[1] - e[1], r = n[0] * h[0] + n[1] * h[1], 
                n = Math.sqrt(n[0] * n[0] + n[1] * n[1]), h = Math.sqrt(h[0] * h[0] + h[1] * h[1]), 
                Math.acos(r / (n * h)) < i) : 0 === triangleArea2(t, e, s);
            }, sqdist2 = function(t, e) {
                var s = e[0] - t[0];
                return s * s + (e = e[1] - t[1]) * e;
            }, polygonAt2 = function(t, e) {
                var s = t.length;
                return t[e < 0 ? e % s + s : e % s];
            }, polygonClear2 = function(t) {
                t.length = 0;
            }, polygonAppend2 = function(t, e, s, i) {
                for (var r = s; r < i; r++) t.push(e[r]);
            }, polygonMakeCCW2 = function(t) {
                for (var e = 0, s = t, i = 1; i < t.length; ++i) (s[i][1] < s[e][1] || s[i][1] === s[e][1] && s[i][0] > s[e][0]) && (e = i);
                return !isLeft2(polygonAt2(t, e - 1), polygonAt2(t, e), polygonAt2(t, e + 1)) && (polygonReverse2(t), 
                !0);
            }, polygonReverse2 = function(t) {
                for (var e = [], s = t.length, i = 0; i !== s; i++) e.push(t.pop());
                for (i = 0; i !== s; i++) t[i] = e[i];
            }, polygonIsReflex2 = function(t, e) {
                return isRight2(polygonAt2(t, e - 1), polygonAt2(t, e), polygonAt2(t, e + 1));
            }, polygonCanSee3 = function(t, e, s) {
                var i, r = tmpLine1, n = tmpLine2;
                if (isLeftOn2(polygonAt2(t, e + 1), polygonAt2(t, e), polygonAt2(t, s)) && isRightOn2(polygonAt2(t, e - 1), polygonAt2(t, e), polygonAt2(t, s))) return !1;
                for (var h = sqdist2(polygonAt2(t, e), polygonAt2(t, s)), o = 0; o !== t.length; ++o) if ((o + 1) % t.length !== e && o !== e && isLeftOn2(polygonAt2(t, e), polygonAt2(t, s), polygonAt2(t, o + 1)) && isRightOn2(polygonAt2(t, e), polygonAt2(t, s), polygonAt2(t, o)) && (r[0] = polygonAt2(t, e), 
                r[1] = polygonAt2(t, s), n[0] = polygonAt2(t, o), n[1] = polygonAt2(t, o + 1), 
                i = lineInt2(r, n), sqdist2(polygonAt2(t, e), i) < h)) return !1;
                return !0;
            }, polygonCanSee22 = function(t, e, s) {
                for (var i = 0; i !== t.length; ++i) if (i !== e && i !== s && (i + 1) % t.length !== e && (i + 1) % t.length !== s && lineSegmentsIntersect2(polygonAt2(t, e), polygonAt2(t, s), polygonAt2(t, i), polygonAt2(t, i + 1))) return !1;
                return !0;
            }, polygonCopy2 = function(t, e, s, i) {
                var r = i || [];
                if (polygonClear2(r), e < s) for (var n = e; n <= s; n++) r.push(t[n]); else {
                    for (n = 0; n <= s; n++) r.push(t[n]);
                    for (n = e; n < t.length; n++) r.push(t[n]);
                }
                return r;
            }, polygonGetCutEdges2 = function(t) {
                for (var e = [], s = [], i = [], r = Number.MAX_VALUE, n = 0; n < t.length; ++n) if (polygonIsReflex2(t, n)) for (var h = 0; h < t.length; ++h) if (polygonCanSee3(t, n, h)) {
                    for (var s = polygonGetCutEdges2(polygonCopy2(t, n, h, i)), o = polygonGetCutEdges2(polygonCopy2(t, h, n, i)), a = 0; a < o.length; a++) s.push(o[a]);
                    s.length < r && (r = (e = s).length, e.push([ polygonAt2(t, n), polygonAt2(t, h) ]));
                }
                return e;
            }, polygonDecomp2 = function(t) {
                var e = polygonGetCutEdges2(t);
                return 0 < e.length ? polygonSlice2(t, e) : [ t ];
            }, polygonSlice2 = function(t, e) {
                if (0 === e.length) return [ t ];
                if (e instanceof Array && e.length && e[0] instanceof Array && 2 === e[0].length && e[0][0] instanceof Array) {
                    for (var s = [ t ], i = 0; i < e.length; i++) for (var r = e[i], n = 0; n < s.length; n++) {
                        var h = polygonSlice2(s[n], r);
                        if (h) {
                            s.splice(n, 1), s.push(h[0], h[1]);
                            break;
                        }
                    }
                    return s;
                }
                return i = t.indexOf((r = e)[0]), n = t.indexOf(r[1]), -1 !== i && -1 !== n && [ polygonCopy2(t, i, n), polygonCopy2(t, n, i) ];
            }, polygonIsSimple2 = function(t) {
                for (var e = t, s = 0; s < e.length - 1; s++) for (var i = 0; i < s - 1; i++) if (lineSegmentsIntersect2(e[s], e[s + 1], e[i], e[i + 1])) return !1;
                for (s = 1; s < e.length - 2; s++) if (lineSegmentsIntersect2(e[0], e[e.length - 1], e[s], e[s + 1])) return !1;
                return !0;
            }, getIntersectionPoint2 = function(t, e, s, i, r) {
                var n = e[1] - t[1], e = t[0] - e[0], t = n * t[0] + e * t[1], h = i[1] - s[1], i = s[0] - i[0], s = h * s[0] + i * s[1], o = n * i - h * e;
                return scalar_eq2(o, 0, r = r || 0) ? [ 0, 0 ] : [ (i * t - e * s) / o, (n * s - h * t) / o ];
            }, polygonQuickDecomp2 = function(t, e, s, i, r, n, h) {
                n = n || 100, h = h || 0, r = r || 25, e = void 0 !== e ? e : [], 
                s = s || [], i = i || [];
                var o = [ 0, 0 ], a = [ 0, 0 ], l = [ 0, 0 ], u = 0, c = 0, f = 0, d = 0, p = 0, m = 0, C = 0, g = [], S = [], _ = t, T = t;
                if (!(T.length < 3)) if (n < ++h) console.warn("quickDecomp: max level (" + n + ") reached."); else {
                    for (var y = 0; y < t.length; ++y) if (polygonIsReflex2(_, y)) {
                        s.push(_[y]);
                        for (var u = c = Number.MAX_VALUE, E = 0; E < t.length; ++E) isLeft2(polygonAt2(_, y - 1), polygonAt2(_, y), polygonAt2(_, E)) && isRightOn2(polygonAt2(_, y - 1), polygonAt2(_, y), polygonAt2(_, E - 1)) && (l = getIntersectionPoint2(polygonAt2(_, y - 1), polygonAt2(_, y), polygonAt2(_, E), polygonAt2(_, E - 1)), 
                        isRight2(polygonAt2(_, y + 1), polygonAt2(_, y), l)) && (f = sqdist2(_[y], l)) < c && (c = f, 
                        a = l, m = E), isLeft2(polygonAt2(_, y + 1), polygonAt2(_, y), polygonAt2(_, E + 1)) && isRightOn2(polygonAt2(_, y + 1), polygonAt2(_, y), polygonAt2(_, E)) && (l = getIntersectionPoint2(polygonAt2(_, y + 1), polygonAt2(_, y), polygonAt2(_, E), polygonAt2(_, E + 1)), 
                        isLeft2(polygonAt2(_, y - 1), polygonAt2(_, y), l)) && (f = sqdist2(_[y], l)) < u && (u = f, 
                        o = l, p = E);
                        if (m === (p + 1) % t.length) l[0] = (a[0] + o[0]) / 2, 
                        l[1] = (a[1] + o[1]) / 2, i.push(l), y < p ? (polygonAppend2(g, _, y, p + 1), 
                        g.push(l), S.push(l), 0 !== m && polygonAppend2(S, _, m, _.length), 
                        polygonAppend2(S, _, 0, y + 1)) : (0 !== y && polygonAppend2(g, _, y, _.length), 
                        polygonAppend2(g, _, 0, p + 1), g.push(l), S.push(l), polygonAppend2(S, _, m, y + 1)); else {
                            if (p < m && (p += t.length), d = Number.MAX_VALUE, 
                            p < m) return e;
                            for (E = m; E <= p; ++E) isLeftOn2(polygonAt2(_, y - 1), polygonAt2(_, y), polygonAt2(_, E)) && isRightOn2(polygonAt2(_, y + 1), polygonAt2(_, y), polygonAt2(_, E)) && (f = sqdist2(polygonAt2(_, y), polygonAt2(_, E))) < d && polygonCanSee22(_, y, E) && (d = f, 
                            C = E % t.length);
                            y < C ? (polygonAppend2(g, _, y, C + 1), 0 !== C && polygonAppend2(S, _, C, T.length), 
                            polygonAppend2(S, _, 0, y + 1)) : (0 !== y && polygonAppend2(g, _, y, T.length), 
                            polygonAppend2(g, _, 0, C + 1), polygonAppend2(S, _, C, y + 1));
                        }
                        return g.length < S.length ? (polygonQuickDecomp2(g, e, s, i, r, n, h), 
                        polygonQuickDecomp2(S, e, s, i, r, n, h)) : (polygonQuickDecomp2(S, e, s, i, r, n, h), 
                        polygonQuickDecomp2(g, e, s, i, r, n, h)), e;
                    }
                    e.push(t);
                }
                return e;
            }, polygonRemoveCollinearPoints2 = function(t, e) {
                for (var s = 0, i = t.length - 1; 3 < t.length && 0 <= i; --i) collinear2(polygonAt2(t, i - 1), polygonAt2(t, i), polygonAt2(t, i + 1), e) && (t.splice(i % t.length, 1), 
                s++);
                return s;
            }, polygonRemoveDuplicatePoints2 = function(t, e) {
                for (var s = t.length - 1; 1 <= s; --s) for (var i = t[s], r = s - 1; 0 <= r; --r) points_eq2(i, t[r], e) && t.splice(s, 1);
            }, scalar_eq2 = function(t, e, s) {
                return s = s || 0, Math.abs(t - e) <= s;
            }, points_eq2 = function(t, e, s) {
                return scalar_eq2(t[0], e[0], s) && scalar_eq2(t[1], e[1], s);
            };
            lineInt = lineInt2, lineSegmentsIntersect = lineSegmentsIntersect2, 
            triangleArea = triangleArea2, isLeft = isLeft2, isLeftOn = isLeftOn2, 
            isRight = isRight2, isRightOn = isRightOn2, collinear = collinear2, 
            sqdist = sqdist2, polygonAt = polygonAt2, polygonClear = polygonClear2, 
            polygonAppend = polygonAppend2, polygonMakeCCW = polygonMakeCCW2, polygonReverse = polygonReverse2, 
            polygonIsReflex = polygonIsReflex2, polygonCanSee = polygonCanSee3, 
            polygonCanSee2 = polygonCanSee22, polygonCopy = polygonCopy2, polygonGetCutEdges = polygonGetCutEdges2, 
            polygonDecomp = polygonDecomp2, polygonSlice = polygonSlice2, polygonIsSimple = polygonIsSimple2, 
            getIntersectionPoint = getIntersectionPoint2, polygonQuickDecomp = polygonQuickDecomp2, 
            polygonRemoveCollinearPoints = polygonRemoveCollinearPoints2, polygonRemoveDuplicatePoints = polygonRemoveDuplicatePoints2, 
            scalar_eq = scalar_eq2, points_eq = points_eq2, tmpPoint1 = [], tmpPoint2 = [], 
            tmpLine1 = [], tmpLine2 = [], self._$polyDecomp$_ = {
                _$decomp$_: polygonDecomp2,
                _$quickDecomp$_: polygonQuickDecomp2,
                _$isSimple$_: polygonIsSimple2,
                _$removeCollinearPoints$_: polygonRemoveCollinearPoints2,
                _$removeDuplicatePoints$_: polygonRemoveDuplicatePoints2,
                _$makeCCW$_: polygonMakeCCW2
            };
        }
        {
            let isReady = !1, hasAppStarted = !1, buildMode = "dev", internalApiToken = Symbol("Construct internal API token"), internalApiTokenAccessesRemaining = 14, C33 = self._$C3$_ = class {
                constructor() {
                    throw TypeError("static class can't be instantiated");
                }
                static _$_GetInternalAPIToken$_() {
                    if (internalApiTokenAccessesRemaining <= 0) throw new Error("cannot obtain internal API token");
                    return --internalApiTokenAccessesRemaining, internalApiToken;
                }
                static _$SetReady$_() {
                    isReady = !0;
                }
                static _$IsReady$_() {
                    return isReady;
                }
                static _$SetAppStarted$_() {
                    hasAppStarted = !0;
                }
                static _$HasAppStarted$_() {
                    return hasAppStarted;
                }
                static _$SetBuildMode$_(t) {
                    buildMode = t;
                }
                static _$GetBuildMode$_() {
                    return buildMode;
                }
                static _$IsReleaseBuild$_() {
                    return "final" === buildMode;
                }
            };
            C33.isDebug = !1, C33._$isDebugDefend$_ = !1, C33.hardwareConcurrency = navigator.hardwareConcurrency || 2, 
            self._$C3X$_ = {};
        }
        {
            const C33 = self._$C3$_;
            C33._$QueryParser$_ = class {
                constructor(t) {
                    this._$_queryString$_ = t, this._$_parameters$_ = new Map(), 
                    this._$_Parse$_();
                }
                _$_Parse$_() {
                    let t = this._$_queryString$_, e = (t = t.startsWith("?") || t.startsWith("#") ? t.substr(1) : t).split("&");
                    for (const s of e) this._$_ParseParameter$_(s);
                }
                _$_ParseParameter$_(t) {
                    if (t) if (t.includes("=")) {
                        const e = t.indexOf("="), s = decodeURIComponent(t.substring(0, e)), i = decodeURIComponent(t.substring(e + 1));
                        this._$_parameters$_.set(s, i);
                    } else this._$_parameters$_.set(t, null);
                }
                _$LogAll$_() {
                    for (const t of this._$_parameters$_) console.log("[QueryParser] Parameter '" + t[0] + "' = " + (null === t[1] ? "null" : "'" + t[1] + "'"));
                }
                _$Has$_(t) {
                    return this._$_parameters$_.has(t);
                }
                _$Get$_(t) {
                    const e = this._$_parameters$_.get(t);
                    return void 0 === e ? null : e;
                }
                _$ClearHash$_() {
                    history.replaceState("", document.title, location.pathname + location.search);
                }
                _$Reparse$_(t) {
                    this._$_queryString$_ = t, this._$_parameters$_.clear(), this._$_Parse$_();
                }
            }, C33._$QueryString$_ = new C33._$QueryParser$_(location.search), C33._$LocationHashString$_ = new C33._$QueryParser$_(location.hash), 
            C33._$QueryString$_._$Has$_("perf") && (C33._$isPerformanceProfiling$_ = !0), 
            "dev" !== C33._$QueryString$_._$Get$_("mode") && C33._$SetBuildMode$_("final");
        }
        {
            let GetWindowsNTVersionName2 = function(t) {
                const e = parseFloat(t), s = windowsNTVerMap.get(e);
                return s || (13 <= e ? "11" : "NT " + t);
            };
            GetWindowsNTVersionName = GetWindowsNTVersionName2;
            const C33 = self._$C3$_, UNKNOWN = "(unknown)", windowsNTVerMap = (C33._$Platform$_ = {
                _$OS$_: UNKNOWN,
                _$OSVersion$_: UNKNOWN,
                _$Browser$_: UNKNOWN,
                _$BrowserVersion$_: UNKNOWN,
                _$BrowserVersionNumber$_: NaN,
                _$BrowserEngine$_: UNKNOWN,
                _$Context$_: "browser",
                _$IsDesktop$_: !0,
                _$IsMobile$_: !1,
                _$IsAppleOS$_: !1,
                _$IsIpadOS$_: !1,
                _$GetDetailedInfo$_: async () => {}
            }, new Map([ [ 5, "2000" ], [ 5.1, "XP" ], [ 5.2, "XP" ], [ 6, "Vista" ], [ 6.1, "7" ], [ 6.2, "8" ], [ 6.3, "8.1" ], [ 10, "10" ] ])), uaStr = navigator.userAgent, uaData = navigator.userAgentData;
            if (uaData && 0 < uaData.brands.length) {
                let ReadBrandList2 = function(t) {
                    let s = "", i = "", r = "", n = "";
                    for (const h of t) {
                        const o = d.get(h.brand), a = (!s && o && (s = o, i = h.version), 
                        e.get(h.brand));
                        !r && a && (r = a, n = h.version);
                    }
                    s || "Chromium" !== r || (C33._$Platform$_._$Browser$_ = "Chromium", 
                    C33._$Platform$_._$BrowserVersion$_ = n), C33._$Platform$_._$Browser$_ = s || UNKNOWN, 
                    C33._$Platform$_._$BrowserVersion$_ = i || UNKNOWN, C33._$Platform$_._$BrowserEngine$_ = r || UNKNOWN;
                };
                ReadBrandList = ReadBrandList2, C33._$Platform$_._$OS$_ = uaData.platform, 
                C33._$Platform$_._$IsMobile$_ = uaData.mobile, C33._$Platform$_._$IsDesktop$_ = !C33._$Platform$_._$IsMobile$_;
                const d = new Map([ [ "Google Chrome", "Chrome" ], [ "Microsoft Edge", "Edge" ], [ "Opera", "Opera" ], [ "Opera GX", "Opera GX" ], [ "Mozilla Firefox", "Firefox" ], [ "Apple Safari", "Safari" ], [ "NW.js", "NW.js" ] ]), e = new Map([ [ "Chromium", "Chromium" ], [ "Gecko", "Gecko" ], [ "WebKit", "WebKit" ] ]);
                ReadBrandList2(uaData.brands);
                let o = !1;
                C33._$Platform$_._$GetDetailedInfo$_ = async () => {
                    if (!o) try {
                        const t = await navigator.userAgentData.getHighEntropyValues([ "platformVersion", "fullVersionList" ]);
                        ReadBrandList2(t.fullVersionList), "Windows" === C33._$Platform$_._$OS$_ ? C33._$Platform$_._$OSVersion$_ = GetWindowsNTVersionName2(t.platformVersion) : C33._$Platform$_._$OSVersion$_ = t.platformVersion, 
                        o = !0;
                    } catch (t) {
                        console.warn("Failed to get detailed user agent information: ", t);
                    }
                };
            } else {
                let RunTest2 = function(t, e) {
                    const s = Array.isArray(t) ? t : [ t ];
                    for (const i of s) {
                        const r = i.exec(uaStr);
                        if (r) {
                            e(r);
                            break;
                        }
                    }
                };
                RunTest = RunTest2, RunTest2(/windows\s+nt\s+([\d\.]+)/i, t => {
                    C33._$Platform$_._$OS$_ = "Windows";
                    const e = t[1];
                    C33._$Platform$_._$OSVersion$_ = GetWindowsNTVersionName2(e);
                }), RunTest2(/mac\s+os\s+x\s+([\d\._]+)/i, t => {
                    C33._$Platform$_._$OS$_ = "macOS", C33._$Platform$_._$OSVersion$_ = t[1].replace(/_/g, ".");
                }), RunTest2(/CrOS/, () => {
                    C33._$Platform$_._$OS$_ = "Chrome OS";
                }), RunTest2(/linux|openbsd|freebsd|netbsd/i, () => {
                    C33._$Platform$_._$OS$_ = "Linux";
                }), RunTest2(/android/i, () => {
                    C33._$Platform$_._$OS$_ = "Android";
                }), RunTest2(/android\s+([\d\.]+)/i, t => {
                    C33._$Platform$_._$OS$_ = "Android", C33._$Platform$_._$OSVersion$_ = t[1];
                }), C33._$Platform$_._$OS$_ === UNKNOWN && (RunTest2(/(iphone|ipod|ipad)/i, t => {
                    C33._$Platform$_._$OS$_ = "iOS";
                }), RunTest2([ /iphone\s+os\s+([\d\._]+)/i, /ipad[^)]*os\s+([\d\._]+)/i ], t => {
                    C33._$Platform$_._$OS$_ = "iOS", C33._$Platform$_._$OSVersion$_ = t[1].replace(/_/g, ".");
                }));
                const q = /chrome\//i.test(uaStr), r = /chromium\//i.test(uaStr), s = /edg\//i.test(uaStr), t = /OPR\//.test(uaStr), u = /nwjs/i.test(uaStr), v = /safari\//i.test(uaStr), w = /webkit/i.test(uaStr), x = (s || t || RunTest2(/chrome\/([\d\.]+)/i, t => {
                    C33._$Platform$_._$Browser$_ = "Chrome", C33._$Platform$_._$BrowserVersion$_ = t[1], 
                    C33._$Platform$_._$BrowserEngine$_ = "Chromium";
                }), RunTest2(/edg\/([\d\.]+)/i, t => {
                    C33._$Platform$_._$Browser$_ = "Edge", C33._$Platform$_._$BrowserVersion$_ = t[1], 
                    C33._$Platform$_._$BrowserEngine$_ = "Chromium";
                }), RunTest2(/OPR\/([\d\.]+)/, t => {
                    C33._$Platform$_._$Browser$_ = "Opera", C33._$Platform$_._$BrowserVersion$_ = t[1], 
                    C33._$Platform$_._$BrowserEngine$_ = "Chromium";
                }), RunTest2(/chromium\/([\d\.]+)/i, t => {
                    C33._$Platform$_._$Browser$_ = "Chromium", C33._$Platform$_._$BrowserVersion$_ = t[1], 
                    C33._$Platform$_._$BrowserEngine$_ = "Chromium";
                }), RunTest2(/nwjs\/[0-9.]+/i, t => {
                    C33._$Platform$_._$Browser$_ = "NW.js", C33._$Platform$_._$BrowserVersion$_ = t[1], 
                    C33._$Platform$_._$BrowserEngine$_ = "Chromium", C33._$Platform$_._$Context$_ = "nwjs";
                }), RunTest2(/firefox\/([\d\.]+)/i, t => {
                    C33._$Platform$_._$Browser$_ = "Firefox", C33._$Platform$_._$BrowserVersion$_ = t[1], 
                    C33._$Platform$_._$BrowserEngine$_ = "Gecko";
                }), !v || q || r || s || t || u || (C33._$Platform$_._$Browser$_ = "Safari", 
                C33._$Platform$_._$BrowserEngine$_ = "WebKit", RunTest2(/version\/([\d\.]+)/i, t => {
                    C33._$Platform$_._$BrowserVersion$_ = t[1];
                }), RunTest2(/crios\/([\d\.]+)/i, t => {
                    C33._$Platform$_._$Browser$_ = "Chrome for iOS", C33._$Platform$_._$BrowserVersion$_ = t[1];
                }), RunTest2(/fxios\/([\d\.]+)/i, t => {
                    C33._$Platform$_._$Browser$_ = "Firefox for iOS", C33._$Platform$_._$BrowserVersion$_ = t[1];
                }), RunTest2(/edgios\/([\d\.]+)/i, t => {
                    C33._$Platform$_._$Browser$_ = "Edge for iOS", C33._$Platform$_._$BrowserVersion$_ = t[1];
                })), C33._$Platform$_._$BrowserEngine$_ === UNKNOWN && w && (C33._$Platform$_._$BrowserEngine$_ = "WebKit"), 
                "Android" === C33._$Platform$_._$OS$_ && "Safari" === C33._$Platform$_._$Browser$_ && (C33._$Platform$_._$Browser$_ = "Stock"), 
                new Set([ "Windows", "macOS", "Linux", "Chrome OS" ])), y = x.has(C33._$Platform$_._$OS$_) || "nwjs" === C33._$Platform$_._$Context$_;
                C33._$Platform$_._$IsDesktop$_ = y, C33._$Platform$_._$IsMobile$_ = !y;
            }
            "Chrome" === C33._$Platform$_._$Browser$_ && "browser" === C33._$Platform$_._$Context$_ && /wv\)/.test(uaStr) && (C33._$Platform$_._$Context$_ = "webview"), 
            "nwjs" !== C33._$Platform$_._$Context$_ && "undefined" != typeof window && (window.matchMedia && window.matchMedia("(display-mode: standalone)").matches || navigator.standalone) && (C33._$Platform$_._$Context$_ = "webapp"), 
            C33._$Platform$_._$BrowserVersionNumber$_ = parseFloat(C33._$Platform$_._$BrowserVersion$_);
            const looksLikeIPadOS = "macOS" === C33._$Platform$_._$OS$_ && navigator.maxTouchPoints && 2 < navigator.maxTouchPoints;
            looksLikeIPadOS && (C33._$Platform$_._$OS$_ = "iOS", C33._$Platform$_._$OSVersion$_ = C33._$Platform$_._$BrowserVersion$_, 
            C33._$Platform$_._$IsDesktop$_ = !1, C33._$Platform$_._$IsMobile$_ = !0, 
            C33._$Platform$_._$IsIpadOS$_ = !0), C33._$Platform$_._$IsAppleOS$_ = "macOS" === C33._$Platform$_._$OS$_ || "iOS" === C33._$Platform$_._$OS$_;
        }
        {
            let asyncifyRequest2 = function(s) {
                return new Promise((t, e) => {
                    s.onsuccess = () => t(s.result), s.onerror = () => e(s.error);
                });
            }, asyncifyTransaction2 = function(s) {
                return new Promise((t, e) => {
                    s.oncomplete = () => t(), s.onerror = () => e(s.error), s.onabort = () => e(s.error);
                });
            }, openReadOnlyTransaction2 = function(t, e) {
                return openTransaction(t, e);
            }, openWriteTransaction2 = function(t, e) {
                return openTransaction(t, e, !0);
            }, lazyOpenDatabase2 = function(e) {
                RequireString2(e);
                let t = c.get(e);
                return t instanceof Promise || (t = openDatabase(e), c.set(e, t), 
                t.catch(t => c.delete(e))), t;
            }, RequireString2 = function(t) {
                if ("string" != typeof t) throw new TypeError("expected string");
            }, getEntriesFromCursor2 = function(t, r) {
                const e = t.objectStore(b).openCursor();
                return new Promise(s => {
                    const i = [];
                    e.onsuccess = t => {
                        const e = t.target.result;
                        if (e) {
                            switch (r) {
                              case "entries":
                                i.push([ e.key, e.value ]);
                                break;

                              case "keys":
                                i.push(e.key);
                                break;

                              case "values":
                                i.push(e.value);
                            }
                            e.continue();
                        } else s(i);
                    };
                });
            };
            asyncifyRequest = asyncifyRequest2, asyncifyTransaction = asyncifyTransaction2, 
            openReadOnlyTransaction = openReadOnlyTransaction2, openWriteTransaction = openWriteTransaction2, 
            lazyOpenDatabase = lazyOpenDatabase2, RequireString = RequireString2, 
            getEntriesFromCursor = getEntriesFromCursor2;
            const a = 2, b = "keyvaluepairs", c = new Map(), d = "undefined" != typeof IDBObjectStore && "function" == typeof IDBObjectStore.prototype.getAll, e = "undefined" != typeof IDBObjectStore && "function" == typeof IDBObjectStore.prototype.getAllKeys;
            async function openTransaction(e, s, i = !1, r = !0) {
                const t = await lazyOpenDatabase2(e);
                try {
                    const n = t.transaction([ b ], i ? "readwrite" : "readonly");
                    return s(n);
                } catch (t) {
                    if (r && "InvalidStateError" === t.name) return c.delete(e), 
                    openTransaction(e, s, i, !1);
                    throw t;
                }
            }
            async function openDatabase(s) {
                RequireString2(s);
                const t = indexedDB.open(s, a);
                return t.addEventListener("upgradeneeded", t => {
                    try {
                        const e = t.target.result;
                        e.createObjectStore(b);
                    } catch (t) {
                        console.error("Failed to create objectstore for database " + s, t);
                    }
                }), asyncifyRequest2(t);
            }
            class f {
                constructor(t) {
                    RequireString2(t), this.name = t;
                }
                async ready() {
                    await lazyOpenDatabase2(this.name);
                }
                set(r, n) {
                    return RequireString2(r), openWriteTransaction2(this.name, async t => {
                        const e = t.objectStore(b).put(n, r), s = asyncifyRequest2(e), i = asyncifyTransaction2(t);
                        await Promise.all([ i, s ]);
                    });
                }
                get(n) {
                    return RequireString2(n), openReadOnlyTransaction2(this.name, async t => {
                        const e = t.objectStore(b).get(n), s = asyncifyRequest2(e), i = asyncifyTransaction2(t), [ , r ] = await Promise.all([ i, s ]);
                        return r;
                    });
                }
                delete(r) {
                    return RequireString2(r), openWriteTransaction2(this.name, async t => {
                        const e = t.objectStore(b).delete(r), s = asyncifyRequest2(e), i = asyncifyTransaction2(t);
                        await Promise.all([ i, s ]);
                    });
                }
                clear() {
                    return openWriteTransaction2(this.name, async t => {
                        const e = t.objectStore(b).clear(), s = asyncifyRequest2(e), i = asyncifyTransaction2(t);
                        await Promise.all([ i, s ]);
                    });
                }
                keys() {
                    return openReadOnlyTransaction2(this.name, async t => {
                        let s;
                        if (e) {
                            const n = t.objectStore(b).getAllKeys();
                            s = asyncifyRequest2(n);
                        } else s = getEntriesFromCursor2(t, "keys");
                        const i = asyncifyTransaction2(t), [ , r ] = await Promise.all([ i, s ]);
                        return r;
                    });
                }
                values() {
                    return openReadOnlyTransaction2(this.name, async t => {
                        let e;
                        if (d) {
                            const r = t.objectStore(b).getAll();
                            e = asyncifyRequest2(r);
                        } else e = getEntriesFromCursor2(t, "values");
                        const s = asyncifyTransaction2(t), [ , i ] = await Promise.all([ s, e ]);
                        return i;
                    });
                }
                entries() {
                    return openReadOnlyTransaction2(this.name, async t => {
                        const e = getEntriesFromCursor2(t, "entries"), s = asyncifyTransaction2(t), [ , i ] = await Promise.all([ s, e ]);
                        return i;
                    });
                }
            }
            self._$KVStorageContainer$_ = f;
        }
        {
            let NOT_IMPLEMENTED2 = function(t) {
                throw new Error(`"${t}" is not implemented`);
            }, DISALLOW_CALLBACK2 = function(t) {
                if ("function" == typeof t) throw new Error("localforage callback API is not implemented; please use the promise API instead");
            }, StructuredClone2 = function(i) {
                return "object" == typeof i ? new Promise(e => {
                    const {
                        port1: t,
                        port2: s
                    } = new MessageChannel();
                    s.onmessage = t => e(t.data), t.postMessage(i);
                }) : Promise.resolve(i);
            };
            NOT_IMPLEMENTED = NOT_IMPLEMENTED2, DISALLOW_CALLBACK = DISALLOW_CALLBACK2, 
            StructuredClone = StructuredClone2;
            const a = self._$KVStorageContainer$_, b = [ /no available storage method found/i, /an attempt was made to break through the security policy of the user agent/i, /the user denied permission to access the database/i, /a mutation operation was attempted on a database that did not allow mutations/i, /idbfactory\.open\(\) called in an invalid security context/i ], c = new WeakMap();
            class d {
                constructor(t) {
                    this._$_inst$_ = t, this._$_isInMemory$_ = !this._$_inst$_, 
                    this._$_isInMemory$_ || "undefined" != typeof indexedDB || (this._$_isInMemory$_ = !0, 
                    console.warn("Unable to use local storage because IndexedDB API is not available")), 
                    this._$_memoryStorage$_ = new Map();
                }
                _$_MaybeSwitchToMemoryFallback$_(t) {
                    if (!this._$_isInMemory$_) for (const e of b) if (t && e.test(t.message)) {
                        console.error("Unable to use local storage, reverting to in-memory store: ", t, t.message), 
                        this._$_isInMemory$_ = !0;
                        break;
                    }
                }
                async _$_getItemFallback$_(t) {
                    const e = this._$_memoryStorage$_.get(t), s = await StructuredClone2(e);
                    return void 0 === s ? null : s;
                }
                async _$_setItemFallback$_(t, e) {
                    e = await StructuredClone2(e), this._$_memoryStorage$_.set(t, e);
                }
                _$_removeItemFallback$_(t) {
                    this._$_memoryStorage$_.delete(t);
                }
                _$_clearFallback$_() {
                    this._$_memoryStorage$_.clear();
                }
                _$_keysFallback$_() {
                    return Array.from(this._$_memoryStorage$_.keys());
                }
                _$IsInMemory$_() {
                    return this._$_isInMemory$_;
                }
                _$GetMemoryStorage$_() {
                    return this._$_memoryStorage$_;
                }
                _$SetMemoryStorage$_(t) {
                    this._$_memoryStorage$_ = t;
                }
                async getItem(e, t) {
                    if (DISALLOW_CALLBACK2(t), this._$_isInMemory$_) return this._$_getItemFallback$_(e);
                    let s;
                    try {
                        s = await this._$_inst$_.get(e);
                    } catch (t) {
                        return this._$_MaybeSwitchToMemoryFallback$_(t), this._$_isInMemory$_ ? this._$_getItemFallback$_(e) : (console.error(`Error reading '${e}' from storage, returning null: `, t), 
                        null);
                    }
                    return void 0 === s ? null : s;
                }
                async setItem(e, s, t) {
                    if (DISALLOW_CALLBACK2(t), void 0 === s && (s = null), this._$_isInMemory$_) await this._$_setItemFallback$_(e, s); else try {
                        await this._$_inst$_.set(e, s);
                    } catch (t) {
                        if (this._$_MaybeSwitchToMemoryFallback$_(t), !this._$_isInMemory$_) throw t;
                        await this._$_setItemFallback$_(e, s);
                    }
                }
                async removeItem(e, t) {
                    if (DISALLOW_CALLBACK2(t), this._$_isInMemory$_) this._$_removeItemFallback$_(e); else try {
                        await this._$_inst$_.delete(e);
                    } catch (t) {
                        this._$_MaybeSwitchToMemoryFallback$_(t), this._$_isInMemory$_ ? this._$_removeItemFallback$_(e) : console.error(`Error removing '${e}' from storage: `, t);
                    }
                }
                async clear(t) {
                    if (DISALLOW_CALLBACK2(t), this._$_isInMemory$_) this._$_clearFallback$_(); else try {
                        await this._$_inst$_.clear();
                    } catch (t) {
                        this._$_MaybeSwitchToMemoryFallback$_(t), this._$_isInMemory$_ ? this._$_clearFallback$_() : console.error("Error clearing storage: ", t);
                    }
                }
                async keys(t) {
                    if (DISALLOW_CALLBACK2(t), this._$_isInMemory$_) return this._$_keysFallback$_();
                    let e = [];
                    try {
                        e = await this._$_inst$_.keys();
                    } catch (t) {
                        if (this._$_MaybeSwitchToMemoryFallback$_(t), this._$_isInMemory$_) return this._$_keysFallback$_();
                        console.error("Error getting storage keys: ", t);
                    }
                    return e;
                }
                ready(t) {
                    return DISALLOW_CALLBACK2(t), this._$_isInMemory$_ ? Promise.resolve(!0) : this._$_inst$_.ready();
                }
                _$createInstance$_(t) {
                    if (t._$forceInMemoryFallback$_) return new d(null);
                    {
                        const e = t.name;
                        if ("string" != typeof e) throw new TypeError("invalid store name");
                        const s = new a(e);
                        return new d(s);
                    }
                }
                length(t) {
                    NOT_IMPLEMENTED2("localforage.length()");
                }
                key(t, e) {
                    NOT_IMPLEMENTED2("localforage.key()");
                }
                iterate(t, e) {
                    NOT_IMPLEMENTED2("localforage.iterate()");
                }
                _$setDriver$_(t) {
                    NOT_IMPLEMENTED2("localforage.setDriver()");
                }
                config(t) {
                    NOT_IMPLEMENTED2("localforage.config()");
                }
                _$defineDriver$_(t) {
                    NOT_IMPLEMENTED2("localforage.defineDriver()");
                }
                _$driver$_() {
                    NOT_IMPLEMENTED2("localforage.driver()");
                }
                supports(t) {
                    NOT_IMPLEMENTED2("localforage.supports()");
                }
                dropInstance() {
                    NOT_IMPLEMENTED2("localforage.dropInstance()");
                }
            }
            self.localforage = new d(new a("localforage"));
        }
        {
            const C33 = self._$C3$_;
            if (C33._$Supports$_ = {}, C33._$Supports$_._$WebAnimations$_ = (() => {
                try {
                    if ("undefined" == typeof document) return !1;
                    const t = document.createElement("div");
                    if (void 0 === t.animate) return !1;
                    const e = t.animate([ {
                        opacity: "0"
                    }, {
                        opacity: "1"
                    } ], 1e3);
                    return void 0 !== e.reverse;
                } catch (t) {
                    return !1;
                }
            })(), C33._$Supports$_._$DialogElement$_ = "undefined" != typeof HTMLDialogElement, 
            C33._$Supports$_._$RequestIdleCallback$_ = !!self.requestIdleCallback, 
            C33._$Supports$_.ImageBitmap = !!self.createImageBitmap, C33._$Supports$_.ImageBitmapOptions = !1, 
            C33._$Supports$_._$ImageBitmapOptionsResize$_ = !1, C33._$Supports$_.ImageBitmap) {
                try {
                    self.createImageBitmap(new ImageData(32, 32), {
                        premultiplyAlpha: "none"
                    }).then(() => {
                        C33._$Supports$_.ImageBitmapOptions = !0;
                    }).catch(() => {
                        C33._$Supports$_.ImageBitmapOptions = !1;
                    });
                } catch (e) {
                    C33._$Supports$_.ImageBitmapOptions = !1;
                }
                try {
                    self.createImageBitmap(new ImageData(32, 32), {
                        resizeWidth: 10,
                        resizeHeight: 10
                    }).then(t => {
                        C33._$Supports$_._$ImageBitmapOptionsResize$_ = 10 === t.width && 10 === t.height;
                    }).catch(() => {
                        C33._$Supports$_._$ImageBitmapOptionsResize$_ = !1;
                    });
                } catch (e) {
                    C33._$Supports$_._$ImageBitmapOptionsResize$_ = !1;
                }
            }
            if (C33._$Supports$_._$ClipboardReadText$_ = !(!navigator.clipboard || !navigator.clipboard.readText), 
            C33._$Supports$_._$PermissionsQuery$_ = !(!navigator.permissions || !navigator.permissions.query), 
            C33._$Supports$_._$ClipboardPermissionsQuery$_ = !1, C33._$Supports$_._$PermissionsQuery$_) {
                const g = {
                    name: "clipboard-read"
                };
                navigator.permissions.query(g).then(() => {
                    C33._$Supports$_._$ClipboardPermissionsQuery$_ = !0;
                }).catch(() => {
                    C33._$Supports$_._$ClipboardPermissionsQuery$_ = !1;
                });
            }
            C33._$Supports$_._$AsyncClipboardApi$_ = !!(navigator.permissions && navigator.clipboard && self.ClipboardItem), 
            C33._$Supports$_._$Proxies$_ = "undefined" != typeof Proxy, C33._$Supports$_._$DownloadAttribute$_ = (() => {
                if ("undefined" == typeof document) return !1;
                const t = document.createElement("a");
                return void 0 !== t.download;
            })(), C33._$Supports$_._$Fetch$_ = "function" == typeof fetch, C33._$Supports$_._$PersistentStorage$_ = !!(self.isSecureContext && "Opera" !== C33._$Platform$_._$Browser$_ && navigator.storage && navigator.storage.persist), 
            C33._$Supports$_._$StorageQuotaEstimate$_ = !!(self.isSecureContext && navigator.storage && navigator.storage.estimate), 
            C33._$Supports$_._$Fullscreen$_ = (() => {
                if ("undefined" == typeof document) return !1;
                if ("iOS" === C33._$Platform$_._$OS$_) return !1;
                const t = document.documentElement;
                return !!(t.requestFullscreen || t.msRequestFullscreen || t.mozRequestFullScreen || t.webkitRequestFullscreen);
            })(), C33._$Supports$_.ImageDecoder = void 0 !== self.ImageDecoder, 
            C33._$Supports$_._$WebCodecs$_ = !!self.VideoEncoder, C33._$Supports$_._$NativeFileSystemAPI$_ = !!self.showOpenFilePicker, 
            C33._$Supports$_._$QueryLocalFonts$_ = !!self.queryLocalFonts, C33._$Supports$_.UserActivation = !!navigator.userActivation, 
            C33._$Supports$_._$CanvasToBlobWebP$_ = !1, (async () => {
                let e;
                "undefined" == typeof document ? e = new OffscreenCanvas(32, 32) : ((e = document.createElement("canvas")).width = 32, 
                e.height = 32);
                const t = e.getContext("2d");
                t.fillStyle = "blue", t.fillRect(0, 0, 32, 32);
                let s = null;
                try {
                    e.convertToBlob ? s = await e.convertToBlob({
                        type: "image/webp",
                        quality: 1
                    }) : e.toBlob && (s = await new Promise(t => e.toBlob(t, "image/webp", 1))), 
                    C33._$Supports$_._$CanvasToBlobWebP$_ = s && "image/webp" === s.type;
                } catch (t) {
                    C33._$Supports$_._$CanvasToBlobWebP$_ = !1;
                }
            })();
        }
        {
            let arrayFlat2 = function(t, s) {
                return t.reduce((t, e) => (0 < s && Array.isArray(e) ? Array.prototype.push.apply(t, arrayFlat2(e, s - 1)) : t.push(e), 
                t), []);
            };
            arrayFlat = arrayFlat2;
            const C33 = self._$C3$_;
            if (!String.prototype.trimStart) {
                const a = /^[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]*/;
                String.prototype.trimStart = function() {
                    return this.replace(a, "");
                };
            }
            if (!String.prototype.trimEnd) {
                const c = /[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]*$/;
                String.prototype.trimEnd = function() {
                    return this.replace(c, "");
                };
            }
            String.prototype.replaceAll || (String.prototype.replaceAll = function(t, e) {
                return this.replace(new RegExp(C33._$EscapeRegex$_(t), "g"), e);
            }), Array.prototype.values || (Array.prototype.values = function*() {
                for (const t of this) yield t;
            }), Array.prototype.flat || (Array.prototype.flat = function(t = 1) {
                return arrayFlat2(this, t);
            }), Array.prototype.at || (Array.prototype.at = function(t) {
                if ((t = Math.trunc(t) || 0) < 0 && (t += this.length), !(t < 0 || t >= this.length)) return this[t];
            }), String.prototype.at || (String.prototype.at = function(t) {
                if ((t = Math.trunc(t) || 0) < 0 && (t += this.length), !(t < 0 || t >= this.length)) return this[t];
            }), RegExp.escape || (RegExp.escape = function(t) {
                return String(t).replace(/[\\^$*+?.()|[\]{}]/g, "\\$&");
            }), Set.prototype._$isSubsetOf$_ || (Set.prototype._$isSubsetOf$_ = function(t) {
                if (!(t instanceof Set)) throw new TypeError("argument must be a Set");
                for (const e of this) if (!t.has(e)) return !1;
                return !0;
            }), navigator.storage && !navigator.storage.estimate && navigator.webkitTemporaryStorage && navigator.webkitTemporaryStorage.queryUsageAndQuota && (navigator.storage.estimate = function() {
                return new Promise((s, t) => navigator.webkitTemporaryStorage.queryUsageAndQuota((t, e) => s({
                    usage: t,
                    quota: e
                }), t));
            }), void 0 === self.isSecureContext && (self.isSecureContext = "https:" === location.protocol), 
            void 0 === self.globalThis && (self.globalThis = self);
        }
        {
            let assertFail2 = function(t) {
                let e = C33._$GetCallStack$_(), s = "Assertion failure: " + t + "\n\nStack trace:\n" + e;
                console.error(s);
            };
            assertFail = assertFail2;
            const C33 = self._$C3$_;
            self.assert = function(t, e) {
                t || assertFail2(e);
            };
        }
        {
            const C33 = self._$C3$_, C3X = self._$C3X$_, TypedArray = (C33._$IsNumber$_ = function(t) {
                return "number" == typeof t;
            }, C33._$IsFiniteNumber$_ = function(t) {
                return C33._$IsNumber$_(t) && isFinite(t);
            }, C33._$RequireNumber$_ = function(t) {
                if (!C33._$IsNumber$_(t)) throw new TypeError("expected number");
            }, C33._$RequireOptionalNumber$_ = function(t) {
                C33._$IsNullOrUndefined$_(t);
            }, C33._$RequireNumberInRange$_ = function(t, e, s) {
                if (!C33._$IsNumber$_(t) || isNaN(t) || t < e || s < t) throw new RangeError("number outside of range");
            }, C33._$RequireAllNumber$_ = function(...e) {
                for (let t of e);
            }, C33._$RequireFiniteNumber$_ = function(t) {
                if (!C33._$IsFiniteNumber$_(t)) throw new TypeError("expected finite number");
            }, C33._$RequireOptionalFiniteNumber$_ = function(t) {
                C33._$IsNullOrUndefined$_(t);
            }, C33._$RequireAllFiniteNumber$_ = function(...e) {
                for (let t of e);
            }, C33._$IsString$_ = function(t) {
                return "string" == typeof t;
            }, C33._$RequireString$_ = function(t) {
                if (!C33._$IsString$_(t)) throw new TypeError("expected string");
            }, C33._$RequireOptionalString$_ = function(t) {
                C33._$IsNullOrUndefined$_(t);
            }, C33._$RequireAllString$_ = function(...e) {
                for (let t of e);
            }, C33._$IsSimpleObject$_ = function(t) {
                if ("object" != typeof t || null === t) return !1;
                let e = Object.getPrototypeOf(t);
                return e ? e.constructor === Object : null === e;
            }, C33._$RequireSimpleObject$_ = function(t) {
                if (!C33._$IsSimpleObject$_(t)) throw new TypeError("expected simple object");
            }, C33._$RequireOptionalSimpleObject$_ = function(t) {
                if (!C33._$IsNullOrUndefined$_(t) && !C33._$IsSimpleObject$_(t)) throw new TypeError("expected simple object");
            }, C33._$IsObject$_ = function(t) {
                return "object" == typeof t && null !== t && !Array.isArray(t);
            }, C33._$RequireObject$_ = function(t) {
                if (!C33._$IsObject$_(t)) throw new TypeError("expected object");
            }, C33._$RequireOptionalObject$_ = function(t) {
                C33._$IsNullOrUndefined$_(t);
            }, C33._$RequireAllObject$_ = function(...e) {
                for (let t of e);
            }, C33._$IsFileLike$_ = function(t) {
                return C33._$WeakIsInstanceOf$_(t, Blob) && "string" == typeof t.name;
            }, C33._$RequireFileLike$_ = function(t) {
                if (!C33._$IsFileLike$_(t)) throw new TypeError("expected file");
            }, C33._$RequireOptionalFileLike$_ = function(t) {
                C33._$IsNullOrUndefined$_(t);
            }, C33._$IsArray$_ = function(t) {
                return Array.isArray(t);
            }, C33._$RequireArray$_ = function(t) {
                if (!C33._$IsArray$_(t)) throw new TypeError("expected array");
            }, C33._$RequireOptionalArray$_ = function(t) {
                C33._$IsNullOrUndefined$_(t);
            }, C33._$RequireAllArray$_ = function(...e) {
                for (let t of e);
            }, C33._$Is2DArray$_ = function(t) {
                return !(!C33._$IsArray$_(t) || t.length && !C33._$IsArray$_(t[0]));
            }, C33._$Require2DArray$_ = function(e) {
                if (!C33._$Is2DArray$_(e)) throw new TypeError("expected 2d array");
                for (let t of e) if (!C33._$IsArray$_(t)) throw new TypeError("expected 2d array");
            }, C33._$RequireOptional2DArray$_ = function(t) {
                C33._$IsNullOrUndefined$_(t);
            }, C33._$IsFunction$_ = function(t) {
                return "function" == typeof t;
            }, C33._$RequireFunction$_ = function(t, e) {
                if (!C33._$IsFunction$_(t)) throw new TypeError("expected function");
                if (!C33._$IsNullOrUndefined$_(e) && t !== e) throw new TypeError("expected same function reference");
            }, C33._$RequireOptionalFunction$_ = function(t) {
                C33._$IsNullOrUndefined$_(t);
            }, C33._$RequireAllFunction$_ = function(...e) {
                for (let t of e);
            }, C33._$RequireAnyFunction$_ = function(e, ...s) {
                if (!C33._$IsFunction$_(e)) throw new TypeError("expected function");
                if (!s.length) throw new Error("missing comparison functions");
                for (let t of s) if (!C33._$IsNullOrUndefined$_(t) && e === t) return;
                throw new TypeError("expected same function reference");
            }, C33._$RequireOptionalAllFunction$_ = function(...e) {
                if (!C33._$IsNullOrUndefined$_(e)) for (let t of e);
            }, C33._$IsInstanceOf$_ = function(t, e) {
                return t instanceof e;
            }, C33._$IsInstanceOfAny$_ = function(e, ...s) {
                for (let t of s) if (C33._$IsInstanceOf$_(e, t)) return !0;
                return !1;
            }, C33._$RequireInstanceOf$_ = function(t, e) {
                if (!C33._$IsInstanceOf$_(t, e)) throw new TypeError("unexpected type");
            }, C33._$RequireOptionalInstanceOf$_ = function(t, e) {
                C33._$IsNullOrUndefined$_(t);
            }, C33._$RequireAllInstanceOf$_ = function(t, ...e) {
                for (let t of e);
            }, C33._$RequireAnyInstanceOf$_ = function(t, ...e) {
                if (!C33._$IsInstanceOfAny$_(t, ...e)) throw new TypeError("unexpected type");
            }, C33._$RequireAnyOptionalInstanceOf$_ = function(t, ...e) {
                if (!C33._$IsNullOrUndefined$_(t) && !C33._$IsInstanceOfAny$_(t, ...e)) throw new TypeError("unexpected type");
            }, C33._$IsArrayOf$_ = function(e, s) {
                for (let t of e) if (!C33._$IsInstanceOf$_(t, s)) return !1;
                return !0;
            }, C33._$IsArrayOfFiniteNumbers$_ = function(e) {
                for (let t of e) if (!C33._$IsFiniteNumber$_(t)) return !1;
                return !0;
            }, C33._$RequireArrayOf$_ = function(e, t) {
                for (let t of e);
            }, C33._$RequireOptionalArrayOf$_ = function(e, t) {
                if (!C33._$IsNullOrUndefined$_(e)) for (let t of e);
            }, C33._$RequireOptionalArrayOfFunctions$_ = function(e, t) {
                if (!C33._$IsNullOrUndefined$_(e)) for (let t of e);
            }, C33._$RequireArrayOfAny$_ = function(e) {
                for (let t of e);
            }, C33._$RequireOptionalArrayOfAny$_ = function(e) {
                if (!C33._$IsNullOrUndefined$_(e)) for (let t of e);
            }, C33._$IsDOMNode$_ = function(t, e) {
                return !(C33._$IsNullOrUndefined$_(t) || !C33._$IsString$_(t.nodeName)) && (!e || C33._$equalsNoCase$_(t.nodeName, e));
            }, C33._$RequireDOMNode$_ = function(t, e) {
                if (C33._$IsNullOrUndefined$_(t) || !C33._$IsString$_(t.nodeName)) throw new TypeError("expected DOM node");
                if (e && !C33._$equalsNoCase$_(t.nodeName, e)) throw new TypeError(`expected DOM '${e}' node`);
            }, C33._$RequireOptionalDOMNode$_ = function(t, e) {
                C33._$IsNullOrUndefined$_(t);
            }, C33._$IsHTMLElement$_ = function(t, e) {
                return !(C33._$IsNullOrUndefined$_(t) || !C33._$IsString$_(t.tagName)) && (!e || C33._$equalsNoCase$_(t.tagName, e));
            }, C33._$RequireHTMLElement$_ = function(t, e) {
                if (C33._$IsNullOrUndefined$_(t) || !C33._$IsString$_(t.tagName)) throw new TypeError("expected HTML element");
                if (e && !C33._$equalsNoCase$_(t.tagName, e)) throw new TypeError(`expected HTML '${e}' element`);
            }, C33._$RequireOptionalHTMLElement$_ = function(t, e) {
                C33._$IsNullOrUndefined$_(t);
            }, C33._$IsDrawable$_ = function(t) {
                return C33._$IsHTMLElement$_(t, "img") || C33._$IsHTMLElement$_(t, "canvas") || C33._$IsHTMLElement$_(t, "video") || "undefined" != typeof OffscreenCanvas && t instanceof OffscreenCanvas || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap;
            }, C33._$RequireDrawable$_ = function(t) {
                if (!C33._$IsDrawable$_(t)) throw new TypeError("expected drawable");
            }, C33._$RequireOptionalDrawable$_ = function(t) {
                C33._$IsNullOrUndefined$_(t);
            }, C33._$IsDrawableOrImageData$_ = function(t) {
                return t instanceof ImageData || C33._$IsDrawable$_(t);
            }, C33._$RequireDrawableOrImageData$_ = function(t) {
                if (!C33._$IsDrawableOrImageData$_(t)) throw new TypeError("expected drawable or image data");
            }, C33._$RequireOptionalDrawableOrImageData$_ = function(t) {
                if (!C33._$IsNullOrUndefined$_(t) && !C33._$IsDrawableOrImageData$_(t)) throw new TypeError("expected drawable or image data");
            }, C33._$IsStringLike$_ = function(t) {
                return "string" == typeof t || C33.HtmlString && t instanceof C33.HtmlString || t instanceof C33._$BBString$_;
            }, C33._$RequireStringLike$_ = function(t) {
                if (!C33._$IsStringLike$_(t)) throw new TypeError("expected string-like");
            }, C33._$RequireOptionalStringLike$_ = function(t) {
                C33._$IsNullOrUndefined$_(t);
            }, C33._$RequireAllStringLike$_ = function(...e) {
                for (let t of e);
            }, C33._$RequireOverride$_ = function() {
                throw new Error("must be overridden");
            }, C33._$NotYetImplemented$_ = function() {
                throw new Error("not yet implemented");
            }, C33._$IsGeneratorFunction$_ = function(t) {
                return t.constructor === function*() {}.constructor;
            }, C33._$RequireGeneratorFunction$_ = function(t) {
                if (!C33._$IsGeneratorFunction$_(t)) throw new Error("expected generator function");
            }, C33._$IsIterable$_ = function(t) {
                return "function" === t[Symbol.iterator];
            }, C33._$RequireIterable$_ = function(t) {
                if (!C33._$IsIterable$_(t)) throw new Error("expected iterable");
            }, C33._$IsDefined$_ = function(t) {
                return !C33._$IsNullOrUndefined$_(t);
            }, C33._$IsNullOrUndefined$_ = function(t) {
                return null == t;
            }, C33._$AreArrayElementsOfSameType$_ = function(e) {
                let s = e[0].constructor;
                for (let t of e) if (t.constructor !== s) return !1;
                return s;
            }, C33._$AreArrayElementsOfType$_ = function(e, s) {
                for (let t of e) if (!(t instanceof s)) return !1;
                return !0;
            }, Object.getPrototypeOf(Uint8Array));
            C33._$IsTypedArray$_ = function(t) {
                return C33._$IsInstanceOf$_(t, TypedArray);
            }, C33._$RequireTypedArray$_ = function(t) {}, C33._$WeakRequireTypedArray$_ = function(t) {
                C33._$WeakRequireInstanceOf$_(t, TypedArray);
            }, C33._$WeakRequireAnyInstanceOf$_ = function(t, ...e) {
                if (!C33._$WeakIsAnyInstanceOf$_(t, ...e)) throw new TypeError("unexpected type");
            }, C33._$WeakIsAnyInstanceOf$_ = function(t, ...e) {
                for (const s of e) if (C33._$WeakIsInstanceOf$_(t, s)) return !0;
                return !1;
            }, C33._$WeakRequireInstanceOf$_ = function(t, e) {
                if (!C33._$WeakIsInstanceOf$_(t, e)) throw new TypeError("unexpected type");
            }, C33._$WeakIsInstanceOf$_ = function(t, e) {
                for (;t = Object.getPrototypeOf(t); ) if (t.constructor.name === e.name) return !0;
                return !1;
            }, C3X._$RequireNumber$_ = C33._$RequireNumber$_, C3X._$RequireOptionalNumber$_ = C33._$RequireOptionalNumber$_, 
            C3X._$RequireFiniteNumber$_ = C33._$RequireFiniteNumber$_, C3X._$RequireOptionalFiniteNumber$_ = C33._$RequireOptionalFiniteNumber$_, 
            C3X._$RequireString$_ = C33._$RequireString$_, C3X._$RequireOptionalString$_ = C33._$RequireOptionalString$_, 
            C3X._$RequireObject$_ = C33._$RequireObject$_, C3X._$RequireOptionalObject$_ = C33._$RequireOptionalObject$_, 
            C3X._$RequireArray$_ = C33._$RequireArray$_, C3X._$RequireOptionalArray$_ = C33._$RequireOptionalArray$_, 
            C3X._$RequireFunction$_ = C33._$RequireFunction$_, C3X._$RequireOptionalFunction$_ = C33._$RequireOptionalFunction$_, 
            C3X._$RequireInstanceOf$_ = C33._$RequireInstanceOf$_, C3X._$RequireOptionalInstanceOf$_ = C33._$RequireOptionalInstanceOf$_, 
            C3X._$IsNullOrUndefined$_ = C33._$IsNullOrUndefined$_;
        }
        {
            let isValidTypeChange2 = function(t, e) {
                let s = C33.getType(t), i = C33.getType(e);
                return "null" === s || "null" === i || "undefined" !== s && "undefined" !== i && s === i;
            }, logDefendedObjectWarning2 = function(t) {
                console.warn("[Defence] " + t + " @", C33._$GetCallStack$_());
            }, CheckDefendedObjectsUsedCorrectly2 = function() {
                if (checkRafId = -1, 0 < ctorObjectToProxy.size || 0 < ctorProxyToObject.size) {
                    let t = new Set([ ...ctorObjectToProxy.keys() ].map(t => C33._$getName$_(t))), e = [ ...t ].join(",");
                    console.warn("An object derived from DefendedBase was not protected with debugDefend(). This will disable some checks. See the coding guidelines! Possible affected class names: " + e), 
                    ctorObjectToProxy.clear(), ctorProxyToObject.clear();
                }
            }, getObjectPropertySet2 = function(e) {
                let s = new Set();
                for (let t in e) s.add(t);
                return s;
            }, VerifyObjectPropertiesConsistent2 = function(t, e) {
                let s = getObjectPropertySet2(e), i = typeProperties.get(t);
                if (i) {
                    let e = [];
                    for (let t of i.values()) s.has(t) ? s.delete(t) : e.push(t);
                    C33._$appendArray$_(e, [ ...s ]), e.length && console.warn(`[Defence] '${C33._$getName$_(t)}' constructor creates inconsistent properties: ` + e.join(", "));
                } else typeProperties.set(t, s);
            };
            isValidTypeChange = isValidTypeChange2, logDefendedObjectWarning = logDefendedObjectWarning2, 
            CheckDefendedObjectsUsedCorrectly = CheckDefendedObjectsUsedCorrectly2, 
            getObjectPropertySet = getObjectPropertySet2, VerifyObjectPropertiesConsistent = VerifyObjectPropertiesConsistent2;
            const C33 = self._$C3$_, logRafIds = new Map();
            C33._$ColorLog$_ = function(t, e) {
                console.log("%c" + t, "font-weight: bold; color:" + e);
            }, C33._$RafLog$_ = function(t, ...e) {
                logRafIds.has(t) || logRafIds.set(t, -1), -1 === logRafIds.get(t) && logRafIds.set(t, requestAnimationFrame(() => {
                    console.log("%c" + t, "font-weight: bold", ...e), logRafIds.set(t, -1);
                }));
            };
            let measures, ctorObjectToProxy = (C33._$StartMeasure$_ = function(t) {
                performance.mark(t), (measures = measures || new Map()).has(t) || measures.set(t, {
                    current: 0,
                    total: 0,
                    _$average$_: 0,
                    _$calls$_: 1,
                    toString: function() {
                        return `${t} :: current => ${this.current.toPrecision(3)} :: average => ${this._$average$_.toPrecision(3)} :: calls => ` + this._$calls$_;
                    }
                });
            }, C33._$EndMeasure$_ = function(t) {
                performance.measure("measure-" + t, t);
                const e = performance.getEntriesByName("measure-" + t)[0], s = measures.get(t);
                s.current = e.duration, s.total += s.current, s._$average$_ = s.total / s._$calls$_, 
                console.log(s.toString()), s._$calls$_++, performance.clearMarks(t), 
                performance.clearMeasures("measure-" + t);
            }, C33._$GetCallStack$_ = function() {
                return new Error().stack;
            }, C33._$Debugger$_ = function() {}, C33.cast = function(t, e) {
                return t && t instanceof e ? t : null;
            }, C33._$getName$_ = function(t) {
                return void 0 === t ? "undefined" : null === t ? "null" : "boolean" == typeof t ? "<boolean>" : C33._$IsNumber$_(t) ? "<number>" : C33._$IsString$_(t) ? "<string>" : C33._$IsArray$_(t) ? "<array>" : "symbol" == typeof t ? "<" + t.toString() + ">" : C33._$IsFunction$_(t) ? t.name && "Function" !== t.name ? t.name : "<anonymous function>" : "object" == typeof t ? t.constructor && t.constructor.name && "Object" !== t.constructor.name ? t.constructor.name : "<anonymous object>" : "<unknown>";
            }, C33.getType = function(t) {
                return null === t ? "null" : Array.isArray(t) ? "array" : typeof t;
            }, C33.range = function*(e, s) {
                if (!isFinite(Math.abs(e - s))) throw new Error("Invalid parameters");
                if (s < e) for (let t = e - 1; t >= s; t--) yield t; else for (let t = e; t < s; t++) yield t;
            }, new Map()), ctorProxyToObject = new Map(), proxyToObject = new WeakMap(), releasedObjects = new WeakMap();
            C33._$DefendHandler$_ = {};
            const VALID_GET_MISSING_KEYS = new Set([ "then", "splice" ]);
            C33._$DefendHandler$_.get = function(t, e) {
                return e in t || "symbol" == typeof e || VALID_GET_MISSING_KEYS.has(e) || logDefendedObjectWarning2(`Accessed missing property '${e}' from defended object '${C33._$getName$_(t)}', returning undefined`), 
                releasedObjects.has(t) && "symbol" != typeof e && !VALID_GET_MISSING_KEYS.has(e) && logDefendedObjectWarning2(`Accessed property '${e}' on a released object '${C33._$getName$_(t)}'
Object was originally released at: ${releasedObjects.get(t)})
Call stack at access: `), t[e];
            }, C33._$DefendHandler$_.set = function(t, e, s) {
                return e in t || ctorObjectToProxy.has(t) || logDefendedObjectWarning2(`Set non-existent property '${e}' to '${s}' on defended object '${C33._$getName$_(t)}'`), 
                isValidTypeChange2(t[e], s) || ctorObjectToProxy.has(t) || logDefendedObjectWarning2(`Set '${C33.getType(t[e])}' property '${e}' to type '${C33.getType(s)}' on defended object '${C33._$getName$_(t)}'`), 
                releasedObjects.has(t) && logDefendedObjectWarning2(`Set property '${e}' on a released object '${C33._$getName$_(t)}'
Object was originally released at: ${releasedObjects.get(t)})
Call stack at access: `), t[e] = s, !0;
            }, C33._$DefendHandler$_.deleteProperty = function(t, e) {
                throw new ReferenceError(`Cannot delete property '${e}' from defended object '${C33._$getName$_(t)}'`);
            }, C33._$DefendHandler$_.defineProperty = function(t, e, s) {
                throw new ReferenceError(`Cannot define property '${e}' on defended object '${C33._$getName$_(t)}'`);
            }, C33._$DefendHandler$_.enumerate = function(t) {
                throw new ReferenceError(`Cannot enumerate defended object '${C33._$getName$_(t)}'`);
            };
            let checkRafId = -1, typeProperties = (C33._$DefendedBase$_ = class {
                constructor() {
                    if (C33._$isDebugDefend$_ && C33._$Supports$_._$Proxies$_) {
                        let t = Object.create(new.target.prototype), e = new Proxy(t, C33._$DefendHandler$_);
                        return ctorObjectToProxy.set(t, e), ctorProxyToObject.set(e, t), 
                        proxyToObject.set(e, t), -1 === checkRafId && (checkRafId = requestAnimationFrame(CheckDefendedObjectsUsedCorrectly2)), 
                        e;
                    }
                }
            }, C33._$debugDefend$_ = function(e) {
                if (C33._$isDebugDefend$_ && C33._$Supports$_._$Proxies$_ && e instanceof C33._$DefendedBase$_) {
                    if (ctorProxyToObject.has(e)) {
                        let t = ctorProxyToObject.get(e);
                        ctorProxyToObject.delete(e), ctorObjectToProxy.delete(t);
                    }
                    return e;
                }
                return C33.isDebug ? Object.seal(e) : e;
            }, C33._$New$_ = function(t, ...e) {
                let s;
                try {
                    s = new t(...e);
                } catch (t) {
                    throw ctorProxyToObject.clear(), ctorObjectToProxy.clear(), 
                    t;
                }
                return C33._$isDebugDefend$_ && VerifyObjectPropertiesConsistent2(t, s), 
                C33._$debugDefend$_(s);
            }, C33._$Release$_ = function(t) {
                let e = proxyToObject.get(t);
                e && releasedObjects.set(e, C33._$GetCallStack$_());
            }, C33._$WasReleased$_ = function(t) {
                let e = proxyToObject.get(t);
                return !!e && !!releasedObjects.get(e);
            }, new Map());
            C33._$PerfMark$_ = class {
                constructor(t) {
                    this._$_name$_ = "", t && this.start(t);
                }
                start(t) {
                    C33._$isPerformanceProfiling$_ && (this._$_name$_ = t, performance.mark(this._$_name$_ + "-Start"));
                }
                end() {
                    C33._$isPerformanceProfiling$_ && (performance.mark(this._$_name$_ + "-End"), 
                    performance.measure(this._$_name$_, this._$_name$_ + "-Start", this._$_name$_ + "-End"));
                }
                next(t) {
                    C33._$isPerformanceProfiling$_ && (this.end(), this._$_name$_ = t, 
                    performance.mark(this._$_name$_ + "-Start"));
                }
            };
        }
        {
            let isNegativeZero2 = function(t) {
                return 0 === t && 1 / t < 0;
            };
            isNegativeZero = isNegativeZero2;
            const C33 = self._$C3$_, TWO_PI = 2 * Math.PI, D_TO_R = Math.PI / 180, R_TO_D = 180 / Math.PI, ALPHAEX_SHIFT = (C33.wrap = function(t, e, s) {
                t = Math.floor(t), e = Math.floor(e);
                const i = (s = Math.floor(s)) - e;
                if (0 == i) return s;
                if (t < e) {
                    const r = s - (e - t) % i;
                    return r === s ? 0 : r;
                }
                return e + (t - e) % i;
            }, C33._$mapToRange$_ = function(t, e, s, i, r) {
                const n = s - e;
                if (0 == n && 0 === i) return t;
                const h = r - i;
                return (t - e) * h / n + i;
            }, C33.normalize = function(t, e, s) {
                return e - s == 0 ? 1 : (t - e) / (s - e);
            }, C33._$clamp$_ = function(t, e, s) {
                return t < e ? e : s < t ? s : t;
            }, C33._$clampAngle$_ = function(t) {
                return (t %= TWO_PI) < 0 && (t += TWO_PI), t;
            }, C33._$toRadians$_ = function(t) {
                return t * D_TO_R;
            }, C33._$toDegrees$_ = function(t) {
                return t * R_TO_D;
            }, C33._$hypot2DFast$_ = function(t, e) {
                return Math.sqrt(t * t + e * e);
            }, C33._$hypot3DFast$_ = function(t, e, s) {
                return Math.sqrt(t * t + e * e + s * s);
            }, C33._$distanceTo$_ = function(t, e, s, i) {
                return C33._$hypot2DFast$_(s - t, i - e);
            }, C33._$distanceSquared$_ = function(t, e, s, i) {
                const r = s - t, n = i - e;
                return r * r + n * n;
            }, C33._$angleTo$_ = function(t, e, s, i) {
                return Math.atan2(i - e, s - t);
            }, C33._$angleDiff$_ = function(t, e) {
                if (t === e) return 0;
                let s = Math.sin(t), i = Math.cos(t), r = Math.sin(e), n = Math.cos(e), h = s * r + i * n;
                return 1 <= h ? 0 : h <= -1 ? Math.PI : Math.acos(h);
            }, C33._$angleRotate$_ = function(t, e, s) {
                let i = Math.sin(t), r = Math.cos(t), n = Math.sin(e), h = Math.cos(e);
                return Math.acos(i * n + r * h) > s ? 0 < r * n - i * h ? C33._$clampAngle$_(t + s) : C33._$clampAngle$_(t - s) : C33._$clampAngle$_(e);
            }, C33._$angleClockwise$_ = function(t, e) {
                let s = Math.sin(t), i = Math.cos(t), r = Math.sin(e), n = Math.cos(e);
                return i * r - s * n <= 0;
            }, C33._$angleLerp$_ = function(t, e, s, i = 0) {
                let r = C33._$angleDiff$_(t, e), n = TWO_PI * i;
                return C33._$angleClockwise$_(e, t) ? C33._$clampAngle$_(t + (r + n) * s) : C33._$clampAngle$_(t - (r + n) * s);
            }, C33._$angleLerpClockwise$_ = function(t, e, s, i = 0) {
                const r = C33._$angleDiff$_(t, e), n = TWO_PI * i;
                return C33._$angleClockwise$_(e, t) ? C33._$clampAngle$_(t + (r + n) * s) : C33._$clampAngle$_(t + (TWO_PI - r + n) * s);
            }, C33._$angleLerpAntiClockwise$_ = function(t, e, s, i = 0) {
                const r = C33._$angleDiff$_(t, e), n = TWO_PI * i;
                return C33._$angleClockwise$_(e, t) ? C33._$clampAngle$_(t - (-TWO_PI + r - n) * s) : C33._$clampAngle$_(t - (r + n) * s);
            }, C33._$angleReflect$_ = function(t, e) {
                const s = C33._$angleDiff$_(t, e);
                return C33._$angleClockwise$_(t, e) ? C33._$clampAngle$_(e - s) : C33._$clampAngle$_(e + s);
            }, C33._$lerp$_ = function(t, e, s) {
                return t + s * (e - t);
            }, C33._$unlerp$_ = function(t, e, s) {
                return t === e ? 0 : (s - t) / (e - t);
            }, C33._$relerp$_ = function(t, e, s, i, r) {
                return C33._$lerp$_(i, r, C33._$unlerp$_(t, e, s));
            }, C33._$qarp$_ = function(t, e, s, i) {
                return C33._$lerp$_(C33._$lerp$_(t, e, i), C33._$lerp$_(e, s, i), i);
            }, C33._$cubic$_ = function(t, e, s, i, r) {
                return C33._$lerp$_(C33._$qarp$_(t, e, s, r), C33._$qarp$_(e, s, i, r), r);
            }, C33._$cosp$_ = function(t, e, s) {
                return (t + e + (t - e) * Math.cos(s * Math.PI)) / 2;
            }, C33._$isPOT$_ = function(t) {
                return 0 < t && 0 == (t - 1 & t);
            }, C33._$nextHighestPowerOfTwo$_ = function(e) {
                --e;
                for (let t = 1; t < 32; t <<= 1) e |= e >> t;
                return e + 1;
            }, C33._$roundToNearestFraction$_ = function(t, e) {
                return Math.round(t * e) / e;
            }, C33._$floorToNearestFraction$_ = function(t, e) {
                return Math.floor(t * e) / e;
            }, C33._$roundToDp$_ = function(t, e) {
                e = Math.max(Math.floor(e), 0);
                const s = Math.pow(10, e);
                return Math.round(t * s) / s;
            }, C33._$countDecimals$_ = function(t) {
                return Math.floor(t) !== t && t.toString().split(".")[1].length || 0;
            }, C33.toFixed = function(t, e) {
                let s = t.toFixed(e), i = s.length - 1;
                for (;0 <= i && "0" === s.charAt(i); --i);
                return 0 <= i && "." === s.charAt(i) && --i, i < 0 ? s : s.substr(0, i + 1);
            }, C33._$PackRGB$_ = function(t, e, s) {
                return C33._$clamp$_(t, 0, 255) | C33._$clamp$_(e, 0, 255) << 8 | C33._$clamp$_(s, 0, 255) << 16;
            }, 1024), ALPHAEX_MAX = 1023, RGBEX_SHIFT = 16384, RGBEX_MAX = 8191, RGBEX_MIN = -8192, COMMON_ASPECT_RATIOS = (C33._$PackRGBAEx$_ = function(t, e, s, i) {
                return t = C33._$clamp$_(Math.floor(1024 * t), RGBEX_MIN, RGBEX_MAX), 
                e = C33._$clamp$_(Math.floor(1024 * e), RGBEX_MIN, RGBEX_MAX), s = C33._$clamp$_(Math.floor(1024 * s), RGBEX_MIN, RGBEX_MAX), 
                i = C33._$clamp$_(Math.floor(i * ALPHAEX_MAX), 0, ALPHAEX_MAX), 
                t < 0 && (t += RGBEX_SHIFT), e < 0 && (e += RGBEX_SHIFT), s < 0 && (s += RGBEX_SHIFT), 
                -(t * RGBEX_SHIFT * RGBEX_SHIFT * ALPHAEX_SHIFT + e * RGBEX_SHIFT * ALPHAEX_SHIFT + s * ALPHAEX_SHIFT + i);
            }, C33._$PackRGBEx$_ = function(t, e, s) {
                return C33._$PackRGBAEx$_(t, e, s, 1);
            }, C33._$GetRValue$_ = function(e) {
                if (0 <= e) return (255 & e) / 255;
                {
                    let t = Math.floor(-e / (RGBEX_SHIFT * RGBEX_SHIFT * ALPHAEX_SHIFT));
                    return t > RGBEX_MAX && (t -= RGBEX_SHIFT), t / 1024;
                }
            }, C33._$GetGValue$_ = function(e) {
                if (0 <= e) return ((65280 & e) >> 8) / 255;
                {
                    let t = Math.floor(-e % (RGBEX_SHIFT * RGBEX_SHIFT * ALPHAEX_SHIFT) / (RGBEX_SHIFT * ALPHAEX_SHIFT));
                    return t > RGBEX_MAX && (t -= RGBEX_SHIFT), t / 1024;
                }
            }, C33._$GetBValue$_ = function(e) {
                if (0 <= e) return ((16711680 & e) >> 16) / 255;
                {
                    let t = Math.floor(-e % (RGBEX_SHIFT * ALPHAEX_SHIFT) / ALPHAEX_SHIFT);
                    return t > RGBEX_MAX && (t -= RGBEX_SHIFT), t / 1024;
                }
            }, C33._$GetAValue$_ = function(t) {
                if (isNegativeZero2(t)) return 0;
                if (0 <= t) return 1;
                {
                    const e = Math.floor(-t % ALPHAEX_SHIFT);
                    return e / ALPHAEX_MAX;
                }
            }, C33._$greatestCommonDivisor$_ = function(e, s) {
                for (e = Math.floor(e), s = Math.floor(s); 0 !== s; ) {
                    let t = s;
                    s = e % s, e = t;
                }
                return e;
            }, [ [ 3, 2 ], [ 4, 3 ], [ 5, 4 ], [ 5, 3 ], [ 6, 5 ], [ 14, 9 ], [ 16, 9 ], [ 16, 10 ], [ 21, 9 ] ]), NO_HIT = (C33._$getAspectRatio$_ = function(s, i) {
                if ((s = Math.floor(s)) === (i = Math.floor(i))) return [ 1, 1 ];
                for (let e of COMMON_ASPECT_RATIOS) {
                    let t = s / e[0] * e[1];
                    if (Math.abs(i - t) < 1) return e.slice(0);
                    if (t = s / e[1] * e[0], Math.abs(i - t) < 1) return [ e[1], e[0] ];
                }
                let t = C33._$greatestCommonDivisor$_(s, i);
                return [ s / t, i / t ];
            }, C33._$segmentsIntersect$_ = function(t, e, s, i, r, n, h, o) {
                const a = Math.min(t, s), l = Math.max(t, s), u = Math.min(r, h), c = Math.max(r, h);
                if (l < u || c < a) return !1;
                const f = Math.min(e, i), d = Math.max(e, i), p = Math.min(n, o), m = Math.max(n, o);
                if (d < p || m < f) return !1;
                const C = r - t + h - s, g = n - e + o - i, S = s - t, _ = i - e, T = h - r, y = o - n, E = Math.abs(_ * T - y * S), A = T * g - y * C;
                if (Math.abs(A) > E) return !1;
                const I = S * g - _ * C;
                return Math.abs(I) <= E;
            }, C33._$segmentsIntersectPreCalc$_ = function(t, e, s, i, r, n, h, o, a, l, u, c) {
                const f = Math.min(a, u), d = Math.max(a, u);
                if (n < f || d < r) return !1;
                const p = Math.min(l, c), m = Math.max(l, c);
                if (o < p || m < h) return !1;
                const C = a - t + u - s, g = l - e + c - i, S = s - t, _ = i - e, T = u - a, y = c - l, E = Math.abs(_ * T - y * S), A = T * g - y * C;
                if (Math.abs(A) > E) return !1;
                const I = S * g - _ * C;
                return Math.abs(I) <= E;
            }, C33._$segmentIntersectsQuad$_ = function(t, e, s, i, r) {
                const n = Math.min(t, s), h = Math.max(t, s), o = Math.min(e, i), a = Math.max(e, i), l = r._$getTlx$_(), u = r._$getTly$_(), c = r._$getTrx$_(), f = r._$getTry$_(), d = r._$getBrx$_(), p = r._$getBry$_(), m = r._$getBlx$_(), C = r._$getBly$_();
                return C33._$segmentsIntersectPreCalc$_(t, e, s, i, n, h, o, a, l, u, c, f) || C33._$segmentsIntersectPreCalc$_(t, e, s, i, n, h, o, a, c, f, d, p) || C33._$segmentsIntersectPreCalc$_(t, e, s, i, n, h, o, a, d, p, m, C) || C33._$segmentsIntersectPreCalc$_(t, e, s, i, n, h, o, a, m, C, l, u);
            }, C33._$segmentIntersectsAnyN$_ = function(e, s, i, r, n) {
                let h = Math.min(e, i), o = Math.max(e, i), a = Math.min(s, r), l = Math.max(s, r), u = 0;
                for (let t = n.length - 4; u <= t; u += 2) if (C33._$segmentsIntersectPreCalc$_(e, s, i, r, h, o, a, l, n[u], n[u + 1], n[u + 2], n[u + 3])) return !0;
                return C33._$segmentsIntersectPreCalc$_(e, s, i, r, h, o, a, l, n[u], n[u + 1], n[0], n[1]);
            }, 2), PADDING = 1e-6;
            C33._$rayIntersect$_ = function(t, e, s, i, r, n, h, o) {
                const a = s - t, l = i - e, u = h - r, c = o - n, f = a * c - l * u;
                if (0 == f) return NO_HIT;
                const d = ((e - i) * (h - t) + a * (o - e)) / f;
                return 0 < d && d < 1 + PADDING ? (c * (h - t) + (r - h) * (o - e)) / f : NO_HIT;
            }, C33._$rayIntersectExtended$_ = function(t, e, s, i, r, n, h, o, a) {
                const l = (h - r) * a, u = (o - n) * a;
                return C33._$rayIntersect$_(t, e, s, i, r - l, n - u, h + l, o + u);
            }, C33._$isPointInTriangleInclusive$_ = function(t, e, s, i, r, n, h, o) {
                const a = r - s, l = n - i, u = h - s, c = o - i, f = t - s, d = e - i, p = a * a + l * l, m = a * u + l * c, C = a * f + l * d, g = u * u + c * c, S = u * f + c * d, _ = 1 / (p * g - m * m), T = (g * C - m * S) * _, y = (p * S - m * C) * _;
                return 0 <= T && 0 <= y && T + y <= 1;
            }, C33._$triangleCartesianToBarycentric$_ = function(t, e, s, i, r, n, h, o) {
                const a = r - s, l = n - i, u = h - s, c = o - i, f = t - s, d = e - i, p = a * a + l * l, m = a * u + l * c, C = u * u + c * c, g = f * a + d * l, S = f * u + d * c, _ = p * C - m * m, T = (C * g - m * S) / _, y = (p * S - m * g) / _, E = 1 - T - y;
                return [ E, T, y ];
            }, C33._$triangleBarycentricToCartesian3d$_ = function(t, e, s, i, r, n, h, o, a, l, u, c) {
                return [ t * i + e * h + s * l, t * r + e * o + s * u, t * n + e * a + s * c ];
            };
        }
        {
            let C33 = self._$C3$_, mainDocument = null, baseHref = "";
            if ("undefined" != typeof document) {
                const a = (mainDocument = document).querySelector("base");
                (baseHref = a && a.hasAttribute("href") ? a.getAttribute("href") : "") && !(baseHref = baseHref.startsWith("/") ? baseHref.substr(1) : baseHref).endsWith("/") && (baseHref += "/");
            }
            C33._$GetBaseHref$_ = function() {
                return baseHref;
            }, C33._$GetBaseURL$_ = function() {
                if (!mainDocument) return "";
                const t = mainDocument.location;
                return C33._$GetPathFromURL$_(t.origin + t.pathname) + baseHref;
            }, C33._$GetPathFromURL$_ = function(t) {
                if (!t.length) return t;
                if (t.endsWith("/") || t.endsWith("\\")) return t;
                const e = Math.max(t.lastIndexOf("/"), t.lastIndexOf("\\"));
                return -1 === e ? "" : t.substr(0, e + 1);
            }, C33._$GetFilenameFromURL$_ = function(t) {
                if (!t.length) return t;
                if (t.endsWith("/") || t.endsWith("\\")) return "";
                const e = Math.max(t.lastIndexOf("/"), t.lastIndexOf("\\"));
                return -1 === e ? t : t.substr(e + 1);
            }, C33._$GetFileExtension$_ = function(t) {
                let e = t.lastIndexOf(".");
                return e < 1 ? "" : t.substr(e);
            }, C33._$SetFileExtension$_ = function(t, e) {
                const s = t.lastIndexOf(".");
                return -1 === s ? t + "." + e : t.substr(0, s + 1) + e;
            }, C33._$GetFileNamePart$_ = function(t) {
                let e = t.lastIndexOf(".");
                return e < 1 ? t : t.substr(0, e);
            }, C33._$NormalizeFileSeparator$_ = function(t) {
                return t.replace(/\\/g, "/");
            }, C33._$IsFileExtension$_ = function(t, e) {
                const s = t ? C33._$GetFileExtension$_(t).slice(1) : "";
                return e === s;
            }, C33._$FileNameEquals$_ = function(t, e) {
                let s, i;
                return C33._$IsFileLike$_(t) && (s = C33._$GetFileNamePart$_(t.name)), 
                C33._$IsString$_(t) && (s = C33._$GetFileNamePart$_(t)), C33._$IsFileLike$_(e) && (i = C33._$GetFileNamePart$_(e.name)), 
                C33._$IsString$_(e) && (i = C33._$GetFileNamePart$_(e)), s === i;
            }, C33._$ParseFilePath$_ = function(t) {
                t = C33._$NormalizeFileSeparator$_(t);
                let e = /^\w\:\//.exec(t), s = (e ? (e = e[0], "/" !== (t = t.slice(3))[0] && (t = "/" + t)) : e = "", 
                (t = 1 < (t = t.replace(/\/{2,}/g, "/")).length && "/" === t.slice(-1) ? t.slice(0, -1) : t).lastIndexOf("/") + 1), i = "", r = t, n, h = "";
                0 < s && (i = t.slice(0, s), r = t.slice(s));
                const o = (n = r).lastIndexOf("."), a = (0 < o && (h = r.slice(o), 
                n = r.slice(0, -h.length)), e + i + r);
                return {
                    dir: i,
                    _$base$_: r,
                    name: n,
                    root: e,
                    ext: h,
                    _$full$_: a
                };
            }, C33._$Wait$_ = function(s, i) {
                return new Promise((t, e) => {
                    self.setTimeout(t, s, i);
                });
            }, C33._$swallowException$_ = function(t) {
                try {
                    t();
                } catch (t) {
                    C33.isDebug && console.warn("Swallowed exception: ", t);
                }
            }, C33._$noop$_ = function() {}, C33._$equalsNoCase$_ = function(t, e) {
                return "string" == typeof t && "string" == typeof e && (t === e || t.normalize().toLowerCase() === e.normalize().toLowerCase());
            }, C33._$equalsCase$_ = function(t, e) {
                return "string" == typeof t && "string" == typeof e && (t === e || t.normalize() === e.normalize());
            }, C33._$typedArraySet16$_ = function(t, e, s) {
                t[s++] = e[0], t[s++] = e[1], t[s++] = e[2], t[s++] = e[3], t[s++] = e[4], 
                t[s++] = e[5], t[s++] = e[6], t[s++] = e[7], t[s++] = e[8], t[s++] = e[9], 
                t[s++] = e[10], t[s++] = e[11], t[s++] = e[12], t[s++] = e[13], 
                t[s++] = e[14], t[s] = e[15];
            }, C33._$truncateArray$_ = function(t, e) {
                t.length = e;
            }, C33._$clearArray$_ = function(t) {
                t && 0 !== t.length && C33._$truncateArray$_(t, 0);
            }, C33._$clear2DArray$_ = function(s) {
                if (s) {
                    for (let e = 0; e < s.length; e++) {
                        let t = s[e];
                        C33._$truncateArray$_(t, 0);
                    }
                    C33._$truncateArray$_(s, 0);
                }
            }, C33._$extendArray$_ = function(e, s, i) {
                const r = e.length;
                if (!((s |= 0) <= r)) for (let t = r; t < s; ++t) e.push(i);
            }, C33._$resizeArray$_ = function(t, e, s) {
                const i = t.length;
                (e |= 0) < i ? C33._$truncateArray$_(t, e) : i < e && C33._$extendArray$_(t, e, s);
            }, C33._$shallowAssignArray$_ = function(t, e) {
                C33._$clearArray$_(t), C33._$appendArray$_(t, e);
            }, C33._$appendArray$_ = function(s, i) {
                if (i.length < 1e4) s.push(...i); else for (let t = 0, e = i.length; t < e; ++t) s.push(i[t]);
            }, C33._$arrayRemove$_ = function(s, i) {
                if (!((i = Math.floor(i)) < 0 || i >= s.length)) {
                    let e = s.length - 1;
                    for (let t = i; t < e; ++t) s[t] = s[t + 1];
                    C33._$truncateArray$_(s, e);
                }
            }, C33._$arrayFindRemove$_ = function(t, e) {
                let s = t.indexOf(e);
                0 <= s && t.splice(s, 1);
            }, C33._$arraysEqual$_ = function(e, s) {
                let i = e.length;
                if (s.length !== i) return !1;
                for (let t = 0; t < i; ++t) if (e[t] !== s[t]) return !1;
                return !0;
            }, C33._$arrayFilterOut$_ = function(s, i) {
                let r = [], n = 0;
                for (let e = 0, t = s.length; e < t; ++e) {
                    let t = s[e];
                    i(t) ? r.push(t) : (s[n] = t, ++n);
                }
                return C33._$truncateArray$_(s, n), r;
            }, C33._$arrayRemoveAllInSet$_ = function(s, i) {
                let t = s.length, r = 0;
                for (let e = 0, t = s.length; e < t; ++e) {
                    let t = s[e];
                    i.has(t) || (s[r++] = t);
                }
                return C33._$truncateArray$_(s, r), t - r;
            }, C33._$isArrayIndexInBounds$_ = function(t, e) {
                return t === Math.floor(t) && 0 <= t && t < e.length;
            }, C33._$validateArrayIndex$_ = function(t, e) {
                if (!C33._$isArrayIndexInBounds$_(t, e)) throw new RangeError("array index out of bounds");
            }, C33._$cloneArray$_ = function(t) {
                return t.slice();
            }, C33._$deepCloneArray$_ = function(t, s) {
                let i = [];
                for (let e of t) if (C33._$IsObject$_(e)) {
                    let t = s(e);
                    if (!t) throw new Error("missing clone");
                    if (t.constructor !== e.constructor) throw new Error("object is not a clone");
                    i.push(t);
                } else C33._$IsArray$_(e) ? i.push(C33._$deepCloneArray$_(e, s)) : i.push(e);
                return i;
            }, C33._$clone2DArray$_ = function(e) {
                let s = [];
                for (let t of e) s.push(t.slice());
                return s;
            }, C33._$splitStringAndNormalize$_ = function(t, e = " ") {
                return t ? t.split(e).map(t => t.trim()).filter(t => !!t) : [];
            }, C33._$filterSet$_ = function(t, e, s) {
                const i = new Set();
                for (const r of t.values()) e(r) && (s ? i.add(s(r)) : i.add(r));
                return i;
            }, C33._$mergeSets$_ = function(t, e) {
                return t.union ? t.union(e) : new Set([ ...t, ...e ]);
            }, C33._$mergeSetsInPlace$_ = function(t, e) {
                for (const s of e) t.add(s);
                return t;
            }, C33.first = function(e) {
                for (let t of e) return t;
                return null;
            }, C33.xor = function(t, e) {
                return !t != !e;
            }, C33.compare = function(t, e, s) {
                switch (e) {
                  case 0:
                    return t === s;

                  case 1:
                    return t !== s;

                  case 2:
                    return t < s;

                  case 3:
                    return t <= s;

                  case 4:
                    return s < t;

                  case 5:
                    return s <= t;

                  default:
                    return !1;
                }
            }, C33._$hasAnyOwnProperty$_ = function(e) {
                for (let t in e) if (e.hasOwnProperty(t)) return !0;
                return !1;
            }, C33._$PromiseAllWithProgress$_ = function(o, a) {
                return o.length ? new Promise((s, i) => {
                    let r = [], n = 0, h = !1;
                    for (let e = 0, t = o.length; e < t; ++e) r.push(void 0), o[e].then(t => {
                        h || (r[e] = t, ++n === o.length ? s(r) : a(n, o.length));
                    }).catch(t => {
                        h = !0, i(t);
                    });
                }) : Promise.resolve([]);
            };
            let memoryCallbacks = [], nextTaskId = (C33._$AddLibraryMemoryCallback$_ = function(t) {
                memoryCallbacks.push(t);
            }, C33._$GetEstimatedLibraryMemoryUsage$_ = function() {
                let s = 0;
                for (let e of memoryCallbacks) {
                    let t = e();
                    s += t;
                }
                return Math.floor(s);
            }, 1), activeTaskIds = new Map(), taskMessageChannel = new MessageChannel(), activeRPAFids = (taskMessageChannel.port2.onmessage = function(t) {
                const e = t.data, s = activeTaskIds.get(e);
                activeTaskIds.delete(e), s && s(performance.now());
            }, C33._$RequestUnlimitedAnimationFrame$_ = function(t) {
                const e = nextTaskId++;
                return activeTaskIds.set(e, t), taskMessageChannel.port1.postMessage(e), 
                e;
            }, C33._$CancelUnlimitedAnimationFrame$_ = function(t) {
                activeTaskIds.delete(t);
            }, C33._$PostTask$_ = C33._$RequestUnlimitedAnimationFrame$_, C33._$WaitForNextTask$_ = function() {
                return new Promise(t => C33._$PostTask$_(t));
            }, new Set());
            C33._$RequestPostAnimationFrame$_ = function(e) {
                const s = self.requestAnimationFrame(async t => {
                    await C33._$WaitForNextTask$_(), activeRPAFids.has(s) && (activeRPAFids.delete(s), 
                    e(t));
                });
                return activeRPAFids.add(s), s;
            }, C33._$CancelPostAnimationFrame$_ = function(t) {
                activeRPAFids.has(t) && (self.cancelAnimationFrame(t), activeRPAFids.delete(t));
            };
        }
        {
            const C33 = self._$C3$_;
            C33._$IsAbsoluteURL$_ = function(t) {
                return /^(?:[a-z\-]+:)?\/\//.test(t) || "data:" === t.substr(0, 5) || "blob:" === t.substr(0, 5);
            }, C33._$IsRelativeURL$_ = function(t) {
                return !C33._$IsAbsoluteURL$_(t);
            }, C33._$ThrowIfNotOk$_ = function(t) {
                if (!t.ok) throw new Error(`fetch '${t.url}' response returned ${t.status} ` + t.statusText);
            }, C33._$FetchOk$_ = function(t, e) {
                return fetch(t, e).then(t => (C33._$ThrowIfNotOk$_(t), t));
            }, C33._$FetchText$_ = function(t) {
                return C33._$FetchOk$_(t).then(t => t.text());
            }, C33._$FetchJson$_ = function(t) {
                return C33._$FetchOk$_(t).then(t => t.json());
            }, C33._$FetchBlob$_ = function(t) {
                return C33._$FetchOk$_(t).then(t => t.blob());
            }, C33._$FetchArrayBuffer$_ = function(t) {
                return C33._$FetchOk$_(t).then(t => t.arrayBuffer());
            }, C33._$FetchImage$_ = function(i) {
                return new Promise((t, e) => {
                    const s = new Image();
                    s.onload = () => t(s), s.onerror = t => e(t), s.src = i;
                });
            }, C33._$BlobToArrayBuffer$_ = function(i) {
                return "function" == typeof i.arrayBuffer ? i.arrayBuffer() : new Promise((t, e) => {
                    const s = new FileReader();
                    s.onload = () => t(s.result), s.onerror = () => e(s.error), 
                    s.readAsArrayBuffer(i);
                });
            }, C33._$BlobToString$_ = function(i) {
                return "function" == typeof i.text ? i.text() : new Promise((t, e) => {
                    const s = new FileReader();
                    s.onload = () => t(s.result), s.onerror = () => e(s.error), 
                    s.readAsText(i);
                });
            }, C33._$BlobToJson$_ = function(t) {
                return C33._$BlobToString$_(t).then(t => JSON.parse(t));
            }, C33._$BlobToImage$_ = async function(t, e) {
                let s = URL.createObjectURL(t);
                try {
                    const i = await C33._$FetchImage$_(s);
                    return URL.revokeObjectURL(s), s = "", e && "function" == typeof i.decode && await i.decode(), 
                    i;
                } finally {
                    s && URL.revokeObjectURL(s);
                }
            }, C33._$CreateCanvas$_ = function(t, e) {
                if ("undefined" == typeof document || "function" != typeof document.createElement) return new OffscreenCanvas(t, e);
                {
                    const s = document.createElement("canvas");
                    return s.width = t, s.height = e, s;
                }
            }, C33._$CanvasToBlob$_ = function(e, s, i) {
                if ("number" != typeof i && (i = 1), s = s || "image/png", i = C33._$clamp$_(i, 0, 1), 
                e.convertToBlob) return e.convertToBlob({
                    type: s,
                    quality: i
                });
                if (e.toBlob) return new Promise(t => e.toBlob(t, s, i));
                throw new Error("could not convert canvas to blob");
            }, C33._$DrawableToBlob$_ = function(t, e, s) {
                const i = C33._$CreateCanvas$_(t.width, t.height), r = i.getContext("2d");
                return r.drawImage(t, 0, 0), C33._$CanvasToBlob$_(i, e, s);
            }, C33._$ImageDataToBlob$_ = function(t, e, s) {
                if (C33._$Supports$_.ImageBitmapOptions) return createImageBitmap(t, {
                    premultiplyAlpha: "none"
                }).then(t => C33._$DrawableToBlob$_(t, e, s));
                if (C33._$Supports$_.ImageBitmap) return createImageBitmap(t).then(t => C33._$DrawableToBlob$_(t, e, s));
                {
                    const i = C33._$CreateCanvas$_(t.width, t.height), r = i.getContext("2d");
                    return r.putImageData(t, 0, 0), C33._$CanvasToBlob$_(i, e, s);
                }
            }, C33._$CopySet$_ = function(t, e) {
                t.clear();
                for (const s of e) t.add(s);
            }, C33._$MapToObject$_ = function(t) {
                const e = Object.create(null);
                for (const [ s, i ] of t.entries()) e[s] = i;
                return e;
            }, C33._$ObjectToMap$_ = function(t, e) {
                e.clear();
                for (const [ s, i ] of Object.entries(t)) e.set(s, i);
            }, C33._$ToSuperJSON$_ = function e(t) {
                if ("object" != typeof t || null === t) return t;
                if (t instanceof Set) return {
                    _c3type_: "set",
                    data: [ ...t ].map(t => e(t))
                };
                if (t instanceof Map) return {
                    _c3type_: "map",
                    data: [ ...t ].map(t => [ t[0], e(t[1]) ])
                };
                {
                    const s = Object.create(null);
                    for (const [ i, r ] of Object.entries(t)) s[i] = e(r);
                    return s;
                }
            }, C33._$FromSuperJSON$_ = function e(t) {
                if ("object" == typeof t & null !== t) {
                    if ("set" === t._c3type_) return new Set(t.data.map(t => e(t)));
                    if ("map" === t._c3type_) return new Map(t.data.map(t => [ t[0], e(t[1]) ]));
                    {
                        const s = Object.create(null);
                        for (const [ i, r ] of Object.entries(t)) s[i] = e(r);
                        return s;
                    }
                }
                return t;
            }, C33._$CSSToCamelCase$_ = function(t) {
                if (t.startsWith("--")) return t;
                let e = "", s = !1, i = 0;
                for (const r of t) "-" === r ? 0 < i && (s = !0) : s ? (e += r.toUpperCase(), 
                s = !1) : e += r, ++i;
                return e;
            }, C33._$IsIterator$_ = function(t) {
                return "object" == typeof t && "function" == typeof t.next;
            }, C33._$MakeFilledArray$_ = function(e, s) {
                const i = [];
                if ("function" == typeof s) for (let t = 0; t < e; ++t) i.push(s()); else for (let t = 0; t < e; ++t) i.push(s);
                return i;
            };
        }
        {
            let padTwoDigits2 = function(t) {
                return 0 === t.length ? "00" : 1 === t.length ? "0" + t : t;
            }, hueToRGB2 = function(t, e, s) {
                return s < 0 && (s += 1), 1 < s && --s, s < 1 / 6 ? t + 6 * (e - t) * s : s < .5 ? e : s < 2 / 3 ? t + (e - t) * (2 / 3 - s) * 6 : t;
            };
            padTwoDigits = padTwoDigits2, hueToRGB = hueToRGB2;
            const C33 = self._$C3$_, HSL_TEST = /([0-9.]+),([0-9.]+)\%?,([0-9.]+)\%?/i, HSLA_TEST = /([0-9.]+),([0-9.]+)\%?,([0-9.]+)\%?,([0-9.])/i;
            C33._$Color$_ = class {
                constructor(t, e, s, i) {
                    this._$_r$_ = NaN, this._$_g$_ = NaN, this._$_b$_ = NaN, this._$_a$_ = NaN, 
                    this._$_r$_ = 0, this._$_g$_ = 0, this._$_b$_ = 0, this._$_a$_ = 0, 
                    t instanceof C33._$Color$_ ? this.set(t) : this._$setRgba$_(t || 0, e || 0, s || 0, i || 0);
                }
                _$setRgb$_(t, e, s) {
                    return this._$_r$_ = +t, this._$_g$_ = +e, this._$_b$_ = +s, 
                    this._$clamp$_(), this;
                }
                _$setRgba$_(t, e, s, i) {
                    return this._$_r$_ = +t, this._$_g$_ = +e, this._$_b$_ = +s, 
                    this._$_a$_ = +i, this._$clamp$_(), this;
                }
                set(t) {
                    return this._$_r$_ = t._$_r$_, this._$_g$_ = t._$_g$_, this._$_b$_ = t._$_b$_, 
                    this._$_a$_ = t._$_a$_, this;
                }
                _$copy$_(t) {
                    return this.set(t);
                }
                add(t) {
                    this._$_r$_ += t._$_r$_, this._$_g$_ += t._$_g$_, this._$_b$_ += t._$_b$_, 
                    this._$_a$_ += t._$_a$_, this._$clamp$_();
                }
                _$addRgb$_(t, e, s, i = 0) {
                    this._$_r$_ += +t, this._$_g$_ += +e, this._$_b$_ += +s, this._$_a$_ += +i, 
                    this._$clamp$_();
                }
                _$diff$_(t) {
                    this._$setR$_(Math.max(this._$_r$_, t._$_r$_) - Math.min(this._$_r$_, t._$_r$_)), 
                    this._$setG$_(Math.max(this._$_g$_, t._$_g$_) - Math.min(this._$_g$_, t._$_g$_)), 
                    this._$setB$_(Math.max(this._$_b$_, t._$_b$_) - Math.min(this._$_b$_, t._$_b$_)), 
                    this._$setA$_(Math.max(this._$_a$_, t._$_a$_) - Math.min(this._$_a$_, t._$_a$_)), 
                    this._$clamp$_();
                }
                _$copyRgb$_(t) {
                    this._$_r$_ = t._$_r$_, this._$_g$_ = t._$_g$_, this._$_b$_ = t._$_b$_;
                }
                _$setR$_(t) {
                    this._$_r$_ = C33._$clamp$_(+t, 0, 1);
                }
                _$getR$_() {
                    return this._$_r$_;
                }
                _$setG$_(t) {
                    this._$_g$_ = C33._$clamp$_(+t, 0, 1);
                }
                _$getG$_() {
                    return this._$_g$_;
                }
                _$setB$_(t) {
                    this._$_b$_ = C33._$clamp$_(+t, 0, 1);
                }
                _$getB$_() {
                    return this._$_b$_;
                }
                _$setA$_(t) {
                    this._$_a$_ = C33._$clamp$_(+t, 0, 1);
                }
                _$getA$_() {
                    return this._$_a$_;
                }
                clone() {
                    return C33._$New$_(C33._$Color$_, this._$_r$_, this._$_g$_, this._$_b$_, this._$_a$_);
                }
                toArray() {
                    return [ this._$_r$_, this._$_g$_, this._$_b$_, this._$_a$_ ];
                }
                _$toTypedArray$_() {
                    return new Float64Array(this.toArray());
                }
                _$writeToTypedArray$_(t, e) {
                    t[e++] = this._$_r$_, t[e++] = this._$_g$_, t[e++] = this._$_b$_, 
                    t[e] = this._$_a$_;
                }
                _$writeRGBToTypedArray$_(t, e) {
                    t[e++] = this._$_r$_, t[e++] = this._$_g$_, t[e] = this._$_b$_;
                }
                equals(t) {
                    return this._$_r$_ === t._$_r$_ && this._$_g$_ === t._$_g$_ && this._$_b$_ === t._$_b$_ && this._$_a$_ === t._$_a$_;
                }
                _$equalsIgnoringAlpha$_(t) {
                    return this._$_r$_ === t._$_r$_ && this._$_g$_ === t._$_g$_ && this._$_b$_ === t._$_b$_;
                }
                _$equalsRgb$_(t, e, s) {
                    return this._$_r$_ === t && this._$_g$_ === e && this._$_b$_ === s;
                }
                _$equalsRgba$_(t, e, s, i) {
                    return this._$_r$_ === t && this._$_g$_ === e && this._$_b$_ === s && this._$_a$_ === i;
                }
                _$equalsF32Array$_(t, e) {
                    return t[e] === Math.fround(this._$_r$_) && t[e + 1] === Math.fround(this._$_g$_) && t[e + 2] === Math.fround(this._$_b$_) && t[e + 3] === Math.fround(this._$_a$_);
                }
                _$equalsRGBF32Array$_(t, e) {
                    return t[e] === Math.fround(this._$_r$_) && t[e + 1] === Math.fround(this._$_g$_) && t[e + 2] === Math.fround(this._$_b$_);
                }
                multiply(t) {
                    this._$_r$_ *= t._$_r$_, this._$_g$_ *= t._$_g$_, this._$_b$_ *= t._$_b$_, 
                    this._$_a$_ *= t._$_a$_;
                }
                _$multiplyAlpha$_(t) {
                    this._$_r$_ *= t, this._$_g$_ *= t, this._$_b$_ *= t, this._$_a$_ *= t;
                }
                _$premultiply$_() {
                    return this._$_r$_ *= this._$_a$_, this._$_g$_ *= this._$_a$_, 
                    this._$_b$_ *= this._$_a$_, this;
                }
                _$unpremultiply$_() {
                    return this._$_r$_ /= this._$_a$_, this._$_g$_ /= this._$_a$_, 
                    this._$_b$_ /= this._$_a$_, this;
                }
                _$clamp$_() {
                    return this._$_r$_ = C33._$clamp$_(this._$_r$_, 0, 1), this._$_g$_ = C33._$clamp$_(this._$_g$_, 0, 1), 
                    this._$_b$_ = C33._$clamp$_(this._$_b$_, 0, 1), this._$_a$_ = C33._$clamp$_(this._$_a$_, 0, 1), 
                    this;
                }
                _$setFromRgbValue$_(t) {
                    this._$_r$_ = C33._$GetRValue$_(t), this._$_g$_ = C33._$GetGValue$_(t), 
                    this._$_b$_ = C33._$GetBValue$_(t), this._$_a$_ = C33._$GetAValue$_(t);
                }
                _$getCssRgb$_(t, e, s) {
                    const i = C33._$IsFiniteNumber$_(t) ? t : this._$getR$_(), r = C33._$IsFiniteNumber$_(e) ? e : this._$getG$_(), n = C33._$IsFiniteNumber$_(s) ? s : this._$getB$_();
                    return `rgb(${100 * i}%, ${100 * r}%, ${100 * n}%)`;
                }
                _$getCssRgba$_(t, e, s, i) {
                    const r = C33._$IsFiniteNumber$_(t) ? t : this._$getR$_(), n = C33._$IsFiniteNumber$_(e) ? e : this._$getG$_(), h = C33._$IsFiniteNumber$_(s) ? s : this._$getB$_(), o = C33._$IsFiniteNumber$_(i) ? i : this._$getA$_();
                    return `rgba(${100 * r}%, ${100 * n}%, ${100 * h}%, ${o})`;
                }
                _$toHexString$_() {
                    const t = Math.round(255 * this._$getR$_()), e = Math.round(255 * this._$getG$_()), s = Math.round(255 * this._$getB$_());
                    return "#" + padTwoDigits2(t.toString(16)) + padTwoDigits2(e.toString(16)) + padTwoDigits2(s.toString(16));
                }
                _$parseHexString$_(t) {
                    if ("string" != typeof t) return !1;
                    let e, s, i;
                    if (3 === (t = "#" === (t = t.trim()).charAt(0) ? t.substr(1) : t).length) e = parseInt(t[0], 16) / 15, 
                    s = parseInt(t[1], 16) / 15, i = parseInt(t[2], 16) / 15; else {
                        if (6 !== t.length) return !1;
                        e = parseInt(t.substr(0, 2), 16) / 255, s = parseInt(t.substr(2, 2), 16) / 255, 
                        i = parseInt(t.substr(4, 2), 16) / 255;
                    }
                    return isFinite(e) && this._$setR$_(e), isFinite(s) && this._$setG$_(s), 
                    isFinite(i) && this._$setB$_(i), this._$setA$_(1), !0;
                }
                _$toCommaSeparatedRgb$_() {
                    const t = Math.round(255 * this._$getR$_()), e = Math.round(255 * this._$getG$_()), s = Math.round(255 * this._$getB$_());
                    return t + `, ${e}, ` + s;
                }
                _$toRgbArray$_() {
                    const t = Math.round(255 * this._$getR$_()), e = Math.round(255 * this._$getG$_()), s = Math.round(255 * this._$getB$_());
                    return [ t, e, s ];
                }
                _$parseCommaSeparatedRgb$_(t) {
                    if ("string" != typeof t) return !1;
                    const e = (t = t.replace(/^rgb\(|\)|%/, "")).split(",");
                    if (e.length < 3) return !1;
                    const s = parseInt(e[0].trim(), 10) / 255, i = parseInt(e[1].trim(), 10) / 255, r = parseInt(e[2].trim(), 10) / 255;
                    return isFinite(s) && this._$setR$_(s), isFinite(i) && this._$setG$_(i), 
                    isFinite(r) && this._$setB$_(r), this._$setA$_(1), !0;
                }
                _$parseCommaSeparatedPercentageRgb$_(t) {
                    if ("string" != typeof t) return !1;
                    const e = (t = t.replace(/^rgb\(|\)|%/, "")).split(",");
                    if (e.length < 3) return !1;
                    const s = parseInt(e[0].trim(), 10) / 100, i = parseInt(e[1].trim(), 10) / 100, r = parseInt(e[2].trim(), 10) / 100;
                    return isFinite(s) && this._$setR$_(s), isFinite(i) && this._$setG$_(i), 
                    isFinite(r) && this._$setB$_(r), this._$setA$_(1), !0;
                }
                _$parseCommaSeparatedRgba$_(t) {
                    if ("string" != typeof t) return !1;
                    const e = (t = t.replace(/^rgba\(|\)|%/, "")).split(",");
                    if (e.length < 4) return !1;
                    const s = parseInt(e[0].trim(), 10) / 255, i = parseInt(e[1].trim(), 10) / 255, r = parseInt(e[2].trim(), 10) / 255, n = parseFloat(e[3].trim());
                    return isFinite(s) && this._$setR$_(s), isFinite(i) && this._$setG$_(i), 
                    isFinite(r) && this._$setB$_(r), isFinite(n) && this._$setA$_(n), 
                    !0;
                }
                _$parseCommaSeparatedPercentageRgba$_(t) {
                    if ("string" != typeof t) return !1;
                    const e = (t = t.replace(/^rgba\(|\)|%/, "")).split(",");
                    if (e.length < 4) return !1;
                    const s = parseInt(e[0].trim(), 10) / 100, i = parseInt(e[1].trim(), 10) / 100, r = parseInt(e[2].trim(), 10) / 100, n = parseFloat(e[3].trim());
                    return isFinite(s) && this._$setR$_(s), isFinite(i) && this._$setG$_(i), 
                    isFinite(r) && this._$setB$_(r), isFinite(n) && this._$setA$_(n), 
                    !0;
                }
                _$parseString$_(t) {
                    if ("string" != typeof t) return !1;
                    if ((t = t.replace(/\s+/, "")).includes(",")) {
                        if (t.startsWith("rgb(")) return t.includes("%") ? this._$parseCommaSeparatedPercentageRgb$_(t) : this._$parseCommaSeparatedRgb$_(t);
                        if (t.startsWith("rgba(")) return t.includes("%") ? this._$parseCommaSeparatedPercentageRgba$_(t) : this._$parseCommaSeparatedRgba$_(t);
                        if (t.startsWith("hsl(") || t.startsWith("hsla(")) return this._$parseHSLString$_(t);
                        {
                            const e = t.split(",");
                            return t.includes("%") ? 3 === e.length ? this._$parseCommaSeparatedPercentageRgb$_(t) : 4 === e.length && this._$parseCommaSeparatedPercentageRgba$_(t) : 3 === e.length ? this._$parseCommaSeparatedRgb$_(t) : 4 === e.length && this._$parseCommaSeparatedRgba$_(t);
                        }
                    }
                    return this._$parseHexString$_(t);
                }
                toJSON() {
                    return [ this._$_r$_, this._$_g$_, this._$_b$_, this._$_a$_ ];
                }
                _$setFromHSLA$_(t, e, s, i) {
                    let r, n, h;
                    if (t %= 360, e = C33._$clamp$_(e, 0, 100), s = C33._$clamp$_(s, 0, 100), 
                    i = C33._$clamp$_(i, 0, 1), t /= 360, s /= 100, 0 == (e /= 100)) r = n = h = s; else {
                        const o = s < .5 ? s * (1 + e) : s + e - s * e, a = 2 * s - o;
                        r = hueToRGB2(a, o, t + 1 / 3), n = hueToRGB2(a, o, t), 
                        h = hueToRGB2(a, o, t - 1 / 3);
                    }
                    return this._$setR$_(r), this._$setG$_(n), this._$setB$_(h), 
                    this._$setA$_(i), this;
                }
                _$parseHSLString$_(t) {
                    const e = t.replace(/ |hsl|hsla|\(|\)|;/gi, ""), s = HSL_TEST.exec(e), i = HSLA_TEST.exec(e);
                    return s && 4 === s.length ? (this._$setFromHSLA$_(+s[1], +s[2], +s[3], 1), 
                    !0) : !(!i || 5 !== i.length || (this._$setFromHSLA$_(+s[1], +s[2], +s[3], +s[4]), 
                    0));
                }
                _$toHSLAString$_() {
                    const t = this._$_r$_, e = this._$_g$_, s = this._$_b$_, i = this._$_a$_, r = C33._$Color$_._$GetHue$_(t, e, s), n = C33._$Color$_._$GetSaturation$_(t, e, s), h = C33._$Color$_._$GetLuminosity$_(t, e, s);
                    return `hsla(${r}, ${n}%, ${h}%, ${i})`;
                }
                _$toHSLAArray$_() {
                    const t = this._$_r$_, e = this._$_g$_, s = this._$_b$_;
                    return [ C33._$Color$_._$GetHue$_(t, e, s), C33._$Color$_._$GetSaturation$_(t, e, s), C33._$Color$_._$GetLuminosity$_(t, e, s), this._$_a$_ ];
                }
                _$setFromJSON$_(t) {
                    !Array.isArray(t) || t.length < 3 || (this._$_r$_ = t[0], this._$_g$_ = t[1], 
                    this._$_b$_ = t[2], this._$_a$_ = 4 <= t.length ? t[3] : 1);
                }
                set r(t) {
                    this._$setR$_(t);
                }
                get r() {
                    return this._$getR$_();
                }
                set g(t) {
                    this._$setG$_(t);
                }
                get g() {
                    return this._$getG$_();
                }
                set b(t) {
                    this._$setB$_(t);
                }
                get b() {
                    return this._$getB$_();
                }
                set a(t) {
                    this._$setA$_(t);
                }
                get a() {
                    return this._$getA$_();
                }
                _$setAtIndex$_(t, e) {
                    switch (t) {
                      case 0:
                        this._$setR$_(e);
                        break;

                      case 1:
                        this._$setG$_(e);
                        break;

                      case 2:
                        this._$setB$_(e);
                        break;

                      case 3:
                        this._$setA$_(e);
                        break;

                      default:
                        throw new RangeError("invalid color index");
                    }
                }
                _$getAtIndex$_(t) {
                    switch (t) {
                      case 0:
                        return this._$getR$_();

                      case 1:
                        return this._$getG$_();

                      case 2:
                        return this._$getB$_();

                      case 3:
                        return this._$getA$_();

                      default:
                        throw new RangeError("invalid color index");
                    }
                }
                static _$Equals$_(t, e) {
                    let s, i;
                    if (Array.isArray(t)) (s = new C33._$Color$_())._$setFromJSON$_(t); else {
                        if (!(t instanceof C33._$Color$_)) throw new Error("unexpected type");
                        s = t;
                    }
                    if (Array.isArray(e)) (i = new C33._$Color$_())._$setFromJSON$_(e); else {
                        if (!(e instanceof C33._$Color$_)) throw new Error("unexpected type");
                        i = e;
                    }
                    return s.equals(i);
                }
                static _$DiffChannel$_(t, e) {
                    return C33._$clamp$_(Math.max(t, e) - Math.min(t, e), 0, 1);
                }
                static _$Diff$_(t, e) {
                    const s = new C33._$Color$_();
                    return s._$setR$_(Math.max(t._$_r$_, e._$_r$_) - Math.min(t._$_r$_, e._$_r$_)), 
                    s._$setG$_(Math.max(t._$_g$_, e._$_g$_) - Math.min(t._$_g$_, e._$_g$_)), 
                    s._$setB$_(Math.max(t._$_b$_, e._$_b$_) - Math.min(t._$_b$_, e._$_b$_)), 
                    s._$setA$_(Math.max(t._$_a$_, e._$_a$_) - Math.min(t._$_a$_, e._$_a$_)), 
                    s;
                }
                static _$DiffNoAlpha$_(t, e) {
                    const s = new C33._$Color$_(0, 0, 0, 1);
                    return s._$setR$_(Math.max(t._$_r$_, e._$_r$_) - Math.min(t._$_r$_, e._$_r$_)), 
                    s._$setG$_(Math.max(t._$_g$_, e._$_g$_) - Math.min(t._$_g$_, e._$_g$_)), 
                    s._$setB$_(Math.max(t._$_b$_, e._$_b$_) - Math.min(t._$_b$_, e._$_b$_)), 
                    s;
                }
                static _$GetHue$_(t, e, s) {
                    const i = Math.max(t, e, s), r = Math.min(t, e, s);
                    if (i === r) return 0;
                    let n = 0;
                    switch (i) {
                      case t:
                        n = (e - s) / (i - r) + (e < s ? 6 : 0);
                        break;

                      case e:
                        n = (s - t) / (i - r) + 2;
                        break;

                      case s:
                        n = (t - e) / (i - r) + 4;
                    }
                    return Math.round(n / 6 * 360);
                }
                static _$GetSaturation$_(t, e, s) {
                    const i = Math.max(t, e, s), r = Math.min(t, e, s);
                    if (i === r) return 0;
                    const n = (i + r) / 2, h = i - r, o = .5 < n ? h / (2 - i - r) : h / (i + r);
                    return Math.round(100 * o);
                }
                static _$GetLuminosity$_(t, e, s) {
                    const i = Math.max(t, e, s), r = Math.min(t, e, s), n = (i + r) / 2;
                    return i ? Math.round(100 * n) : 0;
                }
            }, C33._$Color$_._$White$_ = Object.freeze(C33._$New$_(C33._$Color$_, 1, 1, 1, 1)), 
            C33._$Color$_._$Black$_ = Object.freeze(C33._$New$_(C33._$Color$_, 0, 0, 0, 1)), 
            C33._$Color$_._$TransparentBlack$_ = Object.freeze(C33._$New$_(C33._$Color$_, 0, 0, 0, 0));
        }
        {
            const C33 = self._$C3$_;
            C33._$Vector2$_ = class {
                constructor(t, e) {
                    this._$_x$_ = 0, this._$_y$_ = 0, t instanceof C33._$Vector2$_ ? this._$copy$_(t) : this.set(t || 0, e || 0);
                }
                set(t, e) {
                    this._$_x$_ = +t, this._$_y$_ = +e;
                }
                _$copy$_(t) {
                    this._$_x$_ = t._$_x$_, this._$_y$_ = t._$_y$_;
                }
                equals(t) {
                    return this._$_x$_ === t._$_x$_ && this._$_y$_ === t._$_y$_;
                }
                _$equalsValues$_(t, e) {
                    return this._$_x$_ === t && this._$_y$_ === e;
                }
                _$equalsF32Array$_(t, e) {
                    return t[e] === Math.fround(this._$_x$_) && t[e + 1] === Math.fround(this._$_y$_);
                }
                _$setX$_(t) {
                    this._$_x$_ = +t;
                }
                _$getX$_() {
                    return this._$_x$_;
                }
                _$setY$_(t) {
                    this._$_y$_ = +t;
                }
                _$getY$_() {
                    return this._$_y$_;
                }
                toArray() {
                    return [ this._$_x$_, this._$_y$_ ];
                }
                _$toTypedArray$_() {
                    return new Float64Array(this.toArray());
                }
                _$writeToTypedArray$_(t, e) {
                    t[e++] = this._$_x$_, t[e] = this._$_y$_;
                }
                offset(t, e) {
                    this._$_x$_ += +t, this._$_y$_ += +e;
                }
                scale(t, e) {
                    this._$_x$_ *= t, this._$_y$_ *= e;
                }
                _$divide$_(t, e) {
                    this._$_x$_ /= t, this._$_y$_ /= e;
                }
                round() {
                    this._$_x$_ = Math.round(this._$_x$_), this._$_y$_ = Math.round(this._$_y$_);
                }
                floor() {
                    this._$_x$_ = Math.floor(this._$_x$_), this._$_y$_ = Math.floor(this._$_y$_);
                }
                ceil() {
                    this._$_x$_ = Math.ceil(this._$_x$_), this._$_y$_ = Math.ceil(this._$_y$_);
                }
                angle() {
                    return C33._$angleTo$_(0, 0, this._$_x$_, this._$_y$_);
                }
                _$lengthSquared$_() {
                    return this._$_x$_ * this._$_x$_ + this._$_y$_ * this._$_y$_;
                }
                length() {
                    return C33._$hypot2DFast$_(this._$_x$_, this._$_y$_);
                }
                _$rotatePrecalc$_(t, e) {
                    const s = this._$_x$_ * e - this._$_y$_ * t;
                    this._$_y$_ = this._$_y$_ * e + this._$_x$_ * t, this._$_x$_ = s;
                }
                rotate(t) {
                    0 !== t && this._$rotatePrecalc$_(Math.sin(t), Math.cos(t));
                }
                _$rotateAbout$_(t, e, s) {
                    0 === t || e === this._$_x$_ && s === this._$_y$_ || (this._$_x$_ -= e, 
                    this._$_y$_ -= s, this._$rotatePrecalc$_(Math.sin(t), Math.cos(t)), 
                    this._$_x$_ += +e, this._$_y$_ += +s);
                }
                move(t, e) {
                    0 !== e && (this._$_x$_ += Math.cos(t) * e, this._$_y$_ += Math.sin(t) * e);
                }
                normalize() {
                    const t = this.length();
                    0 !== t && 1 !== t && (this._$_x$_ /= t, this._$_y$_ /= t);
                }
                _$clamp$_(t, e) {
                    this._$_x$_ = C33._$clamp$_(this._$_x$_, t, e), this._$_y$_ = C33._$clamp$_(this._$_y$_, t, e);
                }
                _$dot$_(t) {
                    return this._$_x$_ * t._$_x$_ + this._$_y$_ * t._$_y$_;
                }
                reverse() {
                    this._$_x$_ = -this._$_x$_, this._$_y$_ = -this._$_y$_;
                }
                _$perp$_() {
                    let t = this._$_x$_;
                    return this._$_x$_ = this._$_y$_, this._$_y$_ = -t, this;
                }
            };
        }
        {
            const C33 = self._$C3$_;
            C33.Rect = class {
                constructor(t, e, s, i) {
                    this._$_left$_ = NaN, this._$_top$_ = NaN, this._$_right$_ = NaN, 
                    this._$_bottom$_ = NaN, this._$_left$_ = 0, this._$_top$_ = 0, 
                    this._$_right$_ = 0, this._$_bottom$_ = 0, t instanceof C33.Rect ? this._$copy$_(t) : this.set(t || 0, e || 0, s || 0, i || 0);
                }
                set(t, e, s, i) {
                    this._$_left$_ = +t, this._$_top$_ = +e, this._$_right$_ = +s, 
                    this._$_bottom$_ = +i;
                }
                _$setWH$_(t, e, s, i) {
                    e = +e, this._$_left$_ = t = +t, this._$_top$_ = e, this._$_right$_ = t + +s, 
                    this._$_bottom$_ = e + +i;
                }
                _$copy$_(t) {
                    this._$_left$_ = +t._$_left$_, this._$_top$_ = +t._$_top$_, 
                    this._$_right$_ = +t._$_right$_, this._$_bottom$_ = +t._$_bottom$_;
                }
                clone() {
                    return new C33.Rect(this._$_left$_, this._$_top$_, this._$_right$_, this._$_bottom$_);
                }
                static _$Merge$_(t, e) {
                    const s = new C33.Rect();
                    return s._$setLeft$_(Math.min(t._$_left$_, e._$_left$_)), s._$setTop$_(Math.min(t._$_top$_, e._$_top$_)), 
                    s._$setRight$_(Math.max(t._$_right$_, e._$_right$_)), s._$setBottom$_(Math.max(t._$_bottom$_, e._$_bottom$_)), 
                    s;
                }
                static _$FromObject$_(t) {
                    return new C33.Rect(t.left, t.top, t.right, t.bottom);
                }
                equals(t) {
                    return this._$_left$_ === t._$_left$_ && this._$_top$_ === t._$_top$_ && this._$_right$_ === t._$_right$_ && this._$_bottom$_ === t._$_bottom$_;
                }
                _$equalsWH$_(t, e, s, i) {
                    return this._$_left$_ === t && this._$_top$_ === e && this.width() === s && this.height() === i;
                }
                _$equalsF32Array$_(t, e) {
                    return t[e] === Math.fround(this._$_left$_) && t[e + 1] === Math.fround(this._$_top$_) && t[e + 2] === Math.fround(this._$_right$_) && t[e + 3] === Math.fround(this._$_bottom$_);
                }
                _$setLeft$_(t) {
                    this._$_left$_ = +t;
                }
                _$getLeft$_() {
                    return this._$_left$_;
                }
                _$setTop$_(t) {
                    this._$_top$_ = +t;
                }
                _$getTop$_() {
                    return this._$_top$_;
                }
                _$setRight$_(t) {
                    this._$_right$_ = +t;
                }
                _$getRight$_() {
                    return this._$_right$_;
                }
                _$setBottom$_(t) {
                    this._$_bottom$_ = +t;
                }
                _$getBottom$_() {
                    return this._$_bottom$_;
                }
                toArray() {
                    return [ this._$_left$_, this._$_top$_, this._$_right$_, this._$_bottom$_ ];
                }
                _$toTypedArray$_() {
                    return new Float64Array(this.toArray());
                }
                _$toDOMRect$_() {
                    return new DOMRect(this._$_left$_, this._$_top$_, this.width(), this.height());
                }
                static _$fromDOMRect$_(t) {
                    return C33._$New$_(C33.Rect, t.left, t.top, t.right, t.bottom);
                }
                _$writeToTypedArray$_(t, e) {
                    t[e++] = this._$_left$_, t[e++] = this._$_top$_, t[e++] = this._$_right$_, 
                    t[e] = this._$_bottom$_;
                }
                _$writeAsQuadToTypedArray$_(t, e) {
                    t[e++] = this._$_left$_, t[e++] = this._$_top$_, t[e++] = this._$_right$_, 
                    t[e++] = this._$_top$_, t[e++] = this._$_right$_, t[e++] = this._$_bottom$_, 
                    t[e++] = this._$_left$_, t[e] = this._$_bottom$_;
                }
                _$writeAsQuadToTypedArray3D$_(t, e, s) {
                    t[e++] = this._$_left$_, t[e++] = this._$_top$_, t[e++] = s, 
                    t[e++] = this._$_right$_, t[e++] = this._$_top$_, t[e++] = s, 
                    t[e++] = this._$_right$_, t[e++] = this._$_bottom$_, t[e++] = s, 
                    t[e++] = this._$_left$_, t[e++] = this._$_bottom$_, t[e] = s;
                }
                width() {
                    return this._$_right$_ - this._$_left$_;
                }
                height() {
                    return this._$_bottom$_ - this._$_top$_;
                }
                _$midX$_() {
                    return (this._$_left$_ + this._$_right$_) / 2;
                }
                _$midY$_() {
                    return (this._$_top$_ + this._$_bottom$_) / 2;
                }
                offset(t, e) {
                    e = +e, this._$_left$_ += t = +t, this._$_top$_ += e, this._$_right$_ += t, 
                    this._$_bottom$_ += e;
                }
                offsetLeft(t) {
                    this._$_left$_ += +t;
                }
                offsetTop(t) {
                    this._$_top$_ += +t;
                }
                _$offsetRight$_(t) {
                    this._$_right$_ += +t;
                }
                _$offsetBottom$_(t) {
                    this._$_bottom$_ += +t;
                }
                _$toSquare$_(t) {
                    if ("x" !== t) throw new Error("invalid axis, only 'x' supported");
                    this._$_top$_ < this._$_bottom$_ ? this._$_left$_ < this._$_right$_ ? this._$_bottom$_ = this._$_top$_ + this.width() : this._$_bottom$_ = this._$_top$_ - this.width() : this._$_left$_ < this._$_right$_ ? this._$_bottom$_ = this._$_top$_ - this.width() : this._$_bottom$_ = this._$_top$_ + this.width();
                }
                _$inflate$_(t, e) {
                    e = +e, this._$_left$_ -= t = +t, this._$_top$_ -= e, this._$_right$_ += t, 
                    this._$_bottom$_ += e;
                }
                _$deflate$_(t, e) {
                    e = +e, this._$_left$_ += t = +t, this._$_top$_ += e, this._$_right$_ -= t, 
                    this._$_bottom$_ -= e;
                }
                multiply(t, e) {
                    this._$_left$_ *= t, this._$_top$_ *= e, this._$_right$_ *= t, 
                    this._$_bottom$_ *= e;
                }
                _$divide$_(t, e) {
                    this._$_left$_ /= t, this._$_top$_ /= e, this._$_right$_ /= t, 
                    this._$_bottom$_ /= e;
                }
                _$mirrorAround$_(t) {
                    this._$_left$_ = +t - this._$_left$_, this._$_right$_ = +t - this._$_right$_;
                }
                _$flipAround$_(t) {
                    this._$_top$_ = +t - this._$_top$_, this._$_bottom$_ = +t - this._$_bottom$_;
                }
                _$rotate90DegreesAround$_(t, e) {
                    const s = this.width(), i = this.height(), r = this._$getLeft$_() + s * t, n = this._$getTop$_() + i * e;
                    this._$setWH$_(r - i * e, n - s * t, i, s);
                }
                _$swapLeftRight$_() {
                    const t = this._$_left$_;
                    this._$_left$_ = this._$_right$_, this._$_right$_ = t;
                }
                _$swapTopBottom$_() {
                    const t = this._$_top$_;
                    this._$_top$_ = this._$_bottom$_, this._$_bottom$_ = t;
                }
                _$shuntY$_(t) {
                    const e = this._$_top$_;
                    this._$_top$_ = +t - this._$_bottom$_, this._$_bottom$_ = +t - e;
                }
                round() {
                    this._$_left$_ = Math.round(this._$_left$_), this._$_top$_ = Math.round(this._$_top$_), 
                    this._$_right$_ = Math.round(this._$_right$_), this._$_bottom$_ = Math.round(this._$_bottom$_);
                }
                _$roundInner$_() {
                    this._$_left$_ = Math.ceil(this._$_left$_), this._$_top$_ = Math.ceil(this._$_top$_), 
                    this._$_right$_ = Math.floor(this._$_right$_), this._$_bottom$_ = Math.floor(this._$_bottom$_);
                }
                _$roundOuter$_() {
                    this._$_left$_ = Math.floor(this._$_left$_), this._$_top$_ = Math.floor(this._$_top$_), 
                    this._$_right$_ = Math.ceil(this._$_right$_), this._$_bottom$_ = Math.ceil(this._$_bottom$_);
                }
                floor() {
                    this._$_left$_ = Math.floor(this._$_left$_), this._$_top$_ = Math.floor(this._$_top$_), 
                    this._$_right$_ = Math.floor(this._$_right$_), this._$_bottom$_ = Math.floor(this._$_bottom$_);
                }
                ceil() {
                    this._$_left$_ = Math.ceil(this._$_left$_), this._$_top$_ = Math.ceil(this._$_top$_), 
                    this._$_right$_ = Math.ceil(this._$_right$_), this._$_bottom$_ = Math.ceil(this._$_bottom$_);
                }
                _$clamp$_(t, e, s, i) {
                    this._$_left$_ = Math.max(this._$_left$_, +t), this._$_top$_ = Math.max(this._$_top$_, +e), 
                    this._$_right$_ = Math.min(this._$_right$_, +s), this._$_bottom$_ = Math.min(this._$_bottom$_, +i);
                }
                _$clampBoth$_(t, e, s, i) {
                    t = +t, e = +e, s = +s, i = +i, this._$_left$_ = C33._$clamp$_(this._$_left$_, t, s), 
                    this._$_top$_ = C33._$clamp$_(this._$_top$_, e, i), this._$_right$_ = C33._$clamp$_(this._$_right$_, t, s), 
                    this._$_bottom$_ = C33._$clamp$_(this._$_bottom$_, e, i);
                }
                normalize() {
                    this._$_left$_ > this._$_right$_ && this._$swapLeftRight$_(), 
                    this._$_top$_ > this._$_bottom$_ && this._$swapTopBottom$_();
                }
                _$intersectsRect$_(t) {
                    return !(t._$_right$_ < this._$_left$_ || t._$_bottom$_ < this._$_top$_ || t._$_left$_ > this._$_right$_ || t._$_top$_ > this._$_bottom$_);
                }
                _$intersectsRectOffset$_(t, e, s) {
                    return !(t._$_right$_ + e < this._$_left$_ || t._$_bottom$_ + s < this._$_top$_ || t._$_left$_ + e > this._$_right$_ || t._$_top$_ + s > this._$_bottom$_);
                }
                _$containsPoint$_(t, e) {
                    return t >= this._$_left$_ && t <= this._$_right$_ && e >= this._$_top$_ && e <= this._$_bottom$_;
                }
                _$containsRect$_(t) {
                    return t._$_left$_ >= this._$_left$_ && t._$_top$_ >= this._$_top$_ && t._$_right$_ <= this._$_right$_ && t._$_bottom$_ <= this._$_bottom$_;
                }
                _$expandToContain$_(t) {
                    t._$_left$_ < this._$_left$_ && (this._$_left$_ = +t._$_left$_), 
                    t._$_top$_ < this._$_top$_ && (this._$_top$_ = +t._$_top$_), 
                    t._$_right$_ > this._$_right$_ && (this._$_right$_ = +t._$_right$_), 
                    t._$_bottom$_ > this._$_bottom$_ && (this._$_bottom$_ = +t._$_bottom$_);
                }
                _$lerpInto$_(t) {
                    this._$_left$_ = C33._$lerp$_(t._$_left$_, t._$_right$_, this._$_left$_), 
                    this._$_top$_ = C33._$lerp$_(t._$_top$_, t._$_bottom$_, this._$_top$_), 
                    this._$_right$_ = C33._$lerp$_(t._$_left$_, t._$_right$_, this._$_right$_), 
                    this._$_bottom$_ = C33._$lerp$_(t._$_top$_, t._$_bottom$_, this._$_bottom$_);
                }
            };
        }
        {
            const C33 = self._$C3$_;
            C33._$Quad$_ = class {
                constructor(t, e, s, i, r, n, h, o) {
                    this._$_tlx$_ = NaN, this._$_tly$_ = NaN, this._$_trx$_ = NaN, 
                    this._$_try$_ = NaN, this._$_brx$_ = NaN, this._$_bry$_ = NaN, 
                    this._$_blx$_ = NaN, this._$_bly$_ = NaN, this._$_tlx$_ = 0, 
                    this._$_tly$_ = 0, this._$_trx$_ = 0, this._$_try$_ = 0, this._$_brx$_ = 0, 
                    this._$_bry$_ = 0, this._$_blx$_ = 0, this._$_bly$_ = 0, t instanceof C33._$Quad$_ ? this._$copy$_(t) : this.set(t || 0, e || 0, s || 0, i || 0, r || 0, n || 0, h || 0, o || 0);
                }
                set(t, e, s, i, r, n, h, o) {
                    this._$_tlx$_ = +t, this._$_tly$_ = +e, this._$_trx$_ = +s, 
                    this._$_try$_ = +i, this._$_brx$_ = +r, this._$_bry$_ = +n, 
                    this._$_blx$_ = +h, this._$_bly$_ = +o;
                }
                _$setRect$_(t, e, s, i) {
                    this.set(t, e, s, e, s, i, t, i);
                }
                _$copy$_(t) {
                    this._$_tlx$_ = t._$_tlx$_, this._$_tly$_ = t._$_tly$_, this._$_trx$_ = t._$_trx$_, 
                    this._$_try$_ = t._$_try$_, this._$_brx$_ = t._$_brx$_, this._$_bry$_ = t._$_bry$_, 
                    this._$_blx$_ = t._$_blx$_, this._$_bly$_ = t._$_bly$_;
                }
                equals(t) {
                    return this._$_tlx$_ === t._$_tlx$_ && this._$_tly$_ === t._$_tly$_ && this._$_trx$_ === t._$_trx$_ && this._$_try$_ === t._$_try$_ && this._$_brx$_ === t._$_brx$_ && this._$_bry$_ === t._$_bry$_ && this._$_blx$_ === t._$_blx$_ && this._$_bly$_ === t._$_bly$_;
                }
                _$setTlx$_(t) {
                    this._$_tlx$_ = +t;
                }
                _$getTlx$_() {
                    return this._$_tlx$_;
                }
                _$setTly$_(t) {
                    this._$_tly$_ = +t;
                }
                _$getTly$_() {
                    return this._$_tly$_;
                }
                _$setTrx$_(t) {
                    this._$_trx$_ = +t;
                }
                _$getTrx$_() {
                    return this._$_trx$_;
                }
                _$setTry$_(t) {
                    this._$_try$_ = +t;
                }
                _$getTry$_() {
                    return this._$_try$_;
                }
                _$setBrx$_(t) {
                    this._$_brx$_ = +t;
                }
                _$getBrx$_() {
                    return this._$_brx$_;
                }
                _$setBry$_(t) {
                    this._$_bry$_ = +t;
                }
                _$getBry$_() {
                    return this._$_bry$_;
                }
                _$setBlx$_(t) {
                    this._$_blx$_ = +t;
                }
                _$getBlx$_() {
                    return this._$_blx$_;
                }
                _$setBly$_(t) {
                    this._$_bly$_ = +t;
                }
                _$getBly$_() {
                    return this._$_bly$_;
                }
                _$toDOMQuad$_() {
                    return new DOMQuad(new DOMPoint(this._$_tlx$_, this._$_tly$_), new DOMPoint(this._$_trx$_, this._$_try$_), new DOMPoint(this._$_brx$_, this._$_bry$_), new DOMPoint(this._$_blx$_, this._$_bly$_));
                }
                static _$fromDOMQuad$_(t) {
                    return C33._$New$_(C33._$Quad$_, t.p1.x, t.p1.y, t.p2.x, t.p2.y, t.p3.x, t.p3.y, t.p4.x, t.p4.y);
                }
                toArray() {
                    return [ this._$_tlx$_, this._$_tly$_, this._$_trx$_, this._$_try$_, this._$_brx$_, this._$_bry$_, this._$_blx$_, this._$_bly$_ ];
                }
                _$toTypedArray$_() {
                    return new Float64Array(this.toArray());
                }
                _$writeToTypedArray$_(t, e) {
                    t[e++] = this._$_tlx$_, t[e++] = this._$_tly$_, t[e++] = this._$_trx$_, 
                    t[e++] = this._$_try$_, t[e++] = this._$_brx$_, t[e++] = this._$_bry$_, 
                    t[e++] = this._$_blx$_, t[e] = this._$_bly$_;
                }
                _$writeToTypedArray3D$_(t, e, s) {
                    t[e++] = this._$_tlx$_, t[e++] = this._$_tly$_, t[e++] = s, 
                    t[e++] = this._$_trx$_, t[e++] = this._$_try$_, t[e++] = s, 
                    t[e++] = this._$_brx$_, t[e++] = this._$_bry$_, t[e++] = s, 
                    t[e++] = this._$_blx$_, t[e++] = this._$_bly$_, t[e] = s;
                }
                offset(t, e) {
                    e = +e, this._$_tlx$_ += t = +t, this._$_tly$_ += e, this._$_trx$_ += t, 
                    this._$_try$_ += e, this._$_brx$_ += t, this._$_bry$_ += e, 
                    this._$_blx$_ += t, this._$_bly$_ += e;
                }
                round() {
                    this._$_tlx$_ = Math.round(this._$_tlx$_), this._$_tly$_ = Math.round(this._$_tly$_), 
                    this._$_trx$_ = Math.round(this._$_trx$_), this._$_try$_ = Math.round(this._$_try$_), 
                    this._$_brx$_ = Math.round(this._$_brx$_), this._$_bry$_ = Math.round(this._$_bry$_), 
                    this._$_blx$_ = Math.round(this._$_blx$_), this._$_bly$_ = Math.round(this._$_bly$_);
                }
                floor() {
                    this._$_tlx$_ = Math.floor(this._$_tlx$_), this._$_tly$_ = Math.floor(this._$_tly$_), 
                    this._$_trx$_ = Math.floor(this._$_trx$_), this._$_try$_ = Math.floor(this._$_try$_), 
                    this._$_brx$_ = Math.floor(this._$_brx$_), this._$_bry$_ = Math.floor(this._$_bry$_), 
                    this._$_blx$_ = Math.floor(this._$_blx$_), this._$_bly$_ = Math.floor(this._$_bly$_);
                }
                ceil() {
                    this._$_tlx$_ = Math.ceil(this._$_tlx$_), this._$_tly$_ = Math.ceil(this._$_tly$_), 
                    this._$_trx$_ = Math.ceil(this._$_trx$_), this._$_try$_ = Math.ceil(this._$_try$_), 
                    this._$_brx$_ = Math.ceil(this._$_brx$_), this._$_bry$_ = Math.ceil(this._$_bry$_), 
                    this._$_blx$_ = Math.ceil(this._$_blx$_), this._$_bly$_ = Math.ceil(this._$_bly$_);
                }
                _$setFromRect$_(t) {
                    this._$_tlx$_ = t._$_left$_, this._$_tly$_ = t._$_top$_, this._$_trx$_ = t._$_right$_, 
                    this._$_try$_ = t._$_top$_, this._$_brx$_ = t._$_right$_, this._$_bry$_ = t._$_bottom$_, 
                    this._$_blx$_ = t._$_left$_, this._$_bly$_ = t._$_bottom$_;
                }
                _$setFromRotatedRect$_(t, e) {
                    0 === e ? this._$setFromRect$_(t) : this._$setFromRotatedRectPrecalc$_(t, Math.sin(e), Math.cos(e));
                }
                _$setFromRotatedRectPrecalc$_(t, e, s) {
                    const i = t._$_left$_ * e, r = t._$_top$_ * e, n = t._$_right$_ * e, h = t._$_bottom$_ * e, o = t._$_left$_ * s, a = t._$_top$_ * s, l = t._$_right$_ * s, u = t._$_bottom$_ * s;
                    this._$_tlx$_ = o - r, this._$_tly$_ = a + i, this._$_trx$_ = l - r, 
                    this._$_try$_ = a + n, this._$_brx$_ = l - h, this._$_bry$_ = u + n, 
                    this._$_blx$_ = o - h, this._$_bly$_ = u + i;
                }
                _$getBoundingBox$_(t) {
                    t.set(Math.min(this._$_tlx$_, this._$_trx$_, this._$_brx$_, this._$_blx$_), Math.min(this._$_tly$_, this._$_try$_, this._$_bry$_, this._$_bly$_), Math.max(this._$_tlx$_, this._$_trx$_, this._$_brx$_, this._$_blx$_), Math.max(this._$_tly$_, this._$_try$_, this._$_bry$_, this._$_bly$_));
                }
                _$containsPoint$_(t, e) {
                    let s = this._$_trx$_ - this._$_tlx$_, i = this._$_try$_ - this._$_tly$_, r = this._$_brx$_ - this._$_tlx$_, n = this._$_bry$_ - this._$_tly$_, h = t - this._$_tlx$_, o = e - this._$_tly$_, a = s * s + i * i, l = s * r + i * n, u = s * h + i * o, c = r * r + n * n, f = r * h + n * o, d = 1 / (a * c - l * l), p = (c * u - l * f) * d, m = (a * f - l * u) * d;
                    return 0 <= p && 0 < m && p + m < 1 || (m = ((a = (s = this._$_blx$_ - this._$_tlx$_) * s + (i = this._$_bly$_ - this._$_tly$_) * i) * f - (l = s * r + i * n) * (u = s * h + i * o)) * (d = 1 / (a * c - l * l)), 
                    0 <= (p = (c * u - l * f) * d) && 0 < m && p + m < 1);
                }
                _$midX$_() {
                    return (this._$_tlx$_ + this._$_trx$_ + this._$_brx$_ + this._$_blx$_) / 4;
                }
                _$midY$_() {
                    return (this._$_tly$_ + this._$_try$_ + this._$_bry$_ + this._$_bly$_) / 4;
                }
                _$intersectsSegment$_(t, e, s, i) {
                    return !(!this._$containsPoint$_(t, e) && !this._$containsPoint$_(s, i)) || C33._$segmentIntersectsQuad$_(t, e, s, i, this);
                }
                _$intersectsQuad$_(t) {
                    let e = t._$midX$_(), s = t._$midY$_();
                    if (this._$containsPoint$_(e, s)) return !0;
                    if (e = this._$midX$_(), s = this._$midY$_(), t._$containsPoint$_(e, s)) return !0;
                    const i = this._$_tlx$_, r = this._$_tly$_, n = this._$_trx$_, h = this._$_try$_, o = this._$_brx$_, a = this._$_bry$_, l = this._$_blx$_, u = this._$_bly$_;
                    return C33._$segmentIntersectsQuad$_(i, r, n, h, t) || C33._$segmentIntersectsQuad$_(n, h, o, a, t) || C33._$segmentIntersectsQuad$_(o, a, l, u, t) || C33._$segmentIntersectsQuad$_(l, u, i, r, t);
                }
                _$rotatePointsAnticlockwise$_() {
                    const t = this._$_tlx$_, e = this._$_tly$_;
                    this._$_tlx$_ = this._$_trx$_, this._$_tly$_ = this._$_try$_, 
                    this._$_trx$_ = this._$_brx$_, this._$_try$_ = this._$_bry$_, 
                    this._$_brx$_ = this._$_blx$_, this._$_bry$_ = this._$_bly$_, 
                    this._$_blx$_ = t, this._$_bly$_ = e;
                }
                _$mirror$_() {
                    this._$_swap$_(0, 2), this._$_swap$_(1, 3), this._$_swap$_(6, 4), 
                    this._$_swap$_(7, 5);
                }
                _$flip$_() {
                    this._$_swap$_(0, 6), this._$_swap$_(1, 7), this._$_swap$_(2, 4), 
                    this._$_swap$_(3, 5);
                }
                _$diag$_() {
                    this._$_swap$_(2, 6), this._$_swap$_(3, 7);
                }
                _$_swap$_(t, e) {
                    const s = this._$_getAtIndex$_(t);
                    this._$_setAtIndex$_(t, this._$_getAtIndex$_(e)), this._$_setAtIndex$_(e, s);
                }
                _$_getAtIndex$_(t) {
                    switch (t) {
                      case 0:
                        return this._$_tlx$_;

                      case 1:
                        return this._$_tly$_;

                      case 2:
                        return this._$_trx$_;

                      case 3:
                        return this._$_try$_;

                      case 4:
                        return this._$_brx$_;

                      case 5:
                        return this._$_bry$_;

                      case 6:
                        return this._$_blx$_;

                      case 7:
                        return this._$_bly$_;

                      default:
                        throw new RangeError("invalid quad point index");
                    }
                }
                _$_setAtIndex$_(t, e) {
                    switch (e = +e, t) {
                      case 0:
                        this._$_tlx$_ = e;
                        break;

                      case 1:
                        this._$_tly$_ = e;
                        break;

                      case 2:
                        this._$_trx$_ = e;
                        break;

                      case 3:
                        this._$_try$_ = e;
                        break;

                      case 4:
                        this._$_brx$_ = e;
                        break;

                      case 5:
                        this._$_bry$_ = e;
                        break;

                      case 6:
                        this._$_blx$_ = e;
                        break;

                      case 7:
                        this._$_bly$_ = e;
                        break;

                      default:
                        throw new RangeError("invalid quad point index");
                    }
                }
            };
        }
        {
            const C33 = self._$C3$_, assert = self.assert, DEFAULT_POLY_POINTS = [ 0, 0, 1, 0, 1, 1, 0, 1 ], tempQuad = C33._$New$_(C33._$Quad$_);
            C33._$CollisionPoly$_ = class extends C33._$DefendedBase$_ {
                constructor(t, e = !0) {
                    super(), t = t || DEFAULT_POLY_POINTS, this._$_ptsArr$_ = Float64Array.from(t), 
                    this._$_bbox$_ = new C33.Rect(), this._$_isBboxChanged$_ = !0, 
                    this._$_enabled$_ = e;
                }
                _$Release$_() {}
                _$pointsArr$_() {
                    return this._$_ptsArr$_;
                }
                _$pointCount$_() {
                    return this._$_ptsArr$_.length / 2;
                }
                _$setPoints$_(t) {
                    this._$_ptsArr$_.length === t.length ? this._$_ptsArr$_.set(t) : this._$_ptsArr$_ = Float64Array.from(t), 
                    this._$_isBboxChanged$_ = !0;
                }
                _$setDefaultPoints$_() {
                    this._$setPoints$_(DEFAULT_POLY_POINTS);
                }
                _$copy$_(t) {
                    this._$setPoints$_(t._$_ptsArr$_);
                }
                _$setBboxChanged$_() {
                    this._$_isBboxChanged$_ = !0;
                }
                _$_updateBbox$_() {
                    if (this._$_isBboxChanged$_) {
                        let s = this._$_ptsArr$_, i = s[0], r = s[1], n = i, h = r;
                        for (let t = 0, e = s.length; t < e; t += 2) {
                            const o = s[t], a = s[t + 1];
                            o < i && (i = o), o > n && (n = o), a < r && (r = a), 
                            a > h && (h = a);
                        }
                        this._$_bbox$_.set(i, r, n, h), this._$_isBboxChanged$_ = !1;
                    }
                }
                _$setFromRect$_(t, e, s) {
                    let i = this._$_ptsArr$_;
                    8 !== i.length && (i = new Float64Array(8), this._$_ptsArr$_ = i), 
                    i[0] = t._$getLeft$_() - e, i[1] = t._$getTop$_() - s, i[2] = t._$getRight$_() - e, 
                    i[3] = t._$getTop$_() - s, i[4] = t._$getRight$_() - e, i[5] = t._$getBottom$_() - s, 
                    i[6] = t._$getLeft$_() - e, i[7] = t._$getBottom$_() - s, this._$_bbox$_._$copy$_(t), 
                    0 === e && 0 === s || this._$_bbox$_.offset(-e, -s), this._$_isBboxChanged$_ = !1;
                }
                _$setFromQuad$_(t, e, s) {
                    tempQuad._$copy$_(t), tempQuad.offset(e, s), this._$setPoints$_(tempQuad.toArray()), 
                    this._$_isBboxChanged$_ = !0;
                }
                transform(t, e, s) {
                    let i = 0, r = 1;
                    0 !== s && (i = Math.sin(s), r = Math.cos(s)), this._$transformPrecalc$_(t, e, i, r);
                }
                _$transformPrecalc$_(s, i, r, n) {
                    const h = this._$_ptsArr$_;
                    for (let t = 0, e = h.length; t < e; t += 2) {
                        const o = t + 1, a = h[t] * s, l = h[o] * i;
                        h[t] = a * n - l * r, h[o] = l * n + a * r;
                    }
                    this._$_isBboxChanged$_ = !0;
                }
                offset(s, i) {
                    const r = this._$_ptsArr$_;
                    for (let t = 0, e = r.length; t < e; t += 2) r[t] += s, r[t + 1] += i;
                }
                _$containsPoint$_(s, i) {
                    const r = this._$_ptsArr$_;
                    if (s === r[0] && i === r[1]) return !0;
                    this._$_updateBbox$_();
                    let t = this._$_bbox$_, n = t._$getLeft$_() - 110, h = t._$getTop$_() - 101, o = t._$getRight$_() + 131, a = t._$getBottom$_() + 120, l = 0, u = 0, c, f, d = 0, p = 0, m, C, g = (c = n < s ? (l = n, 
                    s) : (l = s, n), f = h < i ? (u = h, i) : (u = i, h), m = o < s ? (d = o, 
                    s) : (d = s, o), C = a < i ? (p = a, i) : (p = i, a), 0), S = 0;
                    for (let t = 0, e = r.length; t < e; t += 2) {
                        const _ = (t + 2) % e, T = r[t], y = r[t + 1], E = r[_], A = r[1 + _];
                        C33._$segmentsIntersectPreCalc$_(n, h, s, i, l, c, u, f, T, y, E, A) && ++g, 
                        C33._$segmentsIntersectPreCalc$_(o, a, s, i, d, m, p, C, T, y, E, A) && ++S;
                    }
                    return g % 2 == 1 || S % 2 == 1;
                }
                _$intersectsPoly$_(t, c, f) {
                    const d = t._$_ptsArr$_, p = this._$_ptsArr$_;
                    if (this._$containsPoint$_(d[0] + c, d[1] + f)) return !0;
                    if (t._$containsPoint$_(p[0] - c, p[1] - f)) return !0;
                    for (let e = 0, u = p.length; e < u; e += 2) {
                        let t = (e + 2) % u, s = p[e], i = p[e + 1], r = p[t], n = p[1 + t], h = 0, o = 0, a, l;
                        a = s < r ? (h = s, r) : (h = r, s), l = i < n ? (o = i, 
                        n) : (o = n, i);
                        for (let t = 0, e = d.length; t < e; t += 2) {
                            const m = (t + 2) % e, C = d[t] + c, g = d[t + 1] + f, S = d[m] + c, _ = d[1 + m] + f;
                            if (C33._$segmentsIntersectPreCalc$_(s, i, r, n, h, a, o, l, C, g, S, _)) return !0;
                        }
                    }
                    return !1;
                }
                _$intersectsSegment$_(s, i, r, n, h, o) {
                    if (this._$containsPoint$_(r - s, n - i)) return !0;
                    if (this._$containsPoint$_(h - s, o - i)) return !0;
                    let a = 0, l = 0, u, c;
                    u = r < h ? (a = r, h) : (a = h, r), c = n < o ? (l = n, o) : (l = o, 
                    n);
                    const f = this._$_ptsArr$_;
                    for (let t = 0, e = f.length; t < e; t += 2) {
                        const d = (t + 2) % e, p = f[t] + s, m = f[t + 1] + i, C = f[d] + s, g = f[1 + d] + i;
                        if (C33._$segmentsIntersectPreCalc$_(r, n, h, o, a, u, l, c, p, m, C, g)) return !0;
                    }
                    return !1;
                }
                _$mirror$_(s) {
                    const i = this._$_ptsArr$_;
                    for (let t = 0, e = i.length; t < e; t += 2) i[t] = 2 * s - i[t];
                    this._$_isBboxChanged$_ = !0;
                }
                _$flip$_(s) {
                    const i = this._$_ptsArr$_;
                    for (let t = 0, e = i.length; t < e; t += 2) {
                        const r = t + 1;
                        i[r] = 2 * s - i[r];
                    }
                    this._$_isBboxChanged$_ = !0;
                }
                _$diag$_() {
                    const s = this._$_ptsArr$_;
                    for (let t = 0, e = s.length; t < e; t += 2) {
                        const i = t + 1, r = s[t];
                        s[t] = s[i], s[i] = r;
                    }
                    this._$_isBboxChanged$_ = !0;
                }
                _$GetMidX$_() {
                    let s = this._$_ptsArr$_, i = 0;
                    for (let t = 0, e = s.length; t < e; t += 2) i += s[t];
                    return i / this._$pointCount$_();
                }
                _$GetMidY$_() {
                    let s = this._$_ptsArr$_, i = 0;
                    for (let t = 0, e = s.length; t < e; t += 2) i += s[t + 1];
                    return i / this._$pointCount$_();
                }
                _$GetPointsArray$_() {
                    return this._$_ptsArr$_;
                }
                _$GetPointCount$_() {
                    return this._$pointCount$_();
                }
                _$IsEnabled$_() {
                    return this._$_enabled$_;
                }
            };
        }
        {
            const C33 = self._$C3$_;
            C33._$PairMap$_ = class extends C33._$DefendedBase$_ {
                constructor(t) {
                    if (super(), this._$_firstMap$_ = new Map(), t) for (const [ e, s, i ] of t) this.Set(e, s, i);
                }
                _$Release$_() {
                    this._$Clear$_(), this._$_firstMap$_ = null;
                }
                _$IsEmpty$_() {
                    return 0 === this._$_firstMap$_.size;
                }
                _$Clear$_() {
                    const t = this._$_firstMap$_;
                    for (const e of t.values()) e.clear();
                    t.clear();
                }
                Set(t, e, s) {
                    let i = this._$_firstMap$_, r = i.get(t);
                    r || (r = new Map(), i.set(t, r)), r.set(e, s);
                }
                _$Get$_(t, e) {
                    const s = this._$_firstMap$_.get(t);
                    return s && s.get(e);
                }
                _$Has$_(t, e) {
                    const s = this._$_firstMap$_.get(t);
                    return !!s && s.has(e);
                }
                _$Delete$_(t, e) {
                    const s = this._$_firstMap$_, i = s.get(t);
                    if (!i) return !1;
                    const r = i.delete(e);
                    return r && 0 === i.size && s.delete(t), r;
                }
                _$DeleteEither$_(t) {
                    const e = this._$_firstMap$_, s = e.get(t);
                    s && (s.clear(), e.delete(t));
                    for (const [ i, r ] of e.entries()) r.delete(t) && 0 === r.size && e.delete(i);
                }
                _$GetSize$_() {
                    let t = 0;
                    for (const e of this._$_firstMap$_.values()) t += e.size;
                    return t;
                }
                *values() {
                    for (const t of this._$_firstMap$_.values()) yield* t.values();
                }
                *_$keyPairs$_() {
                    for (const [ t, e ] of this._$_firstMap$_.entries()) for (const s of e.keys()) yield [ t, s ];
                }
                *entries() {
                    for (const [ t, e ] of this._$_firstMap$_.entries()) for (const [ s, i ] of e.entries()) yield [ t, s, i ];
                }
            };
        }
        {
            const C33 = self._$C3$_;
            C33._$ArraySet$_ = class extends C33._$DefendedBase$_ {
                constructor() {
                    super(), this._$_set$_ = new Set(), this._$_arr$_ = [], this._$_needToRebuildArray$_ = !1;
                }
                _$Release$_() {
                    this._$Clear$_();
                }
                _$Clear$_() {
                    this._$_set$_.clear(), C33._$clearArray$_(this._$_arr$_), this._$_needToRebuildArray$_ = !1;
                }
                _$Add$_(t) {
                    this._$_set$_.has(t) || (this._$_set$_.add(t), this._$_needToRebuildArray$_) || this._$_arr$_.push(t);
                }
                _$Has$_(t) {
                    return this._$_set$_.has(t);
                }
                _$Delete$_(t) {
                    this._$_set$_.delete(t) && (this._$_needToRebuildArray$_ = !0);
                }
                _$GetSize$_() {
                    return this._$_set$_.size;
                }
                _$IsEmpty$_() {
                    return 0 === this._$_set$_.size;
                }
                _$GetArray$_() {
                    return this._$_needToRebuildArray$_ && (this._$_RebuildArray$_(), 
                    this._$_needToRebuildArray$_ = !1), this._$_arr$_;
                }
                _$_RebuildArray$_() {
                    const t = this._$_arr$_;
                    C33._$clearArray$_(t);
                    for (const e of this._$_set$_) t.push(e);
                }
            };
        }
        {
            const C33 = self._$C3$_, EASE_MAP = new Map(), PREDEFINED_EASE_MAP = new Map(), CUSTOM_EASE_EDITOR_MAP = new Map(), CUSTOM_EASE_DATA_EDITOR_MAP = new Map(), CUSTOM_EASE_RUNTIME_MAP = new Map(), CUSTOM_EASE_DATA_RUNTIME_MAP = new Map(), PRIVATE_EASE_MAP = new Map(), BUILT_IN_TRANSITION_MAP = new Map(), ALIAS_MAP = new Map(), EASE_TRANSLATION_KEYS = (ALIAS_MAP.set("linear", "noease"), 
            ALIAS_MAP.set("default", "noease"), [ "default", "noease", "easeinquad", "easeoutquad", "easeinoutquad", "easeincubic", "easeoutcubic", "easeinoutcubic", "easeinquart", "easeoutquart", "easeinoutquart", "easeinquint", "easeoutquint", "easeinoutquint", "easeinsine", "easeoutsine", "easeinoutsine", "easeinexpo", "easeoutexpo", "easeinoutexpo", "easeincirc", "easeoutcirc", "easeinoutcirc", "easeinelastic", "easeoutelastic", "easeinoutelastic", "easeinback", "easeoutback", "easeinoutback", "easeinbounce", "easeoutbounce", "easeinoutbounce" ]), SHORT_EASE_TRANSLATION_KEYS = [ "default", "noease", "quad", "cubic", "quart", "quint", "sine", "expo", "circ", "elastic", "back", "bounce" ], EASE_API2INTERNAL_NAMES = new Map([ [ "linear", "noease" ], [ "in-sine", "easeinsine" ], [ "out-sine", "easeoutsine" ], [ "in-out-sine", "easeinoutsine" ], [ "in-elastic", "easeinelastic" ], [ "out-elastic", "easeoutelastic" ], [ "in-out-elastic", "easeinoutelastic" ], [ "in-back", "easeinback" ], [ "out-back", "easeoutback" ], [ "in-out-back", "easeinoutback" ], [ "in-bounce", "easeinbounce" ], [ "out-bounce", "easeoutbounce" ], [ "in-out-bounce", "easeinoutbounce" ], [ "in-cubic", "easeincubic" ], [ "out-cubic", "easeoutcubic" ], [ "in-out-cubic", "easeinoutcubic" ], [ "in-quadratic", "easeinquad" ], [ "out-quadratic", "easeoutquad" ], [ "in-out-quadratic", "easeinoutquad" ], [ "in-quartic", "easeinquart" ], [ "out-quartic", "easeoutquart" ], [ "in-out-quartic", "easeinoutquart" ], [ "in-quintic", "easeinquint" ], [ "out-quintic", "easeoutquint" ], [ "in-out-quintic", "easeinoutquint" ], [ "in-circular", "easeincirc" ], [ "out-circular", "easeoutcirc" ], [ "in-out-circular", "easeinoutcirc" ], [ "in-exponential", "easeinexpo" ], [ "out-exponential", "easeoutexpo" ], [ "in-out-exponential", "easeinoutexpo" ] ]), SAMPLE_COUNT = (self._$Ease$_ = class d {
                constructor() {}
                static _$InheritEase$_() {
                    return "default";
                }
                static _$DefaultEase$_() {
                    return "noease";
                }
                static _$ToInternal$_(t) {
                    return EASE_API2INTERNAL_NAMES.get(t);
                }
                static _$GetEditorEaseNames$_(e, ...s) {
                    this._$_CreateEaseMap$_();
                    let t, i = (e ? (CUSTOM_EASE_EDITOR_MAP.has(e) || CUSTOM_EASE_EDITOR_MAP.set(e, new Map()), 
                    [ ...(t = CUSTOM_EASE_EDITOR_MAP.get(e)).keys() ].filter(t => !d._$GetEditorEaseData$_(t, e) || d._$GetEditorEaseData$_(t, e).transition.IsForAnyPurpose())) : [ ...(t = CUSTOM_EASE_RUNTIME_MAP).keys() ]).sort();
                    return [ ...PREDEFINED_EASE_MAP.keys() ].concat(i).filter(t => !s.includes(t));
                }
                static _$GetRuntimeEaseNames$_() {
                    this._$_CreateEaseMap$_();
                    const t = [ ...CUSTOM_EASE_RUNTIME_MAP.keys() ];
                    return t.sort(), [ ...PREDEFINED_EASE_MAP.keys() ].concat(t);
                }
                static _$GetCustomRuntimeEaseNames$_() {
                    this._$_CreateEaseMap$_();
                    const t = [ ...CUSTOM_EASE_RUNTIME_MAP.keys() ];
                    return t.sort(), t;
                }
                static _$IsPredefinedTranslatedName$_(t) {
                    for (const e of EASE_TRANSLATION_KEYS) {
                        const s = self.lang("ui.bars.timeline.eases." + e);
                        if (s === t) return !0;
                    }
                    for (const i of SHORT_EASE_TRANSLATION_KEYS) {
                        const r = self.lang("ui.bars.timeline.short-eases." + i);
                        if (r === t) return !0;
                    }
                }
                static _$IsNamePredefined$_(t) {
                    return this._$_CreateEaseMap$_(), [ ...PREDEFINED_EASE_MAP.keys() ].includes(t);
                }
                static _$_GetEase$_(t) {
                    const e = ALIAS_MAP.get(t);
                    return e ? EASE_MAP.get(e) : d._$IsNamePredefined$_(t) ? EASE_MAP.get(t) : PRIVATE_EASE_MAP.has(t) ? PRIVATE_EASE_MAP.get(t) : void 0;
                }
                static _$GetBuiltInTransition$_(t) {
                    return this._$_CreateEaseMap$_(), BUILT_IN_TRANSITION_MAP.get(t);
                }
                static _$GetEditorEase$_(t, e) {
                    this._$_CreateEaseMap$_();
                    const s = d._$_GetEase$_(t);
                    if (s) return s;
                    if (e) return CUSTOM_EASE_EDITOR_MAP.get(e).get(t);
                    throw new Error("missing ease function");
                }
                static _$GetEditorEaseData$_(t, e) {
                    this._$_CreateEaseMap$_();
                    const s = CUSTOM_EASE_DATA_EDITOR_MAP.get(e);
                    if (s) return s.get(t);
                }
                static _$HasEditorEase$_(t, e) {
                    this._$_CreateEaseMap$_();
                    const s = d._$_GetEase$_(t);
                    return !!s || !!CUSTOM_EASE_EDITOR_MAP.get(e).get(t);
                }
                static _$GetRuntimeEase$_(t) {
                    this._$_CreateEaseMap$_();
                    const e = d._$_GetEase$_(t);
                    return e || CUSTOM_EASE_RUNTIME_MAP.get(t);
                }
                static _$GetRuntimeEaseData$_(t) {
                    return this._$_CreateEaseMap$_(), CUSTOM_EASE_DATA_RUNTIME_MAP.get(t);
                }
                static _$GetEaseFromIndex$_(t) {
                    this._$_CreateEaseMap$_();
                    const e = this._$GetRuntimeEaseNames$_();
                    return e[t];
                }
                static _$GetIndexForEase$_(t, e) {
                    this._$_CreateEaseMap$_();
                    const s = this._$GetEditorEaseNames$_(e);
                    return s.indexOf(t);
                }
                static _$GetIndexForEaseAtRuntime$_(t) {
                    return this._$GetIndexForEase$_(t);
                }
                static _$_CreateEaseMap$_() {
                    0 === EASE_MAP.size && (this._$_AddPredifinedEase$_("default", () => {}), 
                    this._$_AddPredifinedEase$_("noease", [ {
                        x: 0,
                        y: 0,
                        sax: .336,
                        say: 0,
                        eax: 0,
                        eay: 0,
                        se: !0,
                        ee: !1
                    }, {
                        x: 1,
                        y: 1,
                        sax: 0,
                        say: 0,
                        eax: -.336,
                        eay: 0,
                        se: !1,
                        ee: !0
                    } ], !0), this._$_AddPredifinedEase$_("easeinsine", [ {
                        x: 0,
                        y: 0,
                        sax: .485,
                        say: 0,
                        eax: 0,
                        eay: 0,
                        se: !0,
                        ee: !1
                    }, {
                        x: 1,
                        y: 1,
                        sax: 0,
                        say: 0,
                        eax: -.038,
                        eay: 0,
                        se: !1,
                        ee: !0
                    } ]), this._$_AddPredifinedEase$_("easeoutsine", [ {
                        x: 0,
                        y: 0,
                        sax: .038,
                        say: 0,
                        eax: 0,
                        eay: 0,
                        se: !0,
                        ee: !1
                    }, {
                        x: 1,
                        y: 1,
                        sax: 0,
                        say: 0,
                        eax: -.485,
                        eay: 0,
                        se: !1,
                        ee: !0
                    } ]), this._$_AddPredifinedEase$_("easeinoutsine", [ {
                        x: 0,
                        y: 0,
                        sax: .336,
                        say: 0,
                        eax: 0,
                        eay: 0,
                        se: !0,
                        ee: !1
                    }, {
                        x: 1,
                        y: 1,
                        sax: 0,
                        say: 0,
                        eax: -.336,
                        eay: 0,
                        se: !1,
                        ee: !0
                    } ]), this._$_AddPredifinedEase$_("easeinelastic", [ {
                        x: 0,
                        y: 0,
                        sax: .018,
                        say: 0,
                        eax: 0,
                        eay: 0,
                        se: !0,
                        ee: !1
                    }, {
                        x: .116,
                        y: .002,
                        sax: .025,
                        say: 0,
                        eax: -.025,
                        eay: 0,
                        se: !0,
                        ee: !0
                    }, {
                        x: .266,
                        y: -.005,
                        sax: .024,
                        say: 0,
                        eax: -.021,
                        eay: 0,
                        se: !0,
                        ee: !0
                    }, {
                        x: .416,
                        y: .016,
                        sax: .024,
                        say: 0,
                        eax: -.026,
                        eay: 0,
                        se: !0,
                        ee: !0
                    }, {
                        x: .566,
                        y: -.045,
                        sax: .061,
                        say: 0,
                        eax: -.025,
                        eay: 0,
                        se: !0,
                        ee: !0
                    }, {
                        x: .716,
                        y: .132,
                        sax: .072,
                        say: -.004,
                        eax: -.045,
                        eay: 0,
                        se: !0,
                        ee: !0
                    }, {
                        x: .866,
                        y: -.373,
                        sax: .06,
                        say: 0,
                        eax: -.049,
                        eay: -.002,
                        se: !0,
                        ee: !0
                    }, {
                        x: 1,
                        y: 1,
                        sax: 0,
                        say: 0,
                        eax: -.038,
                        eay: -.263,
                        se: !1,
                        ee: !0
                    } ]), this._$_AddPredifinedEase$_("easeoutelastic", [ {
                        x: 0,
                        y: 0,
                        sax: .038,
                        say: .263,
                        eax: 0,
                        eay: 0,
                        se: !0,
                        ee: !1
                    }, {
                        x: .136,
                        y: 1.373,
                        sax: .049,
                        say: .002,
                        eax: -.06,
                        eay: 0,
                        se: !0,
                        ee: !0
                    }, {
                        x: .286,
                        y: .868,
                        sax: .045,
                        say: 0,
                        eax: -.072,
                        eay: .004,
                        se: !0,
                        ee: !0
                    }, {
                        x: .436,
                        y: 1.045,
                        sax: .025,
                        say: 0,
                        eax: -.061,
                        eay: 0,
                        se: !0,
                        ee: !0
                    }, {
                        x: .586,
                        y: .984,
                        sax: .026,
                        say: 0,
                        eax: -.024,
                        eay: 0,
                        se: !0,
                        ee: !0
                    }, {
                        x: .736,
                        y: 1.005,
                        sax: .021,
                        say: 0,
                        eax: -.024,
                        eay: 0,
                        se: !0,
                        ee: !0
                    }, {
                        x: .886,
                        y: .998,
                        sax: .025,
                        say: 0,
                        eax: -.025,
                        eay: 0,
                        se: !0,
                        ee: !0
                    }, {
                        x: 1,
                        y: 1,
                        sax: 0,
                        say: 0,
                        eax: -.018,
                        eay: 0,
                        se: !1,
                        ee: !0
                    } ]), this._$_AddPredifinedEase$_("easeinoutelastic", [ {
                        x: 0,
                        y: 0,
                        sax: .025,
                        say: 0,
                        eax: 0,
                        eay: 0,
                        se: !0,
                        ee: !1
                    }, {
                        x: .067,
                        y: .001,
                        sax: .025,
                        say: 0,
                        eax: -.025,
                        eay: 0,
                        se: !0,
                        ee: !0
                    }, {
                        x: .18,
                        y: -.005,
                        sax: .025,
                        say: 0,
                        eax: -.025,
                        eay: 0,
                        se: !0,
                        ee: !0
                    }, {
                        x: .292,
                        y: .025,
                        sax: .053,
                        say: 0,
                        eax: -.025,
                        eay: 0,
                        se: !0,
                        ee: !0
                    }, {
                        x: .405,
                        y: -.118,
                        sax: .069,
                        say: 0,
                        eax: -.027,
                        eay: 0,
                        se: !0,
                        ee: !0
                    }, {
                        x: .597,
                        y: 1.118,
                        sax: .027,
                        say: 0,
                        eax: -.069,
                        eay: 0,
                        se: !0,
                        ee: !0
                    }, {
                        x: .71,
                        y: .975,
                        sax: .025,
                        say: 0,
                        eax: -.053,
                        eay: 0,
                        se: !0,
                        ee: !0
                    }, {
                        x: .822,
                        y: 1.005,
                        sax: .025,
                        say: 0,
                        eax: -.025,
                        eay: 0,
                        se: !0,
                        ee: !0
                    }, {
                        x: .935,
                        y: .999,
                        sax: .025,
                        say: 0,
                        eax: -.025,
                        eay: 0,
                        se: !0,
                        ee: !0
                    }, {
                        x: 1,
                        y: 1,
                        sax: 0,
                        say: 0,
                        eax: -.025,
                        eay: 0,
                        se: !1,
                        ee: !0
                    } ]), this._$_AddPredifinedEase$_("easeinback", [ {
                        x: 0,
                        y: 0,
                        sax: .35,
                        say: 0,
                        eax: 0,
                        eay: 0,
                        se: !0,
                        ee: !1
                    }, {
                        x: 1,
                        y: 1,
                        sax: 0,
                        say: 0,
                        eax: -.34,
                        eay: -1.579,
                        se: !1,
                        ee: !0
                    } ]), this._$_AddPredifinedEase$_("easeoutback", [ {
                        x: 0,
                        y: 0,
                        sax: .34,
                        say: 1.579,
                        eax: 0,
                        eay: 0,
                        se: !0,
                        ee: !1
                    }, {
                        x: 1,
                        y: 1,
                        sax: 0,
                        say: 0,
                        eax: -.35,
                        eay: 0,
                        se: !1,
                        ee: !0
                    } ]), this._$_AddPredifinedEase$_("easeinoutback", [ {
                        x: 0,
                        y: 0,
                        sax: .035,
                        say: 0,
                        eax: 0,
                        eay: 0,
                        se: !0,
                        ee: !1
                    }, {
                        x: .242,
                        y: -.1,
                        sax: .258,
                        say: 0,
                        eax: -.025,
                        eay: 0,
                        se: !0,
                        ee: !0
                    }, {
                        x: .76,
                        y: 1.1,
                        sax: .025,
                        say: 0,
                        eax: -.26,
                        eay: 0,
                        se: !0,
                        ee: !0
                    }, {
                        x: 1,
                        y: 1,
                        sax: 0,
                        say: 0,
                        eax: -.035,
                        eay: 0,
                        se: !1,
                        ee: !0
                    } ]), this._$_AddPredifinedEase$_("easeinbounce", [ {
                        x: 0,
                        y: 0,
                        sax: .033,
                        say: .025,
                        eax: 0,
                        eay: 0,
                        se: !0,
                        ee: !1
                    }, {
                        x: .092,
                        y: 0,
                        sax: .026,
                        say: .078,
                        eax: -.033,
                        eay: .025,
                        se: !0,
                        ee: !0
                    }, {
                        x: .274,
                        y: 0,
                        sax: .097,
                        say: .319,
                        eax: -.026,
                        eay: .078,
                        se: !0,
                        ee: !0
                    }, {
                        x: .637,
                        y: 0,
                        sax: .105,
                        say: .625,
                        eax: -.097,
                        eay: .319,
                        se: !0,
                        ee: !0
                    }, {
                        x: 1,
                        y: 1,
                        sax: 0,
                        say: 0,
                        eax: -.125,
                        eay: -.004,
                        se: !1,
                        ee: !0
                    } ]), this._$_AddPredifinedEase$_("easeoutbounce", [ {
                        x: 0,
                        y: 0,
                        sax: .125,
                        say: .004,
                        eax: 0,
                        eay: 0,
                        se: !0,
                        ee: !1
                    }, {
                        x: .365,
                        y: 1,
                        sax: .097,
                        say: -.319,
                        eax: -.105,
                        eay: -.625,
                        se: !0,
                        ee: !0
                    }, {
                        x: .728,
                        y: 1,
                        sax: .026,
                        say: -.078,
                        eax: -.097,
                        eay: -.319,
                        se: !0,
                        ee: !0
                    }, {
                        x: .91,
                        y: 1,
                        sax: .033,
                        say: -.025,
                        eax: -.026,
                        eay: -.078,
                        se: !0,
                        ee: !0
                    }, {
                        x: 1,
                        y: 1,
                        sax: 0,
                        say: 0,
                        eax: -.033,
                        eay: -.025,
                        se: !1,
                        ee: !0
                    } ]), this._$_AddPredifinedEase$_("easeinoutbounce", [ {
                        x: 0,
                        y: 0,
                        sax: .01,
                        say: .006,
                        eax: 0,
                        eay: 0,
                        se: !0,
                        ee: !1
                    }, {
                        x: .046,
                        y: 0,
                        sax: .021,
                        say: .038,
                        eax: -.01,
                        eay: .006,
                        se: !0,
                        ee: !0
                    }, {
                        x: .137,
                        y: 0,
                        sax: .059,
                        say: .158,
                        eax: -.021,
                        eay: .038,
                        se: !0,
                        ee: !0
                    }, {
                        x: .319,
                        y: 0,
                        sax: .117,
                        say: .744,
                        eax: -.059,
                        eay: .158,
                        se: !0,
                        ee: !0
                    }, {
                        x: .683,
                        y: 1,
                        sax: .059,
                        say: -.158,
                        eax: -.117,
                        eay: -.744,
                        se: !0,
                        ee: !0
                    }, {
                        x: .865,
                        y: 1,
                        sax: .021,
                        say: -.038,
                        eax: -.059,
                        eay: -.158,
                        se: !0,
                        ee: !0
                    }, {
                        x: .956,
                        y: 1,
                        sax: .01,
                        say: -.006,
                        eax: -.021,
                        eay: -.038,
                        se: !0,
                        ee: !0
                    }, {
                        x: 1,
                        y: 1,
                        sax: 0,
                        say: 0,
                        eax: -.01,
                        eay: -.006,
                        se: !1,
                        ee: !0
                    } ]), this._$_AddPredifinedEase$_("easeincubic", [ {
                        x: 0,
                        y: 0,
                        sax: .75,
                        say: 0,
                        eax: 0,
                        eay: 0,
                        se: !0,
                        ee: !1
                    }, {
                        x: 1,
                        y: 1,
                        sax: 0,
                        say: 0,
                        eax: -.138,
                        eay: -.321,
                        se: !1,
                        ee: !0
                    } ]), this._$_AddPredifinedEase$_("easeoutcubic", [ {
                        x: 0,
                        y: 0,
                        sax: .138,
                        say: .321,
                        eax: 0,
                        eay: 0,
                        se: !0,
                        ee: !1
                    }, {
                        x: 1,
                        y: 1,
                        sax: 0,
                        say: 0,
                        eax: -.75,
                        eay: 0,
                        se: !1,
                        ee: !0
                    } ]), this._$_AddPredifinedEase$_("easeinoutcubic", [ {
                        x: 0,
                        y: 0,
                        sax: .285,
                        say: 0,
                        eax: 0,
                        eay: 0,
                        se: !0,
                        ee: !1
                    }, {
                        x: .5,
                        y: .5,
                        sax: .081,
                        say: .272,
                        eax: -.081,
                        eay: -.272,
                        se: !0,
                        ee: !0
                    }, {
                        x: 1,
                        y: 1,
                        sax: 0,
                        say: 0,
                        eax: -.285,
                        eay: 0,
                        se: !1,
                        ee: !0
                    } ]), this._$_AddPredifinedEase$_("easeinquad", [ {
                        x: 0,
                        y: 0,
                        sax: .4,
                        say: 0,
                        eax: 0,
                        eay: 0,
                        se: !0,
                        ee: !1
                    }, {
                        x: 1,
                        y: 1,
                        sax: 0,
                        say: 0,
                        eax: -.178,
                        eay: -.392,
                        se: !1,
                        ee: !0
                    } ]), this._$_AddPredifinedEase$_("easeoutquad", [ {
                        x: 0,
                        y: 0,
                        sax: .178,
                        say: .392,
                        eax: 0,
                        eay: 0,
                        se: !0,
                        ee: !1
                    }, {
                        x: 1,
                        y: 1,
                        sax: 0,
                        say: 0,
                        eax: -.4,
                        eay: 0,
                        se: !1,
                        ee: !0
                    } ]), this._$_AddPredifinedEase$_("easeinoutquad", [ {
                        x: 0,
                        y: 0,
                        sax: .25,
                        say: 0,
                        eax: 0,
                        eay: 0,
                        se: !0,
                        ee: !1
                    }, {
                        x: .5,
                        y: .5,
                        sax: .03,
                        say: .065,
                        eax: -.03,
                        eay: -.065,
                        se: !0,
                        ee: !0
                    }, {
                        x: 1,
                        y: 1,
                        sax: 0,
                        say: 0,
                        eax: -.25,
                        eay: 0,
                        se: !1,
                        ee: !0
                    } ]), this._$_AddPredifinedEase$_("easeinquart", [ {
                        x: 0,
                        y: 0,
                        sax: .25,
                        say: 1,
                        eax: 0,
                        eay: 0,
                        se: !0,
                        ee: !1
                    }, {
                        x: 1,
                        y: 1,
                        sax: 0,
                        say: 0,
                        eax: -.5,
                        eay: 0,
                        se: !1,
                        ee: !0
                    } ]), this._$_AddPredifinedEase$_("easeoutquart", [ {
                        x: 0,
                        y: 0,
                        sax: .5,
                        say: 0,
                        eax: 0,
                        eay: 0,
                        se: !0,
                        ee: !1
                    }, {
                        x: 1,
                        y: 1,
                        sax: 0,
                        say: 0,
                        eax: -.25,
                        eay: -1,
                        se: !1,
                        ee: !0
                    } ]), this._$_AddPredifinedEase$_("easeinoutquart", [ {
                        x: 0,
                        y: 0,
                        sax: .765,
                        say: .03,
                        eax: 0,
                        eay: 0,
                        se: !0,
                        ee: !1
                    }, {
                        x: 1,
                        y: 1,
                        sax: 0,
                        say: 0,
                        eax: -.765,
                        eay: -.03,
                        se: !1,
                        ee: !0
                    } ]), this._$_AddPredifinedEase$_("easeinquint", [ {
                        x: 0,
                        y: 0,
                        sax: .6,
                        say: 0,
                        eax: 0,
                        eay: 0,
                        se: !0,
                        ee: !1
                    }, {
                        x: 1,
                        y: 1,
                        sax: 0,
                        say: 0,
                        eax: -.2,
                        eay: -1,
                        se: !1,
                        ee: !0
                    } ]), this._$_AddPredifinedEase$_("easeoutquint", [ {
                        x: 0,
                        y: 0,
                        sax: .2,
                        say: 1,
                        eax: 0,
                        eay: 0,
                        se: !0,
                        ee: !1
                    }, {
                        x: 1,
                        y: 1,
                        sax: 0,
                        say: 0,
                        eax: -.6,
                        eay: 0,
                        se: !1,
                        ee: !0
                    } ]), this._$_AddPredifinedEase$_("easeinoutquint", [ {
                        eax: 0,
                        eay: 0,
                        ee: !1,
                        sax: .84,
                        say: 0,
                        se: !0,
                        x: 0,
                        y: 0
                    }, {
                        eax: -.84,
                        eay: 0,
                        ee: !0,
                        sax: 0,
                        say: 0,
                        se: !1,
                        x: 1,
                        y: 1
                    } ]), this._$_AddPredifinedEase$_("easeincirc", [ {
                        x: 0,
                        y: 0,
                        sax: .25,
                        say: 0,
                        eax: 0,
                        eay: 0,
                        se: !0,
                        ee: !1
                    }, {
                        x: 1,
                        y: 1,
                        sax: 0,
                        say: 0,
                        eax: -.024,
                        eay: -.808,
                        se: !1,
                        ee: !0
                    } ]), this._$_AddPredifinedEase$_("easeoutcirc", [ {
                        x: 0,
                        y: 0,
                        sax: .024,
                        say: .808,
                        eax: 0,
                        eay: 0,
                        se: !0,
                        ee: !1
                    }, {
                        x: 1,
                        y: 1,
                        sax: 0,
                        say: 0,
                        eax: -.25,
                        eay: 0,
                        se: !1,
                        ee: !0
                    } ]), this._$_AddPredifinedEase$_("easeinoutcirc", [ {
                        x: 0,
                        y: 0,
                        sax: .125,
                        say: 0,
                        eax: 0,
                        eay: 0,
                        se: !0,
                        ee: !1
                    }, {
                        x: .5,
                        y: .5,
                        sax: .02,
                        say: .428,
                        eax: -.02,
                        eay: -.428,
                        se: !0,
                        ee: !0
                    }, {
                        x: 1,
                        y: 1,
                        sax: 0,
                        say: 0,
                        eax: -.125,
                        eay: 0,
                        se: !1,
                        ee: !0
                    } ]), this._$_AddPredifinedEase$_("easeinexpo", [ {
                        x: 0,
                        y: 0,
                        sax: .66,
                        say: 0,
                        eax: 0,
                        eay: 0,
                        se: !0,
                        ee: !1
                    }, {
                        x: 1,
                        y: 1,
                        sax: 0,
                        say: 0,
                        eax: -.14,
                        eay: -1,
                        se: !1,
                        ee: !0
                    } ]), this._$_AddPredifinedEase$_("easeoutexpo", [ {
                        x: 0,
                        y: 0,
                        sax: .14,
                        say: 1,
                        eax: 0,
                        eay: 0,
                        se: !0,
                        ee: !1
                    }, {
                        x: 1,
                        y: 1,
                        sax: 0,
                        say: 0,
                        eax: -.66,
                        eay: 0,
                        se: !1,
                        ee: !0
                    } ]), this._$_AddPredifinedEase$_("easeinoutexpo", [ {
                        eax: 0,
                        eay: 0,
                        ee: !1,
                        sax: .345,
                        say: 0,
                        se: !0,
                        x: 0,
                        y: 0
                    }, {
                        eax: -.06,
                        eay: -.5,
                        ee: !0,
                        sax: .06,
                        say: .5,
                        se: !0,
                        x: .5,
                        y: .5
                    }, {
                        eax: -.335,
                        eay: 0,
                        ee: !0,
                        sax: 0,
                        say: 0,
                        se: !1,
                        x: 1,
                        y: 1
                    } ]), this._$_AddPrivateCustomEase$_("cubicbezier", this._$EaseCubicBezier$_), 
                    this._$_AddPrivateCustomEase$_("spline", this._$EaseSpline$_));
                }
                static _$_AddPredifinedEase$_(t, e, s = !1) {
                    if ("function" == typeof e) d._$_AddEase$_(t, e, "predefined"); else {
                        if (!C33._$IsArray$_(e)) throw new Error("unexpected arguments");
                        if (self.BuiltInTransition) {
                            const r = C33._$New$_(self.BuiltInTransition, t, s);
                            r.SetFromJson(e), d._$_AddEase$_(t, (t, e, s, i) => r._$Interpolate$_(t, e, s, i), "predefined"), 
                            BUILT_IN_TRANSITION_MAP.set(t, r);
                        } else {
                            const n = C33._$New$_(C33._$Transition$_, [ t, e.map(t => [ t.x, t.y, t.sax, t.say, t.eax, t.eay, t.se, t.ee ]) ], !1);
                            n._$MakeLinear$_(s), d._$_AddEase$_(t, (t, e, s, i) => n._$Interpolate$_(t, e, s, i), "predefined");
                        }
                    }
                }
                static _$_AddPrivateCustomEase$_(t, e) {
                    d._$_AddEase$_(t, e, "private");
                }
                static _$AddCustomEase$_(t, e, s, i) {
                    this._$_CreateEaseMap$_(), d._$_AddEase$_(t, e, "custom", s, i);
                }
                static _$RemoveCustomEase$_(t, e) {
                    if (!this._$IsNamePredefined$_(t) && ![ ...PRIVATE_EASE_MAP.keys() ].includes(t)) {
                        const s = CUSTOM_EASE_EDITOR_MAP.get(e), i = (s && s.delete(t), 
                        CUSTOM_EASE_DATA_EDITOR_MAP.get(e));
                        i && i.delete(t);
                    }
                }
                static _$_AddEase$_(t, e, s, i, r) {
                    switch (s) {
                      case "predefined":
                        EASE_MAP.set(t, e), PREDEFINED_EASE_MAP.set(t, e);
                        break;

                      case "custom":
                        if (i) {
                            CUSTOM_EASE_EDITOR_MAP.has(i) || CUSTOM_EASE_EDITOR_MAP.set(i, new Map()), 
                            CUSTOM_EASE_DATA_EDITOR_MAP.has(i) || CUSTOM_EASE_DATA_EDITOR_MAP.set(i, new Map());
                            const n = CUSTOM_EASE_EDITOR_MAP.get(i), h = (n.set(t, e), 
                            CUSTOM_EASE_DATA_EDITOR_MAP.get(i));
                            h.set(t, r);
                        } else CUSTOM_EASE_RUNTIME_MAP.set(t, e), CUSTOM_EASE_DATA_RUNTIME_MAP.set(t, r);
                        break;

                      case "private":
                        EASE_MAP.set(t, e), PRIVATE_EASE_MAP.set(t, e);
                        break;

                      default:
                        throw new Error("unexpected ease mode");
                    }
                }
                static _$NoEase$_(t, e, s, i) {
                    return 0 === i ? e : s * t / i + e;
                }
                static _$EaseCubicBezier$_(t, e, s, i, r) {
                    const n = e, h = 3 * t * (s - e), o = 3 * t ** 2 * (e + i - 2 * s), a = t ** 3 * (r - e + 3 * s - 3 * i);
                    return n + h + o + a;
                }
                static _$EaseSpline$_(t, e, s, i, r, n, h, o, l, u) {
                    if (i === r && n === h) return t;
                    const f = get_t_for_x(t, e, i, n, o, u), d = a(s, r, h, l), p = b(s, r, h, l), m = c(s, r, h, l);
                    return calc_bezier(f, d, p, m);
                }
                static _$GetBezierSamples$_(t, e, s, i) {
                    const r = [], n = a(t, e, s, i), h = b(t, e, s, i), o = c(t, e, s, i);
                    for (let t = 0; t < SAMPLE_COUNT; ++t) {
                        const l = calc_bezier(t * SAMPLE_STEP, n, h, o);
                        r.push(l);
                    }
                    return r;
                }
            }, 11), SAMPLE_STEP = 1 / (SAMPLE_COUNT - 1), NEWTON_RAPHSON_ITERATIONS = 4, NEWTON_RAPHSON_MIN_SLOPE = .01, SUBDIVISION_PRECISION = 1e-7, SUBDIVISION_MAX_ITERATIONS = 10, a = (t, e, s, i) => i - 3 * s + 3 * e - t, b = (t, e, s, i) => 3 * s - 6 * e + 3 * t, c = (t, e, s, i) => 3 * (e - t), calc_bezier = (t, e, s, i) => ((e * t + s) * t + i) * t, get_slope = (t, e, s, i) => 3 * e * t * t + 2 * s * t + i, get_t_for_x = (h, t, e, s, i, r) => {
                if (1 == h) return 1;
                let o = 0, n = 1, l = r[n], u = SAMPLE_COUNT - 1;
                for (SAMPLE_COUNT; n != u && l <= h; ) n++, l = r[n], o += SAMPLE_STEP;
                n--;
                let f = (h - (l = r[n])) / (r[n + 1] - l), d = o + f * SAMPLE_STEP, p = a(t, e, s, i), m = b(t, e, s, i), C = c(t, e, s, i), g = get_slope(d, p, m, C);
                if (0 === g) return d;
                if (g >= NEWTON_RAPHSON_MIN_SLOPE) {
                    for (let t = 0; t < NEWTON_RAPHSON_ITERATIONS; ++t) {
                        const S = calc_bezier(d, p, m, C) - h, _ = get_slope(d, p, m, C);
                        d -= S / _;
                    }
                    return d;
                }
                {
                    let e = o, s = o + SAMPLE_STEP, i = 0, r, n;
                    do {
                        d = e + (s - e) / 2;
                        let t = calc_bezier(d, p, m, C) - h;
                        0 < t ? s = d : e = d, r = Math.abs(t) > SUBDIVISION_PRECISION, 
                        n = ++i < SUBDIVISION_MAX_ITERATIONS;
                    } while (r && n);
                    return d;
                }
            };
        }
        {
            let RequireStringOrNumber2 = function(t) {
                C33._$IsString$_(t);
            };
            RequireStringOrNumber = RequireStringOrNumber2;
            const C33 = self._$C3$_;
            C33._$ProbabilityTable$_ = class {
                constructor(t) {
                    this._$_items$_ = [], this._$_name$_ = t || "", this._$_totalWeight$_ = 0;
                }
                _$Release$_() {
                    this._$Clear$_(), this._$_items$_ = null;
                }
                _$GetName$_() {
                    return this._$_name$_;
                }
                _$Clear$_() {
                    C33._$clear2DArray$_(this._$_items$_), this._$_totalWeight$_ = 0;
                }
                _$GetTotalWeight$_() {
                    return this._$_totalWeight$_;
                }
                _$Sample$_(t = Math.random() * this._$GetTotalWeight$_()) {
                    let e = 0;
                    for (const [ s, i ] of this._$_items$_) if (t < (e += s)) return i;
                    return 0;
                }
                _$AddItem$_(t, e) {
                    RequireStringOrNumber2(e), this._$_totalWeight$_ += t, this._$_items$_.push([ t, e ]);
                }
                _$RemoveItem$_(e, s) {
                    RequireStringOrNumber2(s);
                    const i = 0 === e;
                    for (let t = 0; t < this._$_items$_.length; t++) {
                        const r = this._$_items$_[t], n = i || r[0] === e, h = r[1] === s;
                        if (n && h) {
                            this._$_items$_.splice(t, 1), this._$_totalWeight$_ -= r[0];
                            break;
                        }
                    }
                }
                _$asJSON$_() {
                    return JSON.stringify(this._$_items$_);
                }
                static _$fromJSON$_(t, e) {
                    const s = new C33._$ProbabilityTable$_(e), i = JSON.parse(t);
                    for (const r of i) {
                        const n = r[0], h = r[1];
                        s._$AddItem$_(n, h);
                    }
                    return s;
                }
            };
        }
        {
            let C33 = self._$C3$_, nextId = 0;
            C33._$ScreenReaderText$_ = class {
                constructor(t, e) {
                    this._$_runtime$_ = t, this._$_text$_ = e, this._$_id$_ = nextId++, 
                    this._$_runtime$_._$PostComponentMessageToDOM$_("runtime", "screen-reader-text", {
                        type: "create",
                        id: this._$_id$_,
                        text: this._$_text$_
                    });
                }
                _$Release$_() {
                    this._$_runtime$_._$PostComponentMessageToDOM$_("runtime", "screen-reader-text", {
                        type: "release",
                        id: this._$_id$_
                    }), this._$_runtime$_ = null, this._$_text$_ = "", this._$_id$_ = -1;
                }
                _$SetText$_(t) {
                    this._$_text$_ !== t && (this._$_text$_ = t, this._$_runtime$_._$PostComponentMessageToDOM$_("runtime", "screen-reader-text", {
                        type: "update",
                        id: this._$_id$_,
                        text: this._$_text$_
                    }));
                }
            };
        }
        {
            const C33 = self._$C3$_;
            C33.Event = class {
                constructor(t, e) {
                    this.type = t, this.cancelable = !!e, this.defaultPrevented = !1, 
                    this._$propagationStopped$_ = !1, this._$isAsync$_ = !1;
                }
                preventDefault() {
                    if (!this.cancelable) throw new Error(`event '${this.type}' is not cancelable`);
                    this.defaultPrevented = !0;
                }
                stopPropagation() {
                    if (!this.cancelable) throw new Error(`event '${this.type}' cannot be stopped`);
                    if (this._$isAsync$_) throw new Error(`cannot stop async event '${this.type}' propagation`);
                    this._$propagationStopped$_ = !0;
                }
            };
        }
        {
            const C33 = self._$C3$_, assert = self.assert;
            C33.Event._$Handler$_ = class extends C33._$DefendedBase$_ {
                constructor(t) {
                    super(), this._$_type$_ = t, this._$_captureListeners$_ = [], 
                    this._$_captureListenersSet$_ = new Set(), this._$_listeners$_ = [], 
                    this._$_listenersSet$_ = new Set(), this._$_fireDepth$_ = 0, 
                    this._$_queueModifyListeners$_ = [];
                }
                _$Release$_() {
                    0 < this._$_fireDepth$_ || (C33._$clearArray$_(this._$_captureListeners$_), 
                    this._$_captureListenersSet$_.clear(), C33._$clearArray$_(this._$_listeners$_), 
                    this._$_listenersSet$_.clear(), C33._$clearArray$_(this._$_queueModifyListeners$_), 
                    C33._$Release$_(this));
                }
                _$_AddListener$_(t, e) {
                    this._$_IsFiring$_() ? this._$_queueModifyListeners$_.push({
                        _$op$_: "add",
                        _$func$_: t,
                        capture: e
                    }) : e ? this._$_captureListenersSet$_.has(t) || (this._$_captureListeners$_.push(t), 
                    this._$_captureListenersSet$_.add(t)) : this._$_listenersSet$_.has(t) || (this._$_listeners$_.push(t), 
                    this._$_listenersSet$_.add(t));
                }
                _$_RemoveListener$_(t, e) {
                    this._$_IsFiring$_() ? this._$_queueModifyListeners$_.push({
                        _$op$_: "remove",
                        _$func$_: t,
                        capture: e
                    }) : e ? this._$_captureListenersSet$_.has(t) && (this._$_captureListenersSet$_.delete(t), 
                    C33._$arrayFindRemove$_(this._$_captureListeners$_, t)) : this._$_listenersSet$_.has(t) && (this._$_listenersSet$_.delete(t), 
                    C33._$arrayFindRemove$_(this._$_listeners$_, t));
                }
                _$_IsEmpty$_() {
                    return !this._$_captureListeners$_.length && !this._$_listeners$_.length;
                }
                _$_IsFiring$_() {
                    return 0 < this._$_fireDepth$_;
                }
                _$_ProcessQueuedListeners$_() {
                    const t = new Set(), e = new Set();
                    for (const s of this._$_queueModifyListeners$_) if ("add" === s._$op$_) this._$_AddListener$_(s._$func$_, s.capture), 
                    (s.capture ? e : t).delete(s._$func$_); else {
                        if ("remove" !== s._$op$_) throw new Error("invalid op");
                        (s.capture ? (this._$_captureListenersSet$_.delete(s._$func$_), 
                        e) : (this._$_listenersSet$_.delete(s._$func$_), t)).add(s._$func$_);
                    }
                    C33._$arrayRemoveAllInSet$_(this._$_listeners$_, t), C33._$arrayRemoveAllInSet$_(this._$_captureListeners$_, e), 
                    C33._$clearArray$_(this._$_queueModifyListeners$_);
                }
                _$_FireCancellable$_(s) {
                    this._$_IncreaseFireDepth$_();
                    let i = !1;
                    for (let t = 0, e = this._$_captureListeners$_.length; t < e; ++t) if (this._$_captureListeners$_[t](s), 
                    s._$propagationStopped$_) {
                        i = !0;
                        break;
                    }
                    if (!i) for (let t = 0, e = this._$_listeners$_.length; t < e && (this._$_listeners$_[t](s), 
                    !s._$propagationStopped$_); ++t);
                    return this._$_DecreaseFireDepth$_(), !s.defaultPrevented;
                }
                _$_FireNonCancellable$_(s) {
                    this._$_IncreaseFireDepth$_();
                    for (let t = 0, e = this._$_captureListeners$_.length; t < e; ++t) this._$_captureListeners$_[t](s);
                    for (let t = 0, e = this._$_listeners$_.length; t < e; ++t) this._$_listeners$_[t](s);
                    return this._$_DecreaseFireDepth$_(), !0;
                }
                _$_IncreaseFireDepth$_() {
                    this._$_fireDepth$_++;
                }
                _$_DecreaseFireDepth$_() {
                    this._$_fireDepth$_--, 0 === this._$_fireDepth$_ && 0 < this._$_queueModifyListeners$_.length && this._$_ProcessQueuedListeners$_();
                }
                _$SetDelayRemoveEventsEnabled$_(t) {
                    t ? this._$_IncreaseFireDepth$_() : this._$_DecreaseFireDepth$_();
                }
                _$_FireAsync$_(s) {
                    let i = [];
                    for (let e = 0, t = this._$_captureListeners$_.length; e < t; ++e) {
                        let t = this._$_captureListeners$_[e];
                        i.push(C33._$Asyncify$_(() => t(s)));
                    }
                    for (let e = 0, t = this._$_listeners$_.length; e < t; ++e) {
                        let t = this._$_listeners$_[e];
                        i.push(C33._$Asyncify$_(() => t(s)));
                    }
                    return Promise.all(i).then(() => !s.defaultPrevented);
                }
                _$_FireAndWait_AsyncOptional$_(s) {
                    const i = [];
                    this._$_IncreaseFireDepth$_();
                    for (let t = 0, e = this._$_captureListeners$_.length; t < e; ++t) {
                        const r = this._$_captureListeners$_[t](s);
                        r instanceof Promise && i.push(r);
                    }
                    for (let t = 0, e = this._$_listeners$_.length; t < e; ++t) {
                        const n = this._$_listeners$_[t](s);
                        n instanceof Promise && i.push(n);
                    }
                    return this._$_DecreaseFireDepth$_(), i.length ? Promise.all(i).then(() => !s.defaultPrevented) : !s.defaultPrevented;
                }
                async _$_FireAndWaitAsync$_(t) {
                    return this._$_FireAndWait_AsyncOptional$_(t);
                }
                async _$_FireAndWaitAsyncSequential$_(s) {
                    this._$_IncreaseFireDepth$_();
                    for (let t = 0, e = this._$_captureListeners$_.length; t < e; ++t) {
                        const i = this._$_captureListeners$_[t](s);
                        i instanceof Promise && await i;
                    }
                    for (let t = 0, e = this._$_listeners$_.length; t < e; ++t) {
                        const r = this._$_listeners$_[t](s);
                        r instanceof Promise && await r;
                    }
                    return this._$_DecreaseFireDepth$_(), !s.defaultPrevented;
                }
                *_$_FireAsGenerator$_(s) {
                    this._$_IncreaseFireDepth$_();
                    for (let t = 0, e = this._$_captureListeners$_.length; t < e; ++t) {
                        const i = this._$_captureListeners$_[t](s);
                        C33._$IsIterator$_(i) && (yield* i);
                    }
                    for (let t = 0, e = this._$_listeners$_.length; t < e; ++t) {
                        const r = this._$_listeners$_[t](s);
                        C33._$IsIterator$_(r) && (yield* r);
                    }
                    this._$_DecreaseFireDepth$_();
                }
            };
        }
        {
            const C33 = self._$C3$_;
            C33.Event._$Dispatcher$_ = class extends C33._$DefendedBase$_ {
                constructor() {
                    super(), this._$_eventHandlers$_ = new Map(), this._$_dispatcherWasReleased$_ = !1;
                }
                _$Release$_() {
                    if (this._$_dispatcherWasReleased$_) throw new Error("already released");
                    this._$ClearEvents$_(), this._$_dispatcherWasReleased$_ = !0, 
                    C33._$Release$_(this);
                }
                _$WasReleased$_() {
                    return this._$_dispatcherWasReleased$_;
                }
                _$ClearEvents$_() {
                    if (this._$_eventHandlers$_) {
                        for (let t of this._$_eventHandlers$_.values()) t._$Release$_();
                        this._$_eventHandlers$_.clear();
                    }
                }
                _$_GetHandlerByType$_(t, e) {
                    let s = this._$_eventHandlers$_.get(t);
                    return s || (e ? (s = C33._$New$_(C33.Event._$Handler$_, t), 
                    this._$_eventHandlers$_.set(t, s), s) : null);
                }
                _$HasAnyHandlerFor$_(t) {
                    return this._$_eventHandlers$_.has(t);
                }
                addEventListener(t, e, s) {
                    let i = this._$_GetHandlerByType$_(t, !0);
                    i._$_AddListener$_(e, !!s);
                }
                removeEventListener(t, e, s) {
                    let i = this._$_GetHandlerByType$_(t, !1);
                    i && (i._$_RemoveListener$_(e, !!s), i._$_IsEmpty$_()) && this._$_eventHandlers$_.delete(t);
                }
                dispatchEvent(t) {
                    const e = this._$_GetHandlerByType$_(t.type, !1);
                    return !e || (t.cancelable ? e._$_FireCancellable$_(t) : e._$_FireNonCancellable$_(t));
                }
                _$dispatchEventAsync$_(t) {
                    const e = this._$_GetHandlerByType$_(t.type, !1);
                    return e ? (t._$isAsync$_ = !0, e._$_FireAsync$_(t)) : Promise.resolve(!0);
                }
                async _$dispatchEventAndClearAsync$_(t) {
                    const e = this._$_GetHandlerByType$_(t.type, !1);
                    if (!e) return !0;
                    this._$_eventHandlers$_.delete(t.type), t._$isAsync$_ = !0;
                    const s = await e._$_FireAsync$_(t);
                    return e._$Release$_(), s;
                }
                async _$dispatchEventAndWaitAsync$_(t) {
                    const e = this._$_GetHandlerByType$_(t.type, !1);
                    return !e || e._$_FireAndWaitAsync$_(t);
                }
                _$dispatchEventAndWait_AsyncOptional$_(t) {
                    const e = this._$_GetHandlerByType$_(t.type, !1);
                    return !e || e._$_FireAndWait_AsyncOptional$_(t);
                }
                async _$dispatchEventAndWaitAsyncSequential$_(t) {
                    const e = this._$_GetHandlerByType$_(t.type, !1);
                    return !e || e._$_FireAndWaitAsyncSequential$_(t);
                }
                _$dispatchGeneratorEvent$_(t) {
                    const e = this._$_GetHandlerByType$_(t.type, !1);
                    if (!e) return null;
                    if (t.cancelable) throw new Error("not supported");
                    return e._$_FireAsGenerator$_(t);
                }
                _$SetDelayRemoveEventsEnabled$_(t) {
                    for (const e of this._$_eventHandlers$_.values()) e._$SetDelayRemoveEventsEnabled$_(t);
                }
            };
        }
        {
            let SetNewCallback2 = function(t) {
                callbackId = SUPPORTS_RIC && 0 === highThroughputMode ? requestIdleCallback(DoAsyncifiedWork2, {
                    timeout: IDLECALLBACK_TIMEOUT
                }) : setTimeout(DoAsyncifiedWork2, 0 < highThroughputMode ? 1 : t);
            }, DoAsyncifiedWork2 = function(r) {
                if (callbackId = -1, workQueue.length) {
                    let s = performance.now(), i = s, t = 0, e;
                    for (;DoNextAsyncifiedJob2(workQueue.shift()), i = performance.now(), 
                    ++t, e = (i - s) / t * 1.1, workQueue.length && (SUPPORTS_RIC && 0 === highThroughputMode && void 0 !== r ? e < r.timeRemaining() : i - s + e < SETTIMEOUT_WORK_DURATION); );
                    if (-1 === callbackId && workQueue.length) {
                        let t = i - s, e = Math.max(SETTIMEOUT_INTERVAL - t, 4);
                        SetNewCallback2(e);
                    }
                }
            }, DoNextAsyncifiedJob2 = function(e) {
                let t;
                try {
                    t = e._$func$_();
                } catch (t) {
                    return void e.reject(t);
                }
                e.resolve(t);
            }, C33 = (SetNewCallback = SetNewCallback2, DoAsyncifiedWork = DoAsyncifiedWork2, 
            DoNextAsyncifiedJob = DoNextAsyncifiedJob2, self._$C3$_), SETTIMEOUT_WORK_DURATION = 12, SETTIMEOUT_INTERVAL = 16, IDLECALLBACK_TIMEOUT = 35, SUPPORTS_RIC = "undefined" != typeof requestIdleCallback, workQueue = [], callbackId = -1, highThroughputMode = 0, asyncifyDisabled = C33._$QueryString$_._$Has$_("disable-asyncify");
            asyncifyDisabled && console.warn("[Asyncify] Asyncify has been disabled due to disable-asyncify in the query string. Some work will now be done synchronously."), 
            C33._$Asyncify$_ = function(s) {
                let i = null;
                return C33.isDebug && (i = C33._$GetCallStack$_()), new Promise((t, e) => {
                    workQueue.push({
                        _$func$_: s,
                        resolve: t,
                        reject: e,
                        stack: i
                    }), asyncifyDisabled ? DoNextAsyncifiedJob2(workQueue.pop()) : -1 === callbackId && SetNewCallback2(SETTIMEOUT_INTERVAL);
                });
            }, C33._$Asyncify$_._$SetHighThroughputMode$_ = function(t) {
                if (t) ++highThroughputMode; else if (--highThroughputMode < 0) throw new Error("already turned off high throughput mode");
            };
        }
        {
            let ClearTimeCache2 = function() {
                cachedNowTime = -1;
            }, CheckActiveIdleTimeouts2 = function() {
                timerId = -1, nextDeadline = -1;
                let s = Date.now();
                for (let e of activeIdleTimeouts) if (e._$_CheckTimeout$_(s)) {
                    let t = e._$_GetDeadline$_();
                    (-1 === nextDeadline || t < nextDeadline) && (nextDeadline = t);
                } else activeIdleTimeouts.delete(e);
                if (-1 !== nextDeadline) {
                    let t = Math.max(nextDeadline - s + IDLE_CHECK_TIMER_OVERSHOOT, IDLE_CHECK_MIN_INTERVAL);
                    timerId = self.setTimeout(CheckActiveIdleTimeouts2, t);
                }
            }, C33 = (ClearTimeCache = ClearTimeCache2, CheckActiveIdleTimeouts = CheckActiveIdleTimeouts2, 
            self._$C3$_), IDLE_CHECK_MIN_INTERVAL = 1e3, IDLE_CHECK_TIMER_OVERSHOOT = 100, cachedNowTime = -1, timerId = (C33._$FastGetDateNow$_ = function() {
                return -1 === cachedNowTime && (cachedNowTime = Date.now(), self.setTimeout(ClearTimeCache2, 16)), 
                cachedNowTime;
            }, -1), nextDeadline = -1, activeIdleTimeouts = new Set();
            C33._$IdleTimeout$_ = class {
                constructor(t, e) {
                    this._$_callback$_ = t, this._$_timeout$_ = 1e3 * e, this._$_deadline$_ = 0, 
                    this._$_isActive$_ = !1;
                }
                _$Reset$_() {
                    let t = C33._$FastGetDateNow$_();
                    this._$_deadline$_ = t + this._$_timeout$_, this._$_isActive$_ || (activeIdleTimeouts.add(this), 
                    this._$_isActive$_ = !0), -1 === timerId ? (nextDeadline = this._$_deadline$_, 
                    timerId = self.setTimeout(CheckActiveIdleTimeouts2, this._$_timeout$_ + IDLE_CHECK_TIMER_OVERSHOOT)) : this._$_deadline$_ < nextDeadline && nextDeadline > t + IDLE_CHECK_MIN_INTERVAL && (self.clearTimeout(timerId), 
                    nextDeadline = this._$_deadline$_, timerId = self.setTimeout(CheckActiveIdleTimeouts2, this._$_timeout$_ + IDLE_CHECK_TIMER_OVERSHOOT));
                }
                _$_CheckTimeout$_(t) {
                    return !(t >= this._$_deadline$_) || (this._$_callback$_() ? (this._$_deadline$_ = t + this._$_timeout$_, 
                    !0) : this._$_isActive$_ = !1);
                }
                _$_GetDeadline$_() {
                    return this._$_deadline$_;
                }
                _$Cancel$_() {
                    this._$_isActive$_ && (activeIdleTimeouts.delete(this), this._$_isActive$_ = !1, 
                    0 === activeIdleTimeouts.size) && -1 !== timerId && (self.clearTimeout(timerId), 
                    timerId = -1, nextDeadline = -1);
                }
                _$Release$_() {
                    this._$Cancel$_(), this._$_callback$_ = null;
                }
            };
        }
        {
            const C33 = self._$C3$_;
            C33._$Disposable$_ = class a {
                constructor(t) {
                    this._$_disposed$_ = !1, this._$_disposeAction$_ = t;
                }
                _$Dispose$_() {
                    this._$_disposed$_ || (this._$_disposed$_ = !0, this._$_disposeAction$_ && (this._$_disposeAction$_(), 
                    this._$_disposeAction$_ = null));
                }
                _$IsDisposed$_() {
                    return this._$_disposed$_;
                }
                _$Release$_() {
                    this._$Dispose$_();
                }
                static _$Release$_(t) {
                    return new a(() => t._$Release$_());
                }
                static _$From$_(e, s, i, r, t) {
                    if (null == r) r = !1; else if ("boolean" != typeof r && "object" != typeof r) throw new TypeError("invalid event listener options");
                    if (t && (i = i.bind(t)), s.includes(" ")) {
                        s = s.split(" ");
                        const n = new C33._$CompositeDisposable$_();
                        for (let t of s) e.addEventListener(t, i, r), n._$Add$_(C33._$New$_(C33._$Disposable$_, () => e.removeEventListener(t, i, r)));
                        return n;
                    }
                    return e.addEventListener(s, i, r), C33._$New$_(C33._$Disposable$_, () => e.removeEventListener(s, i, r));
                }
            }, C33._$StubDisposable$_ = class extends C33._$Disposable$_ {
                _$SetAction$_(t) {
                    this._$_disposeAction$_ = t;
                }
            }, C33._$CompositeDisposable$_ = class extends C33._$Disposable$_ {
                constructor(...e) {
                    super(), this._$_disposables$_ = new Set();
                    for (let t of e) this._$Add$_(t);
                }
                _$Add$_(...e) {
                    if (this._$_disposed$_) throw new Error("already disposed");
                    for (let t of e) this._$_disposables$_.add(t);
                }
                _$Remove$_(t) {
                    if (this._$_disposed$_) throw new Error("already disposed");
                    this._$_disposables$_.delete(t);
                }
                _$RemoveAll$_() {
                    if (this._$_disposed$_) throw new Error("already disposed");
                    if (this._$_disposables$_) {
                        for (let t of this._$_disposables$_) t._$Dispose$_();
                        this._$_disposables$_.clear();
                    }
                }
                _$IsDisposed$_() {
                    return this._$_disposed$_;
                }
                _$Dispose$_() {
                    if (this._$_disposed$_) throw new Error("already disposed");
                    this._$_disposed$_ = !0;
                    for (let t of this._$_disposables$_) t._$Dispose$_();
                    this._$_disposables$_.clear(), this._$_disposables$_ = null;
                }
                _$Release$_() {
                    this._$Dispose$_();
                }
            };
        }
        {
            const C33 = self._$C3$_;
            C33._$KahanSum$_ = class extends C33._$DefendedBase$_ {
                constructor() {
                    super(), this._$_c$_ = 0, this._$_y$_ = 0, this._$_t$_ = 0, 
                    this._$_sum$_ = 0;
                }
                _$Add$_(t) {
                    this._$_y$_ = (t = +t) - this._$_c$_, this._$_t$_ = this._$_sum$_ + this._$_y$_, 
                    this._$_c$_ = this._$_t$_ - this._$_sum$_ - this._$_y$_, this._$_sum$_ = this._$_t$_;
                }
                _$Subtract$_(t) {
                    this._$_sum$_ -= +t;
                }
                _$Get$_() {
                    return this._$_sum$_;
                }
                _$Reset$_() {
                    this._$_c$_ = 0, this._$_y$_ = 0, this._$_t$_ = 0, this._$_sum$_ = 0;
                }
                Set(t) {
                    this._$_c$_ = 0, this._$_y$_ = 0, this._$_t$_ = 0, this._$_sum$_ = +t;
                }
                _$Copy$_(t) {
                    this._$_c$_ = t._$_c$_, this._$_y$_ = t._$_y$_, this._$_t$_ = t._$_t$_, 
                    this._$_sum$_ = t._$_sum$_;
                }
                _$Release$_() {}
            };
        }
        {
            const C33 = self._$C3$_, js_cols = {}, RED = !0, BLACK = !1;
            js_cols._$RBnode$_ = function(t) {
                this._$tree$_ = t, this.right = this._$tree$_._$sentinel$_, this.left = this._$tree$_._$sentinel$_, 
                this.parent = null, this.color = !1, this.key = null;
            }, js_cols._$RedBlackSet$_ = function(t) {
                this.size = 0, this._$sentinel$_ = new js_cols._$RBnode$_(this), 
                this._$sentinel$_.color = BLACK, this.root = this._$sentinel$_, 
                this.root.parent = this._$sentinel$_, this.compare = t || this._$default_compare$_;
            }, js_cols._$RedBlackSet$_.prototype._$default_compare$_ = function(t, e) {
                return t < e ? -1 : e < t ? 1 : 0;
            }, js_cols._$RedBlackSet$_.prototype.clone = function() {
                var t = new js_cols._$RedBlackSet$_(this.compare);
                return t._$insertAll$_(this), t;
            }, js_cols._$RedBlackSet$_.prototype.clear = function() {
                this.size = 0, this._$sentinel$_ = new js_cols._$RBnode$_(this), 
                this._$sentinel$_.color = BLACK, this.root = this._$sentinel$_, 
                this.root.parent = this._$sentinel$_;
            }, js_cols._$RedBlackSet$_.prototype._$leftRotate$_ = function(t) {
                var e = t.right;
                t.right = e.left, e.left != this._$sentinel$_ && (e.left.parent = t), 
                e.parent = t.parent, t.parent == this._$sentinel$_ ? this.root = e : t == t.parent.left ? t.parent.left = e : t.parent.right = e, 
                (e.left = t).parent = e;
            }, js_cols._$RedBlackSet$_.prototype._$rightRotate$_ = function(t) {
                var e = t.left;
                t.left = e.right, e.right != this._$sentinel$_ && (e.right.parent = t), 
                e.parent = t.parent, t.parent == this._$sentinel$_ ? this.root = e : t == t.parent.right ? t.parent.right = e : t.parent.left = e, 
                (e.right = t).parent = e;
            }, js_cols._$RedBlackSet$_.prototype._$insert$_ = function(t) {
                if (this.contains(t)) this._$get_$_(t).key = t; else {
                    for (var e = new js_cols._$RBnode$_(this), s = (e.key = t, this._$sentinel$_), i = this.root; i != this._$sentinel$_; ) s = i, 
                    i = this.compare(e.key, i.key) < 0 ? i.left : i.right;
                    (e.parent = s) == this._$sentinel$_ ? this.root = e : this.compare(e.key, s.key) < 0 ? s.left = e : s.right = e, 
                    e.left = this._$sentinel$_, e.right = this._$sentinel$_, e.color = RED, 
                    this._$insertFixup$_(e), this.size++;
                }
            }, js_cols._$RedBlackSet$_.prototype._$insertFixup$_ = function(t) {
                for (;t != this._$sentinel$_ && t != this.root && t.parent.color == RED; ) {
                    var e;
                    t.parent == t.parent.parent.left ? (e = t.parent.parent.right).color == RED ? (t.parent.color = BLACK, 
                    e.color = BLACK, t.parent.parent.color = RED, t = t.parent.parent) : (t == t.parent.right && (t = t.parent, 
                    this._$leftRotate$_(t)), t.parent.color = BLACK, t.parent.parent.color = RED, 
                    t.parent.parent != this._$sentinel$_ && this._$rightRotate$_(t.parent.parent)) : (e = t.parent.parent.left).color == RED ? (t.parent.color = BLACK, 
                    e.color = BLACK, t.parent.parent.color = RED, t = t.parent.parent) : (t == t.parent.left && (t = t.parent, 
                    this._$rightRotate$_(t)), t.parent.color = BLACK, t.parent.parent.color = RED, 
                    t.parent.parent != this._$sentinel$_ && this._$leftRotate$_(t.parent.parent));
                }
                this.root.color = BLACK;
            }, js_cols._$RedBlackSet$_.prototype._$delete_$_ = function(t) {
                var e = t.left == this._$sentinel$_ || t.right == this._$sentinel$_ ? t : this._$successor_$_(t), s = e.left != this._$sentinel$_ ? e.left : e.right;
                s.parent = e.parent, e.parent == this._$sentinel$_ ? this.root = s : e == e.parent.left ? e.parent.left = s : e.parent.right = s, 
                e != t && (t.key = e.key), e.color == BLACK && this._$deleteFixup$_(s), 
                this.size--;
            }, js_cols._$RedBlackSet$_.prototype._$deleteFixup$_ = function(t) {
                for (;t != this.root && t.color == BLACK; ) {
                    var e;
                    t = t == t.parent.left ? ((e = t.parent.right).color == RED && (e.color = BLACK, 
                    t.parent.color = RED, this._$leftRotate$_(t.parent), e = t.parent.right), 
                    e.left.color == BLACK && e.right.color == BLACK ? (e.color = RED, 
                    t.parent) : (e.right.color == BLACK && (e.left.color = BLACK, 
                    e.color = RED, this._$rightRotate$_(e), e = t.parent.right), 
                    e.color = t.parent.color, t.parent.color = BLACK, e.right.color = BLACK, 
                    this._$leftRotate$_(t.parent), this.root)) : ((e = t.parent.left).color == RED && (e.color = BLACK, 
                    t.parent.color = RED, this._$rightRotate$_(t.parent), e = t.parent.left), 
                    e.right.color == BLACK && e.left.color == BLACK ? (e.color = RED, 
                    t.parent) : (e.left.color == BLACK && (e.right.color = BLACK, 
                    e.color = RED, this._$leftRotate$_(e), e = t.parent.left), e.color = t.parent.color, 
                    t.parent.color = BLACK, e.left.color = BLACK, this._$rightRotate$_(t.parent), 
                    this.root));
                }
                t.color = BLACK;
            }, js_cols._$RedBlackSet$_.prototype.remove = function(t) {
                var e;
                return (t = this._$get_$_(t)) != this._$sentinel$_ ? (e = t.key, 
                this._$delete_$_(t), e) : null;
            }, js_cols._$RedBlackSet$_.prototype._$removeSwapped$_ = function(t, e) {
                this.remove(e);
            }, js_cols._$RedBlackSet$_.prototype.min = function(t) {
                for (;t.left != this._$sentinel$_; ) t = t.left;
                return t;
            }, js_cols._$RedBlackSet$_.prototype.max = function(t) {
                for (;t.right != this._$sentinel$_; ) t = t.right;
                return t;
            }, js_cols._$RedBlackSet$_.prototype._$successor_$_ = function(t) {
                if (t.right != this._$sentinel$_) return this.min(t.right);
                for (var e = t.parent; e != this._$sentinel$_ && t == e.right; ) e = (t = e).parent;
                return e;
            }, js_cols._$RedBlackSet$_.prototype._$predeccessor_$_ = function(t) {
                if (t.left != this._$sentinel$_) return this.max(t.left);
                for (var e = t.parent; e != this._$sentinel$_ && t == e.left; ) e = (t = e).parent;
                return e;
            }, js_cols._$RedBlackSet$_.prototype._$successor$_ = function(t) {
                if (0 < this.size) {
                    var e = this._$get_$_(t);
                    if (e == this._$sentinel$_) return null;
                    if (e.right != this._$sentinel$_) return this.min(e.right).key;
                    for (var s = e.parent; s != this._$sentinel$_ && e == s.right; ) s = (e = s).parent;
                    return s != this._$sentinel$_ ? s.key : null;
                }
                return null;
            }, js_cols._$RedBlackSet$_.prototype._$predecessor$_ = function(t) {
                if (0 < this.size) {
                    var e = this._$get_$_(t);
                    if (e == this._$sentinel$_) return null;
                    if (e.left != this._$sentinel$_) return this.max(e.left).key;
                    for (var s = e.parent; s != this._$sentinel$_ && e == s.left; ) s = (e = s).parent;
                    return s != this._$sentinel$_ ? s.key : null;
                }
                return null;
            }, js_cols._$RedBlackSet$_.prototype._$getMin$_ = function() {
                return this.min(this.root).key;
            }, js_cols._$RedBlackSet$_.prototype._$getMax$_ = function() {
                return this.max(this.root).key;
            }, js_cols._$RedBlackSet$_.prototype._$get_$_ = function(t) {
                for (var e = this.root; e != this._$sentinel$_ && 0 != this.compare(e.key, t); ) e = this.compare(t, e.key) < 0 ? e.left : e.right;
                return e;
            }, js_cols._$RedBlackSet$_.prototype.contains = function(t) {
                return null != this._$get_$_(t).key;
            }, js_cols._$RedBlackSet$_.prototype.getValues = function() {
                var e = [];
                return this.forEach(function(t) {
                    e.push(t);
                }), e;
            }, js_cols._$RedBlackSet$_.prototype._$insertAll$_ = function(t) {
                if ("array" == js_cols.typeOf(t)) for (var e = 0; e < t.length; e++) this._$insert$_(t[e]); else if ("function" == js_cols.typeOf(t.forEach)) t.forEach(this._$insert$_, this); else if ("function" == js_cols.typeOf(t.getValues)) for (var s = t.getValues(), e = 0; e < s.length; e++) this._$insert$_(s[e]); else if ("object" == js_cols.typeOf(t)) for (var i in t) this._$insert$_(t[i]);
            }, js_cols._$RedBlackSet$_.prototype._$removeAll$_ = function(t) {
                if ("array" == js_cols.typeOf(t)) for (var e = 0; e < t.length; e++) this.remove(t[e]); else if ("function" == js_cols.typeOf(t.forEach)) t.forEach(this._$removeSwapped$_, this); else if ("function" == js_cols.typeOf(t.getValues)) for (var s = t.getValues(), e = 0; e < s.length; e++) this.remove(s[e]); else if ("object" == js_cols.typeOf(t)) for (var i in t) this.remove(t[i]);
            }, js_cols._$RedBlackSet$_.prototype._$containsAll$_ = function(t) {
                if ("array" == js_cols.typeOf(t)) {
                    for (var e = 0; e < t.length; e++) if (!this.contains(t[e])) return !1;
                    return !0;
                }
                if ("function" == js_cols.typeOf(t.forEach)) return t.every(this.contains, this);
                if ("function" == js_cols.typeOf(t.getValues)) {
                    for (var s = t.getValues(), e = 0; e < s.length; e++) if (!this.contains(s[e])) return !1;
                    return !0;
                }
                if ("object" == js_cols.typeOf(t)) {
                    for (var i in t) if (!this.contains(t[i])) return !1;
                    return !0;
                }
            }, js_cols._$RedBlackSet$_.prototype.range = function(t, e) {
                var s = [];
                return this._$traverseFromTo$_(function(t) {
                    s.push(t);
                }, t, e), s;
            }, js_cols._$RedBlackSet$_.prototype._$traverse$_ = function(t, e) {
                if (!this._$isEmpty$_()) for (var s = this.min(this.root); s != this._$sentinel$_; ) {
                    if (t.call(e, s.key, this)) return;
                    s = this._$successor_$_(s);
                }
            }, js_cols._$RedBlackSet$_.prototype._$traverseFrom$_ = function(t, e, s) {
                if (!this._$isEmpty$_()) for (var i = this._$get_$_(e); i != this._$sentinel$_; ) {
                    if (t.call(s, i.key, this)) return;
                    i = this._$successor_$_(i);
                }
            }, js_cols._$RedBlackSet$_.prototype._$traverseTo$_ = function(t, e, s) {
                if (!this._$isEmpty$_()) for (var i = this.min(this.root), r = this._$get_$_(e); i != r; ) {
                    if (t.call(s, i.key, this)) return;
                    i = this._$successor_$_(i);
                }
            }, js_cols._$RedBlackSet$_.prototype._$traverseFromTo$_ = function(t, e, s, i) {
                if (!this._$isEmpty$_()) for (var r = this._$get_$_(e), n = this._$get_$_(s); r != n; ) {
                    if (t.call(i, r.key, this)) return;
                    r = this._$successor_$_(r);
                }
            }, js_cols._$RedBlackSet$_.prototype._$traverseBackwards$_ = function(t, e) {
                if (!this._$isEmpty$_()) for (var s = this.max(this.root); s != this._$sentinel$_; ) {
                    if (t.call(e, s.key, this)) return;
                    s = this._$predeccessor_$_(s);
                }
            }, js_cols._$RedBlackSet$_.prototype.forEach = function(t, e) {
                if (!this._$isEmpty$_()) for (var s = this.min(this.root); s != this._$sentinel$_; s = this._$successor_$_(s)) t.call(e, s.key, s.key, this);
            }, js_cols._$RedBlackSet$_.prototype.some = function(t, e) {
                if (!this._$isEmpty$_()) for (var s = this.min(this.root); s != this._$sentinel$_; s = this._$successor_$_(s)) if (t.call(e, s.key, s.key, this)) return !0;
                return !1;
            }, js_cols._$RedBlackSet$_.prototype.every = function(t, e) {
                if (this._$isEmpty$_()) return !1;
                for (var s = this.min(this.root); s != this._$sentinel$_; s = this._$successor_$_(s)) if (!t.call(e, s.key, s.key, this)) return !1;
                return !0;
            }, js_cols._$RedBlackSet$_.prototype.map = function(t, e) {
                var s = [];
                if (!this._$isEmpty$_()) for (var i = this.min(this.root); i != this._$sentinel$_; i = this._$successor_$_(i)) s.push(t.call(e, i.key, i.key, this));
                return s;
            }, js_cols._$RedBlackSet$_.prototype.filter = function(t, e) {
                var s = [];
                if (!this._$isEmpty$_()) for (var i = this.min(this.root); i != this._$sentinel$_; i = this._$successor_$_(i)) t.call(e, i.key, i.key, this) && s.push(i.key);
                return s;
            }, js_cols._$RedBlackSet$_.prototype.getCount = function() {
                return this.size;
            }, js_cols._$RedBlackSet$_.prototype._$isEmpty$_ = function() {
                return 0 == this.size;
            }, js_cols._$RedBlackSet$_.prototype._$isSubsetOf$_ = function(t) {
                var e = js_cols.getCount(t);
                if (this.getCount() > e) return !1;
                var s = 0;
                if (this._$isEmpty$_()) return !0;
                for (var i = this.min(this.root); i != this._$sentinel$_; i = this._$successor_$_(i)) js_cols.contains.call(t, t, i.key) && s++;
                return s == this.getCount();
            }, js_cols._$RedBlackSet$_.prototype._$intersection$_ = function(t) {
                var e = new js_cols._$RedBlackSet$_(this.compare);
                if (!this._$isEmpty$_()) for (var s = this.min(this.root); s != this._$sentinel$_; s = this._$successor_$_(s)) t.contains.call(t, s.key, s.key, this) && e._$insert$_(s.key);
                return e;
            }, C33._$RedBlackSet$_ = class extends C33._$DefendedBase$_ {
                constructor(t) {
                    super(), this._$_rbSet$_ = new js_cols._$RedBlackSet$_(t), this._$_enableQueue$_ = !1, 
                    this._$_queueInsert$_ = new Set(), this._$_queueRemove$_ = new Set();
                }
                _$Add$_(t) {
                    this._$_enableQueue$_ ? this._$_rbSet$_.contains(t) ? this._$_queueRemove$_.delete(t) : this._$_queueInsert$_.add(t) : this._$_rbSet$_._$insert$_(t);
                }
                _$Remove$_(t) {
                    this._$_enableQueue$_ ? this._$_rbSet$_.contains(t) ? this._$_queueRemove$_.add(t) : this._$_queueInsert$_.delete(t) : this._$_rbSet$_.remove(t);
                }
                _$Has$_(t) {
                    return this._$_enableQueue$_ ? !!this._$_queueInsert$_.has(t) || !this._$_queueRemove$_.has(t) && this._$_rbSet$_.contains(t) : this._$_rbSet$_.contains(t);
                }
                _$Clear$_() {
                    this._$_rbSet$_.clear(), this._$_queueInsert$_.clear(), this._$_queueRemove$_.clear();
                }
                toArray() {
                    if (this._$_enableQueue$_) throw new Error("cannot be used in queueing mode");
                    return this._$_rbSet$_.getValues();
                }
                _$GetSize$_() {
                    return this._$_rbSet$_.getCount() + this._$_queueInsert$_.size - this._$_queueRemove$_.size;
                }
                _$IsEmpty$_() {
                    return 0 === this._$GetSize$_();
                }
                _$Front$_() {
                    if (this._$IsEmpty$_()) throw new Error("empty set");
                    if (this._$_enableQueue$_) throw new Error("cannot be used in queueing mode");
                    const t = this._$_rbSet$_, e = t.min(t.root);
                    return e.key;
                }
                _$Shift$_() {
                    if (this._$IsEmpty$_()) throw new Error("empty set");
                    if (this._$_enableQueue$_) throw new Error("cannot be used in queueing mode");
                    const t = this._$Front$_();
                    return this._$Remove$_(t), t;
                }
                _$SetQueueingEnabled$_(t) {
                    if (this._$_enableQueue$_ !== (t = !!t) && !(this._$_enableQueue$_ = t)) {
                        for (const e of this._$_queueRemove$_) this._$_rbSet$_.remove(e);
                        this._$_queueRemove$_.clear();
                        for (const s of this._$_queueInsert$_) this._$_rbSet$_._$insert$_(s);
                        this._$_queueInsert$_.clear();
                    }
                }
                _$ForEach$_(t) {
                    this._$_rbSet$_.forEach(t);
                }
                *values() {
                    if (!this._$IsEmpty$_()) {
                        const e = this._$_rbSet$_;
                        for (let t = e.min(e.root); t != e._$sentinel$_; t = e._$successor_$_(t)) yield t.key;
                    }
                }
                [Symbol.iterator]() {
                    return this.values();
                }
            };
        }
        {
            const C33 = self._$C3$_;
            C33._$PromiseThrottle$_ = class {
                constructor(t = C33.hardwareConcurrency) {
                    this._$_maxParallel$_ = t, this._$_queue$_ = [], this._$_activeCount$_ = 0;
                }
                _$Add$_(s) {
                    return new Promise((t, e) => {
                        this._$_queue$_.push({
                            _$func$_: s,
                            resolve: t,
                            reject: e
                        }), this._$_MaybeStartNext$_();
                    });
                }
                _$_FindInQueue$_(s) {
                    for (let t = 0, e = this._$_queue$_.length; t < e; ++t) if (this._$_queue$_[t]._$func$_ === s) return t;
                    return -1;
                }
                _$RemoveAndResolve$_(t, e) {
                    const s = this._$_FindInQueue$_(t);
                    if (-1 === s) throw new Error("cannot find promise to resolve");
                    this._$_queue$_[s].resolve(e), this._$_queue$_.splice(s, 1);
                }
                _$RemoveAndReject$_(t, e) {
                    const s = this._$_FindInQueue$_(t);
                    if (-1 === s) throw new Error("cannot find promise to reject");
                    this._$_queue$_[s].reject(e), this._$_queue$_.splice(s, 1);
                }
                async _$_MaybeStartNext$_() {
                    if (this._$_queue$_.length && !(this._$_activeCount$_ >= this._$_maxParallel$_)) {
                        this._$_activeCount$_++;
                        const e = this._$_queue$_.shift();
                        try {
                            const t = await e._$func$_();
                            e.resolve(t);
                        } catch (t) {
                            e.reject(t);
                        }
                        this._$_activeCount$_--, this._$_MaybeStartNext$_();
                    }
                }
                static async _$Batch$_(t, e) {
                    let s = [], i = !1, r = [];
                    for (;t--; ) r.push((async () => {
                        let t;
                        for (;t = e.pop(); ) {
                            if (i) return;
                            try {
                                s.push(await t());
                            } catch (t) {
                                throw i = !0, t;
                            }
                        }
                    })());
                    return await Promise.all(r), s;
                }
            };
        }
        {
            const C33 = self._$C3$_;
            C33._$RateLimiter$_ = class {
                constructor(t, e, s) {
                    this._$_callback$_ = t, this._$_interval$_ = e, this._$_intervalOnBattery$_ = s || 2 * e, 
                    this._$_timerId$_ = -1, this._$_lastCallTime$_ = -1 / 0, this._$_timerCallFunc$_ = () => this._$_OnTimer$_(), 
                    this._$_ignoreReset$_ = !1, this._$_canRunImmediate$_ = !1, 
                    this._$_callbackArguments$_ = null;
                }
                _$SetCanRunImmediate$_(t) {
                    this._$_canRunImmediate$_ = !!t;
                }
                _$_GetInterval$_() {
                    return void 0 !== C33.Battery && C33.Battery.IsOnBatteryPower() ? this._$_intervalOnBattery$_ : this._$_interval$_;
                }
                _$Call$_(...i) {
                    if (-1 === this._$_timerId$_) {
                        this._$_callbackArguments$_ = i;
                        let t = C33._$FastGetDateNow$_(), e = t - this._$_lastCallTime$_, s = this._$_GetInterval$_();
                        s <= e && this._$_canRunImmediate$_ ? (this._$_lastCallTime$_ = t, 
                        this._$_RunCallback$_()) : this._$_timerId$_ = self.setTimeout(this._$_timerCallFunc$_, Math.max(s - e, 4));
                    }
                }
                _$_RunCallback$_() {
                    this._$_ignoreReset$_ = !0;
                    const t = this._$_callbackArguments$_;
                    this._$_callbackArguments$_ = null, t ? this._$_callback$_(...t) : this._$_callback$_(), 
                    this._$_ignoreReset$_ = !1;
                }
                _$Reset$_() {
                    this._$_ignoreReset$_ || (this._$_CancelTimer$_(), this._$_callbackArguments$_ = null, 
                    this._$_lastCallTime$_ = C33._$FastGetDateNow$_());
                }
                _$_OnTimer$_() {
                    this._$_timerId$_ = -1, this._$_lastCallTime$_ = C33._$FastGetDateNow$_(), 
                    this._$_RunCallback$_();
                }
                _$_CancelTimer$_() {
                    -1 !== this._$_timerId$_ && (self.clearTimeout(this._$_timerId$_), 
                    this._$_timerId$_ = -1);
                }
                _$Release$_() {
                    this._$_CancelTimer$_(), this._$_callback$_ = null, this._$_callbackArguments$_ = null, 
                    this._$_timerCallFunc$_ = null;
                }
            };
        }
        {
            const C33 = self._$C3$_;
            C33._$SVGRasterManager$_ = class {
                constructor() {
                    this._$_images$_ = new Map(), this._$_allowNpotSurfaces$_ = !1, 
                    this._$_getBaseSizeCallback$_ = null, this._$_rasterAtSizeCallback$_ = null, 
                    this._$_releaseResultCallback$_ = null, this._$_redrawCallback$_ = null;
                }
                _$SetNpotSurfaceAllowed$_(t) {
                    this._$_allowNpotSurfaces$_ = !!t;
                }
                _$IsNpotSurfaceAllowed$_() {
                    return this._$_allowNpotSurfaces$_;
                }
                _$SetGetBaseSizeCallback$_(t) {
                    this._$_getBaseSizeCallback$_ = t;
                }
                _$GetBaseSize$_(t) {
                    if (this._$_getBaseSizeCallback$_) return this._$_getBaseSizeCallback$_(t);
                    throw new Error("no get base size callback set");
                }
                _$SetRasterAtSizeCallback$_(t) {
                    this._$_rasterAtSizeCallback$_ = t;
                }
                _$RasterAtSize$_(t, e, s, i, r, n) {
                    if (this._$_rasterAtSizeCallback$_) return this._$_rasterAtSizeCallback$_(t, e, s, i, r, n);
                    throw new Error("no raster at size callback set");
                }
                _$SetReleaseResultCallback$_(t) {
                    this._$_releaseResultCallback$_ = t;
                }
                _$ReleaseResult$_(t) {
                    if (!this._$_releaseResultCallback$_) throw new Error("no release result callback set");
                    this._$_releaseResultCallback$_(t);
                }
                _$SetRedrawCallback$_(t) {
                    this._$_redrawCallback$_ = t;
                }
                _$Redraw$_() {
                    if (!this._$_redrawCallback$_) throw new Error("no redraw callback set");
                    this._$_redrawCallback$_();
                }
                _$AddImage$_(t) {
                    let e = this._$_images$_.get(t);
                    return e || (e = C33._$New$_(C33._$SVGRasterImage$_, this, t), 
                    this._$_images$_.set(t, e)), e._$IncReference$_(), e;
                }
                _$_RemoveImage$_(t) {
                    this._$_images$_.delete(t._$GetDataSource$_());
                }
                _$OnTexturesChanged$_() {
                    for (const t of this._$_images$_.values()) t._$ReleaseRasterizedResult$_(), 
                    t._$ForceRasterAgain$_();
                }
            };
        }
        {
            const C33 = self._$C3$_, MAX_SURFACE_SIZE = 4096;
            C33._$SVGRasterImage$_ = class {
                constructor(t, e) {
                    this._$_manager$_ = t, this._$_dataSource$_ = e, this._$_refCount$_ = 0, 
                    this._$_baseWidth$_ = 0, this._$_baseHeight$_ = 0, this._$_getBaseSizePromise$_ = this._$_manager$_._$GetBaseSize$_(e).then(t => {
                        this._$_manager$_ && (this._$_baseWidth$_ = t[0], this._$_baseHeight$_ = t[1], 
                        this._$_manager$_._$Redraw$_());
                    }).catch(t => {
                        console.error("[SVG] Error loading SVG: ", t), this._$_hadError$_ = !0, 
                        this._$_manager$_ && this._$_manager$_._$Redraw$_();
                    }), this._$_rasterSurfaceWidth$_ = 0, this._$_rasterSurfaceHeight$_ = 0, 
                    this._$_rasterImageWidth$_ = 0, this._$_rasterImageHeight$_ = 0, 
                    this._$_isRasterizing$_ = !1, this._$_rasterizedResult$_ = null, 
                    this._$_forceRaster$_ = !1, this._$_hadError$_ = !1;
                }
                _$Release$_() {
                    if (this._$_refCount$_ <= 0) throw new Error("already released");
                    this._$_refCount$_--, 0 === this._$_refCount$_ && this._$_Release$_();
                }
                _$ReleaseRasterizedResult$_() {
                    this._$_rasterizedResult$_ && (this._$_manager$_._$ReleaseResult$_(this._$_rasterizedResult$_), 
                    this._$_rasterizedResult$_ = null);
                }
                _$_Release$_() {
                    this._$ReleaseRasterizedResult$_(), this._$_manager$_._$_RemoveImage$_(this), 
                    this._$_manager$_ = null;
                }
                _$GetDataSource$_() {
                    return this._$_dataSource$_;
                }
                _$IncReference$_() {
                    this._$_refCount$_++;
                }
                _$HasReferences$_() {
                    return 0 < this._$_refCount$_;
                }
                _$GetRasterizedResult$_() {
                    return this._$_rasterizedResult$_;
                }
                _$ForceRasterAgain$_() {
                    this._$_forceRaster$_ = !0;
                }
                async _$StartRasterForSize$_(i, r, n) {
                    if (0 !== r && 0 !== n && !this._$_hadError$_ && !this._$_isRasterizing$_) {
                        let t = C33._$nextHighestPowerOfTwo$_(Math.ceil(r)), e = C33._$nextHighestPowerOfTwo$_(Math.ceil(n)), s = Math.max(t, e);
                        if (s > MAX_SURFACE_SIZE) {
                            const h = MAX_SURFACE_SIZE / s;
                            r *= h, n *= h, t = Math.min(Math.ceil(t * h), MAX_SURFACE_SIZE), 
                            e = Math.min(Math.ceil(e * h), MAX_SURFACE_SIZE);
                        }
                        if (r < t && n < e) {
                            const o = r / n, a = t / e;
                            n = o < a ? (r = e * o, e) : (r = t) / o;
                        }
                        if (this._$_manager$_._$IsNpotSurfaceAllowed$_() && (t = Math.ceil(r), 
                        e = Math.ceil(n)), !(t <= this._$_rasterSurfaceWidth$_ && e <= this._$_rasterSurfaceHeight$_) || this._$_forceRaster$_) {
                            this._$_isRasterizing$_ = !0, this._$_rasterSurfaceWidth$_ = t, 
                            this._$_rasterSurfaceHeight$_ = e;
                            const l = await this._$_manager$_._$RasterAtSize$_(this._$_dataSource$_, i, this._$_rasterSurfaceWidth$_, this._$_rasterSurfaceHeight$_, r, n);
                            this._$_manager$_ && (this._$ReleaseRasterizedResult$_(), 
                            this._$_rasterizedResult$_ = l, this._$_rasterImageWidth$_ = r, 
                            this._$_rasterImageHeight$_ = n, this._$_isRasterizing$_ = !1, 
                            this._$_forceRaster$_ = !1, this._$_manager$_._$Redraw$_());
                        }
                    }
                }
                _$WhenBaseSizeReady$_() {
                    return this._$_getBaseSizePromise$_;
                }
                _$GetBaseWidth$_() {
                    return this._$_baseWidth$_;
                }
                _$GetBaseHeight$_() {
                    return this._$_baseHeight$_;
                }
                _$GetRasterWidth$_() {
                    return this._$_rasterImageWidth$_;
                }
                _$GetRasterHeight$_() {
                    return this._$_rasterImageHeight$_;
                }
                _$HadError$_() {
                    return this._$_hadError$_;
                }
            };
        }
        {
            let lookupHtmlEntity2 = function(t) {
                return HTML_ENTITY_MAP.get(t);
            };
            lookupHtmlEntity = lookupHtmlEntity2;
            const C33 = self._$C3$_, NUMERIC_CHARS = (C33._$UTF8_BOM$_ = "\ufeff", 
            new Set("0123456789")), WHITESPACE_CHARS = (C33._$IsNumericChar$_ = function(t) {
                return NUMERIC_CHARS.has(t);
            }, new Set(" \t\n\r\u2028\u2029"));
            C33._$IsWhitespaceChar$_ = function(t) {
                return WHITESPACE_CHARS.has(t);
            }, C33._$FilterWhitespace$_ = function(t) {
                return [ ...t ].filter(t => !C33._$IsWhitespaceChar$_(t)).join("");
            }, C33._$IsStringAllWhitespace$_ = function(t) {
                for (const e of t) if (!C33._$IsWhitespaceChar$_(e)) return !1;
                return !0;
            }, C33._$IsCharArrayAllWhitespace$_ = function(t) {
                for (const e of t) if (!C33._$IsWhitespaceChar$_(e)) return !1;
                return !0;
            }, C33._$IsUnprintableChar$_ = function(t) {
                return 1 === t.length && t.charCodeAt(0) < 32;
            }, C33._$FilterUnprintableChars$_ = function(t) {
                return [ ...t ].filter(t => !C33._$IsUnprintableChar$_(t)).join("");
            };
            let cjkPunctuationRegex = null;
            try {
                cjkPunctuationRegex = new RegExp("\\p{P}(?<=[\\u3000-\\u303F\\uFF00-\\uFFEF])", "u");
            } catch (t) {
                console.warn("Unable to detect CJK punctuation: ", t);
            }
            C33._$IsCJKPunctuationChar$_ = function(t) {
                return !C33._$IsWhitespaceChar$_(t) && cjkPunctuationRegex && cjkPunctuationRegex.test(t);
            };
            const NUMERIC_STRING_CHARS = new Set("0123456789.+-e"), HTML_ENTITY_MAP = (C33._$IsStringNumber$_ = function(e) {
                if (!(e = e.trim()).length) return !1;
                let t = e.charAt(0);
                if ("-" !== t && !NUMERIC_CHARS.has(t)) return !1;
                for (let t of e) if (!NUMERIC_STRING_CHARS.has(t)) return !1;
                return !0;
            }, C33._$RemoveTrailingDigits$_ = function(e) {
                let s = e.length;
                for (;0 < s; ) {
                    let t = e.charAt(s - 1);
                    if (!C33._$IsNumericChar$_(t)) break;
                    --s;
                }
                return e.substr(0, s);
            }, C33._$IncrementNumberAtEndOf$_ = function(t) {
                let e = C33._$RemoveTrailingDigits$_(t), s = t.substr(e.length);
                return e + (s ? (parseInt(s, 10) + 1).toString() : "2");
            }, new Map([ [ "&", "&amp;" ], [ "<", "&lt;" ], [ ">", "&gt;" ], [ '"', "&quot;" ], [ "'", "&#39;" ] ])), HTML_ENTITY_REGEX = /[&<>"']/g, ESCAPE_REGEX = (C33._$EscapeHTML$_ = function(t) {
                return t.replace(HTML_ENTITY_REGEX, lookupHtmlEntity2);
            }, C33._$EscapeJS$_ = function(t) {
                let e = C33._$ReplaceAll$_(t, "\\", "\\\\");
                return e = C33._$ReplaceAll$_(e, '"', '\\"'), e = C33._$ReplaceAll$_(e, "\t", "\\t"), 
                e = C33._$ReplaceAll$_(e, "\r", ""), C33._$ReplaceAll$_(e, "\n", "\\n");
            }, C33._$EscapeXML$_ = function(t) {
                let e = C33._$ReplaceAll$_(t, "&", "&amp;");
                return e = C33._$ReplaceAll$_(e, "<", "&lt;"), e = C33._$ReplaceAll$_(e, ">", "&gt;"), 
                C33._$ReplaceAll$_(e, '"', "&quot;");
            }, /[-[\]{}()*+?.,\\^$|#\s]/g), intlSegmenter = (C33._$EscapeRegex$_ = function(t) {
                return t.replace(ESCAPE_REGEX, "\\$&");
            }, C33._$CountCharsInString$_ = function(t, e) {
                let s = 0;
                for (const i of t) i === e && ++s;
                return s;
            }, C33._$FindAll$_ = function(t, e, s = !1) {
                if (!e) return [];
                s || (t = t.toLowerCase(), e = e.toLowerCase());
                let i = e.length, r = 0, n, h = [];
                for (;-1 < (n = t.indexOf(e, r)); ) h.push(n), r = n + i;
                return h;
            }, C33._$ReplaceAll$_ = function(t, e, s) {
                return t.replaceAll(e, () => s);
            }, C33._$ReplaceAllCaseInsensitive$_ = function(t, e, s) {
                return t.replace(new RegExp(C33._$EscapeRegex$_(e), "gi"), () => s);
            }, C33._$SetElementContent$_ = function(t, e) {
                "string" == typeof e ? t.textContent = e : e._$isPlainText$_() ? t.textContent = e.toString() : (t.innerHTML = e._$toHTML$_(), 
                e instanceof C33._$BBString$_ && e._$attachLinkHandlers$_(t));
            }, C33._$StringLikeEquals$_ = function(t, e) {
                return t instanceof C33.HtmlString || t instanceof C33._$BBString$_ ? t.equals(e) : e instanceof C33.HtmlString || e instanceof C33._$BBString$_ ? e.equals(t) : t === e;
            }, C33._$StringSubstitute$_ = function(s, ...i) {
                let r = s;
                for (let t = 0, e = i.length; t < e; ++t) {
                    const n = `{${t}}`;
                    if (!s.includes(n)) throw new Error(`missing placeholder '${n}' in string substitution`);
                    r = r.replace(n, i[t].toString());
                }
                return r;
            }, C33._$StringSubstituteAllowMissing$_ = function(s, ...i) {
                let r = s, n = -1, h = -1;
                for (let t = 0, e = i.length; t < e; ++t) {
                    const o = `{${t}}`;
                    s.includes(o) ? (h = t, r = r.replace(o, i[t].toString())) : -1 === n && (n = t);
                }
                if (0 <= n && 0 <= h && n < h) throw new Error(`missing placeholder '${n}' in string substitution`);
                return r;
            }, C33._$StringSubstituteMap$_ = function(t, s) {
                let i = t;
                for (let [ t, e ] of Object.entries(s)) i = i.replaceAll(t, e.toString());
                return i;
            }, C33._$SortAZ$_ = function(t, e) {
                return e < t ? 1 : t < e ? -1 : 0;
            }, C33._$SortAZCaseInsensitive$_ = function(t, e) {
                let s = t.toLowerCase(), i = e.toLowerCase();
                return i < s ? 1 : s < i ? -1 : 0;
            }, new self.Intl.Segmenter()), KILOBYTE = (C33._$SplitGraphemes$_ = function(t) {
                const e = [];
                for (const s of intlSegmenter.segment(t)) e.push(s.segment);
                return e;
            }, C33._$IterateGraphemes$_ = function*(t) {
                for (const e of intlSegmenter.segment(t)) yield e.segment;
            }, C33._$CountGraphemes$_ = function(t) {
                let e = 0;
                for (const s of intlSegmenter.segment(t)) ++e;
                return e;
            }, 1024), MEGABYTE = 1024 * KILOBYTE, GIGABYTE = 1024 * MEGABYTE, TERABYTE = 1024 * GIGABYTE, DEFAULT_FORMATTIME_OPTS = {
                _$approximate$_: (C33._$FormatDataSize$_ = function(e, t) {
                    let s = "common." + (t ? "dataRates" : "dataSizes") + ".", i = self.langSub;
                    if (e < KILOBYTE) return i(s + "bytes", e);
                    if (e < MEGABYTE) {
                        let t = e / KILOBYTE;
                        return t = t < 10 ? Math.round(10 * t) / 10 : Math.round(t), 
                        i(s + "kilobytes", t);
                    }
                    if (e < GIGABYTE) {
                        let t = e / MEGABYTE;
                        return t = t < 10 ? Math.round(10 * t) / 10 : Math.round(t), 
                        i(s + "megabytes", t);
                    }
                    if (e < TERABYTE) {
                        let t = e / GIGABYTE;
                        return t = t < 10 ? Math.round(10 * t) / 10 : Math.round(t), 
                        i(s + "gigabytes", t);
                    }
                    {
                        let t = e / TERABYTE;
                        return t = t < 10 ? Math.round(10 * t) / 10 : Math.round(t), 
                        i(s + "terabytes", t);
                    }
                }, !1),
                _$days$_: !0,
                _$hours$_: !0,
                _$minutes$_: !0,
                _$seconds$_: !0
            };
            C33._$FormatTime$_ = function(t, e) {
                e = Object.assign({}, DEFAULT_FORMATTIME_OPTS, e), C33.Lang.PushContext("common.time");
                const s = [], i = self.lang, r = self.langPluralSub;
                if (e._$days$_) {
                    const h = Math.floor(t / 86400);
                    0 < h && (t -= 24 * h * 3600, s.push(r(".days", null, h)));
                }
                if (e._$hours$_) {
                    const o = Math.floor(t / 3600);
                    (0 < o || s.length) && (t -= 3600 * o, s.push(r(".hours", null, o)));
                }
                if (e._$minutes$_) {
                    const a = Math.floor(t / 60);
                    (0 < a || s.length || !e._$seconds$_) && (t -= 60 * a, s.push(r(".minutes", null, a)));
                }
                if (e._$seconds$_) {
                    const l = Math.floor(t % 60);
                    s.push(r(".seconds", null, l));
                }
                const n = (e._$approximate$_ ? i(".approx-prefix") : "") + s.join(i(".separator"));
                return C33.Lang.PopContext(), n;
            }, C33._$ZeroPad$_ = function(t, e) {
                let s = t < 0 ? "-" : "", i = (t = Math.abs(t)).toString(), r = e - i.length;
                for (let t = 0; t < r; ++t) s += "0";
                return s + i;
            }, C33._$StringToTitleCase$_ = function(t) {
                return t.toLowerCase().replace(/\b\w/g, t => t.toUpperCase());
            }, C33._$CompareVersionStrings$_ = function(t, e) {
                let s = t.split(".").map(t => t.trim()), i = e.split(".").map(t => t.trim());
                C33._$resizeArray$_(s, 4, "0"), C33._$resizeArray$_(i, 4, "0"), 
                s = s.map(t => parseInt(t, 10)), i = i.map(t => parseInt(t, 10));
                for (let t = 0; t < 4; ++t) {
                    const r = s[t] - i[t];
                    if (0 != r) return r < 0 ? -1 : 1;
                }
                return 0;
            }, C33._$CreateGUID$_ = function() {
                return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, t => {
                    const e = Math.floor(16 * Math.random()), s = "x" === t ? e : 3 & e | 8;
                    return s.toString(16);
                });
            }, C33._$StringHammingDistance$_ = function(s, i) {
                if (s.length !== i.length) throw new Error("strings must be same length");
                let r = 0;
                for (let t = 0, e = s.length; t < e; ++t) s.charAt(t) !== i.charAt(t) && ++r;
                return r;
            }, C33._$StringLevenshteinDistance$_ = function(t, e) {
                if (0 === t.length) return e.length;
                if (0 === e.length) return t.length;
                let s, i, r, n, h, o;
                for (e.length < t.length && (s = t, t = e, e = s), o = Array(t.length + 1), 
                i = 0; i <= t.length; i++) o[i] = i;
                for (i = 1; i <= e.length; i++) {
                    for (n = i, r = 1; r <= t.length; r++) h = e[i - 1] === t[r - 1] ? o[r - 1] : Math.min(o[r - 1] + 1, Math.min(n + 1, o[r] + 1)), 
                    o[r - 1] = n, n = h;
                    o[t.length] = n;
                }
                return o[t.length];
            };
        }
        {
            let bbToHtmlReplacerFunc2 = function(t, s, i) {
                const r = BB_CODE_MAP.get(i);
                if (!r) return "class" === i ? s ? "</span>" : `<span class="bbclass${classIndex++}">` : t;
                if ("string" == typeof r) {
                    if ("a" === r && 0 === linkActions.length || "abbr" === r && 0 === tipList.length) return t;
                    if ("a" !== r || s) {
                        if ("abbr" !== r || s) return "<" + s + r + ">";
                        {
                            const n = parseInt(i.substring(3), 10) - 1;
                            if (n < 0 || n >= tipList.length) throw new Error("invalid bbcode tip substitution");
                            let t = tipList[n], e = "";
                            if ("string" == typeof t ? e = t : "function" == typeof t && (e = t()), 
                            "string" != typeof e) throw new TypeError("invalid bbcode tip");
                            return `<abbr title="${C33._$ReplaceAll$_(e, '"', "&quot;")}">`;
                        }
                    }
                    {
                        const e = parseInt(i.substring(1), 10) - 1;
                        if (e < 0 || e >= linkActions.length) throw new Error("invalid bbcode link substitution");
                        const h = linkActions[e];
                        if ("string" == typeof h) return `<a href="${linkActions[e]}">`;
                        if ("function" == typeof h) return `<a class="bblink${e}">`;
                        throw new TypeError("invalid bbcode link action");
                    }
                }
                if (Array.isArray(r)) {
                    let t = r[0], e = r[1];
                    return s ? "</" + t + ">" : `<${t} class="${e}">`;
                }
            }, C33 = (bbToHtmlReplacerFunc = bbToHtmlReplacerFunc2, self._$C3$_), assert = self.assert, BB_CODE_MAP = new Map([ [ "b", "strong" ], [ "i", "em" ], [ "s", "s" ], [ "u", "u" ], [ "sub", "sub" ], [ "sup", "sup" ], [ "small", "small" ], [ "mark", "mark" ], [ "code", "code" ], [ "a1", "a" ], [ "a2", "a" ], [ "a3", "a" ], [ "a4", "a" ], [ "a5", "a" ], [ "a6", "a" ], [ "a7", "a" ], [ "a8", "a" ], [ "a9", "a" ], [ "tip1", "abbr" ], [ "tip2", "abbr" ], [ "tip3", "abbr" ], [ "tip4", "abbr" ], [ "tip5", "abbr" ], [ "tip6", "abbr" ], [ "tip7", "abbr" ], [ "tip8", "abbr" ], [ "tip9", "abbr" ], [ "bad", [ "span", "bbCodeBad" ] ], [ "good", [ "span", "bbCodeGood" ] ], [ "info", [ "span", "bbCodeInfo" ] ], [ "h1", [ "span", "bbCodeH1" ] ], [ "h2", [ "span", "bbCodeH2" ] ], [ "h3", [ "span", "bbCodeH3" ] ], [ "h4", [ "span", "bbCodeH4" ] ], [ "item", [ "span", "bbCodeItem" ] ] ]), SELF_CLOSING_TAGS = new Set([ "icon" ]), BBREGEX = /\[(\/?)([a-zA-Z0-9]+)\]/g, CUSTOM_BBREGEX = /\[(\/?)([^\[\n]*?)\]/g, linkActions = null, tipList = null, classIndex = 0, LINEBREAK_REGEX = /\n/g;
            C33._$BBString$_ = class {
                constructor(t, e) {
                    if (this._$_bbstr$_ = e && e._$noEscape$_ ? t : C33._$EscapeHTML$_(t), 
                    this._$_htmlstr$_ = "", this._$_convertLineBreaks$_ = !1, this._$_linkActions$_ = [], 
                    this._$_tipList$_ = [], e) {
                        if (this._$_convertLineBreaks$_ = !!e.convertLineBreaks, 
                        e.links) {
                            if (9 < e.links.length) throw new Error("too many links");
                            this._$_linkActions$_ = e.links;
                        }
                        if (e.tips) {
                            if (9 < e.tips.length) throw new Error("too many tips");
                            this._$_tipList$_ = e.tips;
                        }
                    }
                    this._$_hasAnyBBtags$_ = this._$_bbstr$_.includes("["), this._$_needsLineBreakConversion$_ = this._$_convertLineBreaks$_ && this._$_bbstr$_.includes("\n"), 
                    this._$_isPlain$_ = !this._$_hasAnyBBtags$_ && !this._$_needsLineBreakConversion$_ && !this._$_bbstr$_.includes("&"), 
                    this._$_hasParsedFragments$_ = !1, this._$_fragments$_ = [];
                }
                toString() {
                    return this._$_bbstr$_;
                }
                valueOf() {
                    return this._$_bbstr$_;
                }
                _$isPlainText$_() {
                    return this._$_isPlain$_;
                }
                _$toPlainText$_() {
                    return this._$_hasAnyBBtags$_ ? this._$_bbstr$_.replace(BBREGEX, "") : this._$_bbstr$_;
                }
                _$toHTML$_() {
                    if (this._$_isPlain$_) return this._$_bbstr$_;
                    if (!this._$_htmlstr$_ && this._$_bbstr$_) {
                        let t = this._$_bbstr$_;
                        this._$_hasAnyBBtags$_ && (classIndex = 0, linkActions = this._$_linkActions$_, 
                        tipList = this._$_tipList$_, t = t.replace(BBREGEX, bbToHtmlReplacerFunc2), 
                        linkActions = null, tipList = null), this._$_needsLineBreakConversion$_ && (t = t.replace(LINEBREAK_REGEX, "<br>")), 
                        this._$_htmlstr$_ = t;
                    }
                    return this._$_htmlstr$_;
                }
                _$attachLinkHandlers$_(s) {
                    if (this._$_linkActions$_.length) for (let t = 0, e = this._$_linkActions$_.length; t < e; ++t) {
                        const i = this._$_linkActions$_[t];
                        if ("function" == typeof i) {
                            const r = s.querySelector(".bblink" + t);
                            if (!r) throw new Error("unable to attach BBString link handler");
                            r.onclick = i;
                        }
                    }
                }
                equals(t) {
                    return t instanceof C33.HtmlString ? this._$toHTML$_() === t._$toHTML$_() : t instanceof C33._$BBString$_ ? this._$_bbstr$_ === t._$_bbstr$_ : this._$_bbstr$_ === t;
                }
                _$toFragmentList$_() {
                    if (!this._$_hasParsedFragments$_) {
                        let i = [], t = this._$_bbstr$_, r = [], e = CUSTOM_BBREGEX.lastIndex = 0, s;
                        for (;null !== (s = CUSTOM_BBREGEX.exec(t)); ) {
                            const n = s.index;
                            if (!(0 < n && "\\" === t.charAt(n - 1))) {
                                const h = s[0], o = s[1], a = s[2], l = t.substring(e, n);
                                if (e = n + h.length, l && i.push({
                                    text: l,
                                    _$styles$_: r.slice(0)
                                }), a) if (o) {
                                    const u = a.toLowerCase();
                                    for (let t = r.length - 1; 0 <= t; --t) if (r[t].tag === u) {
                                        r.splice(t, 1);
                                        break;
                                    }
                                } else {
                                    let t = a, e = null, s = a.indexOf("=");
                                    if (-1 !== s ? (t = a.substring(0, s).toLowerCase(), 
                                    e = a.substring(s + 1)) : t = t.toLowerCase(), 
                                    SELF_CLOSING_TAGS.has(t)) {
                                        if ("icon" !== t) throw new Error("unknown self-closing tag " + t);
                                        i.push({
                                            icon: e,
                                            _$styles$_: r.slice(0)
                                        });
                                    } else r.push({
                                        tag: t,
                                        param: e
                                    });
                                }
                            }
                        }
                        e < t.length && i.push({
                            text: t.substring(e),
                            _$styles$_: r.slice(0)
                        });
                        for (const c of i) c.text && (c.text = this._$_ProcessBBCodeEscapeSequences$_(c.text));
                        this._$_fragments$_ = i.map(t => t.icon ? C33._$New$_(C33._$IconFragment$_, {
                            icon: t.icon,
                            _$styles$_: t._$styles$_
                        }) : C33._$New$_(C33._$TextFragment$_, {
                            _$chArr$_: C33._$SplitGraphemes$_(t.text),
                            _$styles$_: t._$styles$_
                        })), this._$_hasParsedFragments$_ = !0;
                    }
                    return this._$_fragments$_;
                }
                _$_ProcessBBCodeEscapeSequences$_(t) {
                    return t = C33._$ReplaceAll$_(t, "\\[", "["), C33._$ReplaceAll$_(t, "\\\\", "\\");
                }
                static _$StripTags$_(t) {
                    return C33._$New$_(C33._$BBString$_, t, {
                        _$noEscape$_: !0
                    })._$toPlainText$_();
                }
                static _$StripAnyTags$_(t) {
                    return t.replace(CUSTOM_BBREGEX, "");
                }
            };
        }
        {
            let IsWordBreakWhiteSpace2 = function(t) {
                return "" !== t && "" !== t && C33._$IsWhitespaceChar$_(t);
            }, IsOpeningCJKPunctiationChar2 = function(t) {
                return CJK_OPEN_PUNCTUATION.has(t);
            }, IsContinuingCJKPunctuationChar2 = function(t) {
                return C33._$IsCJKPunctuationChar$_(t) && !IsOpeningCJKPunctiationChar2(t);
            }, WordBreakTrimEnd2 = function(t) {
                for (;0 < t.length && IsWordBreakWhiteSpace2(t.at(-1)); ) t.pop();
            }, IsNewline2 = function(t) {
                return "\n" === t || "\r\n" === t;
            };
            IsWordBreakWhiteSpace = IsWordBreakWhiteSpace2, IsOpeningCJKPunctiationChar = IsOpeningCJKPunctiationChar2, 
            IsContinuingCJKPunctuationChar = IsContinuingCJKPunctuationChar2, WordBreakTrimEnd = WordBreakTrimEnd2, 
            IsNewline = IsNewline2;
            const C33 = self._$C3$_, CJK_OPEN_PUNCTUATION = new Set("");
            C33._$WordWrap$_ = class {
                constructor() {
                    this._$_lines$_ = [], this._$_iconSet$_ = null;
                }
                _$GetLines$_() {
                    return this._$_lines$_;
                }
                _$GetLineCount$_() {
                    return this._$_lines$_.length;
                }
                _$SetIconSet$_(t) {
                    this._$_iconSet$_ = t;
                }
                _$_MeasureLine$_(t, e) {
                    let s = 0, i = 0, r = 0, n = 0, h = 0;
                    for (const o of t) {
                        if (-1 === o._$GetWidth$_()) {
                            const a = e(o);
                            o._$SetHeight$_(a.height), o._$SetFontBoundingBoxAscent$_(a.fontBoundingBoxAscent || 0), 
                            o._$SetFontBoundingBoxDescent$_(a.fontBoundingBoxDescent || 0), 
                            o._$SetTopToAlphabeticDistance$_(a._$topToAlphabeticDistance$_ || 0), 
                            o._$IsText$_() ? o._$SetWidth$_(a.width) : o._$IsIcon$_() && o._$CalculateWidthFromHeight$_(this._$_iconSet$_);
                        }
                        s += o._$GetWidth$_(), i = Math.max(i, o._$GetHeight$_()), 
                        r = Math.max(r, o._$GetFontBoundingBoxAscent$_()), n = Math.max(n, o._$GetFontBoundingBoxDescent$_()), 
                        h = Math.max(h, o._$GetTopToAlphabeticDistance$_());
                    }
                    return {
                        width: s,
                        height: i,
                        fontBoundingBoxAscent: r,
                        fontBoundingBoxDescent: n,
                        _$topToAlphabeticDistance$_: h
                    };
                }
                _$_AddLine$_(t, e, s, i, r, n) {
                    this._$_lines$_.push(C33._$New$_(C33._$WordWrap$_._$Line$_, {
                        _$fragments$_: t,
                        width: e,
                        height: s,
                        fontBoundingBoxAscent: i,
                        fontBoundingBoxDescent: r,
                        _$topToAlphabeticDistance$_: n
                    }));
                }
                _$WordWrap$_(e, n, h, s, o) {
                    if ("string" == typeof e && (e = [ C33._$New$_(C33._$TextFragment$_, {
                        _$chArr$_: C33._$SplitGraphemes$_(e)
                    }) ]), C33._$clearArray$_(this._$_lines$_), !(!e.length || 1 === e.length && e[0]._$IsText$_() && e[0]._$IsEmpty$_() || h < 2)) {
                        if (1 === e.length) {
                            const a = e[0];
                            if (a._$IsText$_() && a._$GetLength$_() <= 100 && !a._$HasNewLine$_()) {
                                let {
                                    width: t,
                                    height: e,
                                    fontBoundingBoxAscent: s,
                                    fontBoundingBoxDescent: i,
                                    _$topToAlphabeticDistance$_: r
                                } = n(a);
                                if (t += o, a._$SetWidth$_(t), a._$SetHeight$_(e), 
                                a._$SetFontBoundingBoxAscent$_(s || 0), a._$SetFontBoundingBoxDescent$_(i || 0), 
                                a._$SetTopToAlphabeticDistance$_(r || 0), t <= h) return void this._$_AddLine$_([ a ], t, e, s, i, r);
                            }
                        }
                        let t;
                        t = "word" === s ? this._$_TokeniseByWord$_(e) : "cjk" === s ? this._$_TokeniseByCJK$_(e) : this._$_TokeniseByChar$_(e), 
                        this._$_WrapText$_(t, n, h, o);
                    }
                }
                _$_TokeniseByWord$_(t) {
                    let e = [], s = [], i = !1;
                    for (const r of t) {
                        const n = r._$GetStyles$_();
                        if (r._$IsIcon$_()) 0 < s.length && e.push(s), e.push([ r ]), 
                        s = []; else for (const h of r._$GetCharacterArray$_()) if (IsNewline2(h)) 0 < s.length && e.push(s), 
                        e.push([ C33._$New$_(C33._$TextFragment$_, {
                            _$chArr$_: [ "\n" ],
                            _$styles$_: n
                        }) ]), s = []; else if (0 === s.length) s.push(C33._$New$_(C33._$TextFragment$_, {
                            _$chArr$_: [ h ],
                            _$styles$_: n
                        })), i = IsWordBreakWhiteSpace2(h); else {
                            const o = IsWordBreakWhiteSpace2(h);
                            if (o === i) {
                                const a = s.at(-1);
                                a._$GetStyles$_() === n ? a._$_AppendChar$_(h) : s.push(C33._$New$_(C33._$TextFragment$_, {
                                    _$chArr$_: [ h ],
                                    _$styles$_: n
                                }));
                            } else e.push(s), s = [ C33._$New$_(C33._$TextFragment$_, {
                                _$chArr$_: [ h ],
                                _$styles$_: n
                            }) ], i = o;
                        }
                    }
                    return 0 < s.length && e.push(s), e;
                }
                _$_TokeniseByCJK$_(t) {
                    let e = [], s = [], i = !1;
                    for (const r of t) {
                        const n = r._$GetStyles$_();
                        if (r._$IsIcon$_()) 0 < s.length && e.push(s), e.push([ r ]), 
                        s = []; else for (const h of r._$GetCharacterArray$_()) if (IsNewline2(h)) 0 < s.length && e.push(s), 
                        e.push([ C33._$New$_(C33._$TextFragment$_, {
                            _$chArr$_: [ "\n" ],
                            _$styles$_: n
                        }) ]), s = []; else {
                            if (0 === s.length) s.push(C33._$New$_(C33._$TextFragment$_, {
                                _$chArr$_: [ h ],
                                _$styles$_: n
                            })); else if (i || IsContinuingCJKPunctuationChar2(h)) {
                                const o = s.at(-1);
                                o._$GetStyles$_() === n ? o._$_AppendChar$_(h) : s.push(C33._$New$_(C33._$TextFragment$_, {
                                    _$chArr$_: [ h ],
                                    _$styles$_: n
                                }));
                            } else e.push(s), s = [ C33._$New$_(C33._$TextFragment$_, {
                                _$chArr$_: [ h ],
                                _$styles$_: n
                            }) ];
                            i = IsOpeningCJKPunctiationChar2(h);
                        }
                    }
                    return 0 < s.length && e.push(s), e;
                }
                _$_TokeniseByChar$_(t) {
                    const e = [];
                    for (const s of t) if (s._$IsText$_()) {
                        const i = s._$GetCharacterArray$_();
                        C33._$appendArray$_(e, i.map(t => [ C33._$New$_(C33._$TextFragment$_, {
                            _$chArr$_: [ t ],
                            _$styles$_: s._$GetStyles$_()
                        }) ]));
                    } else e.push([ s ]);
                    return e;
                }
                _$_CopyLine$_(t) {
                    return t.map(t => t._$_Clone$_());
                }
                _$_AddWordToLine$_(e, s) {
                    let t = e.length ? e.at(-1) : null, i = 0;
                    t && t._$IsText$_() && s[0]._$IsText$_() && s[0]._$GetStyles$_() === t._$GetStyles$_() && (t._$_Append$_(s[0]._$GetCharacterArray$_()), 
                    i = 1);
                    for (let t = s.length; i < t; ++i) {
                        const r = s[i];
                        e.push(r._$_Clone$_());
                    }
                }
                _$_WrapText$_(t, e, s, i) {
                    let r = [], n = 0, h = 0, o = 0, a = 0, l = 0;
                    for (const u of t) if (1 === u.length && u[0]._$IsText$_() && 1 === u[0]._$GetLength$_() && IsNewline2(u[0]._$GetCharacterArray$_()[0])) {
                        if (0 === h) {
                            const c = C33._$New$_(C33._$TextFragment$_, {
                                _$chArr$_: [ " " ],
                                _$styles$_: u[0]._$GetStyles$_()
                            }), f = e(c);
                            h = f.height, o = f.fontBoundingBoxAscent || 0, a = f.fontBoundingBoxDescent || 0, 
                            l = f._$topToAlphabeticDistance$_ || 0;
                        }
                        this._$_AddLine$_(r, n, h, o, a, l), r = [], n = 0, h = 0, 
                        o = 0, a = 0, l = 0;
                    } else {
                        const d = this._$_CopyLine$_(r), p = (this._$_AddWordToLine$_(d, u), 
                        this._$_MeasureLine$_(d, e)), m = p.width;
                        if (s <= m) if (0 < r.length && this._$_AddLine$_(r, n, h, o, a, l), 
                        r = [], u[0]._$IsText$_() && C33._$IsCharArrayAllWhitespace$_(u[0]._$GetCharacterArray$_())) n = 0, 
                        h = 0, o = 0, a = 0, l = 0; else {
                            this._$_AddWordToLine$_(r, u);
                            const C = this._$_MeasureLine$_(r, e);
                            n = C.width, h = C.height, o = C.fontBoundingBoxAscent, 
                            a = C.fontBoundingBoxDescent, l = C._$topToAlphabeticDistance$_;
                        } else r = d, n = m, h = p.height, o = p.fontBoundingBoxAscent, 
                        a = p.fontBoundingBoxDescent, l = p._$topToAlphabeticDistance$_;
                    }
                    0 < r.length && this._$_AddLine$_(r, n, h, o, a, l), this._$_TrimLinesTrailingWhitespace$_(e, i);
                }
                _$_TrimLinesTrailingWhitespace$_(e, s) {
                    for (const i of this._$_lines$_) {
                        const r = i._$_GetFragmentsArray$_();
                        if (r.length) {
                            let t = r.at(-1);
                            if (t._$IsText$_()) {
                                const n = t._$GetCharacterArray$_(), h = n.slice(0);
                                if (WordBreakTrimEnd2(h), 0 === h.length) i._$OffsetWidth$_(-t._$GetWidth$_()), 
                                r.pop(); else if (h.length < n.length) {
                                    t._$SetCharacterArray$_(h);
                                    const o = e(t).width, a = t._$GetWidth$_() - o;
                                    t._$SetWidth$_(o), i._$OffsetWidth$_(-a);
                                }
                                0 !== s && 0 < r.length && ((t = r.at(-1))._$OffsetWidth$_(s), 
                                i._$OffsetWidth$_(s));
                            }
                        }
                    }
                }
                _$Clear$_() {
                    C33._$clearArray$_(this._$_lines$_);
                }
                _$GetMaxLineWidth$_() {
                    return this._$_lines$_.reduce((t, e) => Math.max(t, e._$GetWidth$_()), 0);
                }
                _$GetTotalLineHeight$_() {
                    return this._$_lines$_.reduce((t, e) => t + e._$GetHeight$_(), 0);
                }
            };
        }
        {
            const C33 = self._$C3$_;
            C33._$WordWrap$_._$Line$_ = class {
                constructor(t) {
                    this._$_fragments$_ = t._$fragments$_ || [], this._$_width$_ = t.width || -1, 
                    this._$_height$_ = t.height || -1, this._$_fontBoundingBoxAscent$_ = t.fontBoundingBoxAscent || -1, 
                    this._$_fontBoundingBoxDescent$_ = t.fontBoundingBoxDescent || -1, 
                    this._$_topToAlphabeticDistance$_ = t._$topToAlphabeticDistance$_ || -1, 
                    this._$_posX$_ = 0, this._$_posY$_ = 0;
                }
                _$fragments$_() {
                    return this._$_fragments$_.values();
                }
                *_$fragmentsReverse$_() {
                    const e = this._$_fragments$_;
                    for (let t = e.length - 1; 0 <= t; --t) yield e[t];
                }
                _$_GetFragmentsArray$_() {
                    return this._$_fragments$_;
                }
                _$OffsetWidth$_(t) {
                    this._$_width$_ += t;
                }
                _$GetWidth$_() {
                    return this._$_width$_;
                }
                _$GetHeight$_() {
                    return this._$_height$_;
                }
                _$GetFoundBoundingBoxAscent$_() {
                    return this._$_fontBoundingBoxAscent$_;
                }
                _$GetFontBoundingBoxDescent$_() {
                    return this._$_fontBoundingBoxDescent$_;
                }
                _$GetTopToAlphabeticDistance$_() {
                    return this._$_topToAlphabeticDistance$_;
                }
                _$SetPosX$_(t) {
                    this._$_posX$_ = t;
                }
                _$GetPosX$_() {
                    return this._$_posX$_;
                }
                _$SetPosY$_(t) {
                    this._$_posY$_ = t;
                }
                _$GetPosY$_() {
                    return this._$_posY$_;
                }
            };
        }
        {
            const C33 = self._$C3$_;
            C33._$FragmentBase$_ = class {
                constructor(t) {
                    this._$_styles$_ = t._$styles$_ || [], this._$_width$_ = t.width || -1, 
                    this._$_height$_ = t.height || -1, this._$_fontBoundingBoxAscent$_ = t.fontBoundingBoxAscent || -1, 
                    this._$_fontBoundingBoxDescent$_ = t.fontBoundingBoxDescent || -1, 
                    this._$_topToAlphabeticDistance$_ = t._$topToAlphabeticDistance$_ || -1, 
                    this._$_posX$_ = 0, this._$_posY$_ = 0;
                }
                _$IsText$_() {
                    return !1;
                }
                _$IsIcon$_() {
                    return !1;
                }
                _$GetStyles$_() {
                    return this._$_styles$_;
                }
                _$GetStyleTag$_(e) {
                    const s = this._$_styles$_;
                    for (let t = s.length - 1; 0 <= t; --t) {
                        const i = s[t];
                        if (i.tag === e) return i;
                    }
                    return null;
                }
                _$HasStyleTag$_(t) {
                    return !!this._$GetStyleTag$_(t);
                }
                _$GetStyleMap$_() {
                    const t = new Map();
                    for (const e of this._$_styles$_) t.set(e.tag, e.param);
                    return t;
                }
                _$OffsetWidth$_(t) {
                    this._$_width$_ += t;
                }
                _$SetWidth$_(t) {
                    this._$_width$_ = t;
                }
                _$GetWidth$_() {
                    return this._$_width$_;
                }
                _$SetHeight$_(t) {
                    this._$_height$_ = t;
                }
                _$GetHeight$_() {
                    return this._$_height$_;
                }
                _$SetFontBoundingBoxAscent$_(t) {
                    this._$_fontBoundingBoxAscent$_ = t;
                }
                _$GetFontBoundingBoxAscent$_() {
                    return this._$_fontBoundingBoxAscent$_;
                }
                _$SetFontBoundingBoxDescent$_(t) {
                    this._$_fontBoundingBoxDescent$_ = t;
                }
                _$GetFontBoundingBoxDescent$_() {
                    return this._$_fontBoundingBoxDescent$_;
                }
                _$SetTopToAlphabeticDistance$_(t) {
                    this._$_topToAlphabeticDistance$_ = t;
                }
                _$GetTopToAlphabeticDistance$_() {
                    return this._$_topToAlphabeticDistance$_;
                }
                _$SetPosX$_(t) {
                    this._$_posX$_ = t;
                }
                _$GetPosX$_() {
                    return this._$_posX$_;
                }
                _$SetPosY$_(t) {
                    this._$_posY$_ = t;
                }
                _$GetPosY$_() {
                    return this._$_posY$_;
                }
            };
        }
        {
            const C33 = self._$C3$_;
            C33._$TextFragment$_ = class extends C33._$FragmentBase$_ {
                constructor(t) {
                    super(t), this._$_chArr$_ = t._$chArr$_;
                }
                _$IsText$_() {
                    return !0;
                }
                _$_Append$_(t) {
                    C33._$appendArray$_(this._$_chArr$_, t), this._$_width$_ = -1, 
                    this._$_height$_ = -1, this._$_fontBoundingBoxAscent$_ = -1, 
                    this._$_fontBoundingBoxDescent$_ = -1, this._$_topToAlphabeticDistance$_ = -1;
                }
                _$_AppendChar$_(t) {
                    this._$_chArr$_.push(t);
                }
                _$_Clone$_() {
                    return C33._$New$_(C33._$TextFragment$_, {
                        _$chArr$_: this._$_chArr$_.slice(0),
                        _$styles$_: this._$_styles$_,
                        width: this._$_width$_,
                        height: this._$_height$_,
                        fontBoundingBoxAscent: this._$_fontBoundingBoxAscent$_,
                        fontBoundingBoxDescent: this._$_fontBoundingBoxDescent$_,
                        _$topToAlphabeticDistance$_: this._$_topToAlphabeticDistance$_
                    });
                }
                _$GetCharacterArray$_() {
                    return this._$_chArr$_;
                }
                _$SetCharacterArray$_(t) {
                    this._$_chArr$_ = t;
                }
                _$GetLength$_() {
                    return this._$_chArr$_.length;
                }
                _$IsEmpty$_() {
                    return 0 === this._$_chArr$_.length;
                }
                _$HasNewLine$_() {
                    return this._$_chArr$_.includes("\n");
                }
            };
        }
        {
            const C33 = self._$C3$_;
            C33._$IconFragment$_ = class extends C33._$FragmentBase$_ {
                constructor(t) {
                    super(t), this._$_icon$_ = t.icon;
                }
                _$IsIcon$_() {
                    return !0;
                }
                _$GetIconParameter$_() {
                    return this._$_icon$_;
                }
                _$_Clone$_() {
                    return C33._$New$_(C33._$IconFragment$_, {
                        icon: this._$_icon$_,
                        _$styles$_: this._$_styles$_,
                        width: this._$_width$_,
                        height: this._$_height$_,
                        fontBoundingBoxAscent: this._$_fontBoundingBoxAscent$_,
                        fontBoundingBoxDescent: this._$_fontBoundingBoxDescent$_,
                        _$topToAlphabeticDistance$_: this._$_topToAlphabeticDistance$_
                    });
                }
                _$GetTextIcon$_(t) {
                    if (!t) return null;
                    let e = Number(this._$_icon$_);
                    return String(e) === this._$_icon$_ ? (e = Math.floor(e), t._$GetTextIconByIndex$_(e)) : t._$GetTextIconByTag$_(this._$_icon$_);
                }
                _$CalculateWidthFromHeight$_(t) {
                    const e = this._$GetTextIcon$_(t);
                    this._$_width$_ = e ? this._$_height$_ * e._$GetWidth$_() / e._$GetHeight$_() : 0;
                }
                _$GetDrawable$_(t) {
                    const e = this._$GetTextIcon$_(t);
                    return e ? e._$GetDrawable$_() : null;
                }
                _$GetLength$_() {
                    return 1;
                }
            };
        }
        {
            const C33 = self._$C3$_;
            C33._$TextIconManager$_ = class {
                constructor(t) {
                    this._$_iconSets$_ = new Map(), this._$_getIconSetMetaCallback$_ = t._$getIconSetMeta$_, 
                    this._$_getIconSetContentCallback$_ = t._$getIconSetContent$_;
                }
                _$Release$_() {
                    for (const t of this._$_iconSets$_.values()) t._$Release$_();
                    this._$_iconSets$_.clear();
                }
                _$GetIconSet$_(t) {
                    let e = this._$_iconSets$_.get(t);
                    if (!e) {
                        const s = this._$_getIconSetMetaCallback$_(t);
                        e = C33._$New$_(C33._$TextIconSet$_, this, {
                            source: t,
                            _$iconMeta$_: s
                        }), this._$_iconSets$_.set(t, e);
                    }
                    return e;
                }
                _$HasIconSet$_(t) {
                    return this._$_iconSets$_.has(t);
                }
                _$DeleteIconSet$_(t) {
                    const e = this._$_iconSets$_.get(t);
                    e && e._$Release$_(), this._$_iconSets$_.delete(t);
                }
                async _$_GetIconSetContent$_(t) {
                    return this._$_getIconSetContentCallback$_(t);
                }
            };
        }
        {
            const C33 = self._$C3$_;
            C33._$TextIconSet$_ = class {
                constructor(t, e) {
                    this._$_textIconManager$_ = t, this._$_source$_ = e.source, 
                    this._$_iconsArray$_ = [], this._$_iconsByTag$_ = new Map(), 
                    this._$_hasStartedLoad$_ = !1, this._$_isLoading$_ = !1, this._$_loadPromise$_ = null;
                    const s = e._$iconMeta$_._$icons$_;
                    for (let t = 0, e = s.length; t < e; ++t) {
                        const i = s[t], r = C33._$New$_(C33._$TextIcon$_, this, {
                            index: t,
                            tag: i.tag,
                            source: i.source,
                            width: i.width,
                            height: i.height
                        });
                        this._$_iconsArray$_.push(r), i.tag && this._$_iconsByTag$_.set(i.tag.toLowerCase(), r);
                    }
                }
                _$Release$_() {
                    for (const t of this._$_iconsArray$_) t._$Release$_();
                    C33._$clearArray$_(this._$_iconsArray$_), this._$_iconsByTag$_.clear(), 
                    this._$_textIconManager$_ = null, this._$_source$_ = null;
                }
                _$HasLoaded$_() {
                    return this._$_hasStartedLoad$_;
                }
                _$IsLoading$_() {
                    return this._$_isLoading$_;
                }
                _$LoadContent$_() {
                    return this._$_loadPromise$_ || (this._$_loadPromise$_ = this._$_DoLoadContent$_()), 
                    this._$_loadPromise$_;
                }
                async _$_DoLoadContent$_() {
                    if (!this._$_hasStartedLoad$_) {
                        this._$_hasStartedLoad$_ = !0, this._$_isLoading$_ = !0;
                        const t = await this._$_textIconManager$_._$_GetIconSetContent$_(this._$_source$_);
                        if (this._$_textIconManager$_) {
                            const s = t._$icons$_;
                            for (let t = 0, e = Math.min(s.length, this._$_iconsArray$_.length); t < e; ++t) {
                                const i = s[t]._$drawable$_;
                                this._$_iconsArray$_[t]._$_SetDrawable$_(i);
                            }
                            this._$_isLoading$_ = !1;
                        }
                    }
                }
                _$GetTextIconByIndex$_(t) {
                    return (t = Math.floor(t)) < 0 || t >= this._$_iconsArray$_.length ? null : this._$_iconsArray$_[t];
                }
                _$GetTextIconByTag$_(t) {
                    return this._$_iconsByTag$_.get(t.toLowerCase()) || null;
                }
            };
        }
        {
            const C33 = self._$C3$_;
            C33._$TextIcon$_ = class {
                constructor(t, e) {
                    this._$_textIconSet$_ = t, this._$_source$_ = e.source || null, 
                    this._$_index$_ = e.index, this._$_tag$_ = e.tag, this._$_width$_ = e.width, 
                    this._$_height$_ = e.height, this._$_drawable$_ = null;
                }
                _$Release$_() {
                    this._$_width$_ = 0, this._$_height$_ = 0, this._$_textIconSet$_ = null;
                }
                _$GetSource$_() {
                    return this._$_source$_;
                }
                _$GetWidth$_() {
                    return this._$_width$_;
                }
                _$GetHeight$_() {
                    return this._$_height$_;
                }
                _$_SetDrawable$_(t) {
                    this._$_drawable$_ = t;
                }
                _$GetDrawable$_() {
                    return this._$_drawable$_;
                }
            };
        }
        {
            let PlaneFromPoints2 = function(t, e, s, i) {
                const r = tempVec3c;
                vec32._$subtract$_(tempVec3a, s, e), vec32._$subtract$_(tempVec3b, t, e), 
                vec32._$cross$_(r, tempVec3a, tempVec3b), vec32.normalize(r, r), 
                i.set(r[0], r[1], r[2], vec32._$dot$_(t, r));
            }, IsInFrontOfPlane2 = function(t, e, s, i, r, n, h) {
                const o = h.x, a = h.y, l = h.z, u = h.w, c = h._$xF$_, f = h._$yF$_, d = h._$zF$_, p = 1 - c, m = 1 - f, C = 1 - d, g = o * t * c + o * i * p + a * e * f + a * r * m + l * s * d + l * n * C;
                if (u <= g) return !0;
                const S = o * i * c + o * t * p + a * r * f + a * e * m + l * n * d + l * s * C;
                return u < S;
            }, IsPointInFrontOfPlane2 = function(t, e, s, i) {
                const r = i.x, n = i.y, h = i.z, o = i.w, a = r * t + n * e + h * s;
                return o <= a;
            };
            PlaneFromPoints = PlaneFromPoints2, IsInFrontOfPlane = IsInFrontOfPlane2, 
            IsPointInFrontOfPlane = IsPointInFrontOfPlane2;
            const C33 = self._$C3$_, glMatrix = self._$glMatrix$_, vec32 = glMatrix._$vec3$_, vec42 = glMatrix._$vec4$_, mat42 = glMatrix._$mat4$_, tempVec3a = vec32.create(), tempVec3b = vec32.create(), tempVec3c = vec32.create(), tempVec4 = vec42.create(), tempMat4 = mat42.create(), neartl = vec32.create(), neartr = vec32.create(), nearbl = vec32.create(), nearbr = vec32.create(), fartl = vec32.create(), fartr = vec32.create(), farbl = vec32.create(), farbr = vec32.create(), unitViewport = vec42._$fromValues$_(0, 0, 1, 1);
            C33._$Gfx$_ = {
                _$Project$_(t, e, s, i, r, n, h) {
                    let o = i[0] * t + i[4] * e + i[8] * s + i[12], a = i[1] * t + i[5] * e + i[9] * s + i[13], l = i[2] * t + i[6] * e + i[10] * s + i[14], u = i[3] * t + i[7] * e + i[11] * s + i[15], c = r[0] * o + r[4] * a + r[8] * l + r[12] * u, f = r[1] * o + r[5] * a + r[9] * l + r[13] * u, d = r[2] * o + r[6] * a + r[10] * l + r[14] * u, p = r[3] * o + r[7] * a + r[11] * l + r[15] * u;
                    return 0 != p && (f *= p = 1 / p, d *= p, h[0] = (.5 * (c *= p) + .5) * n[2] + n[0], 
                    h[1] = (.5 * f + .5) * n[3] + n[1], h[2] = .5 * (1 + d), !0);
                },
                _$Unproject$_(t, e, s, i, r, n, h) {
                    const o = tempMat4, a = tempVec4;
                    return mat42.multiply(o, r, i), null !== mat42._$invert$_(o, o) && (a[0] = (t - n[0]) / n[2] * 2 - 1, 
                    a[1] = (e - n[1]) / n[3] * 2 - 1, a[2] = 2 * s - 1, a[3] = 1, 
                    vec42._$transformMat4$_(a, a, o), 0 !== a[3]) && (a[3] = 1 / a[3], 
                    h[0] = a[0] * a[3], h[1] = a[1] * a[3], h[2] = a[2] * a[3], 
                    !0);
                },
                _$UnprojectScreenToWorldZ$_(t, e, s, i, r, n, h) {
                    const o = tempVec3a, a = tempVec3b;
                    if (!C33._$Gfx$_._$Unproject$_(t, e, 0, i, r, n, o)) return !1;
                    if (!C33._$Gfx$_._$Unproject$_(t, e, 1, i, r, n, a)) return !1;
                    let l = tempVec3b, u = (vec32._$subtract$_(l, a, o), tempVec3c), c = (vec32.set(u, 0, 0, 1), 
                    -s), f = vec32._$dot$_(u, l), d = 0;
                    if (0 === f) {
                        const p = vec32._$dot$_(u, o) + c;
                        if (0 !== p) return !1;
                    } else if ((d = -(vec32._$dot$_(o, u) + c) / f) < 0) return !1;
                    return vec32._$scaleAndAdd$_(h, o, l, d), !0;
                }
            };
            class Plane {
                constructor() {
                    this.x = NaN, this.y = NaN, this.z = NaN, this.w = NaN, this._$xF$_ = NaN, 
                    this._$yF$_ = NaN, this._$zF$_ = NaN;
                }
                set(t, e, s, i) {
                    this.x = t, this.y = e, this.z = s, this.w = i, this._$xF$_ = 0 < t ? 1 : 0, 
                    this._$yF$_ = 0 < e ? 1 : 0, this._$zF$_ = 0 < s ? 1 : 0;
                }
            }
            C33._$Gfx$_._$ViewFrustum$_ = class {
                constructor() {
                    this._$_leftP$_ = new Plane(), this._$_topP$_ = new Plane(), 
                    this._$_rightP$_ = new Plane(), this._$_bottomP$_ = new Plane(), 
                    this._$_nearP$_ = new Plane(), this._$_farP$_ = new Plane();
                }
                _$CalculatePlanes$_(t, e) {
                    const s = unitViewport;
                    C33._$Gfx$_._$Unproject$_(0, 1, 0, t, e, s, neartl), C33._$Gfx$_._$Unproject$_(1, 1, 0, t, e, s, neartr), 
                    C33._$Gfx$_._$Unproject$_(0, 0, 0, t, e, s, nearbl), C33._$Gfx$_._$Unproject$_(1, 0, 0, t, e, s, nearbr), 
                    C33._$Gfx$_._$Unproject$_(0, 1, 1, t, e, s, fartl), C33._$Gfx$_._$Unproject$_(1, 1, 1, t, e, s, fartr), 
                    C33._$Gfx$_._$Unproject$_(0, 0, 1, t, e, s, farbl), C33._$Gfx$_._$Unproject$_(1, 0, 1, t, e, s, farbr), 
                    PlaneFromPoints2(nearbl, neartl, fartl, this._$_leftP$_), PlaneFromPoints2(neartl, neartr, fartr, this._$_topP$_), 
                    PlaneFromPoints2(neartr, nearbr, farbr, this._$_rightP$_), PlaneFromPoints2(nearbr, nearbl, farbl, this._$_bottomP$_), 
                    PlaneFromPoints2(farbl, fartl, fartr, this._$_farP$_), PlaneFromPoints2(nearbr, neartr, neartl, this._$_nearP$_);
                }
                _$ContainsAABB$_(t, e, s, i, r, n) {
                    return IsInFrontOfPlane2(t, e, s, i, r, n, this._$_leftP$_) && IsInFrontOfPlane2(t, e, s, i, r, n, this._$_topP$_) && IsInFrontOfPlane2(t, e, s, i, r, n, this._$_rightP$_) && IsInFrontOfPlane2(t, e, s, i, r, n, this._$_bottomP$_) && IsInFrontOfPlane2(t, e, s, i, r, n, this._$_nearP$_) && IsInFrontOfPlane2(t, e, s, i, r, n, this._$_farP$_);
                }
                _$IsBehindNearPlane$_(t, e, s) {
                    return !IsPointInFrontOfPlane2(t, e, s, this._$_nearP$_);
                }
            };
        }
        {
            const C33 = self._$C3$_, glMatrix = self._$glMatrix$_, vec32 = glMatrix._$vec3$_, vec42 = glMatrix._$vec4$_, mat42 = glMatrix._$mat4$_, tempMat4 = mat42.create(), tmpVec3a = vec32._$fromValues$_(0, 0, 0), tmpVec3b = vec32._$fromValues$_(0, 0, 0), tmpVec3c = vec32._$fromValues$_(0, 0, 0), defaultUpVector = vec32._$fromValues$_(0, 1, 0), tmpVec4 = vec42._$fromValues$_(0, 0, 0, 0), tmpQuad = new C33._$Quad$_(), tmpRect = new C33.Rect(), defaultTexCoordsQuad = new C33._$Quad$_(0, 0, 1, 0, 1, 1, 0, 1), DEFAULT_RENDERERBASE_OPTS = {
                _$nearZ$_: 1,
                _$farZ$_: 1e4
            }, matWebGLtoWebGPU = mat42._$fromValues$_(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, .5, 0, 0, 0, .5, 1);
            C33._$Gfx$_._$RendererBase$_ = class {
                constructor(t) {
                    t = Object.assign({}, DEFAULT_RENDERERBASE_OPTS, t), this._$_width$_ = 0, 
                    this._$_height$_ = 0, this._$_fovY$_ = C33._$toRadians$_(45), 
                    this._$_tan_fovY_2$_ = Math.tan(this._$_fovY$_ / 2), this._$_matP$_ = mat42.create(), 
                    this._$_matMV$_ = mat42.create(), this._$_zAxisScale$_ = !1, 
                    this._$_nearZ$_ = t._$nearZ$_, this._$_farZ$_ = t._$farZ$_, 
                    this._$_allShaderPrograms$_ = [], this._$_shaderProgramsByName$_ = new Map(), 
                    this._$_spTextureFill$_ = null, this._$_spPoints$_ = null, this._$_spTilemapFill$_ = null, 
                    this._$_spTileRandomization$_ = null, this._$_spColorFill$_ = null, 
                    this._$_spLinearGradientFill$_ = null, this._$_spPenumbraFill$_ = null, 
                    this._$_spHardEllipseFill$_ = null, this._$_spHardEllipseOutline$_ = null, 
                    this._$_spSmoothEllipseFill$_ = null, this._$_spSmoothEllipseOutline$_ = null, 
                    this._$_spSmoothLineFill$_ = null, this._$_stateGroups$_ = new Map(), 
                    this._$_currentStateGroup$_ = null, this._$_blendModeTable$_ = [], 
                    this._$_namedBlendModeMap$_ = new Map(), this._$_baseZ$_ = 0, 
                    this._$_currentZ$_ = 0, this._$_lineWidth$_ = 1, this._$_lineWidthStack$_ = [ this._$_lineWidth$_ ], 
                    this._$_lineCap$_ = 1, this._$_lineCapStack$_ = [ this._$_lineCap$_ ], 
                    this._$_lineOffset$_ = .5, this._$_lineOffsetStack$_ = [ this._$_lineOffset$_ ], 
                    this._$_frameNumber$_ = 0, this._$_enableMipmaps$_ = !0, this._$_hasMajorPerformanceCaveat$_ = !1;
                }
                _$FillIndexBufferData$_(t) {
                    let e = 0, s = t.length, i = 0;
                    for (;e < s; ) t[e++] = i, t[e++] = i + 1, t[e++] = i + 2, t[e++] = i, 
                    t[e++] = i + 2, t[e++] = i + 3, i += 4;
                }
                _$_ClearState$_() {
                    this._$_baseZ$_ = 0, this._$_currentZ$_ = 0, this._$_spTextureFill$_ = null, 
                    this._$_spPoints$_ = null, this._$_spTilemapFill$_ = null, this._$_spTileRandomization$_ = null, 
                    this._$_spColorFill$_ = null, this._$_spLinearGradientFill$_ = null, 
                    this._$_spPenumbraFill$_ = null, this._$_spHardEllipseFill$_ = null, 
                    this._$_spHardEllipseOutline$_ = null, this._$_spSmoothEllipseFill$_ = null, 
                    this._$_spSmoothEllipseOutline$_ = null, this._$_spSmoothLineFill$_ = null, 
                    this._$_ClearAllShaderPrograms$_();
                }
                _$InitState$_() {
                    this._$_ClearState$_(), this._$_currentStateGroup$_ = null;
                }
                _$OnDeviceOrContextLost$_() {
                    for (const t of this._$_allShaderPrograms$_) t._$Release$_();
                    this._$_ClearState$_();
                }
                _$GetWidth$_() {
                    return this._$_width$_;
                }
                _$GetHeight$_() {
                    return this._$_height$_;
                }
                _$GetDefaultCameraZ$_(t) {
                    return this._$IsZAxisScaleNormalized$_() ? 100 : t / (2 * this._$_GetTanFovYDiv2$_());
                }
                _$GetZAxisScaleFactor$_(t) {
                    if (this._$IsZAxisScaleNormalized$_()) {
                        const e = t / (2 * this._$_GetTanFovYDiv2$_());
                        return e / this._$GetDefaultCameraZ$_(t);
                    }
                    return 1;
                }
                _$SetNearZ$_(t) {
                    this._$_nearZ$_ = t;
                }
                _$GetNearZ$_() {
                    return this._$_nearZ$_;
                }
                _$SetFarZ$_(t) {
                    this._$_farZ$_ = t;
                }
                _$GetFarZ$_() {
                    return this._$_farZ$_;
                }
                _$SetFovY$_(t) {
                    this._$_fovY$_ = t, this._$_tan_fovY_2$_ = Math.tan(this._$_fovY$_ / 2);
                }
                _$GetFovY$_() {
                    return this._$_fovY$_;
                }
                _$_GetTanFovYDiv2$_() {
                    return this._$_tan_fovY_2$_;
                }
                _$SetZAxisScaleNormalized$_() {
                    this._$_zAxisScale$_ = !1;
                }
                _$SetZAxisScaleRegular$_() {
                    this._$_zAxisScale$_ = !0;
                }
                _$IsZAxisScaleNormalized$_() {
                    return !this._$_zAxisScale$_;
                }
                _$IsZAxisScaleRegular$_() {
                    return this._$_zAxisScale$_;
                }
                _$CalculatePerspectiveMatrix$_(t, e, s = .5, i = .5) {
                    const r = this._$GetNearZ$_(), n = this._$GetFarZ$_(), h = this._$GetFovY$_();
                    if (.5 === s && .5 === i) this._$IsWebGPU$_() ? mat42._$perspectiveZO$_(t, h, e, r, n) : mat42.perspective(t, h, e, r, n); else {
                        const o = 2 * (s = 1 - s) - 2, a = 2 * s, l = 2 * i - 2, u = 2 * i, c = this._$_GetTanFovYDiv2$_() * r, f = c * e;
                        mat42._$frustum$_(t, o * f, a * f, l * c, u * c, r, n), 
                        this._$IsWebGPU$_() && mat42.mul(t, matWebGLtoWebGPU, t);
                    }
                }
                _$CalculateOrthographicMatrix$_(t, e, s, i = 1) {
                    const r = self.devicePixelRatio, n = 2 * this._$GetDefaultCameraZ$_(s) * r * this._$_GetTanFovYDiv2$_() / s, h = e * n / (2 * r * i), o = s * n / (2 * r * i), a = -h, l = h, u = -o, c = o;
                    this._$IsWebGPU$_() ? mat42._$orthoZO$_(t, a, l, u, c, this._$GetNearZ$_(), this._$GetFarZ$_()) : mat42.ortho(t, a, l, u, c, this._$GetNearZ$_(), this._$GetFarZ$_());
                }
                _$CalculateLookAtModelView$_(t, e, s, i, r, n = 1) {
                    let h = 1;
                    this._$IsZAxisScaleNormalized$_() && (h = 200 * this._$_GetTanFovYDiv2$_() / r);
                    const o = tmpVec3c, a = (vec32.set(o, h, -h, 1), tmpVec3a), l = tmpVec3b;
                    vec32.multiply(a, e, o), vec32.multiply(l, s, o), mat42._$lookAt$_(t, a, l, i || defaultUpVector), 
                    o[2] = n, mat42.scale(t, t, o);
                }
                _$CalculateLookAtModelView2$_(t, e, s, i, r, n, h, o) {
                    return vec32.set(tmpVec3a, t, e, s), vec32.set(tmpVec3b, i, r, n), 
                    this._$CalculateLookAtModelView$_(tempMat4, tmpVec3a, tmpVec3b, defaultUpVector, h, o), 
                    tempMat4;
                }
                _$_AddShaderProgram$_(t) {
                    this._$_allShaderPrograms$_.push(t), this._$_shaderProgramsByName$_.set(t._$GetName$_(), t);
                }
                _$_RemoveShaderProgram$_(t) {
                    const e = this._$_allShaderPrograms$_.indexOf(t);
                    -1 !== e && this._$_allShaderPrograms$_.splice(e, 1), this._$_shaderProgramsByName$_.delete(t._$GetName$_());
                }
                _$_ClearAllShaderPrograms$_() {
                    C33._$clearArray$_(this._$_allShaderPrograms$_), this._$_shaderProgramsByName$_.clear();
                }
                _$GetShaderProgramByName$_(t) {
                    return this._$_shaderProgramsByName$_.get(t) || null;
                }
                _$GetTextureFillShaderProgram$_() {
                    return this._$_spTextureFill$_;
                }
                _$SetTextureFillMode$_() {
                    this._$SetProgram$_(this._$_spTextureFill$_);
                }
                _$GetPointsRenderingProgram$_() {
                    return this._$_spPoints$_;
                }
                _$SetPointsRenderingProgram$_() {
                    this._$SetProgram$_(this._$_spPoints$_);
                }
                _$SetTilemapFillMode$_() {
                    this._$SetProgram$_(this._$_spTilemapFill$_);
                }
                _$SetTileRandomizationMode$_() {
                    this._$SetProgram$_(this._$_spTileRandomization$_);
                }
                _$SetColorFillMode$_() {
                    this._$SetProgram$_(this._$_spColorFill$_);
                }
                _$SetLinearGradientFillMode$_() {
                    this._$SetProgram$_(this._$_spLinearGradientFill$_);
                }
                _$SetPenumbraFillMode$_() {
                    this._$SetProgram$_(this._$_spPenumbraFill$_);
                }
                _$SetHardEllipseFillMode$_() {
                    this._$SetProgram$_(this._$_spHardEllipseFill$_);
                }
                _$SetHardEllipseOutlineMode$_() {
                    this._$SetProgram$_(this._$_spHardEllipseOutline$_);
                }
                _$SetSmoothEllipseFillMode$_() {
                    this._$SetProgram$_(this._$_spSmoothEllipseFill$_);
                }
                _$SetSmoothEllipseOutlineMode$_() {
                    this._$SetProgram$_(this._$_spSmoothEllipseOutline$_);
                }
                _$SetSmoothLineFillMode$_() {
                    this._$SetProgram$_(this._$_spSmoothLineFill$_);
                }
                _$_SetCurrentStateGroup$_(t) {
                    this._$_currentStateGroup$_ = t;
                }
                _$GetCurrentStateGroup$_() {
                    return this._$_currentStateGroup$_;
                }
                _$AcquireStateGroup$_(t, e, s, i) {
                    let r = C33._$Gfx$_._$StateGroup$_._$MakeKey$_(t, e, s, i), n = this._$_stateGroups$_.get(r);
                    return n || (n = C33._$New$_(C33._$Gfx$_._$StateGroup$_, this, t, e, s, i), 
                    this._$_stateGroups$_.set(r, n)), n._$AddRef$_(), n;
                }
                _$ReleaseStateGroup$_(t) {
                    t._$DecRef$_(), 0 === t._$_GetRefCount$_() && (this._$_currentStateGroup$_ === t && (this._$_currentStateGroup$_ = null), 
                    this._$_stateGroups$_.delete(t._$GetKey$_()), t._$Release$_());
                }
                _$_InitBlendModeData$_(t) {
                    C33._$clearArray$_(this._$_blendModeTable$_), this._$_namedBlendModeMap$_.clear();
                    let e = 0;
                    for (const s of t) {
                        const i = s[0], r = s[1], n = s[2];
                        this._$_blendModeTable$_.push([ r, n ]), this._$_namedBlendModeMap$_.set(i, {
                            number: e,
                            _$srcBlend$_: r,
                            _$destBlend$_: n
                        }), e++;
                    }
                }
                _$_GetBlendByIndex$_(t) {
                    return this._$_blendModeTable$_[t];
                }
                _$GetSrcBlendByIndex$_(t) {
                    return this._$_GetBlendByIndex$_(t)[0];
                }
                _$GetDestBlendByIndex$_(t) {
                    return this._$_GetBlendByIndex$_(t)[1];
                }
                _$GetNamedBlend$_(t) {
                    const e = this._$_namedBlendModeMap$_.get(t);
                    if (void 0 === e) throw new Error("invalid blend name");
                    return e;
                }
                _$NamedBlendToNumber$_(t) {
                    const e = this._$_namedBlendModeMap$_.get(t);
                    if (void 0 === e) throw new Error("invalid blend name");
                    return e.number;
                }
                _$SetBaseZ$_(t) {
                    this._$_baseZ$_ = t;
                }
                _$GetBaseZ$_() {
                    return this._$_baseZ$_;
                }
                _$SetCurrentZ$_(t) {
                    this._$_currentZ$_ = t, this._$_currentStateGroup$_ = null;
                }
                _$GetCurrentZ$_() {
                    return this._$_currentZ$_;
                }
                _$Line$_(t, e, s, i) {
                    const r = C33._$angleTo$_(t, e, s, i), n = Math.sin(r), h = Math.cos(r), o = .5 * this._$_lineWidth$_, a = n * o, l = h * o, u = this._$_lineCap$_;
                    2 === u ? this._$LinePreCalc_LineCap2$_(t, e, 0, s, i, 0, a, l) : 1 === u ? this._$LinePreCalc_LineCap1$_(t, e, 0, s, i, 0, a, l) : this._$LinePreCalc_LineCap0$_(t, e, 0, s, i, 0, a, l);
                }
                _$Line3D$_(t, e, s, i, r, n) {
                    const h = C33._$angleTo$_(t, e, i, r), o = Math.sin(h), a = Math.cos(h), l = .5 * this._$_lineWidth$_, u = o * l, c = a * l, f = this._$_lineCap$_;
                    2 === f ? this._$LinePreCalc_LineCap2$_(t, e, s, i, r, n, u, c) : 1 === f ? this._$LinePreCalc_LineCap1$_(t, e, s, i, r, n, u, c) : this._$LinePreCalc_LineCap0$_(t, e, s, i, r, n, u, c);
                }
                _$LinePreCalc_LineCap2$_(t, e, s, i, r, n, h, o) {
                    const a = this._$_lineOffset$_, l = t + a - o, u = e + a - h, c = i + a + o, f = r + a + h, d = 2 * o, p = 2 * h, m = l + h, C = u - o, g = l - h + d, S = u + o + p, _ = c + h, T = f - o, y = c - h - d, E = f + o - p;
                    this._$Quad3D2$_(m, C, s, _, T, n, y, E, n, g, S, s, defaultTexCoordsQuad);
                }
                _$LinePreCalc_LineCap1$_(t, e, s, i, r, n, h, o) {
                    const a = this._$_lineOffset$_, l = t + a - o, u = e + a - h, c = i + a + o, f = r + a + h, d = l + h, p = u - o, m = l - h, C = u + o, g = c + h, S = f - o, _ = c - h, T = f + o;
                    this._$Quad3D2$_(d, p, s, g, S, n, _, T, n, m, C, s, defaultTexCoordsQuad);
                }
                _$LinePreCalc_LineCap0$_(t, e, s, i, r, n, h, o) {
                    const a = this._$_lineOffset$_, l = t + a, u = e + a, c = i + a, f = r + a, d = l + h, p = u - o, m = l - h, C = u + o, g = c + h, S = f - o, _ = c - h, T = f + o;
                    this._$Quad3D2$_(d, p, s, g, S, n, _, T, n, m, C, s, defaultTexCoordsQuad);
                }
                _$TexturedLine$_(t, e, s, i, r, n) {
                    const h = C33._$angleTo$_(t, e, s, i), o = Math.sin(h), a = Math.cos(h), l = .5 * this._$_lineWidth$_, u = o * l, c = a * l, f = this._$_lineCap$_;
                    2 === f ? this._$TexturedLinePreCalc_LineCap2$_(t, e, s, i, u, c, r, n) : 1 === f ? this._$TexturedLinePreCalc_LineCap1$_(t, e, s, i, u, c, r, n) : this._$TexturedLinePreCalc_LineCap0$_(t, e, s, i, u, c, r, n);
                }
                _$TexturedLinePreCalc_LineCap2$_(t, e, s, i, r, n, h, o) {
                    const a = this._$_lineOffset$_, l = t + a - n, u = e + a - r, c = s + a + n, f = i + a + r, d = 2 * n, p = 2 * r, m = l + r, C = u - n, g = l - r + d, S = u + n + p, _ = c + r, T = f - n, y = c - r - d, E = f + n - p;
                    tmpQuad.set(m, C, _, T, y, E, g, S), tmpRect.set(h, 0, o, 0), 
                    this._$Quad3$_(tmpQuad, tmpRect);
                }
                _$TexturedLinePreCalc_LineCap1$_(t, e, s, i, r, n, h, o) {
                    const a = this._$_lineOffset$_, l = t + a - n, u = e + a - r, c = s + a + n, f = i + a + r, d = l + r, p = u - n, m = l - r, C = u + n, g = c + r, S = f - n, _ = c - r, T = f + n;
                    tmpQuad.set(d, p, g, S, _, T, m, C), tmpRect.set(h, 0, o, 0), 
                    this._$Quad3$_(tmpQuad, tmpRect);
                }
                _$TexturedLinePreCalc_LineCap0$_(t, e, s, i, r, n, h, o) {
                    const a = this._$_lineOffset$_, l = t + a, u = e + a, c = s + a, f = i + a, d = l + r, p = u - n, m = l - r, C = u + n, g = c + r, S = f - n, _ = c - r, T = f + n;
                    tmpQuad.set(d, p, g, S, _, T, m, C), tmpRect.set(h, 0, o, 0), 
                    this._$Quad3$_(tmpQuad, tmpRect);
                }
                _$LineRect$_(t, e, s, i) {
                    const r = .5 * this._$_lineWidth$_, n = this._$_lineCap$_;
                    2 === n ? this._$_LineRectPreCalc_LineCap2$_(t, e, s, i, r) : 1 === n ? this._$_LineRectPreCalc_LineCap1$_(t, e, s, i, r) : this._$_LineRectPreCalc_LineCap0$_(t, e, s, i, r);
                }
                _$_LineRectPreCalc_LineCap2$_(t, e, s, i, r) {
                    this._$LinePreCalc_LineCap2$_(t, e, 0, s, e, 0, 0, r), this._$LinePreCalc_LineCap2$_(s, e, 0, s, i, 0, r, 0), 
                    this._$LinePreCalc_LineCap2$_(s, i, 0, t, i, 0, 0, -r), this._$LinePreCalc_LineCap2$_(t, i, 0, t, e, 0, -r, 0);
                }
                _$_LineRectPreCalc_LineCap1$_(t, e, s, i, r) {
                    this._$LinePreCalc_LineCap1$_(t, e, 0, s, e, 0, 0, r), this._$LinePreCalc_LineCap1$_(s, e, 0, s, i, 0, r, 0), 
                    this._$LinePreCalc_LineCap1$_(s, i, 0, t, i, 0, 0, -r), this._$LinePreCalc_LineCap1$_(t, i, 0, t, e, 0, -r, 0);
                }
                _$_LineRectPreCalc_LineCap0$_(t, e, s, i, r) {
                    this._$LinePreCalc_LineCap0$_(t, e, 0, s, e, 0, 0, r), this._$LinePreCalc_LineCap0$_(s, e, 0, s, i, 0, r, 0), 
                    this._$LinePreCalc_LineCap0$_(s, i, 0, t, i, 0, 0, -r), this._$LinePreCalc_LineCap0$_(t, i, 0, t, e, 0, -r, 0);
                }
                _$LineRect2$_(t) {
                    this._$LineRect$_(t._$getLeft$_(), t._$getTop$_(), t._$getRight$_(), t._$getBottom$_());
                }
                _$LineQuad$_(t) {
                    const e = C33._$angleTo$_(t._$getTlx$_(), t._$getTly$_(), t._$getTrx$_(), t._$getTry$_()), s = Math.sin(e), i = Math.cos(e), r = .5 * this._$_lineWidth$_, n = s * r, h = i * r, o = this._$_lineCap$_;
                    2 === o ? this._$_LineQuadPreCalc_LineCap2$_(t, n, h) : 1 === o ? this._$_LineQuadPreCalc_LineCap1$_(t, n, h) : this._$_LineQuadPreCalc_LineCap0$_(t, n, h);
                }
                _$_LineQuadPreCalc_LineCap2$_(t, e, s) {
                    this._$LinePreCalc_LineCap2$_(t._$getTlx$_(), t._$getTly$_(), 0, t._$getTrx$_(), t._$getTry$_(), 0, e, s), 
                    this._$LinePreCalc_LineCap2$_(t._$getTrx$_(), t._$getTry$_(), 0, t._$getBrx$_(), t._$getBry$_(), 0, s, -e), 
                    this._$LinePreCalc_LineCap2$_(t._$getBrx$_(), t._$getBry$_(), 0, t._$getBlx$_(), t._$getBly$_(), 0, -e, -s), 
                    this._$LinePreCalc_LineCap2$_(t._$getBlx$_(), t._$getBly$_(), 0, t._$getTlx$_(), t._$getTly$_(), 0, -s, e);
                }
                _$_LineQuadPreCalc_LineCap1$_(t, e, s) {
                    this._$LinePreCalc_LineCap1$_(t._$getTlx$_(), t._$getTly$_(), 0, t._$getTrx$_(), t._$getTry$_(), 0, e, s), 
                    this._$LinePreCalc_LineCap1$_(t._$getTrx$_(), t._$getTry$_(), 0, t._$getBrx$_(), t._$getBry$_(), 0, s, -e), 
                    this._$LinePreCalc_LineCap1$_(t._$getBrx$_(), t._$getBry$_(), 0, t._$getBlx$_(), t._$getBly$_(), 0, -e, -s), 
                    this._$LinePreCalc_LineCap1$_(t._$getBlx$_(), t._$getBly$_(), 0, t._$getTlx$_(), t._$getTly$_(), 0, -s, e);
                }
                _$_LineQuadPreCalc_LineCap0$_(t, e, s) {
                    this._$LinePreCalc_LineCap0$_(t._$getTlx$_(), t._$getTly$_(), 0, t._$getTrx$_(), t._$getTry$_(), 0, e, s), 
                    this._$LinePreCalc_LineCap0$_(t._$getTrx$_(), t._$getTry$_(), 0, t._$getBrx$_(), t._$getBry$_(), 0, s, -e), 
                    this._$LinePreCalc_LineCap0$_(t._$getBrx$_(), t._$getBry$_(), 0, t._$getBlx$_(), t._$getBly$_(), 0, -e, -s), 
                    this._$LinePreCalc_LineCap0$_(t._$getBlx$_(), t._$getBly$_(), 0, t._$getTlx$_(), t._$getTly$_(), 0, -s, e);
                }
                _$SetLineWidth$_(t) {
                    this._$_lineWidth$_ = t, this._$_lineWidthStack$_[this._$_lineWidthStack$_.length - 1] = t;
                }
                _$GetLineWidth$_() {
                    return this._$_lineWidth$_;
                }
                _$PushLineWidth$_(t) {
                    if (100 <= this._$_lineWidthStack$_.length) throw new Error("pushed too many line widths - check push/pop pairs");
                    this._$_lineWidthStack$_.push(t), this._$_lineWidth$_ = t;
                }
                _$PopLineWidth$_() {
                    if (this._$_lineWidthStack$_.length <= 1) throw new Error("cannot pop last line width - check push/pop pairs");
                    this._$_lineWidthStack$_.pop(), this._$_lineWidth$_ = this._$_lineWidthStack$_.at(-1);
                }
                _$SetLineCapButt$_() {
                    this._$_lineCap$_ = 0, this._$_lineCapStack$_[this._$_lineCapStack$_.length - 1] = 0;
                }
                _$SetLineCapSquare$_() {
                    this._$_lineCap$_ = 1, this._$_lineCapStack$_[this._$_lineCapStack$_.length - 1] = 0;
                }
                _$SetLineCapZag$_() {
                    this._$_lineCap$_ = 2, this._$_lineCapStack$_[this._$_lineCapStack$_.length - 1] = 0;
                }
                _$PushLineCap$_(t) {
                    if ("butt" === t) this._$PushLineCapButt$_(); else if ("square" === t) this._$PushLineCapSquare$_(); else {
                        if ("zag" !== t) throw new Error("invalid line cap");
                        this._$PushLineCapZag$_();
                    }
                }
                _$PushLineCapButt$_() {
                    if (100 <= this._$_lineCapStack$_.length) throw new Error("pushed too many line caps - check push/pop pairs");
                    this._$_lineCapStack$_.push(0), this._$_lineCap$_ = 0;
                }
                _$PushLineCapSquare$_() {
                    if (100 <= this._$_lineCapStack$_.length) throw new Error("pushed too many line caps - check push/pop pairs");
                    this._$_lineCapStack$_.push(1), this._$_lineCap$_ = 1;
                }
                _$PushLineCapZag$_() {
                    if (100 <= this._$_lineCapStack$_.length) throw new Error("pushed too many line caps - check push/pop pairs");
                    this._$_lineCapStack$_.push(2), this._$_lineCap$_ = 2;
                }
                _$PopLineCap$_() {
                    if (this._$_lineCapStack$_.length <= 1) throw new Error("cannot pop last line cap - check push/pop pairs");
                    this._$_lineCapStack$_.pop(), this._$_lineCap$_ = this._$_lineCapStack$_.at(-1);
                }
                _$SetLineOffset$_(t) {
                    this._$_lineOffset$_ = t, this._$_lineOffsetStack$_[this._$_lineOffsetStack$_.length - 1] = t;
                }
                _$GetLineOffset$_() {
                    return this._$_lineOffset$_;
                }
                _$PushLineOffset$_(t) {
                    if (100 <= this._$_lineOffsetStack$_.length) throw new Error("pushed too many line offsets - check push/pop pairs");
                    this._$_lineOffsetStack$_.push(t), this._$_lineOffset$_ = t;
                }
                _$PopLineOffset$_() {
                    if (this._$_lineOffsetStack$_.length <= 1) throw new Error("cannot pop last line offset - check push/pop pairs");
                    this._$_lineOffsetStack$_.pop(), this._$_lineOffset$_ = this._$_lineOffsetStack$_.at(-1);
                }
                _$ConvexPoly$_(e) {
                    const t = e.length / 2;
                    if (t < 3) throw new Error("need at least 3 points");
                    const s = t - 2, i = s - 1, r = e[0], n = e[1];
                    for (let t = 0; t < s; t += 2) {
                        const h = 2 * t, o = e[2 + h], a = e[3 + h], l = e[4 + h], u = e[5 + h];
                        if (t === i) this._$Quad2$_(r, n, o, a, l, u, l, u); else {
                            const c = e[6 + h], f = e[7 + h];
                            this._$Quad2$_(r, n, o, a, l, u, c, f);
                        }
                    }
                }
                _$GetNumVertexComponents$_() {
                    return 3;
                }
                _$Finish$_() {
                    this._$EndBatch$_(!0), this._$_frameNumber$_++;
                }
                _$GetFrameNumber$_() {
                    return this._$_frameNumber$_;
                }
                _$IncrementFrameNumber$_() {
                    this._$_frameNumber$_++;
                }
                _$SetMipmapsEnabled$_(t) {
                    this._$_enableMipmaps$_ = !!t;
                }
                _$AreMipmapsEnabled$_() {
                    return this._$_enableMipmaps$_;
                }
                _$SetHasMajorPerformanceCaveat$_(t) {
                    this._$_hasMajorPerformanceCaveat$_ = !!t;
                }
                _$HasMajorPerformanceCaveat$_() {
                    return this._$_hasMajorPerformanceCaveat$_;
                }
                _$IsWebGL$_() {
                    return !1;
                }
                _$IsWebGPU$_() {
                    return !1;
                }
                _$GetEstimatedBackBufferMemoryUsage$_() {}
                _$GetEstimatedRenderBufferMemoryUsage$_() {}
                _$GetEstimatedTextureMemoryUsage$_() {}
                _$GetEstimatedTotalMemoryUsage$_() {
                    return this._$GetEstimatedBackBufferMemoryUsage$_() + this._$GetEstimatedRenderBufferMemoryUsage$_() + this._$GetEstimatedTextureMemoryUsage$_();
                }
                _$CreateRendererText$_() {
                    return C33._$New$_(C33._$Gfx$_._$RendererText$_, this);
                }
            };
        }
        {
            const C33 = self._$C3$_;
            C33._$Gfx$_._$ShaderProgramBase$_ = class {
                constructor(t, e) {
                    this._$_name$_ = e.name, this._$_renderer$_ = t, this._$_extendBoxHorizontal$_ = e.extendBoxHorizontal || 0, 
                    this._$_extendBoxVertical$_ = e.extendBoxVertical || 0, this._$_crossSampling$_ = !!e.crossSampling, 
                    this._$_mustPreDraw$_ = !!e.mustPreDraw, this._$_preservesOpaqueness$_ = !!e.preservesOpaqueness, 
                    this._$_supports3dDirectRendering$_ = !!e.supports3dDirectRendering, 
                    this._$_animated$_ = !!e.animated, this._$_blendsBackground$_ = !!e.blendsBackground, 
                    this._$_usesDepth$_ = !!e.usesDepth, this._$_usesAnySrcRectOrPixelSize$_ = !1, 
                    this._$_needsPostDrawOrExtendBox$_ = this._$_crossSampling$_ || this._$_blendsBackground$_ || 0 !== this._$_extendBoxHorizontal$_ || 0 !== this._$_extendBoxVertical$_;
                }
                _$Release$_() {
                    this._$_renderer$_ = null;
                }
                _$GetRenderer$_() {
                    return this._$_renderer$_;
                }
                _$GetName$_() {
                    return this._$_name$_;
                }
                _$ExtendsBox$_() {
                    return 0 !== this._$_extendBoxHorizontal$_ || 0 !== this._$_extendBoxVertical$_;
                }
                _$GetBoxExtendHorizontal$_() {
                    return this._$_extendBoxHorizontal$_;
                }
                _$GetBoxExtendVertical$_() {
                    return this._$_extendBoxVertical$_;
                }
                _$UsesCrossSampling$_() {
                    return this._$_crossSampling$_;
                }
                _$MustPreDraw$_() {
                    return this._$_mustPreDraw$_;
                }
                _$PreservesOpaqueness$_() {
                    return this._$_preservesOpaqueness$_;
                }
                _$Supports3DDirectRendering$_() {
                    return this._$_supports3dDirectRendering$_;
                }
                _$IsAnimated$_() {
                    return this._$_animated$_;
                }
                _$BlendsBackground$_() {
                    return this._$_blendsBackground$_;
                }
                _$UsesDepth$_() {
                    return this._$_usesDepth$_;
                }
                _$UsesAnySrcRectOrPixelSize$_() {
                    return this._$_usesAnySrcRectOrPixelSize$_;
                }
                _$NeedsPostDrawOrExtendsBox$_() {
                    return this._$_needsPostDrawOrExtendBox$_;
                }
                _$UsesIsSrcTexRotated$_() {
                    return !1;
                }
            };
        }
        {
            const C33 = self._$C3$_;
            C33._$Gfx$_._$StateGroup$_ = class {
                constructor(t, e, s, i, r) {
                    this._$_renderer$_ = t, this._$_refCount$_ = 0, this._$_shaderProgram$_ = null, 
                    this._$_shaderProgramName$_ = "", this._$_blendMode$_ = s, this._$_color$_ = C33._$New$_(C33._$Color$_), 
                    this._$_color$_.set(i), this._$_zElevation$_ = r, "string" == typeof e ? this._$_shaderProgramName$_ = e : (this._$_shaderProgram$_ = e, 
                    this._$_shaderProgramName$_ = this._$_shaderProgram$_._$GetName$_());
                }
                _$Release$_() {
                    if (0 < this._$_refCount$_) throw new Error("releasing state group still in use");
                    this._$_renderer$_ = null, this._$_shaderProgram$_ = null, this._$_shaderProgramName$_ = "";
                }
                _$Apply$_() {
                    const t = this._$_renderer$_;
                    t._$SetProgram$_(this._$_shaderProgram$_), t._$SetBlendMode$_(this._$_blendMode$_), 
                    t._$SetColor$_(this._$_color$_), t._$SetCurrentZ$_(this._$_zElevation$_), 
                    t._$_SetCurrentStateGroup$_(this);
                }
                _$GetKey$_() {
                    return C33._$Gfx$_._$StateGroup$_._$MakeKey$_(this._$_shaderProgramName$_, this._$_blendMode$_, this._$_color$_, this._$_zElevation$_);
                }
                _$AddRef$_() {
                    ++this._$_refCount$_;
                }
                _$DecRef$_() {
                    --this._$_refCount$_;
                }
                _$_GetRefCount$_() {
                    return this._$_refCount$_;
                }
                _$OnContextLost$_() {
                    this._$_shaderProgram$_ = null;
                }
                _$OnContextRestored$_(t) {
                    if (this._$_shaderProgram$_ = t._$GetShaderProgramByName$_(this._$_shaderProgramName$_), 
                    !this._$_shaderProgram$_) throw new Error("failed to restore shader program");
                }
                static _$MakeKey$_(t, e, s, i) {
                    const r = "string" == typeof t ? t : t._$GetName$_();
                    return r + "," + e + "," + s._$getR$_() + "," + s._$getG$_() + "," + s._$getB$_() + "," + s._$getA$_() + "," + i;
                }
            };
        }
        {
            let interpolateQuad2 = function(t, e, s) {
                const i = s._$getTlx$_(), r = s._$getTly$_(), n = s._$getTrx$_() - i, h = s._$getTry$_() - r, o = s._$getBlx$_() - i, a = s._$getBly$_() - r, l = n * t, u = h * t, c = o * e, f = a * e;
                return [ i + l + c, r + u + f ];
            };
            interpolateQuad = interpolateQuad2;
            const C33 = self._$C3$_, tempQuadTex = C33._$New$_(C33._$Quad$_);
            C33._$Gfx$_._$MeshPoint$_ = class {
                constructor(t, e, s) {
                    this._$_mesh$_ = t, this._$_col$_ = e, this._$_row$_ = s, this._$_x$_ = NaN, 
                    this._$_y$_ = NaN, this._$_zElevation$_ = NaN, this._$_u$_ = NaN, 
                    this._$_v$_ = NaN, this._$_x$_ = 0, this._$_y$_ = 0, this._$_zElevation$_ = 0, 
                    this._$_u$_ = 0, this._$_v$_ = 0;
                }
                _$_Init$_(t, e, s, i) {
                    this._$_x$_ = t, this._$_y$_ = e, this._$_u$_ = s, this._$_v$_ = i;
                }
                _$GetX$_() {
                    return this._$_x$_;
                }
                _$SetX$_(t) {
                    this._$_x$_ !== t && (this._$_x$_ = t, this._$_mesh$_._$_SetPointsChanged$_());
                }
                _$GetY$_() {
                    return this._$_y$_;
                }
                _$SetY$_(t) {
                    this._$_y$_ !== t && (this._$_y$_ = t, this._$_mesh$_._$_SetPointsChanged$_());
                }
                _$GetZElevation$_() {
                    return this._$_zElevation$_;
                }
                _$SetZElevation$_(t) {
                    this._$_zElevation$_ !== t && (this._$_zElevation$_ = Math.max(t, 0), 
                    this._$_mesh$_._$_SetPointsChanged$_());
                }
                _$GetU$_() {
                    return this._$_u$_;
                }
                _$SetU$_(t) {
                    this._$_u$_ = t;
                }
                _$GetV$_() {
                    return this._$_v$_;
                }
                _$SetV$_(t) {
                    this._$_v$_ = t;
                }
                _$_Interpolate_TexRect$_(t, e, s) {
                    [ this._$_x$_, this._$_y$_ ] = interpolateQuad2(t._$_x$_, t._$_y$_, e), 
                    this._$_zElevation$_ = t._$_zElevation$_, this._$_u$_ = C33._$lerp$_(s._$getLeft$_(), s._$getRight$_(), t._$_u$_), 
                    this._$_v$_ = C33._$lerp$_(s._$getTop$_(), s._$getBottom$_(), t._$_v$_);
                }
                _$_Interpolate_TexQuad$_(t, e, s) {
                    [ this._$_x$_, this._$_y$_ ] = interpolateQuad2(t._$_x$_, t._$_y$_, e), 
                    this._$_zElevation$_ = t._$_zElevation$_, [ this._$_u$_, this._$_v$_ ] = interpolateQuad2(t._$_u$_, t._$_v$_, s);
                }
                _$SaveToJson$_() {
                    return {
                        x: this._$GetX$_(),
                        y: this._$GetY$_(),
                        z: this._$GetZElevation$_(),
                        u: this._$GetU$_(),
                        v: this._$GetV$_()
                    };
                }
                _$LoadFromJson$_(t) {
                    this._$SetX$_(t.x), this._$SetY$_(t.y), t.hasOwnProperty("z") && this._$SetZElevation$_(t.z), 
                    this._$SetU$_(t.u), this._$SetV$_(t.v);
                }
                _$GetMesh$_() {
                    return this._$_mesh$_;
                }
                _$GetColumn$_() {
                    return this._$_col$_;
                }
                _$GetRow$_() {
                    return this._$_row$_;
                }
            }, C33._$Gfx$_._$Mesh$_ = class {
                constructor(s, t, e) {
                    if (s < 2 || t < 2) throw new Error("invalid mesh size");
                    this._$_hsize$_ = s, this._$_vsize$_ = t, this._$_owner$_ = e || null, 
                    this._$_pts$_ = [], this._$_minX$_ = 0, this._$_minY$_ = 0, 
                    this._$_maxX$_ = 1, this._$_maxY$_ = 1, this._$_maxZ$_ = 0, 
                    this._$_pointsChanged$_ = !1;
                    const i = s - 1, r = t - 1;
                    for (let e = 0; e < t; ++e) {
                        const n = [];
                        for (let t = 0; t < s; ++t) {
                            const h = C33._$New$_(C33._$Gfx$_._$MeshPoint$_, this, t, e), o = t / i, a = e / r;
                            h._$_Init$_(o, a, o, a), n.push(h);
                        }
                        this._$_pts$_.push(n);
                    }
                }
                _$Release$_() {
                    C33._$clearArray$_(this._$_pts$_);
                }
                _$GetHSize$_() {
                    return this._$_hsize$_;
                }
                _$GetVSize$_() {
                    return this._$_vsize$_;
                }
                _$GetOwner$_() {
                    return this._$_owner$_;
                }
                _$_GetPoints$_() {
                    return this._$_pts$_;
                }
                _$_SetPointsChanged$_() {
                    this._$_pointsChanged$_ = !0;
                }
                _$_MaybeComputeBounds$_() {
                    if (this._$_pointsChanged$_) {
                        let t = 1 / 0, e = 1 / 0, s = -1 / 0, i = -1 / 0, r = 0;
                        for (const n of this._$_pts$_) for (const h of n) {
                            const o = h._$GetX$_(), a = h._$GetY$_();
                            t = Math.min(t, o), e = Math.min(e, a), s = Math.max(s, o), 
                            i = Math.max(i, a), r = Math.max(r, h._$GetZElevation$_());
                        }
                        this._$_minX$_ = t, this._$_minY$_ = e, this._$_maxX$_ = s, 
                        this._$_maxY$_ = i, this._$_maxZ$_ = r, this._$_pointsChanged$_ = !1;
                    }
                }
                _$GetMinX$_() {
                    return this._$_MaybeComputeBounds$_(), this._$_minX$_;
                }
                _$GetMinY$_() {
                    return this._$_MaybeComputeBounds$_(), this._$_minY$_;
                }
                _$GetMaxX$_() {
                    return this._$_MaybeComputeBounds$_(), this._$_maxX$_;
                }
                _$GetMaxY$_() {
                    return this._$_MaybeComputeBounds$_(), this._$_maxY$_;
                }
                _$GetMaxZ$_() {
                    return this._$_MaybeComputeBounds$_(), this._$_maxZ$_;
                }
                _$HasAnyZElevation$_() {
                    return 0 < this._$GetMaxZ$_();
                }
                _$GetMeshPointAt$_(t, e) {
                    return t = Math.floor(t), e = Math.floor(e), t < 0 || t >= this._$_hsize$_ || e < 0 || e >= this._$_vsize$_ ? null : this._$_pts$_[e][t];
                }
                _$CalculateTransformedMesh$_(t, s, i) {
                    const r = i instanceof C33.Rect;
                    if (t._$GetHSize$_() !== this._$GetHSize$_() || t._$GetVSize$_() !== this._$GetVSize$_()) throw new Error("source mesh wrong size");
                    const n = t._$_pts$_, h = this._$_pts$_;
                    for (let t = 0, e = h.length; t < e; ++t) {
                        const o = n[t], a = h[t];
                        for (let t = 0, e = a.length; t < e; ++t) {
                            const l = o[t], u = a[t];
                            r ? u._$_Interpolate_TexRect$_(l, s, i) : u._$_Interpolate_TexQuad$_(l, s, i);
                        }
                    }
                }
                _$Draw$_(n) {
                    let h = this._$_pts$_, o = h[0];
                    for (let t = 1, e = h.length; t < e; ++t) {
                        let s = h[t], i = o[0], r = s[0];
                        for (let t = 1, e = s.length; t < e; ++t) {
                            const a = o[t], l = s[t];
                            tempQuadTex.set(i._$GetU$_(), i._$GetV$_(), a._$GetU$_(), a._$GetV$_(), l._$GetU$_(), l._$GetV$_(), r._$GetU$_(), r._$GetV$_()), 
                            n._$Quad3D2$_(i._$GetX$_(), i._$GetY$_(), i._$GetZElevation$_(), a._$GetX$_(), a._$GetY$_(), a._$GetZElevation$_(), l._$GetX$_(), l._$GetY$_(), l._$GetZElevation$_(), r._$GetX$_(), r._$GetY$_(), r._$GetZElevation$_(), tempQuadTex), 
                            i = a, r = l;
                        }
                        o = s;
                    }
                }
                _$Outline$_(o, a) {
                    a = a || ((t, e, s) => [ t, e, s ]);
                    let t = this._$_pts$_, l = t[0];
                    for (let n = 1, h = t.length; n < h; ++n) {
                        let s = t[n], i = l[0], r = s[0];
                        for (let t = 1, e = s.length; t < e; ++t) {
                            const u = l[t], c = s[t], [ f, d, p ] = a(i._$GetX$_(), i._$GetY$_(), i._$GetZElevation$_()), [ m, C, g ] = a(u._$GetX$_(), u._$GetY$_(), u._$GetZElevation$_()), [ S, _, T ] = a(c._$GetX$_(), c._$GetY$_(), c._$GetZElevation$_()), [ y, E, A ] = a(r._$GetX$_(), r._$GetY$_(), r._$GetZElevation$_());
                            o._$Line3D$_(f, d, p, m, C, g), o._$Line3D$_(f, d, p, S, _, T), 
                            o._$Line3D$_(f, d, p, y, E, A), t === e - 1 && o._$Line3D$_(m, C, g, S, _, T), 
                            n === h - 1 && o._$Line3D$_(y, E, A, S, _, T), i = u, 
                            r = c;
                        }
                        l = s;
                    }
                }
                _$InsertPolyMeshVertices$_(t) {
                    let s = .99999999, i = t._$pointsArr$_(), r = [], n = this._$GetHSize$_() - 1, h = this._$GetVSize$_() - 1, o = 1 / n, a = 1 / h, l = n - 1, u = h - 1, c = i[0], f = i[1], d = C33._$clamp$_(Math.floor(c * n), 0, l), p = C33._$clamp$_(Math.floor(f * h), 0, u), m = !0, C = 0, g = 0, S = 0, _ = -1, T = () => {
                        c = C33._$clamp$_(C33._$lerp$_(c, C, S), 0, 1), f = C33._$clamp$_(C33._$lerp$_(f, g, S), 0, 1), 
                        r.push(c, f);
                    };
                    for (let t = 0, e = i.length; t < e; t += 2) {
                        c = i[t], f = i[t + 1], r.push(c, f), d = C33._$clamp$_(Math.floor(c * n), 0, l), 
                        p = C33._$clamp$_(Math.floor(f * h), 0, u);
                        const y = (t + 2) % e;
                        for (C = i[y], g = i[1 + y], _ = -1; ;) {
                            if (1e6 < r.length) throw new Error("Too many mesh poly points");
                            const E = d * o, A = p * a, I = (d + 1) * o, M = (p + 1) * a;
                            if (m = C33._$isPointInTriangleInclusive$_(c, f, E, A, I, A, I, M), 
                            0 !== _ && 0 <= (S = C33._$rayIntersectExtended$_(c, f, C, g, E, A, I, M, -.001)) && S <= s) T(), 
                            m = !m, _ = 0; else if (0 < p && 2 !== _ && 0 <= (S = C33._$rayIntersectExtended$_(c, f, C, g, E, A, I, A, .001)) && S <= s) T(), 
                            p--, m = !1, _ = 4; else if (d < l && 3 !== _ && 0 <= (S = C33._$rayIntersectExtended$_(c, f, C, g, I, A, I, M, .001)) && S <= s) T(), 
                            d++, m = !1, _ = 1; else if (0 < d && 1 !== _ && 0 <= (S = C33._$rayIntersectExtended$_(c, f, C, g, E, A, E, M, .001)) && S <= s) T(), 
                            d--, m = !0, _ = 3; else {
                                if (!(p < u && 4 !== _ && 0 <= (S = C33._$rayIntersectExtended$_(c, f, C, g, E, M, I, M, .001)) && S <= s)) break;
                                T(), p++, m = !0, _ = 2;
                            }
                        }
                    }
                    return C33._$New$_(C33._$CollisionPoly$_, r);
                }
                _$TransformCollisionPoly$_(t, e) {
                    const s = this._$_TransformPolyPoints$_(t);
                    this._$_SimplifyPoly$_(s), e._$setPoints$_(s);
                }
                _$_TransformPolyPoints$_(t) {
                    const s = [], i = t._$pointsArr$_();
                    for (let t = 0, e = i.length; t < e; t += 2) {
                        const r = i[t], n = i[t + 1], [ h, o ] = this._$TransformPoint$_(r, n);
                        s.push(h, o);
                    }
                    return s;
                }
                _$TransformPoint$_(t, e) {
                    const s = this._$GetHSize$_() - 1, i = this._$GetVSize$_() - 1, r = 1 / s, n = 1 / i, h = C33._$clamp$_(Math.floor(t * s), 0, s - 1), o = C33._$clamp$_(Math.floor(e * i), 0, i - 1), a = h * r, l = o * n, u = (h + 1) * r, c = (o + 1) * n, f = this._$GetMeshPointAt$_(h, o), d = this._$GetMeshPointAt$_(h + 1, o + 1), p = C33._$isPointInTriangleInclusive$_(t, e, a, l, u, l, u, c), m = p ? a + r : a, C = p ? l : l + n, g = this._$GetMeshPointAt$_(h + (p ? 1 : 0), o + (p ? 0 : 1)), [ S, _, T ] = C33._$triangleCartesianToBarycentric$_(t, e, a, l, m, C, u, c);
                    return C33._$triangleBarycentricToCartesian3d$_(S, _, T, f._$GetX$_(), f._$GetY$_(), f._$GetZElevation$_(), g._$GetX$_(), g._$GetY$_(), g._$GetZElevation$_(), d._$GetX$_(), d._$GetY$_(), d._$GetZElevation$_());
                }
                _$_SimplifyPoly$_(s) {
                    let i = [], r = s[0], n = s[1], h = r - s.at(-2), o = n - s.at(-1);
                    for (let t = 0, e = s.length; t < e; t += 2) {
                        const a = (t + 2) % e, l = s[a], u = s[1 + a], c = l - r, f = u - n, d = Math.abs(c) < 1e-7 && Math.abs(h) < 1e-7 && Math.sign(f) === Math.sign(o), p = Math.abs(f) < 1e-7 && Math.abs(o) < 1e-7 && Math.sign(c) === Math.sign(h);
                        (!d && !p && .001 < Math.abs(c / h - f / o) || 0 == c && 0 == f) && i.push(r, n), 
                        r = l, n = u, h = c, o = f;
                    }
                    6 <= i.length && i.length < s.length && C33._$shallowAssignArray$_(s, i);
                }
                _$SaveToJson$_() {
                    return {
                        cols: this._$GetHSize$_(),
                        rows: this._$GetVSize$_(),
                        points: this._$_pts$_.map(t => t.map(t => t._$SaveToJson$_()))
                    };
                }
                _$LoadFromJson$_(t) {
                    const s = this._$GetHSize$_(), i = this._$GetVSize$_();
                    if (t.cols !== s || t.rows !== i) throw new Error("mesh data wrong size");
                    const r = t.points;
                    for (let e = 0; e < i; ++e) {
                        const n = r[e];
                        for (let t = 0; t < s; ++t) {
                            const h = this._$GetMeshPointAt$_(t, e);
                            h._$LoadFromJson$_(n[t]);
                        }
                    }
                }
            };
        }
        {
            let GetFormatSpecifiers2 = function(t, e) {
                let s, i, r, n;
                switch (t) {
                  case "rgba8":
                    s = e.RGBA8, i = e.RGBA, r = e.RGBA, n = e.UNSIGNED_BYTE;
                    break;

                  case "rgb8":
                    s = e.RGB8, i = e.RGB, r = e.RGB, n = e.UNSIGNED_BYTE;
                    break;

                  case "rgba4":
                    s = e.RGBA4, i = e.RGBA, r = e.RGBA, n = e.UNSIGNED_SHORT_4_4_4_4;
                    break;

                  case "rgb5_a1":
                    s = e.RGB5_A1, i = e.RGBA, r = e.RGBA, n = e.UNSIGNED_SHORT_5_5_5_1;
                    break;

                  case "rgb565":
                    s = e.RGB565, i = e.RGB, r = e.RGB, n = e.UNSIGNED_SHORT_5_6_5;
                    break;

                  default:
                    throw new Error("invalid pixel format");
                }
                return {
                    _$sizedinternalformat$_: s,
                    _$internalformat$_: i,
                    format: r,
                    type: n
                };
            };
            GetFormatSpecifiers = GetFormatSpecifiers2;
            const C33 = self._$C3$_, VALID_PIXEL_FORMATS = new Set([ "rgba8", "rgb8", "rgba4", "rgb5_a1", "rgb565" ]), VALID_SAMPLINGS = new Set([ "nearest", "bilinear", "trilinear" ]), VALID_MIPMAP_QUALITIES = new Set([ "default", "low", "high" ]), VALID_WRAP_MODES = new Set([ "clamp-to-edge", "repeat", "mirror-repeat" ]), CREATEFROM_DEFAULT_OPTIONS = {
                _$wrapX$_: "clamp-to-edge",
                _$wrapY$_: "clamp-to-edge",
                _$sampling$_: "trilinear",
                _$anisotropy$_: 0,
                _$pixelFormat$_: "rgba8",
                _$mipMap$_: !0,
                _$mipMapQuality$_: "default",
                premultiplyAlpha: !0,
                _$isSvg$_: !1,
                width: -1,
                height: -1
            }, UPDATE_DEFAULT_OPTIONS = {
                premultiplyAlpha: !0,
                flipY: !1
            }, allTextures = new Set();
            C33._$Gfx$_._$WebGLRendererTexture$_ = class {
                constructor(t) {
                    this._$_renderer$_ = t, this._$_texture$_ = null, this._$_width$_ = 0, 
                    this._$_height$_ = 0, this._$_isStatic$_ = !0, this._$_wrapX$_ = "clamp-to-edge", 
                    this._$_wrapY$_ = "clamp-to-edge", this._$_sampling$_ = "trilinear", 
                    this._$_anisotropy$_ = 0, this._$_pixelFormat$_ = "rgba8", this._$_isMipMapped$_ = !1, 
                    this._$_mipMapQuality$_ = "default", this._$_refCount$_ = 0;
                }
                _$_CreateStatic$_(e, t) {
                    if (!("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap || "undefined" != typeof OffscreenCanvas && e instanceof OffscreenCanvas || e instanceof ImageData || e instanceof ArrayBuffer || null === e)) throw new Error("invalid texture source");
                    if (t = Object.assign({}, CREATEFROM_DEFAULT_OPTIONS, t), this._$_texture$_) throw new Error("already created texture");
                    if (this._$_wrapX$_ = t._$wrapX$_, this._$_wrapY$_ = t._$wrapY$_, 
                    this._$_sampling$_ = t._$sampling$_, this._$_anisotropy$_ = t._$anisotropy$_, 
                    this._$_pixelFormat$_ = t._$pixelFormat$_, this._$_isMipMapped$_ = !!t._$mipMap$_ && this._$_renderer$_._$AreMipmapsEnabled$_(), 
                    this._$_mipMapQuality$_ = t._$mipMapQuality$_, !VALID_WRAP_MODES.has(this._$_wrapX$_) || !VALID_WRAP_MODES.has(this._$_wrapY$_)) throw new Error("invalid wrap mode");
                    if (!VALID_SAMPLINGS.has(this._$_sampling$_)) throw new Error("invalid sampling");
                    if (!VALID_PIXEL_FORMATS.has(this._$_pixelFormat$_)) throw new Error("invalid pixel format");
                    if (!VALID_MIPMAP_QUALITIES.has(this._$_mipMapQuality$_)) throw new Error("invalid mipmap quality");
                    if (this._$_isStatic$_ = !0, e instanceof ArrayBuffer || null === e || t._$isSvg$_) {
                        if (this._$_width$_ = t.width, this._$_height$_ = t.height, 
                        e instanceof ArrayBuffer && e.byteLength !== this._$_width$_ * this._$_height$_ * 4) throw new Error("ArrayBuffer wrong size");
                    } else this._$_width$_ = e.width, this._$_height$_ = e.height;
                    if (this._$_width$_ <= 0 || this._$_height$_ <= 0) throw new Error("invalid texture data size");
                    if (t._$isSvg$_) {
                        const o = C33._$CreateCanvas$_(this._$_width$_, this._$_height$_), a = o.getContext("2d");
                        a.drawImage(e, 0, 0, this._$_width$_, this._$_height$_), 
                        e = o;
                    }
                    const s = C33._$isPOT$_(this._$_width$_) && C33._$isPOT$_(this._$_height$_), i = this._$_renderer$_._$GetMaxTextureSize$_();
                    if (this._$_width$_ > i || this._$_height$_ > i) throw new Error("texture data exceeds maximum texture size");
                    const r = this._$_renderer$_._$GetContext$_(), n = this._$_renderer$_._$GetWebGLVersionNumber$_(), h = (this._$_texture$_ = r.createTexture(), 
                    r.bindTexture(r.TEXTURE_2D, this._$_texture$_), r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t.premultiplyAlpha), 
                    r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, !1), GetFormatSpecifiers2(this._$_pixelFormat$_, r));
                    if (this._$_renderer$_._$SupportsNPOTTextures$_() || s || !this._$_IsTiled$_()) if (2 <= n) {
                        let t;
                        t = this._$_isMipMapped$_ ? Math.floor(Math.log2(Math.max(this._$_width$_, this._$_height$_)) + 1) : 1, 
                        r.texStorage2D(r.TEXTURE_2D, t, h._$sizedinternalformat$_, this._$_width$_, this._$_height$_), 
                        e instanceof ArrayBuffer ? r.texSubImage2D(r.TEXTURE_2D, 0, 0, 0, this._$_width$_, this._$_height$_, h.format, h.type, new Uint8Array(e)) : null !== e && r.texSubImage2D(r.TEXTURE_2D, 0, 0, 0, h.format, h.type, e);
                    } else e instanceof ArrayBuffer ? r.texImage2D(r.TEXTURE_2D, 0, h._$internalformat$_, this._$_width$_, this._$_height$_, 0, h.format, h.type, new Uint8Array(e)) : null === e ? r.texImage2D(r.TEXTURE_2D, 0, h._$internalformat$_, this._$_width$_, this._$_height$_, 0, h.format, h.type, null) : r.texImage2D(r.TEXTURE_2D, 0, h._$internalformat$_, h.format, h.type, e); else {
                        if (null === e) throw new Error("cannot pass null data when creating a NPOT tiled texture without NPOT support");
                        if ((e = e instanceof ArrayBuffer ? new ImageData(new Uint8ClampedArray(e), this._$_width$_, this._$_height$_) : e) instanceof ImageData) {
                            const c = C33._$CreateCanvas$_(this._$_width$_, this._$_height$_), f = c.getContext("2d");
                            f.putImageData(e, 0, 0), e = c;
                        }
                        const l = C33._$CreateCanvas$_(C33._$nextHighestPowerOfTwo$_(this._$_width$_), C33._$nextHighestPowerOfTwo$_(this._$_height$_)), u = l.getContext("2d");
                        u.imageSmoothingEnabled = "nearest" !== this._$_sampling$_, 
                        u.drawImage(e, 0, 0, this._$_width$_, this._$_height$_, 0, 0, l.width, l.height), 
                        r.texImage2D(r.TEXTURE_2D, 0, h._$internalformat$_, h.format, h.type, l);
                    }
                    null !== e && this._$_SetTextureParameters$_(r), r.bindTexture(r.TEXTURE_2D, null), 
                    this._$_renderer$_._$_ResetLastTexture$_(), this._$_refCount$_ = 1, 
                    allTextures.add(this);
                }
                _$_CreateDynamic$_(t, e, s) {
                    if (s = Object.assign({}, CREATEFROM_DEFAULT_OPTIONS, s), this._$_texture$_) throw new Error("already created texture");
                    if (this._$_wrapX$_ = s._$wrapX$_, this._$_wrapY$_ = s._$wrapY$_, 
                    this._$_sampling$_ = s._$sampling$_, this._$_pixelFormat$_ = s._$pixelFormat$_, 
                    this._$_isMipMapped$_ = !!s._$mipMap$_ && this._$_renderer$_._$AreMipmapsEnabled$_(), 
                    this._$_mipMapQuality$_ = s._$mipMapQuality$_, !VALID_WRAP_MODES.has(this._$_wrapX$_) || !VALID_WRAP_MODES.has(this._$_wrapY$_)) throw new Error("invalid wrap mode");
                    if (!VALID_SAMPLINGS.has(this._$_sampling$_)) throw new Error("invalid sampling");
                    if (!VALID_PIXEL_FORMATS.has(this._$_pixelFormat$_)) throw new Error("invalid pixel format");
                    if (!VALID_MIPMAP_QUALITIES.has(this._$_mipMapQuality$_)) throw new Error("invalid mipmap quality");
                    this._$_isStatic$_ = !1, this._$_width$_ = Math.floor(t), this._$_height$_ = Math.floor(e);
                    const i = C33._$isPOT$_(this._$_width$_) && C33._$isPOT$_(this._$_height$_), r = this._$_renderer$_._$GetMaxTextureSize$_();
                    if (this._$_width$_ <= 0 || this._$_height$_ <= 0) throw new Error("invalid texture size");
                    if (this._$_width$_ > r || this._$_height$_ > r) throw new Error("texture exceeds maximum texture size");
                    if (!this._$_renderer$_._$SupportsNPOTTextures$_() && this._$_IsTiled$_() && !i) throw new Error("non-power-of-two tiled textures not supported");
                    const n = this._$_renderer$_._$GetContext$_(), h = this._$_renderer$_._$GetWebGLVersionNumber$_(), o = (this._$_texture$_ = n.createTexture(), 
                    n.bindTexture(n.TEXTURE_2D, this._$_texture$_), n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, s.premultiplyAlpha), 
                    n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, !1), GetFormatSpecifiers2(this._$_pixelFormat$_, n)), a = 2 <= h ? o._$sizedinternalformat$_ : o._$internalformat$_;
                    n.texImage2D(n.TEXTURE_2D, 0, a, this._$_width$_, this._$_height$_, 0, o.format, o.type, null), 
                    this._$_SetTextureParameters$_(n), n.bindTexture(n.TEXTURE_2D, null), 
                    this._$_renderer$_._$_ResetLastTexture$_(), this._$_refCount$_ = 1, 
                    allTextures.add(this);
                }
                _$_GetMipMapHint$_(t) {
                    if ("default" === this._$_mipMapQuality$_) return this._$_isStatic$_ ? t.NICEST : t.FASTEST;
                    if ("low" === this._$_mipMapQuality$_) return t.FASTEST;
                    if ("high" === this._$_mipMapQuality$_) return t.NICEST;
                    throw new Error("invalid mipmap quality");
                }
                _$_IsTiled$_() {
                    return "clamp-to-edge" !== this._$_wrapX$_ || "clamp-to-edge" !== this._$_wrapY$_;
                }
                _$_GetTextureWrapMode$_(t, e) {
                    if ("clamp-to-edge" === e) return t.CLAMP_TO_EDGE;
                    if ("repeat" === e) return t.REPEAT;
                    if ("mirror-repeat" === e) return t.MIRRORED_REPEAT;
                    throw new Error("invalid wrap mode");
                }
                _$_SetTextureParameters$_(t) {
                    const e = C33._$isPOT$_(this._$_width$_) && C33._$isPOT$_(this._$_height$_);
                    if (t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, this._$_GetTextureWrapMode$_(t, this._$_wrapX$_)), 
                    t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, this._$_GetTextureWrapMode$_(t, this._$_wrapY$_)), 
                    "nearest" === this._$_sampling$_) t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, t.NEAREST), 
                    t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.NEAREST), 
                    this._$_isMipMapped$_ = !1; else if (t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, t.LINEAR), 
                    (e || this._$_renderer$_._$SupportsNPOTTextures$_()) && this._$_isMipMapped$_) {
                        t.hint(t.GENERATE_MIPMAP_HINT, this._$_GetMipMapHint$_(t)), 
                        t.generateMipmap(t.TEXTURE_2D);
                        const i = "trilinear" === this._$_sampling$_ && !this._$_renderer$_._$HasMajorPerformanceCaveat$_();
                        t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, i ? t.LINEAR_MIPMAP_LINEAR : t.LINEAR_MIPMAP_NEAREST);
                    } else t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.LINEAR), 
                    this._$_isMipMapped$_ = !1;
                    const s = this._$_renderer$_._$_GetAnisotropicExtension$_();
                    s && 0 < this._$_anisotropy$_ && "nearest" !== this._$_sampling$_ && t.texParameterf(t.TEXTURE_2D, s.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(this._$_anisotropy$_, this._$_renderer$_._$_GetMaxAnisotropy$_()));
                }
                _$_Update$_(t, e) {
                    if (!("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLVideoElement && t instanceof HTMLVideoElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap || "undefined" != typeof OffscreenCanvas && t instanceof OffscreenCanvas || t instanceof ImageData)) throw new Error("invalid texture source");
                    if (!this._$_texture$_ || this._$_refCount$_ <= 0) throw new Error("texture not created");
                    if (this._$_isStatic$_) throw new Error("cannot update static texture");
                    e = Object.assign({}, UPDATE_DEFAULT_OPTIONS, e);
                    const s = t.width || t.videoWidth, i = t.height || t.videoHeight, r = this._$_renderer$_._$GetWebGLVersionNumber$_(), n = this._$_renderer$_._$GetContext$_(), h = (n.bindTexture(n.TEXTURE_2D, this._$_texture$_), 
                    n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e.premultiplyAlpha), 
                    n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, !!e.flipY), GetFormatSpecifiers2(this._$_pixelFormat$_, n)), o = 2 <= r ? h._$sizedinternalformat$_ : h._$internalformat$_;
                    try {
                        if (this._$_width$_ === s && this._$_height$_ === i) {
                            const a = C33._$isPOT$_(this._$_width$_) && C33._$isPOT$_(this._$_height$_);
                            n.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, h.format, h.type, t), 
                            (a || this._$_renderer$_._$SupportsNPOTTextures$_()) && this._$_isMipMapped$_ && (n.hint(n.GENERATE_MIPMAP_HINT, this._$_GetMipMapHint$_(n)), 
                            n.generateMipmap(n.TEXTURE_2D));
                        } else {
                            this._$_width$_ = s, this._$_height$_ = i;
                            const l = C33._$isPOT$_(this._$_width$_) && C33._$isPOT$_(this._$_height$_);
                            if (!this._$_renderer$_._$SupportsNPOTTextures$_() && this._$_IsTiled$_() && !l) throw new Error("non-power-of-two tiled textures not supported");
                            n.texImage2D(n.TEXTURE_2D, 0, o, h.format, h.type, t), 
                            (l || this._$_renderer$_._$SupportsNPOTTextures$_()) && this._$_isMipMapped$_ && (n.hint(n.GENERATE_MIPMAP_HINT, this._$_GetMipMapHint$_(n)), 
                            n.generateMipmap(n.TEXTURE_2D));
                        }
                    } catch (t) {
                        console.error("Error updating WebGL texture: ", t);
                    }
                    n.bindTexture(n.TEXTURE_2D, null), this._$_renderer$_._$_ResetLastTexture$_();
                }
                _$_Delete$_() {
                    if (0 < this._$_refCount$_) throw new Error("texture still has references");
                    if (!this._$_texture$_) throw new Error("already deleted texture");
                    allTextures.delete(this);
                    const t = this._$_renderer$_._$GetContext$_();
                    t.deleteTexture(this._$_texture$_), this._$_texture$_ = null;
                }
                _$IsValid$_() {
                    return !!this._$_texture$_;
                }
                _$_GetTexture$_() {
                    return this._$_texture$_;
                }
                _$GetRenderer$_() {
                    return this._$_renderer$_;
                }
                _$AddReference$_() {
                    this._$_refCount$_++;
                }
                _$SubtractReference$_() {
                    if (this._$_refCount$_ <= 0) throw new Error("no more references");
                    this._$_refCount$_--;
                }
                _$GetReferenceCount$_() {
                    return this._$_refCount$_;
                }
                _$GetWidth$_() {
                    return this._$_width$_;
                }
                _$GetHeight$_() {
                    return this._$_height$_;
                }
                _$IsStatic$_() {
                    return this._$_isStatic$_;
                }
                _$GetEstimatedMemoryUsage$_() {
                    let t = this._$_width$_ * this._$_height$_;
                    switch (this._$_pixelFormat$_) {
                      case "rgba8":
                        t *= 4;
                        break;

                      case "rgb8":
                        t *= 3;
                        break;

                      case "rgba4":
                      case "rgb5_a1":
                      case "rgb565":
                        t *= 2;
                    }
                    return this._$_isMipMapped$_ && (t += Math.floor(t / 3)), t;
                }
                static _$OnContextLost$_() {
                    allTextures.clear();
                }
                static _$allTextures$_() {
                    return allTextures.values();
                }
            };
        }
        {
            const C33 = self._$C3$_, assert = self.assert, glMatrix = self._$glMatrix$_, vec32 = glMatrix._$vec3$_, mat42 = glMatrix._$mat4$_, VALID_SAMPLINGS = new Set([ "nearest", "bilinear", "trilinear" ]), DEFAULT_RENDERTARGET_OPTIONS = {
                _$sampling$_: "trilinear",
                alpha: !0,
                depth: !1,
                _$isSampled$_: !0,
                _$isDefaultSize$_: !0,
                _$multisampling$_: 0
            }, allRenderTargets = new Set();
            C33._$Gfx$_._$WebGLRenderTarget$_ = class {
                constructor(t) {
                    this._$_renderer$_ = t, this._$_frameBuffer$_ = null, this._$_frameBufferNoDepth$_ = null, 
                    this._$_texture$_ = null, this._$_renderBuffer$_ = null, this._$_width$_ = 0, 
                    this._$_height$_ = 0, this._$_isDefaultSize$_ = !0, this._$_sampling$_ = "trilinear", 
                    this._$_alpha$_ = !0, this._$_depth$_ = !1, this._$_isSampled$_ = !0, 
                    this._$_multisampling$_ = 0, this._$_projectionMatrix$_ = mat42.create(), 
                    this._$_lastFov$_ = 0, this._$_lastNearZ$_ = 0, this._$_lastFarZ$_ = 0;
                }
                _$_Create$_(t, e, s) {
                    s = Object.assign({}, DEFAULT_RENDERTARGET_OPTIONS, s);
                    const i = this._$_renderer$_._$GetWebGLVersionNumber$_();
                    if (this._$_texture$_ || this._$_renderBuffer$_) throw new Error("already created render target");
                    if (this._$_sampling$_ = s._$sampling$_, this._$_alpha$_ = !!s.alpha, 
                    this._$_depth$_ = !!s.depth, this._$_isSampled$_ = !!s._$isSampled$_, 
                    this._$_isDefaultSize$_ = !!s._$isDefaultSize$_, this._$_multisampling$_ = s._$multisampling$_, 
                    !VALID_SAMPLINGS.has(this._$_sampling$_)) throw new Error("invalid sampling");
                    if (0 < this._$_multisampling$_ && (i < 2 || this._$_isSampled$_)) throw new Error("invalid use of multisampling");
                    if (i < 2 && (this._$_isSampled$_ = !0), this._$_width$_ = t, 
                    this._$_height$_ = e, this._$_width$_ <= 0 || this._$_height$_ <= 0) throw new Error("invalid render target size");
                    this._$_CalculateProjection$_();
                    const r = this._$_renderer$_._$GetContext$_();
                    if (this._$_frameBuffer$_ = r.createFramebuffer(), this._$_depth$_ && (this._$_frameBufferNoDepth$_ = r.createFramebuffer()), 
                    this._$_isSampled$_) {
                        this._$_texture$_ = this._$_renderer$_._$CreateDynamicTexture$_(this._$_width$_, this._$_height$_, {
                            _$sampling$_: this._$_sampling$_,
                            _$pixelFormat$_: this._$_alpha$_ ? "rgba8" : "rgb8",
                            _$mipMap$_: !1
                        });
                        const h = this._$_texture$_._$_GetTexture$_();
                        r.bindFramebuffer(r.FRAMEBUFFER, this._$_frameBuffer$_), 
                        r.framebufferTexture2D(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.TEXTURE_2D, h, 0), 
                        this._$_depth$_ && (r.bindFramebuffer(r.FRAMEBUFFER, this._$_frameBufferNoDepth$_), 
                        r.framebufferTexture2D(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.TEXTURE_2D, h, 0));
                    } else {
                        this._$_renderBuffer$_ = r.createRenderbuffer(), r.bindRenderbuffer(r.RENDERBUFFER, this._$_renderBuffer$_);
                        const o = this._$_alpha$_ ? r.RGBA8 : r.RGB8;
                        if (0 < this._$_multisampling$_) {
                            const a = r.getInternalformatParameter(r.RENDERBUFFER, o, r.SAMPLES);
                            if (a && a[0]) {
                                const l = a[0];
                                this._$_multisampling$_ > l && (this._$_multisampling$_ = l);
                            } else this._$_multisampling$_ = 0;
                        }
                        0 === this._$_multisampling$_ ? r.renderbufferStorage(r.RENDERBUFFER, o, this._$_width$_, this._$_height$_) : r.renderbufferStorageMultisample(r.RENDERBUFFER, this._$_multisampling$_, o, this._$_width$_, this._$_height$_), 
                        r.bindFramebuffer(r.FRAMEBUFFER, this._$_frameBuffer$_), 
                        r.framebufferRenderbuffer(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.RENDERBUFFER, this._$_renderBuffer$_), 
                        this._$_depth$_ && (r.bindFramebuffer(r.FRAMEBUFFER, this._$_frameBufferNoDepth$_), 
                        r.framebufferRenderbuffer(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.RENDERBUFFER, this._$_renderBuffer$_)), 
                        r.bindRenderbuffer(r.RENDERBUFFER, null);
                    }
                    const n = this._$_renderer$_._$_GetDepthBuffer$_();
                    this._$_depth$_ && n && (r.bindFramebuffer(r.FRAMEBUFFER, this._$_frameBuffer$_), 
                    this._$_renderer$_._$_CanSampleDepth$_() ? r.framebufferTexture2D(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.TEXTURE_2D, n, 0) : r.framebufferRenderbuffer(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.RENDERBUFFER, n)), 
                    r.bindFramebuffer(r.FRAMEBUFFER, null), allRenderTargets.add(this);
                }
                _$_Resize$_(t, e) {
                    if (this._$_width$_ !== t || this._$_height$_ !== e) {
                        this._$_width$_ = t, this._$_height$_ = e, this._$_CalculateProjection$_();
                        const s = this._$_renderer$_._$GetContext$_(), i = (s.bindFramebuffer(s.FRAMEBUFFER, this._$_frameBuffer$_), 
                        this._$_texture$_ ? this._$_texture$_._$_Update$_(new ImageData(this._$_width$_, this._$_height$_)) : (s.bindRenderbuffer(s.RENDERBUFFER, this._$_renderBuffer$_), 
                        s.renderbufferStorage(s.RENDERBUFFER, this._$_alpha$_ ? s.RGBA8 : s.RGB8, this._$_width$_, this._$_height$_), 
                        s.bindRenderbuffer(s.RENDERBUFFER, null)), this._$_renderer$_._$_GetDepthBuffer$_());
                        this._$_depth$_ && i && (this._$_renderer$_._$_CanSampleDepth$_() ? s.framebufferTexture2D(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, s.TEXTURE_2D, i, 0) : s.framebufferRenderbuffer(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, s.RENDERBUFFER, i)), 
                        s.bindFramebuffer(s.FRAMEBUFFER, null);
                    }
                }
                _$_Delete$_() {
                    if (!this._$_texture$_ && !this._$_renderBuffer$_) throw new Error("already deleted render target");
                    allRenderTargets.delete(this);
                    const t = this._$_renderer$_._$GetContext$_(), e = (this._$_texture$_ ? (t.bindFramebuffer(t.FRAMEBUFFER, this._$_frameBuffer$_), 
                    t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, null, 0), 
                    this._$_depth$_ && (t.bindFramebuffer(t.FRAMEBUFFER, this._$_frameBufferNoDepth$_), 
                    t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, null, 0)), 
                    this._$_renderer$_._$DeleteTexture$_(this._$_texture$_), this._$_texture$_ = null) : this._$_renderBuffer$_ && (t.bindFramebuffer(t.FRAMEBUFFER, this._$_frameBuffer$_), 
                    t.framebufferRenderbuffer(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.RENDERBUFFER, null), 
                    this._$_depth$_ && (t.bindFramebuffer(t.FRAMEBUFFER, this._$_frameBufferNoDepth$_), 
                    t.framebufferRenderbuffer(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.RENDERBUFFER, null)), 
                    t.deleteRenderbuffer(this._$_renderBuffer$_), this._$_renderBuffer$_ = null), 
                    t.bindFramebuffer(t.FRAMEBUFFER, null), 2 <= this._$_renderer$_._$GetWebGLVersionNumber$_() && (t.bindFramebuffer(t.READ_FRAMEBUFFER, null), 
                    t.bindFramebuffer(t.DRAW_FRAMEBUFFER, null)), t.deleteFramebuffer(this._$_frameBuffer$_), 
                    this._$_depth$_ && t.deleteFramebuffer(this._$_frameBufferNoDepth$_), 
                    this._$_renderer$_._$GetBatchState$_());
                    e._$currentFramebuffer$_ = null, this._$_frameBuffer$_ = e._$currentFramebufferNoDepth$_ = null;
                }
                _$_CalculateProjection$_() {
                    this._$_renderer$_._$CalculatePerspectiveMatrix$_(this._$_projectionMatrix$_, this._$_width$_ / this._$_height$_), 
                    this._$_lastFov$_ = this._$_renderer$_._$GetFovY$_(), this._$_lastNearZ$_ = this._$_renderer$_._$GetNearZ$_(), 
                    this._$_lastFarZ$_ = this._$_renderer$_._$GetFarZ$_();
                }
                _$_GetFramebuffer$_() {
                    return this._$_frameBuffer$_;
                }
                _$_GetFramebufferNoDepth$_() {
                    return this._$_frameBufferNoDepth$_;
                }
                _$GetRenderer$_() {
                    return this._$_renderer$_;
                }
                _$GetTexture$_() {
                    return this._$_texture$_;
                }
                _$GetProjectionMatrix$_() {
                    return this._$_renderer$_._$GetFovY$_() === this._$_lastFov$_ && this._$_renderer$_._$GetNearZ$_() === this._$_lastNearZ$_ && this._$_renderer$_._$GetFarZ$_() === this._$_lastFarZ$_ || this._$_CalculateProjection$_(), 
                    this._$_projectionMatrix$_;
                }
                _$IsLinearSampling$_() {
                    return "nearest" !== this._$_sampling$_;
                }
                _$HasAlpha$_() {
                    return this._$_alpha$_;
                }
                _$IsSampled$_() {
                    return this._$_isSampled$_;
                }
                _$HasDepthBuffer$_() {
                    return this._$_depth$_;
                }
                _$GetWidth$_() {
                    return this._$_width$_;
                }
                _$GetHeight$_() {
                    return this._$_height$_;
                }
                _$IsDefaultSize$_() {
                    return this._$_isDefaultSize$_;
                }
                _$GetMultisampling$_() {
                    return this._$_multisampling$_;
                }
                _$GetOptions$_() {
                    const t = {
                        _$sampling$_: this._$_sampling$_,
                        alpha: this._$_alpha$_,
                        _$isSampled$_: this._$_isSampled$_
                    };
                    return this._$_isDefaultSize$_ || (t.width = this._$_width$_, 
                    t.height = this._$_height$_), t;
                }
                _$IsCompatibleWithOptions$_(t) {
                    return "nearest" !== (t = Object.assign({}, DEFAULT_RENDERTARGET_OPTIONS, t))._$sampling$_ === this._$IsLinearSampling$_() && !!t.alpha === this._$HasAlpha$_() && !!t.depth === this._$HasDepthBuffer$_() && !(2 <= this._$_renderer$_._$GetWebGLVersionNumber$_() && !!t._$isSampled$_ !== this._$IsSampled$_()) && ("number" == typeof t.width || "number" == typeof t.height ? !this._$IsDefaultSize$_() && this._$GetWidth$_() === Math.floor(t.width) && this._$GetHeight$_() === Math.floor(t.height) : this._$IsDefaultSize$_());
                }
                _$_GetWebGLTexture$_() {
                    return this._$_texture$_ ? this._$_texture$_._$_GetTexture$_() : null;
                }
                _$GetEstimatedMemoryUsage$_() {
                    return this._$_texture$_ ? this._$_texture$_._$GetEstimatedMemoryUsage$_() : this._$_width$_ * this._$_height$_ * (this._$_alpha$_ ? 4 : 3);
                }
                static async _$DebugReadPixelsToBlob$_(t, e) {
                    const s = await t._$ReadBackRenderTargetToImageData$_(e, !0);
                    return C33._$ImageDataToBlob$_(s);
                }
                static _$OnContextLost$_() {
                    allRenderTargets.clear();
                }
                static _$allRenderTargets$_() {
                    return allRenderTargets.values();
                }
                static _$ResizeAll$_(t, e) {
                    for (const s of allRenderTargets) s._$IsDefaultSize$_() && s._$_Resize$_(t, e);
                }
            };
        }
        {
            const C33 = self._$C3$_, glMatrix = self._$glMatrix$_, vec32 = glMatrix._$vec3$_, mat42 = glMatrix._$mat4$_, RESERVED_UNIFORM_NAMES = new Set([ "aPos", "aTex", "aPoints", "matP", "matMV", "samplerFront", "samplerBack", "samplerDepth", "destStart", "destEnd", "srcStart", "srcEnd", "srcOriginStart", "srcOriginEnd", "pixelSize", "seconds", "devicePixelRatio", "layerScale", "layerAngle", "layoutStart", "layoutEnd", "color", "color2_", "pointTexStart", "pointTexEnd", "zElevation", "tileSize", "tileSpacing", "outlineThickness", "zNear", "zFar" ]);
            C33._$Gfx$_._$WebGLShaderProgram$_ = class extends C33._$Gfx$_._$ShaderProgramBase$_ {
                static async _$Compile$_(t, e) {
                    const s = t._$GetContext$_(), i = e.src, r = e._$vertexSrc$_, n = e.name, h = s.createShader(s.FRAGMENT_SHADER), o = (s.shaderSource(h, i), 
                    s.compileShader(h), s.createShader(s.VERTEX_SHADER)), a = (s.shaderSource(o, r), 
                    s.compileShader(o), s.createProgram()), l = (s.attachShader(a, h), 
                    s.attachShader(a, o), s.bindAttribLocation(a, 0, "aPos"), s.bindAttribLocation(a, 1, "aTex"), 
                    s.bindAttribLocation(a, 2, "aPoints"), s.linkProgram(a), t._$_GetParallelShaderCompileExtension$_());
                    if (l ? await t._$_WaitForObjectReady$_(() => s.getProgramParameter(a, l.COMPLETION_STATUS_KHR)) : await C33._$Wait$_(5), 
                    !s.getShaderParameter(h, s.COMPILE_STATUS)) {
                        const c = s.getShaderInfoLog(h);
                        throw s.deleteShader(h), s.deleteShader(o), s.deleteProgram(a), 
                        new Error("Error compiling fragment shader: " + c);
                    }
                    if (!s.getShaderParameter(o, s.COMPILE_STATUS)) {
                        const f = s.getShaderInfoLog(o);
                        throw s.deleteShader(h), s.deleteShader(o), s.deleteProgram(a), 
                        new Error("Error compiling vertex shader: " + f);
                    }
                    if (!s.getProgramParameter(a, s.LINK_STATUS)) {
                        const d = s.getProgramInfoLog(a);
                        throw s.deleteShader(h), s.deleteShader(o), s.deleteProgram(a), 
                        new Error("Error linking shader program: " + d);
                    }
                    const u = C33._$FilterUnprintableChars$_(s.getProgramInfoLog(a) || "").trim();
                    return u && !C33._$IsStringAllWhitespace$_(u) && console.info(`[WebGL] Shader program '${n}' compilation log: `, u), 
                    s.deleteShader(h), s.deleteShader(o), a;
                }
                static async _$Create$_(t, e) {
                    const s = await C33._$Gfx$_._$WebGLShaderProgram$_._$Compile$_(t, e);
                    return new C33._$Gfx$_._$WebGLShaderProgram$_(t, s, e);
                }
                constructor(t, e, s) {
                    super(t, s);
                    const i = t._$GetContext$_(), r = t._$GetBatchState$_(), n = (t._$EndBatch$_(), 
                    i.useProgram(e), this._$_gl$_ = i, this._$_shaderProgram$_ = e, 
                    this._$_isDeviceTransform$_ = "<default-device-transform>" === s.name, 
                    i.getAttribLocation(e, "aPos")), h = i.getAttribLocation(e, "aTex"), o = (this._$_locAPoints$_ = i.getAttribLocation(e, "aPoints"), 
                    -1 !== n && (i.bindBuffer(i.ARRAY_BUFFER, t._$_vertexBuffer$_), 
                    i.vertexAttribPointer(n, t._$GetNumVertexComponents$_(), i.FLOAT, !1, 0, 0), 
                    i.enableVertexAttribArray(n)), -1 !== h && (i.bindBuffer(i.ARRAY_BUFFER, t._$_texcoordBuffer$_), 
                    i.vertexAttribPointer(h, 2, i.FLOAT, !1, 0, 0), i.enableVertexAttribArray(h)), 
                    -1 !== this._$_locAPoints$_ && (i.bindBuffer(i.ARRAY_BUFFER, t._$_pointBuffer$_), 
                    i.vertexAttribPointer(this._$_locAPoints$_, 4, i.FLOAT, !1, 0, 0), 
                    i.enableVertexAttribArray(this._$_locAPoints$_)), i.bindBuffer(i.ARRAY_BUFFER, null), 
                    this._$_uMatP$_ = new C33._$Gfx$_._$WebGLShaderUniform$_(this, "matP", "mat4"), 
                    this._$_uMatMV$_ = new C33._$Gfx$_._$WebGLShaderUniform$_(this, "matMV", "mat4"), 
                    this._$_uColor$_ = new C33._$Gfx$_._$WebGLShaderUniform$_(this, "color", "vec4"), 
                    this._$_uSamplerFront$_ = new C33._$Gfx$_._$WebGLShaderUniform$_(this, "samplerFront", "sampler"), 
                    this._$_uPointTexStart$_ = new C33._$Gfx$_._$WebGLShaderUniform$_(this, "pointTexStart", "vec2"), 
                    this._$_uPointTexEnd$_ = new C33._$Gfx$_._$WebGLShaderUniform$_(this, "pointTexEnd", "vec2"), 
                    this._$_uZElevation$_ = new C33._$Gfx$_._$WebGLShaderUniform$_(this, "zElevation", "float"), 
                    this._$_uTileSize$_ = new C33._$Gfx$_._$WebGLShaderUniform$_(this, "tileSize", "vec2"), 
                    this._$_uTileSpacing$_ = new C33._$Gfx$_._$WebGLShaderUniform$_(this, "tileSpacing", "vec2"), 
                    this._$_uColor2$_ = new C33._$Gfx$_._$WebGLShaderUniform$_(this, "color2_", "vec4"), 
                    this._$_uOutlineThickness$_ = new C33._$Gfx$_._$WebGLShaderUniform$_(this, "outlineThickness", "float"), 
                    this._$_uSamplerBack$_ = new C33._$Gfx$_._$WebGLShaderUniform$_(this, "samplerBack", "sampler"), 
                    this._$_uSamplerDepth$_ = new C33._$Gfx$_._$WebGLShaderUniform$_(this, "samplerDepth", "sampler"), 
                    this._$_uDestStart$_ = new C33._$Gfx$_._$WebGLShaderUniform$_(this, "destStart", "vec2"), 
                    this._$_uDestEnd$_ = new C33._$Gfx$_._$WebGLShaderUniform$_(this, "destEnd", "vec2"), 
                    this._$_uSrcStart$_ = new C33._$Gfx$_._$WebGLShaderUniform$_(this, "srcStart", "vec2"), 
                    this._$_uSrcEnd$_ = new C33._$Gfx$_._$WebGLShaderUniform$_(this, "srcEnd", "vec2"), 
                    this._$_uSrcOriginStart$_ = new C33._$Gfx$_._$WebGLShaderUniform$_(this, "srcOriginStart", "vec2"), 
                    this._$_uSrcOriginEnd$_ = new C33._$Gfx$_._$WebGLShaderUniform$_(this, "srcOriginEnd", "vec2"), 
                    this._$_uPixelSize$_ = new C33._$Gfx$_._$WebGLShaderUniform$_(this, "pixelSize", "vec2"), 
                    this._$_uSeconds$_ = new C33._$Gfx$_._$WebGLShaderUniform$_(this, "seconds", "float"), 
                    this._$_uDevicePixelRatio$_ = new C33._$Gfx$_._$WebGLShaderUniform$_(this, "devicePixelRatio", "float"), 
                    this._$_uLayerScale$_ = new C33._$Gfx$_._$WebGLShaderUniform$_(this, "layerScale", "float"), 
                    this._$_uLayerAngle$_ = new C33._$Gfx$_._$WebGLShaderUniform$_(this, "layerAngle", "float"), 
                    this._$_uLayoutStart$_ = new C33._$Gfx$_._$WebGLShaderUniform$_(this, "layoutStart", "vec2"), 
                    this._$_uLayoutEnd$_ = new C33._$Gfx$_._$WebGLShaderUniform$_(this, "layoutEnd", "vec2"), 
                    this._$_uZNear$_ = new C33._$Gfx$_._$WebGLShaderUniform$_(this, "zNear", "float"), 
                    this._$_uZFar$_ = new C33._$Gfx$_._$WebGLShaderUniform$_(this, "zFar", "float"), 
                    this._$_hasAnyOptionalUniforms$_ = !!(this._$_uPixelSize$_._$IsUsed$_() || this._$_uSeconds$_._$IsUsed$_() || this._$_uSamplerBack$_._$IsUsed$_() || this._$_uDestStart$_._$IsUsed$_() || this._$_uDestEnd$_._$IsUsed$_() || this._$_uSrcStart$_._$IsUsed$_() || this._$_uSrcEnd$_._$IsUsed$_() || this._$_uSrcOriginStart$_._$IsUsed$_() || this._$_uSrcOriginEnd$_._$IsUsed$_() || this._$_uDevicePixelRatio$_._$IsUsed$_() || this._$_uLayerScale$_._$IsUsed$_() || this._$_uLayerAngle$_._$IsUsed$_() || this._$_uLayoutStart$_._$IsUsed$_() || this._$_uLayoutEnd$_._$IsUsed$_()), 
                    s.parameters || []);
                    this._$_uCustomParameters$_ = [], this._$_usesAnySrcRectOrPixelSize$_ = this._$_uPixelSize$_._$IsUsed$_() || this._$_uSrcStart$_._$IsUsed$_() || this._$_uSrcEnd$_._$IsUsed$_() || this._$_uSrcOriginStart$_._$IsUsed$_() || this._$_uSrcOriginEnd$_._$IsUsed$_(), 
                    this._$_hasCurrentMatP$_ = !1, this._$_hasCurrentMatMV$_ = !1, 
                    this._$_uColor$_._$Init4f$_(1, 1, 1, 1), this._$_uColor2$_._$Init4f$_(1, 1, 1, 1), 
                    this._$_uSamplerFront$_._$Init1i$_(0), this._$_uSamplerBack$_._$Init1i$_(1), 
                    this._$_uSamplerDepth$_._$Init1i$_(2), this._$_uPointTexStart$_._$Init2f$_(0, 0), 
                    this._$_uPointTexEnd$_._$Init2f$_(1, 1), this._$_uZElevation$_._$Init1f$_(0), 
                    this._$_uTileSize$_._$Init2f$_(0, 0), this._$_uTileSpacing$_._$Init2f$_(0, 0), 
                    this._$_uDestStart$_._$Init2f$_(0, 0), this._$_uDestEnd$_._$Init2f$_(1, 1), 
                    this._$_uSrcStart$_._$Init2f$_(0, 0), this._$_uSrcEnd$_._$Init2f$_(0, 0), 
                    this._$_uSrcOriginStart$_._$Init2f$_(0, 0), this._$_uSrcOriginEnd$_._$Init2f$_(0, 0), 
                    this._$_uPixelSize$_._$Init2f$_(0, 0), this._$_uDevicePixelRatio$_._$Init1f$_(1), 
                    this._$_uZNear$_._$Init1f$_(t._$GetNearZ$_()), this._$_uZFar$_._$Init1f$_(t._$GetFarZ$_()), 
                    this._$_uLayerScale$_._$Init1f$_(1), this._$_uLayerAngle$_._$Init1f$_(0), 
                    this._$_uSeconds$_._$Init1f$_(0), this._$_uLayoutStart$_._$Init2f$_(0, 0), 
                    this._$_uLayoutEnd$_._$Init2f$_(0, 0), this._$_uOutlineThickness$_._$Init1f$_(1);
                    for (const l of o) {
                        const u = l[0], c = l[2], f = new C33._$Gfx$_._$WebGLShaderUniform$_(this, u, c);
                        "color" === c ? f._$Init3f$_(0, 0, 0) : f._$Init1f$_(0), 
                        this._$_uCustomParameters$_.push(f);
                    }
                    this._$_isDeviceTransform$_ ? this._$_UpdateDeviceTransformUniforms$_(r._$currentMatP$_) : (this._$UpdateMatP$_(r._$currentMatP$_, !0), 
                    this._$UpdateMatMV$_(r._$currentMV$_, !0));
                    const a = r._$currentShader$_;
                    i.useProgram(a ? a._$_shaderProgram$_ : null);
                }
                _$Release$_() {
                    this._$_gl$_.deleteProgram(this._$_shaderProgram$_), this._$_shaderProgram$_ = null, 
                    this._$_renderer$_._$_RemoveShaderProgram$_(this), this._$_gl$_ = null, 
                    super._$Release$_();
                }
                _$GetWebGLContext$_() {
                    return this._$_gl$_;
                }
                _$GetShaderProgram$_() {
                    return this._$_shaderProgram$_;
                }
                _$GetParameterCount$_() {
                    return this._$_uCustomParameters$_.length;
                }
                _$GetParameterType$_(t) {
                    return t < 0 || t >= this._$_uCustomParameters$_.length ? null : this._$_uCustomParameters$_[t]._$GetType$_();
                }
                _$AreCustomParametersAlreadySetInBatch$_(s) {
                    for (let t = 0, e = s.length; t < e; ++t) if (!this._$_uCustomParameters$_[t]._$IsSetToCustomInBatch$_(s[t])) return !1;
                    return !0;
                }
                _$SetCustomParametersInBatch$_(s) {
                    for (let t = 0, e = s.length; t < e; ++t) this._$_uCustomParameters$_[t]._$SetBatchValueCustom$_(s[t]);
                }
                _$AreOptionalUniformsAlreadySetInBatch$_(t, e, s, i, r, n, h, o, a, l) {
                    return !this._$_uSamplerBack$_._$IsUsed$_() && !(this._$_uPixelSize$_._$IsUsed$_() && !this._$_uPixelSize$_._$IsSetTo2InBatch$_(r, n) || this._$_uDestStart$_._$IsUsed$_() && !this._$_uDestStart$_._$IsSetTo2InBatch$_(t._$getLeft$_(), t._$getTop$_()) || this._$_uDestEnd$_._$IsUsed$_() && !this._$_uDestEnd$_._$IsSetTo2InBatch$_(t._$getRight$_(), t._$getBottom$_()) || this._$_uDevicePixelRatio$_._$IsUsed$_() && !this._$_uDevicePixelRatio$_._$IsSetTo1InBatch$_(h) || this._$_uLayerScale$_._$IsUsed$_() && !this._$_uLayerScale$_._$IsSetTo1InBatch$_(o) || this._$_uLayerAngle$_._$IsUsed$_() && !this._$_uLayerAngle$_._$IsSetTo1InBatch$_(a) || this._$_uSrcStart$_._$IsUsed$_() && !this._$_uSrcStart$_._$IsSetTo2InBatch$_(e._$getLeft$_(), e._$getTop$_()) || this._$_uSrcEnd$_._$IsUsed$_() && !this._$_uSrcEnd$_._$IsSetTo2InBatch$_(e._$getRight$_(), e._$getBottom$_()) || this._$_uSrcOriginStart$_._$IsUsed$_() && !this._$_uSrcOriginStart$_._$IsSetTo2InBatch$_(s._$getLeft$_(), s._$getTop$_()) || this._$_uSrcOriginEnd$_._$IsUsed$_() && !this._$_uSrcOriginEnd$_._$IsSetTo2InBatch$_(s._$getRight$_(), s._$getBottom$_()) || this._$_uLayoutStart$_._$IsUsed$_() && !this._$_uLayoutStart$_._$IsSetTo2InBatch$_(i._$getLeft$_(), i._$getTop$_()) || this._$_uLayoutEnd$_._$IsUsed$_() && !this._$_uLayoutEnd$_._$IsSetTo2InBatch$_(i._$getTop$_(), i._$getBottom$_()) || this._$_uSeconds$_._$IsUsed$_() && !this._$_uSeconds$_._$IsSetTo1InBatch$_(l));
                }
                _$SetOptionalUniformsInBatch$_(t, e, s, i, r, n, h, o, a, l) {
                    this._$_uSamplerBack$_._$IsUsed$_() || (this._$_uPixelSize$_._$IsUsed$_() && this._$_uPixelSize$_._$SetBatch2$_(r, n), 
                    this._$_uDestStart$_._$IsUsed$_() && this._$_uDestStart$_._$SetBatch2$_(t._$getLeft$_(), t._$getTop$_()), 
                    this._$_uDestEnd$_._$IsUsed$_() && this._$_uDestEnd$_._$SetBatch2$_(t._$getRight$_(), t._$getBottom$_()), 
                    this._$_uDevicePixelRatio$_._$IsUsed$_() && this._$_uDevicePixelRatio$_._$SetBatch1$_(h), 
                    this._$_uLayerScale$_._$IsUsed$_() && this._$_uLayerScale$_._$SetBatch1$_(o), 
                    this._$_uLayerAngle$_._$IsUsed$_() && this._$_uLayerAngle$_._$SetBatch1$_(a), 
                    this._$_uSrcStart$_._$IsUsed$_() && this._$_uSrcStart$_._$SetBatch2$_(e._$getLeft$_(), e._$getTop$_()), 
                    this._$_uSrcEnd$_._$IsUsed$_() && this._$_uSrcEnd$_._$SetBatch2$_(e._$getRight$_(), e._$getBottom$_()), 
                    this._$_uSrcOriginStart$_._$IsUsed$_() && this._$_uSrcOriginStart$_._$SetBatch2$_(s._$getLeft$_(), s._$getTop$_()), 
                    this._$_uSrcOriginEnd$_._$IsUsed$_() && this._$_uSrcOriginEnd$_._$SetBatch2$_(s._$getRight$_(), s._$getBottom$_()), 
                    this._$_uLayoutStart$_._$IsUsed$_() && this._$_uLayoutStart$_._$SetBatch2$_(i._$getLeft$_(), i._$getTop$_()), 
                    this._$_uLayoutEnd$_._$IsUsed$_() && this._$_uLayoutEnd$_._$SetBatch2$_(i._$getTop$_(), i._$getBottom$_()), 
                    this._$_uSeconds$_._$IsUsed$_() && this._$_uSeconds$_._$SetBatch1$_(l));
                }
                _$UpdateMatP$_(t, e) {
                    this._$_hasCurrentMatP$_ && !e || this._$_isDeviceTransform$_ || (this._$_uMatP$_._$IsUsed$_() && this._$_uMatP$_._$UpdateMatrix4fv$_(t), 
                    this._$_hasCurrentMatP$_ = !0);
                }
                _$SetMatPStale$_() {
                    this._$_hasCurrentMatP$_ = !1;
                }
                _$UpdateMatMV$_(t, e) {
                    this._$_hasCurrentMatMV$_ && !e || this._$_isDeviceTransform$_ || (this._$_uMatMV$_._$IsUsed$_() && this._$_uMatMV$_._$UpdateMatrix4fv$_(t), 
                    this._$_hasCurrentMatMV$_ = !0);
                }
                _$SetMatMVStale$_() {
                    this._$_hasCurrentMatMV$_ = !1;
                }
                _$_UpdateDeviceTransformUniforms$_(t) {
                    if (!this._$_isDeviceTransform$_) throw new Error("not device transform shader");
                    this._$_uMatP$_._$UpdateMatrix4fv$_(t);
                    const e = this._$_renderer$_, s = e._$GetWidth$_() / 2, i = e._$GetHeight$_() / 2, r = e._$CalculateLookAtModelView2$_(s, i, e._$GetDefaultCameraZ$_(e._$GetHeight$_()), s, i, 0, e._$GetHeight$_());
                    this._$_uMatMV$_._$UpdateMatrix4fv$_(r);
                }
                _$UpdateColor$_(t) {
                    this._$_uColor$_._$IsUsed$_() && this._$_uColor$_._$Update4f$_(t[0], t[1], t[2], t[3]);
                }
                static _$GetReservedUniformNames$_() {
                    return RESERVED_UNIFORM_NAMES;
                }
                static _$GetDefaultVertexShaderSource$_(t) {
                    const e = t ? "highmedp" : "mediump";
                    return [ "#ifdef GL_FRAGMENT_PRECISION_HIGH", "#define highmedp highp", "#else", "#define highmedp mediump", "#endif", "attribute highp vec3 aPos;", `attribute ${e} vec2 aTex;`, `varying ${e} vec2 vTex;`, "uniform highp mat4 matP;", "uniform highp mat4 matMV;", "void main(void) {", `	gl_Position = matP * matMV * vec4(aPos, 1.0);`, `	vTex = aTex;`, "}" ].join("\n");
                }
                static _$GetDefaultVertexShaderSource_WebGL2$_(t) {
                    const e = t ? "highp" : "mediump";
                    return [ "#version 300 es", "in highp vec3 aPos;", `in ${e} vec2 aTex;`, `out ${e} vec2 vTex;`, "uniform highp mat4 matP;", "uniform highp mat4 matMV;", "void main(void) {", `	gl_Position = matP * matMV * vec4(aPos, 1.0);`, `	vTex = aTex;`, "}" ].join("\n");
                }
                static _$GetTextureFillFragmentShaderSource_WebGL1_NoFragDepth$_() {
                    return [ "varying mediump vec2 vTex;", "uniform lowp vec4 color;", "uniform lowp sampler2D samplerFront;", "void main(void) {", "\tgl_FragColor = texture2D(samplerFront, vTex) * color;", "}" ].join("\n");
                }
                static _$GetTextureFillFragmentShaderSource_WebGL1_FragDepthEXT$_() {
                    return [ "#extension GL_EXT_frag_depth : enable", "varying mediump vec2 vTex;", "uniform lowp vec4 color;", "uniform lowp sampler2D samplerFront;", "void main(void) {", "\tgl_FragColor = texture2D(samplerFront, vTex) * color;", "\tgl_FragDepthEXT = (gl_FragColor.a == 0.0 ? 1.0 : gl_FragCoord.z);", "}" ].join("\n");
                }
                static _$GetTextureFillFragmentShaderSource_WebGL2$_() {
                    return [ "#version 300 es", "in mediump vec2 vTex;", "out lowp vec4 outColor;", "uniform lowp vec4 color;", "uniform lowp sampler2D samplerFront;", "void main(void) {", "\toutColor = texture(samplerFront, vTex) * color;", "\tgl_FragDepth = (outColor.a == 0.0 ? 1.0 : gl_FragCoord.z);", "}" ].join("\n");
                }
                static _$GetTilemapFragmentShaderSource_WebGL1_NoFragDepth$_() {
                    return [ "#ifdef GL_FRAGMENT_PRECISION_HIGH", "#define highmedp highp", "#else", "#define highmedp mediump", "#endif", "varying highmedp vec2 vTex;", "uniform lowp vec4 color;", "uniform lowp sampler2D samplerFront;", "uniform highmedp vec2 srcStart;", "uniform highmedp vec2 pixelSize;", "uniform highmedp vec2 tileSize;", "uniform highmedp vec2 tileSpacing;", "void main(void) {", "\thighmedp vec2 tile = floor(vTex);", "\thighmedp vec2 tex = fract(vTex);", "\thighmedp vec2 tileOrigin = srcStart + tile * (tileSize + tileSpacing);", "\thighmedp vec2 lowerBound = tileOrigin + pixelSize / 2.0;", "\thighmedp vec2 upperBound = tileOrigin + tileSize - pixelSize / 2.0;", "\tgl_FragColor = texture2D(samplerFront, clamp(tex, lowerBound, upperBound), -16.0) * color;", "}" ].join("\n");
                }
                static _$GetTilemapFragmentShaderSource_WebGL1_FragDepthEXT$_() {
                    return [ "#extension GL_EXT_frag_depth : enable", "#ifdef GL_FRAGMENT_PRECISION_HIGH", "#define highmedp highp", "#else", "#define highmedp mediump", "#endif", "varying highmedp vec2 vTex;", "uniform lowp vec4 color;", "uniform lowp sampler2D samplerFront;", "uniform highmedp vec2 srcStart;", "uniform highmedp vec2 pixelSize;", "uniform highmedp vec2 tileSize;", "uniform highmedp vec2 tileSpacing;", "void main(void) {", "\thighmedp vec2 tile = floor(vTex);", "\thighmedp vec2 tex = fract(vTex);", "\thighmedp vec2 tileOrigin = srcStart + tile * (tileSize + tileSpacing);", "\thighmedp vec2 lowerBound = tileOrigin + pixelSize / 2.0;", "\thighmedp vec2 upperBound = tileOrigin + tileSize - pixelSize / 2.0;", "\tgl_FragColor = texture2D(samplerFront, clamp(tex, lowerBound, upperBound), -16.0) * color;", "\tgl_FragDepthEXT = (gl_FragColor.a == 0.0 ? 1.0 : gl_FragCoord.z);", "}" ].join("\n");
                }
                static _$GetTilemapFragmentShaderSource_WebGL2$_() {
                    return [ "#version 300 es", "in highp vec2 vTex;", "out lowp vec4 outColor;", "uniform lowp vec4 color;", "uniform lowp sampler2D samplerFront;", "uniform highp vec2 srcStart;", "uniform highp vec2 pixelSize;", "uniform highp vec2 tileSize;", "uniform highp vec2 tileSpacing;", "void main(void) {", "\thighp vec2 tile = floor(vTex);", "\thighp vec2 tex = fract(vTex);", "\thighp vec2 tileOrigin = srcStart + tile * (tileSize + tileSpacing);", "\thighp vec2 lowerBound = tileOrigin + pixelSize / 2.0;", "\thighp vec2 upperBound = tileOrigin + tileSize - pixelSize / 2.0;", "\toutColor = texture(samplerFront, clamp(tex, lowerBound, upperBound), -16.0) * color;", "\tgl_FragDepth = (outColor.a == 0.0 ? 1.0 : gl_FragCoord.z);", "}" ].join("\n");
                }
                static _$GetTileRandomizationFragmentShaderSource$_(t, e, s) {
                    let i = "";
                    return 2 <= t ? i = "#version 300 es\n" : (e && (i = "#extension GL_EXT_frag_depth : enable\n"), 
                    s && (i += "#extension GL_EXT_shader_texture_lod : enable\n#extension GL_OES_standard_derivatives : enable\n")), 
                    i + `
#ifdef GL_FRAGMENT_PRECISION_HIGH
#define highmedp highp
#else
#define highmedp mediump
#endif
precision highmedp float;
${2 <= t ? "in" : "varying"} vec2 vTex;
${2 <= t ? "out lowp vec4 outColor;" : ""}
uniform lowp vec4 color;
uniform lowp sampler2D samplerFront;
uniform vec2 pixelSize;

uniform vec2 tileSize;
uniform vec2 tileSpacing;
uniform float outlineThickness;

const float PI = 3.1415926;

lowp vec4 cospVec4(lowp vec4 a, lowp vec4 b, float x)
{
	return (a + b + (a - b) * cos(x * PI)) / 2.0;
}

vec3 randVec3(vec2 seed)
{
	return vec3(fract(sin(dot(seed.xy + vec2(0.1, 0.1), vec2(12.9898,78.233))) * 43758.5453),
				fract(sin(dot(seed.yx + vec2(0.1, 0.1), vec2(12.9898,-78.233))) * 43758.5453),
				fract(sin(dot(seed.xy + vec2(0.1, 0.1), vec2(-12.9898,-78.233))) * 43758.5453));
}

lowp vec4 sampleTile(vec2 tile, vec2 uv, vec2 ddx, vec2 ddy)
{
	vec2 posRandom = tileSize;
	float angleRandom = outlineThickness;
	
	vec3 rand = (randVec3(floor(tile + 0.5)) - 0.5) * 2.0;
	
	float angle = angleRandom * rand.z * PI;
	float sin_a = sin(angle);
	float cos_a = cos(angle);
	float aspect = pixelSize.x / pixelSize.y;

	vec2 mid = tile + vec2(0.5, 0.5);
	vec2 dp = uv - mid;
	dp.x /= aspect;
	vec2 r = vec2(dp.x * cos_a - dp.y * sin_a,
				  dp.y * cos_a + dp.x * sin_a);
	r.x *= aspect;

	vec2 p = mid + r + (posRandom * rand.xy / 2.0);
	
	${2 <= t ? "return textureGrad(samplerFront, p, ddx, ddy);" : ""}
	${t < 2 && s ? "return texture2DGradEXT(samplerFront, p, ddx, ddy);" : ""}
	${t < 2 && !s ? "return texture2D(samplerFront, p);" : ""}
}

void main(void) {
	
	${t < 2 ? "lowp vec4 outColor;" : ""}
	
	float blendMarginX = tileSpacing.x;
	float blendMarginY = tileSpacing.y;
	
	vec2 tile = floor(vTex);
	vec2 tex = fract(vTex);
	vec2 ddx = ${2 <= t || s ? "dFdx(vTex)" : "vec2(0.0, 0.0)"};
	vec2 ddy = ${2 <= t || s ? "dFdy(vTex)" : "vec2(0.0, 0.0)"};
	
	vec4 curTile = sampleTile(tile, vTex, ddx, ddy);
	
	bool inLeftMargin = (tex.x < blendMarginX);
	bool inRightMargin = (tex.x > 1.0 - blendMarginX);
	bool inTopMargin = (tex.y < blendMarginY);
	bool inBottomMargin = (tex.y > 1.0 - blendMarginY);
	
	if (inLeftMargin)
	{
		lowp vec4 leftTile = sampleTile(tile + vec2(-1.0, 0.0), vTex, ddx, ddy);
		float leftMix = (tex.x / (blendMarginX * 2.0)) + 0.5;
		lowp vec4 leftMixedTile = cospVec4(leftTile, curTile, leftMix);
		
		if (inTopMargin)
		{
			lowp vec4 topTile =     sampleTile(tile + vec2(0.0,  -1.0), vTex, ddx, ddy);
			lowp vec4 topLeftTile = sampleTile(tile + vec2(-1.0, -1.0), vTex, ddx, ddy);
			lowp vec4 topLeftMixedTile = cospVec4(topLeftTile, topTile, leftMix);
			
			outColor = cospVec4(topLeftMixedTile, leftMixedTile, (tex.y / (blendMarginY * 2.0)) + 0.5);
		}
		else if (inBottomMargin)
		{
			lowp vec4 bottomTile =     sampleTile(tile + vec2(0.0,  1.0), vTex, ddx, ddy);
			lowp vec4 bottomLeftTile = sampleTile(tile + vec2(-1.0, 1.0), vTex, ddx, ddy);
			lowp vec4 bottomLeftMixedTile = cospVec4(bottomLeftTile, bottomTile, leftMix);
			
			outColor = cospVec4(leftMixedTile, bottomLeftMixedTile, (tex.y - (1.0 - blendMarginY)) / (blendMarginY * 2.0));
		}
		else
		{
			outColor = leftMixedTile;
		}
	}
	else if (inRightMargin)
	{
		lowp vec4 rightTile = sampleTile(tile + vec2(1.0, 0.0), vTex, ddx, ddy);
		float rightMix = (tex.x - (1.0 - blendMarginX)) / (blendMarginX * 2.0);
		lowp vec4 rightMixedTile = cospVec4(curTile, rightTile, rightMix);
		
		if (inTopMargin)
		{
			lowp vec4 topTile =      sampleTile(tile + vec2(0.0, -1.0), vTex, ddx, ddy);
			lowp vec4 topRightTile = sampleTile(tile + vec2(1.0, -1.0), vTex, ddx, ddy);
			lowp vec4 topRightMixedTile = cospVec4(topTile, topRightTile, rightMix);
			
			outColor = cospVec4(topRightMixedTile, rightMixedTile, (tex.y / (blendMarginY * 2.0)) + 0.5);
		}
		else if (inBottomMargin)
		{
			lowp vec4 bottomTile =      sampleTile(tile + vec2(0.0, 1.0), vTex, ddx, ddy);
			lowp vec4 bottomRightTile = sampleTile(tile + vec2(1.0, 1.0), vTex, ddx, ddy);
			lowp vec4 bottomRightMixedTile = cospVec4(bottomTile, bottomRightTile, rightMix);
			
			outColor = cospVec4(rightMixedTile, bottomRightMixedTile, (tex.y - (1.0 - blendMarginY)) / (blendMarginY * 2.0));
		}
		else
		{
			outColor = rightMixedTile;
		}
	}
	else if (inTopMargin)
	{
		lowp vec4 topTile = sampleTile(tile + vec2(0.0, -1.0), vTex, ddx, ddy);
		outColor = cospVec4(topTile, curTile, (tex.y / (blendMarginY * 2.0)) + 0.5);
	}
	else if (inBottomMargin)
	{
		lowp vec4 bottomTile = sampleTile(tile + vec2(0.0, 1.0), vTex, ddx, ddy);
		outColor = cospVec4(curTile, bottomTile, (tex.y - (1.0 - blendMarginY)) / (blendMarginY * 2.0));
	}
	else
	{
		outColor = curTile;
	}
	
	outColor *= color;
	${t < 2 ? "gl_FragColor = outColor;" : ""}
	${2 <= t ? "gl_FragDepth = (outColor.a == 0.0 ? 1.0 : gl_FragCoord.z);" : ""}
	${t < 2 && e ? "gl_FragDepthEXT = (outColor.a == 0.0 ? 1.0 : gl_FragCoord.z);" : ""}
}
`;
                }
                static _$GetPointVertexShaderSource_WebGL1$_() {
                    return [ "attribute vec4 aPoints;", "varying float pointOpacity;", "uniform float zElevation;", "uniform mat4 matP;", "uniform mat4 matMV;", "void main(void) {", "\tgl_Position = matP * matMV * vec4(aPoints.xy, zElevation, 1.0);", "\tgl_PointSize = aPoints.z;", "\tpointOpacity = aPoints.w;", "}" ].join("\n");
                }
                static _$GetPointVertexShaderSource_WebGL2$_() {
                    return [ "#version 300 es", "in vec4 aPoints;", "out float pointOpacity;", "uniform float zElevation;", "uniform mat4 matP;", "uniform mat4 matMV;", "void main(void) {", "\tgl_Position = matP * matMV * vec4(aPoints.xy, zElevation, 1.0);", "\tgl_PointSize = aPoints.z;", "\tpointOpacity = aPoints.w;", "}" ].join("\n");
                }
                static _$GetPointFragmentShaderSource_WebGL1_NoFragDepth$_() {
                    return [ "uniform lowp sampler2D samplerFront;", "varying lowp float pointOpacity;", "uniform mediump vec2 pointTexStart;", "uniform mediump vec2 pointTexEnd;", "uniform lowp vec4 color;", "void main(void) {", "\tmediump vec2 pointTexMin = min(pointTexStart, pointTexEnd);", "\tmediump vec2 pointTexMax = max(pointTexStart, pointTexEnd);", "\tmediump vec2 pointCoord = (pointTexEnd.x > pointTexStart.x ? gl_PointCoord : vec2(1.0 - gl_PointCoord.y, gl_PointCoord.x));", "\tgl_FragColor = texture2D(samplerFront, mix(pointTexMin, pointTexMax, pointCoord)) * color * pointOpacity;", "}" ].join("\n");
                }
                static _$GetPointFragmentShaderSource_WebGL1_FragDepthEXT$_() {
                    return [ "#extension GL_EXT_frag_depth : enable", "uniform lowp sampler2D samplerFront;", "varying lowp float pointOpacity;", "uniform mediump vec2 pointTexStart;", "uniform mediump vec2 pointTexEnd;", "uniform lowp vec4 color;", "void main(void) {", "\tmediump vec2 pointTexMin = min(pointTexStart, pointTexEnd);", "\tmediump vec2 pointTexMax = max(pointTexStart, pointTexEnd);", "\tmediump vec2 pointCoord = (pointTexEnd.x > pointTexStart.x ? gl_PointCoord : vec2(1.0 - gl_PointCoord.y, gl_PointCoord.x));", "\tgl_FragColor = texture2D(samplerFront, mix(pointTexMin, pointTexMax, pointCoord)) * color * pointOpacity;", "\tgl_FragDepthEXT = (gl_FragColor.a == 0.0 ? 1.0 : gl_FragCoord.z);", "}" ].join("\n");
                }
                static _$GetPointFragmentShaderSource_WebGL2$_() {
                    return [ "#version 300 es", "uniform lowp sampler2D samplerFront;", "in lowp float pointOpacity;", "uniform mediump vec2 pointTexStart;", "uniform mediump vec2 pointTexEnd;", "uniform lowp vec4 color;", "out lowp vec4 outColor;", "void main(void) {", "\tmediump vec2 pointTexMin = min(pointTexStart, pointTexEnd);", "\tmediump vec2 pointTexMax = max(pointTexStart, pointTexEnd);", "\tmediump vec2 pointCoord = (pointTexEnd.x > pointTexStart.x ? gl_PointCoord : vec2(1.0 - gl_PointCoord.y, gl_PointCoord.x));", "\toutColor = texture(samplerFront, mix(pointTexMin, pointTexMax, pointCoord)) * color * pointOpacity;", "\tgl_FragDepth = (outColor.a == 0.0 ? 1.0 : gl_FragCoord.z);", "}" ].join("\n");
                }
                static _$GetColorFillFragmentShaderSource$_() {
                    return [ "uniform lowp vec4 color;", "void main(void) {", "\tgl_FragColor = color;", "}" ].join("\n");
                }
                static _$GetLinearGradientFillFragmentShaderSource$_() {
                    return [ "precision lowp float;", "varying mediump vec2 vTex;", "uniform vec4 color;", "uniform vec4 color2_;", "vec3 fromLinear(vec3 linearRGB)", "{", "\tbvec3 cutoff = lessThan(linearRGB, vec3(0.0031308));", "\tvec3 higher = vec3(1.055) * pow(abs(linearRGB), vec3(1.0/2.4)) - vec3(0.055);", "\tvec3 lower = linearRGB * vec3(12.92);", "\treturn mix(higher, lower, vec3(cutoff));", "}", "vec3 toLinear(vec3 sRGB)", "{", "\tbvec3 cutoff = lessThan(sRGB, vec3(0.04045));", "\tvec3 higher = pow(abs((sRGB + vec3(0.055))/vec3(1.055)), vec3(2.4));", "\tvec3 lower = sRGB/vec3(12.92);", "\treturn mix(higher, lower, vec3(cutoff));", "}", "void main(void) {", "\tvec3 linearGrad = mix(toLinear(color.rgb), toLinear(color2_.rgb), vTex.x);", "\tfloat a = mix(color.a, color2_.a, vTex.x);", "\tgl_FragColor = vec4(fromLinear(linearGrad) * a, a);", "}" ].join("\n");
                }
                static _$GetPenumbraFillFragmentShaderSource$_() {
                    return [ "#ifdef GL_FRAGMENT_PRECISION_HIGH", "#define highmedp highp", "#else", "#define highmedp mediump", "#endif", "precision lowp float;", "varying highmedp vec2 vTex;", "uniform vec4 color;", "void main(void) {", `	highmedp float grad = vTex.x / (1.0 - vTex.y);`, `	gl_FragColor = color * (1.0 - (cos(grad * 3.141592653589793) + 1.0) / 2.0);`, "}" ].join("\n");
                }
                static _$GetSmoothLineFillFragmentShaderSource$_() {
                    return [ "varying mediump vec2 vTex;", "uniform lowp vec4 color;", "void main(void) {", "\tlowp float f = 1.0 - abs(vTex.y - 0.5) * 2.0;", "\tgl_FragColor = color * f;", "}" ].join("\n");
                }
                static _$GetHardEllipseFillFragmentShaderSource$_() {
                    return [ "varying mediump vec2 vTex;", "uniform lowp vec4 color;", "void main(void) {", "\tmediump vec2 diff = vTex - vec2(0.5, 0.5);", "\tmediump vec2 diffSq = diff * diff;", "\tmediump float f = step(diffSq.x + diffSq.y, 0.25);", "\tgl_FragColor = color * f;", "}" ].join("\n");
                }
                static _$GetHardEllipseOutlineFragmentShaderSource$_() {
                    return [ "varying mediump vec2 vTex;", "uniform lowp vec4 color;", "uniform mediump vec2 pixelSize;", "uniform mediump float outlineThickness;", "void main(void) {", "\tmediump vec2 diff = vTex - vec2(0.5, 0.5);", "\tmediump vec2 diffSq = diff * diff;", "\tmediump float distSq = diffSq.x + diffSq.y;", "\tmediump vec2 norm = normalize(diff);", "\tmediump vec2 halfNorm = norm * 0.5;", "\tmediump float innerF = step(distSq, 0.25);", "\tmediump vec2 innerEdge = halfNorm - pixelSize * norm * outlineThickness;", "\tmediump vec2 innerEdgeSq = innerEdge * innerEdge;", "\tmediump float outerF = step(innerEdgeSq.x + innerEdgeSq.y, distSq);", "\tgl_FragColor = color * innerF * outerF;", "}" ].join("\n");
                }
                static _$GetSmoothEllipseFillFragmentShaderSource$_() {
                    return [ "varying mediump vec2 vTex;", "uniform lowp vec4 color;", "uniform mediump vec2 pixelSize;", "void main(void) {", "\tmediump vec2 diff = vTex - vec2(0.5, 0.5);", "\tmediump vec2 diffSq = diff * diff;", "\tmediump vec2 norm = normalize(diff);", "\tmediump vec2 halfNorm = norm * 0.5;", "\tmediump vec2 halfNormSq = halfNorm * halfNorm;", "\tmediump vec2 innerEdge = halfNorm - pixelSize * norm;", "\tmediump vec2 innerEdgeSq = innerEdge * innerEdge;", "\tmediump float f = smoothstep(halfNormSq.x + halfNormSq.y, innerEdgeSq.x + innerEdgeSq.y, diffSq.x + diffSq.y);", "\tgl_FragColor = color * f;", "}" ].join("\n");
                }
                static _$GetSmoothEllipseOutlineFragmentShaderSource$_() {
                    return [ "varying mediump vec2 vTex;", "uniform lowp vec4 color;", "uniform mediump vec2 pixelSize;", "uniform mediump float outlineThickness;", "void main(void) {", "\tmediump vec2 diff = vTex - vec2(0.5, 0.5);", "\tmediump vec2 diffSq = diff * diff;", "\tmediump float distSq = diffSq.x + diffSq.y;", "\tmediump vec2 norm = normalize(diff);", "\tmediump vec2 halfNorm = norm * 0.5;", "\tmediump vec2 halfNormSq = halfNorm * halfNorm;", "\tmediump vec2 pxNorm = pixelSize * norm;", "\tmediump vec2 innerEdge1 = halfNorm - pxNorm;", "\tmediump vec2 innerEdge1Sq = innerEdge1 * innerEdge1;", "\tmediump float innerF = smoothstep(halfNormSq.x + halfNormSq.y, innerEdge1Sq.x + innerEdge1Sq.y, distSq);", "\tmediump vec2 innerEdge2 = halfNorm - pxNorm * outlineThickness;", "\tmediump vec2 innerEdge2Sq = innerEdge2 * innerEdge2;", "\tmediump vec2 innerEdge3 = halfNorm - pxNorm * (outlineThickness + 1.0);", "\tmediump vec2 innerEdge3Sq = innerEdge3 * innerEdge3;", "\tmediump float outerF = smoothstep(innerEdge3Sq.x + innerEdge3Sq.y, innerEdge2Sq.x + innerEdge2Sq.y, distSq);", "\tgl_FragColor = color * innerF * outerF;", "}" ].join("\n");
                }
            };
        }
        {
            const C33 = self._$C3$_, glMatrix = self._$glMatrix$_, mat42 = glMatrix._$mat4$_, TYPE_SIZES = new Map([ [ "float", 1 ], [ "percent", 1 ], [ "sampler", 1 ], [ "vec2", 2 ], [ "vec3", 3 ], [ "color", 3 ], [ "vec4", 4 ], [ "mat4", 16 ] ]);
            C33._$Gfx$_._$WebGLShaderUniform$_ = class {
                constructor(t, e, s) {
                    if (!TYPE_SIZES.has(s)) throw new Error("invalid uniform type");
                    this._$_owner$_ = t, this._$_gl$_ = this._$_owner$_._$GetWebGLContext$_(), 
                    this._$_name$_ = e, this._$_type$_ = s, this._$_isColorType$_ = "color" === this._$_type$_, 
                    this._$_location$_ = this._$_gl$_.getUniformLocation(this._$_owner$_._$GetShaderProgram$_(), e), 
                    this._$_isUsed$_ = !!this._$_location$_;
                    const i = TYPE_SIZES.get(s);
                    this._$_lastValue$_ = new Float32Array(i), this._$_lastBatchValue$_ = new Float32Array(i);
                }
                _$Release$_() {
                    this._$_owner$_ = null, this._$_gl$_ = null, this._$_location$_ = null;
                }
                _$IsUsed$_() {
                    return this._$_isUsed$_;
                }
                _$GetType$_() {
                    return this._$_type$_;
                }
                _$IsColorType$_() {
                    return this._$_isColorType$_;
                }
                _$Init1f$_(t) {
                    this._$IsUsed$_() && (this._$_lastValue$_[0] = t, this._$_lastBatchValue$_.set(this._$_lastValue$_), 
                    this._$_gl$_.uniform1f(this._$_location$_, t));
                }
                _$Init1i$_(t) {
                    this._$IsUsed$_() && (this._$_lastValue$_[0] = t, this._$_lastBatchValue$_.set(this._$_lastValue$_), 
                    this._$_gl$_.uniform1i(this._$_location$_, t));
                }
                _$Init2f$_(t, e) {
                    this._$IsUsed$_() && (this._$_lastValue$_[0] = t, this._$_lastValue$_[1] = e, 
                    this._$_lastBatchValue$_.set(this._$_lastValue$_), this._$_gl$_.uniform2f(this._$_location$_, t, e));
                }
                _$Init3f$_(t, e, s) {
                    this._$IsUsed$_() && (this._$_lastValue$_[0] = t, this._$_lastValue$_[1] = e, 
                    this._$_lastValue$_[2] = s, this._$_lastBatchValue$_.set(this._$_lastValue$_), 
                    this._$_gl$_.uniform3f(this._$_location$_, t, e, s));
                }
                _$Init4f$_(t, e, s, i) {
                    this._$IsUsed$_() && (this._$_lastValue$_[0] = t, this._$_lastValue$_[1] = e, 
                    this._$_lastValue$_[2] = s, this._$_lastValue$_[3] = i, this._$_lastBatchValue$_.set(this._$_lastValue$_), 
                    this._$_gl$_.uniform4f(this._$_location$_, t, e, s, i));
                }
                _$Update1f$_(t) {
                    t = Math.fround(t);
                    const e = this._$_lastValue$_;
                    e[0] !== t && (e[0] = t, this._$_gl$_.uniform1f(this._$_location$_, t));
                }
                _$Update1i$_(t) {
                    const e = this._$_lastValue$_;
                    e[0] !== t && this._$_gl$_.uniform1i(this._$_location$_, e[0] = t);
                }
                _$Update2f$_(t, e) {
                    t = Math.fround(t), e = Math.fround(e);
                    const s = this._$_lastValue$_;
                    s[0] === t && s[1] === e || (s[0] = t, s[1] = e, this._$_gl$_.uniform2f(this._$_location$_, t, e));
                }
                _$Update3f$_(t, e, s) {
                    t = Math.fround(t), e = Math.fround(e), s = Math.fround(s);
                    const i = this._$_lastValue$_;
                    i[0] === t && i[1] === e && i[2] === s || (i[0] = t, i[1] = e, 
                    i[2] = s, this._$_gl$_.uniform3f(this._$_location$_, t, e, s));
                }
                _$Update4f$_(t, e, s, i) {
                    t = Math.fround(t), e = Math.fround(e), s = Math.fround(s), 
                    i = Math.fround(i);
                    const r = this._$_lastValue$_;
                    r[0] === t && r[1] === e && r[2] === s && r[3] === i || (r[0] = t, 
                    r[1] = e, r[2] = s, r[3] = i, this._$_gl$_.uniform4f(this._$_location$_, t, e, s, i));
                }
                _$UpdateMatrix4fv$_(t) {
                    const e = this._$_lastValue$_;
                    mat42._$exactEquals$_(e, t) || (C33._$typedArraySet16$_(e, t, 0), 
                    this._$_gl$_.uniformMatrix4fv(this._$_location$_, !1, t));
                }
                _$IsSetToCustomInBatch$_(t) {
                    const e = this._$_lastBatchValue$_;
                    return this._$IsColorType$_() ? e[0] === Math.fround(t._$getR$_()) && e[1] === Math.fround(t._$getG$_()) && e[2] === Math.fround(t._$getB$_()) : e[0] === Math.fround(t);
                }
                _$SetBatchValueCustom$_(t) {
                    const e = this._$_lastBatchValue$_;
                    this._$IsColorType$_() ? (e[0] = t._$getR$_(), e[1] = t._$getG$_(), 
                    e[2] = t._$getB$_()) : e[0] = t;
                }
                _$IsSetTo1InBatch$_(t) {
                    return this._$_lastBatchValue$_[0] === Math.fround(t);
                }
                _$IsSetTo2InBatch$_(t, e) {
                    const s = this._$_lastBatchValue$_;
                    return s[0] === Math.fround(t) && s[1] === Math.fround(e);
                }
                _$SetBatch1$_(t) {
                    this._$_lastBatchValue$_[0] = t;
                }
                _$SetBatch2$_(t, e) {
                    const s = this._$_lastBatchValue$_;
                    s[0] = t, s[1] = e;
                }
            };
        }
        {
            const C33 = self._$C3$_, glMatrix = self._$glMatrix$_, vec42 = glMatrix._$vec4$_, mat42 = glMatrix._$mat4$_, BATCH_NULL = 0, BATCH_QUAD = 1, BATCH_SETTEXTURE = 2, BATCH_SETCOLOR = 3, BATCH_SETBLEND = 4, BATCH_SETVIEWPORT = 5, BATCH_SETPROJECTION = 6, BATCH_SETMODELVIEW = 7, BATCH_SETRENDERTARGET = 8, BATCH_CLEARSURFACE = 9, BATCH_POINTS = 10, BATCH_SETPROGRAM = 11, BATCH_SETPROGRAMPARAMETERS = 12, BATCH_SETPROGRAMCUSTOMPARAMETERS = 13, BATCH_INVALIDATEFRAMEBUFFER = 14, BATCH_SETPOINTTEXCOORDS = 15, BATCH_SETTILEMAPINFO = 16, BATCH_BLITFRAMEBUFFER = 17, BATCH_STARTQUERY = 18, BATCH_ENDQUERY = 19, BATCH_SETELLIPSEPARAMS = 20, BATCH_SETGRADIENTCOLOR = 21, BATCH_CLEARDEPTH = 22, BATCH_SETDEPTHENABLED = 23, BATCH_SETDEPTHSAMPLINGENABLED = 24, BATCH_COPLANAR_STARTSTENCILPASS = 25, BATCH_COPLANAR_STARTCOLORPASS = 26, BATCH_COPLANAR_RESTORE = 27, BATCH_SET_SCISSOR = 28, BATCH_SETTILERANDOMIZATIONINFO = 29;
            C33._$Gfx$_._$BatchState$_ = class {
                constructor(t) {
                    this.renderer = t, this._$currentMV$_ = mat42.create(), this._$currentMatP$_ = mat42.create(), 
                    this._$currentFramebuffer$_ = null, this._$currentFramebufferNoDepth$_ = null, 
                    this._$isDepthSamplingEnabled$_ = !1, this._$currentColor$_ = vec42._$fromValues$_(1, 1, 1, 1), 
                    this._$currentShader$_ = null, this._$pointTexCoords$_ = new C33.Rect(), 
                    this.clearColor = C33._$New$_(C33._$Color$_, 0, 0, 0, 0);
                }
            }, C33._$Gfx$_._$WebGLBatchJob$_ = class {
                constructor(t) {
                    const e = new ArrayBuffer(96);
                    this._$_type$_ = 0, this._$_batchState$_ = t, this._$_gl$_ = t.renderer._$GetContext$_(), 
                    this._$_startIndex$_ = 0, this._$_indexCount$_ = 0, this._$_texParam$_ = null, 
                    this._$_mat4param$_ = new Float32Array(e, 0, 16), this._$_colorParam$_ = new Float32Array(e, 64, 4), 
                    this._$_srcOriginRect$_ = new Float32Array(e, 80, 4), this._$_shaderParams$_ = [];
                }
                _$InitQuad$_(t, e) {
                    this._$_type$_ = BATCH_QUAD, this._$_startIndex$_ = t, this._$_indexCount$_ = e;
                }
                _$DoQuad$_() {
                    const t = this._$_gl$_;
                    t.drawElements(t.TRIANGLES, this._$_indexCount$_, t.UNSIGNED_SHORT, this._$_startIndex$_);
                }
                _$InitSetTexture$_(t) {
                    this._$_type$_ = BATCH_SETTEXTURE, this._$_texParam$_ = t;
                }
                _$DoSetTexture$_() {
                    const t = this._$_gl$_, e = this._$_texParam$_;
                    t.bindTexture(t.TEXTURE_2D, e ? e._$_GetTexture$_() : null);
                }
                _$InitSetColor$_(t) {
                    this._$_type$_ = BATCH_SETCOLOR, t._$writeToTypedArray$_(this._$_colorParam$_, 0);
                }
                _$DoSetColor$_() {
                    const t = this._$_colorParam$_, e = this._$_batchState$_;
                    vec42._$copy$_(e._$currentColor$_, t), e._$currentShader$_._$UpdateColor$_(t);
                }
                _$InitSetGradientColor$_(t) {
                    this._$_type$_ = BATCH_SETGRADIENTCOLOR, t._$writeToTypedArray$_(this._$_colorParam$_, 0);
                }
                _$DoSetGradientColor$_() {
                    const t = this._$_colorParam$_, e = this._$_batchState$_._$currentShader$_;
                    e._$_uColor2$_._$IsUsed$_() && e._$_uColor2$_._$Update4f$_(t[0], t[1], t[2], t[3]);
                }
                _$InitSetBlend$_(t, e) {
                    this._$_type$_ = BATCH_SETBLEND, this._$_startIndex$_ = t, this._$_indexCount$_ = e;
                }
                _$DoSetBlend$_() {
                    this._$_gl$_.blendFunc(this._$_startIndex$_, this._$_indexCount$_);
                }
                _$InitSetViewport$_(t, e, s, i) {
                    this._$_type$_ = BATCH_SETVIEWPORT;
                    const r = this._$_colorParam$_;
                    r[0] = t, r[1] = e, r[2] = s, r[3] = i;
                }
                _$DoSetViewport$_() {
                    const t = this._$_colorParam$_;
                    this._$_gl$_.viewport(t[0], t[1], t[2], t[3]);
                }
                _$InitSetProjection$_(t) {
                    this._$_type$_ = BATCH_SETPROJECTION, mat42._$copy$_(this._$_mat4param$_, t);
                }
                _$DoSetProjection$_() {
                    const t = this._$_batchState$_, s = t.renderer._$_allShaderPrograms$_, i = t._$currentShader$_, r = this._$_mat4param$_;
                    for (let t = 0, e = s.length; t < e; ++t) {
                        const n = s[t];
                        n === i ? n._$UpdateMatP$_(r, !0) : n._$SetMatPStale$_();
                    }
                    mat42._$copy$_(t._$currentMatP$_, r);
                }
                _$InitSetModelView$_(t) {
                    this._$_type$_ = BATCH_SETMODELVIEW, mat42._$copy$_(this._$_mat4param$_, t);
                }
                _$DoSetModelView$_() {
                    const t = this._$_batchState$_, s = t.renderer._$_allShaderPrograms$_, i = t._$currentShader$_, r = this._$_mat4param$_;
                    for (let t = 0, e = s.length; t < e; ++t) {
                        const n = s[t];
                        n === i ? n._$UpdateMatMV$_(r, !0) : n._$SetMatMVStale$_();
                    }
                    mat42._$copy$_(t._$currentMV$_, r);
                }
                _$InitSetRenderTarget$_(t) {
                    this._$_type$_ = BATCH_SETRENDERTARGET, this._$_texParam$_ = t;
                }
                _$DoSetRenderTarget$_() {
                    const t = this._$_gl$_, e = this._$_texParam$_, s = this._$_batchState$_;
                    e ? (s._$currentFramebuffer$_ = e._$_GetFramebuffer$_(), s._$currentFramebufferNoDepth$_ = e._$_GetFramebufferNoDepth$_(), 
                    s._$isDepthSamplingEnabled$_ && s._$currentFramebufferNoDepth$_ ? t.bindFramebuffer(t.FRAMEBUFFER, s._$currentFramebufferNoDepth$_) : t.bindFramebuffer(t.FRAMEBUFFER, s._$currentFramebuffer$_)) : (s._$currentFramebuffer$_ = null, 
                    s._$currentFramebufferNoDepth$_ = null, t.bindFramebuffer(t.FRAMEBUFFER, null));
                }
                _$InitClearSurface$_(t) {
                    this._$_type$_ = BATCH_CLEARSURFACE, t._$writeToTypedArray$_(this._$_mat4param$_, 0);
                }
                _$InitClearSurface2$_(t, e, s, i) {
                    this._$_type$_ = BATCH_CLEARSURFACE;
                    const r = this._$_mat4param$_;
                    r[0] = t, r[1] = e, r[2] = s, r[3] = i;
                }
                _$DoClearSurface$_() {
                    const t = this._$_gl$_, e = this._$_mat4param$_, s = this._$_batchState$_, i = s.clearColor, r = e[0], n = e[1], h = e[2], o = e[3];
                    i._$equalsRgba$_(r, n, h, o) || (t.clearColor(r, n, h, o), i._$setRgba$_(r, n, h, o)), 
                    t.clear(t.COLOR_BUFFER_BIT);
                }
                _$InitSetPointTexCoords$_(t) {
                    this._$_type$_ = BATCH_SETPOINTTEXCOORDS, t._$writeToTypedArray$_(this._$_mat4param$_, 0);
                }
                _$DoSetPointTextureCoords$_() {
                    const t = this._$_mat4param$_;
                    this._$_batchState$_._$pointTexCoords$_.set(t[0], t[1], t[2], t[3]);
                }
                _$InitPoints$_(t, e) {
                    this._$_type$_ = BATCH_POINTS, this._$_startIndex$_ = t, this._$_indexCount$_ = 1, 
                    this._$_mat4param$_[0] = e;
                }
                _$DoPoints$_() {
                    const t = this._$_gl$_, e = this._$_batchState$_, s = e.renderer, i = s._$_spPoints$_, r = (t.useProgram(i._$_shaderProgram$_), 
                    i._$UpdateMatP$_(e._$currentMatP$_, !1), i._$UpdateMatMV$_(e._$currentMV$_, !1), 
                    e._$pointTexCoords$_), n = (i._$_uPointTexStart$_._$IsUsed$_() && i._$_uPointTexStart$_._$Update2f$_(r._$getLeft$_(), r._$getTop$_()), 
                    i._$_uPointTexEnd$_._$IsUsed$_() && i._$_uPointTexEnd$_._$Update2f$_(r._$getRight$_(), r._$getBottom$_()), 
                    this._$_mat4param$_[0]);
                    if (i._$_uZElevation$_._$IsUsed$_() && i._$_uZElevation$_._$Update1f$_(n), 
                    i._$_uColor$_._$IsUsed$_()) {
                        const h = e._$currentColor$_;
                        i._$_uColor$_._$Update4f$_(h[0], h[1], h[2], h[3]);
                    }
                    t.drawArrays(t.POINTS, this._$_startIndex$_ / 4, this._$_indexCount$_), 
                    t.useProgram(e._$currentShader$_._$_shaderProgram$_);
                }
                _$InitSetProgram$_(t) {
                    this._$_type$_ = BATCH_SETPROGRAM, this._$_texParam$_ = t;
                }
                _$DoSetProgram$_() {
                    const t = this._$_gl$_, e = this._$_batchState$_, s = this._$_texParam$_;
                    if (e._$currentShader$_ = s, t.useProgram(s._$_shaderProgram$_), 
                    s._$UpdateMatP$_(e._$currentMatP$_, !1), s._$UpdateMatMV$_(e._$currentMV$_, !1), 
                    s._$_uColor$_._$IsUsed$_()) {
                        const i = e._$currentColor$_;
                        s._$_uColor$_._$Update4f$_(i[0], i[1], i[2], i[3]);
                    }
                }
                _$InitSetProgramParameters$_() {
                    this._$_type$_ = BATCH_SETPROGRAMPARAMETERS;
                }
                _$DoSetProgramParameters$_() {
                    const t = this._$_batchState$_._$currentShader$_, e = this._$_gl$_, s = this._$_mat4param$_, i = this._$_colorParam$_, r = this._$_srcOriginRect$_;
                    if (t._$_uSamplerBack$_._$IsUsed$_()) {
                        const n = this._$_batchState$_.renderer, h = this._$_texParam$_;
                        n._$_lastTexture1$_ !== h && (e.activeTexture(e.TEXTURE1), 
                        e.bindTexture(e.TEXTURE_2D, h ? h._$_GetTexture$_() : null), 
                        n._$_lastTexture1$_ = h, e.activeTexture(e.TEXTURE0));
                    }
                    t._$_uPixelSize$_._$IsUsed$_() && t._$_uPixelSize$_._$Update2f$_(s[0], s[1]), 
                    t._$_uDestStart$_._$IsUsed$_() && t._$_uDestStart$_._$Update2f$_(s[2], s[3]), 
                    t._$_uDestEnd$_._$IsUsed$_() && t._$_uDestEnd$_._$Update2f$_(s[4], s[5]), 
                    t._$_uDevicePixelRatio$_._$IsUsed$_() && t._$_uDevicePixelRatio$_._$Update1f$_(this._$_indexCount$_), 
                    t._$_uLayerScale$_._$IsUsed$_() && t._$_uLayerScale$_._$Update1f$_(s[6]), 
                    t._$_uLayerAngle$_._$IsUsed$_() && t._$_uLayerAngle$_._$Update1f$_(s[7]), 
                    t._$_uSrcStart$_._$IsUsed$_() && t._$_uSrcStart$_._$Update2f$_(s[12], s[13]), 
                    t._$_uSrcEnd$_._$IsUsed$_() && t._$_uSrcEnd$_._$Update2f$_(s[14], s[15]), 
                    t._$_uSrcOriginStart$_._$IsUsed$_() && t._$_uSrcOriginStart$_._$Update2f$_(r[0], r[1]), 
                    t._$_uSrcOriginEnd$_._$IsUsed$_() && t._$_uSrcOriginEnd$_._$Update2f$_(r[2], r[3]), 
                    t._$_uLayoutStart$_._$IsUsed$_() && t._$_uLayoutStart$_._$Update2f$_(i[0], i[1]), 
                    t._$_uLayoutEnd$_._$IsUsed$_() && t._$_uLayoutEnd$_._$Update2f$_(i[2], i[3]), 
                    t._$_uSeconds$_._$IsUsed$_() && t._$_uSeconds$_._$Update1f$_(this._$_startIndex$_);
                }
                _$InitSetProgramCustomParameters$_() {
                    this._$_type$_ = BATCH_SETPROGRAMCUSTOMPARAMETERS;
                }
                _$DoSetProgramCustomParameters$_() {
                    const t = this._$_batchState$_._$currentShader$_, s = t._$_uCustomParameters$_, i = this._$_shaderParams$_;
                    for (let t = 0, e = s.length; t < e; ++t) {
                        const r = s[t], n = i[t];
                        r._$IsColorType$_() ? r._$Update3f$_(n._$getR$_(), n._$getG$_(), n._$getB$_()) : r._$Update1f$_(n);
                    }
                }
                _$InitInvalidateFramebuffer$_(t) {
                    this._$_type$_ = BATCH_INVALIDATEFRAMEBUFFER, this._$_texParam$_ = t;
                }
                _$DoInvalidateFramebuffer$_() {
                    const t = this._$_gl$_, e = this._$_texParam$_, s = this._$_batchState$_._$currentFramebuffer$_;
                    e !== s && t.bindFramebuffer(t.FRAMEBUFFER, e), t.invalidateFramebuffer(t.FRAMEBUFFER, [ t.COLOR_ATTACHMENT0 ]), 
                    e !== s && t.bindFramebuffer(t.FRAMEBUFFER, s);
                }
                _$InitBlitFramebuffer$_(t, e, s) {
                    this._$_type$_ = BATCH_BLITFRAMEBUFFER;
                    const i = this._$_mat4param$_, r = this._$_batchState$_.renderer, n = (i[0] = t._$GetWidth$_(), 
                    i[1] = t._$GetHeight$_(), i[2] = (e || r)._$GetWidth$_(), i[3] = (e || r)._$GetHeight$_(), 
                    i[4] = t._$IsLinearSampling$_() ? 1 : 0, i[5] = "stretch" === s, 
                    this._$_shaderParams$_);
                    C33._$clearArray$_(n), n.push(t._$_GetFramebuffer$_()), n.push(e ? e._$_GetFramebuffer$_() : null);
                }
                _$DoBlitFramebuffer$_() {
                    const t = this._$_mat4param$_, e = this._$_shaderParams$_, s = this._$_gl$_, i = t[0], r = t[1], n = t[2], h = t[3], o = 0 !== t[4], a = 0 !== t[5], l = e[0], u = e[1];
                    if (s.bindFramebuffer(s.READ_FRAMEBUFFER, l), s.bindFramebuffer(s.DRAW_FRAMEBUFFER, u), 
                    a) s.blitFramebuffer(0, 0, i, r, 0, 0, n, h, s.COLOR_BUFFER_BIT, o ? s.LINEAR : s.NEAREST); else {
                        const c = Math.min(i, n), f = Math.min(r, h), d = Math.max(r - h, 0), p = Math.max(h - r, 0);
                        s.blitFramebuffer(0, d, c, f + d, 0, p, c, f + p, s.COLOR_BUFFER_BIT, s.NEAREST);
                    }
                }
                _$InitStartQuery$_(t) {
                    this._$_type$_ = BATCH_STARTQUERY, this._$_texParam$_ = t;
                }
                _$DoStartQuery$_() {
                    this._$_texParam$_._$BeginTimeElapsed$_(), this._$_texParam$_ = null;
                }
                _$InitEndQuery$_(t) {
                    this._$_type$_ = BATCH_ENDQUERY, this._$_texParam$_ = t;
                }
                _$DoEndQuery$_() {
                    this._$_texParam$_._$EndTimeElapsed$_(), this._$_texParam$_ = null;
                }
                _$InitSetEllipseParams$_(t, e, s) {
                    this._$_type$_ = BATCH_SETELLIPSEPARAMS;
                    const i = this._$_mat4param$_;
                    i[0] = t, i[1] = e, i[2] = s;
                }
                _$DoSetEllipseParams$_() {
                    const t = this._$_batchState$_._$currentShader$_, e = this._$_mat4param$_;
                    t._$_uPixelSize$_._$IsUsed$_() && t._$_uPixelSize$_._$Update2f$_(e[0], e[1]), 
                    t._$_uOutlineThickness$_._$IsUsed$_() && t._$_uOutlineThickness$_._$Update1f$_(e[2]);
                }
                _$InitSetTilemapInfo$_(t, e, s, i, r, n, h) {
                    this._$_type$_ = BATCH_SETTILEMAPINFO;
                    const o = this._$_mat4param$_;
                    t._$writeToTypedArray$_(o, 0), o[4] = 1 / e, o[5] = 1 / s, o[6] = i / e, 
                    o[7] = r / s, o[8] = n / e, o[9] = h / s;
                }
                _$DoSetTilemapInfo$_() {
                    const t = this._$_batchState$_._$currentShader$_, e = this._$_mat4param$_;
                    t._$_uSrcStart$_._$IsUsed$_() && t._$_uSrcStart$_._$Update2f$_(e[0], e[1]), 
                    t._$_uPixelSize$_._$IsUsed$_() && t._$_uPixelSize$_._$Update2f$_(e[4], e[5]), 
                    t._$_uTileSize$_._$IsUsed$_() && t._$_uTileSize$_._$Update2f$_(e[6], e[7]), 
                    t._$_uTileSpacing$_._$IsUsed$_() && t._$_uTileSpacing$_._$Update2f$_(e[8], e[9]);
                }
                _$InitSetTileRandomizationInfo$_(t, e, s, i, r, n, h) {
                    this._$_type$_ = BATCH_SETTILERANDOMIZATIONINFO;
                    const o = this._$_mat4param$_;
                    o[0] = 1 / t, o[1] = 1 / e, o[2] = s, o[3] = i, o[4] = r, o[5] = n, 
                    o[6] = h;
                }
                _$DoSetTileRandomizationInfo$_() {
                    const t = this._$_batchState$_._$currentShader$_, e = this._$_mat4param$_;
                    t._$_uPixelSize$_._$IsUsed$_() && t._$_uPixelSize$_._$Update2f$_(e[0], e[1]), 
                    t._$_uTileSize$_._$IsUsed$_() && t._$_uTileSize$_._$Update2f$_(e[2], e[3]), 
                    t._$_uOutlineThickness$_._$IsUsed$_() && t._$_uOutlineThickness$_._$Update1f$_(e[4]), 
                    t._$_uTileSpacing$_._$IsUsed$_() && t._$_uTileSpacing$_._$Update2f$_(e[5], e[6]);
                }
                _$InitClearDepth$_(t) {
                    this._$_type$_ = BATCH_CLEARDEPTH, this._$_startIndex$_ = t ? 1 : 0;
                }
                _$DoClearDepth$_() {
                    const t = this._$_gl$_, e = 0 !== this._$_startIndex$_;
                    e || t.depthMask(!0), t.clear(t.DEPTH_BUFFER_BIT), e || t.depthMask(!1);
                }
                _$InitSetDepthEnabled$_(t) {
                    this._$_type$_ = BATCH_SETDEPTHENABLED, this._$_startIndex$_ = t ? 1 : 0;
                }
                _$DoSetDepthEnabled$_() {
                    const t = this._$_gl$_;
                    0 === this._$_startIndex$_ ? (t.disable(t.DEPTH_TEST), t.depthMask(!1)) : (t.enable(t.DEPTH_TEST), 
                    t.depthMask(!0));
                }
                _$InitSetDepthSamplingEnabled$_(t) {
                    this._$_type$_ = BATCH_SETDEPTHSAMPLINGENABLED, this._$_startIndex$_ = t ? 1 : 0;
                }
                _$DoSetDepthSamplingEnabled$_() {
                    const t = this._$_gl$_, e = this._$_batchState$_, s = e.renderer, i = 0 !== this._$_startIndex$_;
                    e._$isDepthSamplingEnabled$_ = i, t.activeTexture(t.TEXTURE2), 
                    i ? (e._$currentFramebufferNoDepth$_ && t.bindFramebuffer(t.FRAMEBUFFER, e._$currentFramebufferNoDepth$_), 
                    t.bindTexture(t.TEXTURE_2D, s._$_GetDepthBuffer$_())) : (t.bindTexture(t.TEXTURE_2D, null), 
                    e._$currentFramebufferNoDepth$_ && t.bindFramebuffer(t.FRAMEBUFFER, e._$currentFramebuffer$_)), 
                    t.activeTexture(t.TEXTURE0);
                }
                _$InitCoplanarStartStencilPass$_() {
                    this._$_type$_ = BATCH_COPLANAR_STARTSTENCILPASS;
                }
                _$DoCoplanarStartStencilPass$_() {
                    const t = this._$_gl$_;
                    t.clear(t.STENCIL_BUFFER_BIT), t.enable(t.STENCIL_TEST), t.stencilFunc(t.ALWAYS, 1, 1), 
                    t.stencilOp(t.KEEP, t.KEEP, t.REPLACE), t.colorMask(!1, !1, !1, !1);
                }
                _$InitCoplanarStartColorPass$_() {
                    this._$_type$_ = BATCH_COPLANAR_STARTCOLORPASS;
                }
                _$DoCoplanarStartColorPass$_() {
                    const t = this._$_gl$_;
                    t.colorMask(!0, !0, !0, !0), t.stencilFunc(t.EQUAL, 1, 1), t.stencilOp(t.KEEP, t.KEEP, t.KEEP);
                }
                _$InitCoplanarRestore$_() {
                    this._$_type$_ = BATCH_COPLANAR_RESTORE;
                }
                _$DoCoplanarRestore$_() {
                    const t = this._$_gl$_;
                    t.disable(t.STENCIL_TEST);
                }
                _$InitSetScissor$_(t, e, s, i, r) {
                    this._$_type$_ = BATCH_SET_SCISSOR, this._$_startIndex$_ = t ? 1 : 0;
                    const n = this._$_mat4param$_;
                    n[0] = e, n[1] = s, n[2] = i, n[3] = r;
                }
                _$DoSetScissor$_() {
                    const t = this._$_gl$_, e = this._$_mat4param$_;
                    1 === this._$_startIndex$_ ? (t.enable(t.SCISSOR_TEST), t.scissor(e[0], e[1], e[2], e[3])) : t.disable(t.SCISSOR_TEST);
                }
                _$Run$_() {
                    switch (this._$_type$_) {
                      case 1:
                        return void this._$DoQuad$_();

                      case 2:
                        return void this._$DoSetTexture$_();

                      case 3:
                        return void this._$DoSetColor$_();

                      case 4:
                        return void this._$DoSetBlend$_();

                      case 5:
                        return void this._$DoSetViewport$_();

                      case 6:
                        return void this._$DoSetProjection$_();

                      case 7:
                        return void this._$DoSetModelView$_();

                      case 8:
                        return void this._$DoSetRenderTarget$_();

                      case 9:
                        return void this._$DoClearSurface$_();

                      case 10:
                        return void this._$DoPoints$_();

                      case 11:
                        return void this._$DoSetProgram$_();

                      case 12:
                        return void this._$DoSetProgramParameters$_();

                      case 13:
                        return void this._$DoSetProgramCustomParameters$_();

                      case 14:
                        return void this._$DoInvalidateFramebuffer$_();

                      case 15:
                        return void this._$DoSetPointTextureCoords$_();

                      case 16:
                        return void this._$DoSetTilemapInfo$_();

                      case 17:
                        return void this._$DoBlitFramebuffer$_();

                      case 18:
                        return void this._$DoStartQuery$_();

                      case 19:
                        return void this._$DoEndQuery$_();

                      case 20:
                        return void this._$DoSetEllipseParams$_();

                      case 21:
                        return void this._$DoSetGradientColor$_();

                      case 22:
                        return void this._$DoClearDepth$_();

                      case 23:
                        return void this._$DoSetDepthEnabled$_();

                      case 24:
                        return void this._$DoSetDepthSamplingEnabled$_();

                      case 25:
                        return void this._$DoCoplanarStartStencilPass$_();

                      case 26:
                        return void this._$DoCoplanarStartColorPass$_();

                      case 27:
                        return void this._$DoCoplanarRestore$_();

                      case 28:
                        return void this._$DoSetScissor$_();

                      case 29:
                        return void this._$DoSetTileRandomizationInfo$_();
                    }
                }
            };
        }
        {
            let fillOrStrokeRect2 = function(t, e, s, i, r, n) {
                e ? t.strokeRect(s, i, r, n) : t.fillRect(s, i, r, n);
            }, ptToPx2 = function(t) {
                return t * (4 / 3);
            }, getOffsetParam2 = function(t, e) {
                t = t.trim();
                const s = parseFloat(t);
                return isFinite(s) ? t.endsWith("%") ? e * s / 100 : s : 0;
            };
            fillOrStrokeRect = fillOrStrokeRect2, ptToPx = ptToPx2, getOffsetParam = getOffsetParam2;
            const C33 = self._$C3$_, MAX_TEXTURE_SIZE = 4096, EXTRA_LINE_HEIGHT = 4, GENERIC_FONT_FAMILIES = new Set([ "serif", "sans-serif", "monospace", "cursive", "fantasy", "system-ui", "ui-serif", "ui-sans-serif", "ui-monospace", "ui-rounded", "math", "emoji", "fangsong" ]), DEFAULT_OPTS = {
                timeout: 60
            }, tempColor = new C33._$Color$_(0, 0, 0, 1), VALID_HORIZ_ALIGNMENTS = new Set([ "left", "center", "right" ]), VALID_VERT_ALIGNMENTS = new Set([ "top", "center", "bottom" ]), VALID_WORD_WRAP_MODES = new Set([ "word", "cjk", "character" ]), VALID_TEXT_DIRECTIONS = new Set([ "ltr", "rtl" ]), allRendererTexts = new Set();
            C33.FontManager && C33.FontManager.addEventListener("fontload", t => {
                const e = t.font._$GetName$_();
                for (const s of allRendererTexts) (s._$IsBBCodeEnabled$_() || C33._$equalsNoCase$_(s._$GetFontName$_(), e)) && s._$_SetWordWrapChanged$_();
            });
            let didCheckFoundBoundingBoxSupport = !1, supportsFontBoundingBoxMeasurements = !1;
            C33._$Gfx$_._$RendererText$_ = class {
                constructor(t, e) {
                    e = Object.assign({}, DEFAULT_OPTS, e), this._$_renderer$_ = t, 
                    this._$_fontName$_ = "Arial", this._$_fontSize$_ = 16, this._$_fontSizeScale$_ = 1, 
                    this._$_lineHeight$_ = 0, this._$_isBold$_ = !1, this._$_isItalic$_ = !1, 
                    this._$_colorStr$_ = "black", this._$_isBBcodeEnabled$_ = !1, 
                    this._$_iconSet$_ = null, this._$_iconSmoothing$_ = !0, this._$onloadfont$_ = null, 
                    this._$_alreadyLoadedFonts$_ = new Set(), this._$_horizontalAlign$_ = "left", 
                    this._$_verticalAlign$_ = "top", this._$_text$_ = "", this._$_bbString$_ = null, 
                    this._$_wrappedText$_ = C33._$New$_(C33._$WordWrap$_), this._$_wrapMode$_ = "word", 
                    this._$_textDirection$_ = "ltr", this._$_wordWrapChanged$_ = !1, 
                    this._$_textLayoutChanged$_ = !1, this._$_drawChanged$_ = !1, 
                    this._$_drawMaxCharCount$_ = -1, this._$_drawCharCount$_ = 0, 
                    this._$_cssWidth$_ = 0, this._$_cssHeight$_ = 0, this._$_width$_ = 0, 
                    this._$_height$_ = 0, this._$_zoom$_ = 1, this._$_textCanvas$_ = null, 
                    this._$_textContext$_ = null, this._$_measureContext$_ = null, 
                    this._$_measureContextTop$_ = null, this._$_lastCanvasWidth$_ = -1, 
                    this._$_lastCanvasHeight$_ = -1, this._$_lastTextCanvasFont$_ = "", 
                    this._$_lastMeasureCanvasFont$_ = "", this._$_lastTextCanvasFillStyle$_ = "", 
                    this._$_lastTextCanvasOpacity$_ = 1, this._$_lastTextCanvasLineWidth$_ = 1, 
                    this._$_measureTextCallback$_ = t => this._$_MeasureText$_(t), 
                    this._$_texture$_ = null, this._$_rcTex$_ = new C33.Rect(), 
                    this._$_scaleFactor$_ = 1, this._$_textureTimeout$_ = new C33._$IdleTimeout$_(() => {
                        this._$ReleaseTexture$_(), this._$_SetTextCanvasSize$_(8, 8);
                    }, e.timeout), this._$ontextureupdate$_ = null, this._$_wasReleased$_ = !1, 
                    allRendererTexts.add(this);
                }
                _$Release$_() {
                    this._$onloadfont$_ = null, this._$_alreadyLoadedFonts$_.clear(), 
                    this._$_iconSet$_ = null, this._$_bbString$_ = null, this._$_textCanvas$_ = null, 
                    this._$_textContext$_ = null, this._$_measureContext$_ = null, 
                    this._$_measureContextTop$_ = null, this._$_measureTextCallback$_ = null, 
                    this._$_textureTimeout$_._$Release$_(), this._$ontextureupdate$_ = null, 
                    this._$ReleaseTexture$_(), this._$_wrappedText$_._$Clear$_(), 
                    this._$_wrappedText$_ = null, this._$_renderer$_ = null, this._$_wasReleased$_ = !0, 
                    allRendererTexts.delete(this);
                }
                _$_SetDrawChanged$_() {
                    this._$_drawChanged$_ = !0;
                }
                _$_SetTextLayoutChanged$_() {
                    this._$_SetDrawChanged$_(), this._$_textLayoutChanged$_ = !0;
                }
                _$_SetWordWrapChanged$_() {
                    this._$_SetTextLayoutChanged$_(), this._$_wordWrapChanged$_ = !0;
                }
                _$SetBBCodeEnabled$_(t) {
                    if (this._$_isBBcodeEnabled$_ !== (t = !!t)) {
                        this._$_isBBcodeEnabled$_ = t;
                        const e = this._$_isBBcodeEnabled$_ ? "alphabetic" : "top";
                        this._$_textContext$_ && (this._$_textContext$_.textBaseline = e), 
                        this._$_measureContext$_ && (this._$_measureContext$_.textBaseline = e), 
                        this._$_SetWordWrapChanged$_();
                    }
                }
                _$IsBBCodeEnabled$_() {
                    return this._$_isBBcodeEnabled$_;
                }
                _$SetIconSet$_(t) {
                    this._$_iconSet$_ !== t && (this._$_iconSet$_ = t, this._$_wrappedText$_._$SetIconSet$_(t), 
                    this._$_iconSet$_ && this._$_iconSet$_._$IsLoading$_() && this._$_iconSet$_._$LoadContent$_().then(() => this._$_SetDrawChanged$_()), 
                    this._$_SetWordWrapChanged$_());
                }
                _$SetIconSmoothing$_(t) {
                    this._$_iconSmoothing$_ !== (t = !!t) && (this._$_iconSmoothing$_ = t, 
                    this._$_SetDrawChanged$_());
                }
                _$SetFontName$_(t) {
                    this._$_fontName$_ !== (t = t || "serif") && (this._$_fontName$_ = t, 
                    this._$_SetWordWrapChanged$_());
                }
                _$GetFontName$_() {
                    return this._$_fontName$_;
                }
                _$SetFontSize$_(t) {
                    this._$_fontSize$_ !== (t = t < .1 ? .1 : t) && (this._$_fontSize$_ = t, 
                    this._$_SetWordWrapChanged$_());
                }
                _$GetFontSize$_() {
                    return this._$_fontSize$_;
                }
                _$SetFontSizeScale$_(t) {
                    this._$_fontSizeScale$_ !== t && (this._$_fontSizeScale$_ = t, 
                    this._$_SetWordWrapChanged$_());
                }
                _$SetLineHeight$_(t) {
                    this._$_lineHeight$_ !== t && (this._$_lineHeight$_ = t, this._$_SetTextLayoutChanged$_());
                }
                _$GetLineHeight$_() {
                    return this._$_lineHeight$_;
                }
                _$SetBold$_(t) {
                    this._$_isBold$_ !== (t = !!t) && (this._$_isBold$_ = t, this._$_SetWordWrapChanged$_());
                }
                _$IsBold$_() {
                    return this._$_isBold$_;
                }
                _$SetItalic$_(t) {
                    this._$_isItalic$_ !== (t = !!t) && (this._$_isItalic$_ = t, 
                    this._$_SetWordWrapChanged$_());
                }
                _$IsItalic$_() {
                    return this._$_isItalic$_;
                }
                _$SetDrawMaxCharacterCount$_(t) {
                    t = Math.floor(t), this._$_drawMaxCharCount$_ !== t && (this._$_drawMaxCharCount$_ = t, 
                    this._$_SetDrawChanged$_());
                }
                _$GetDrawMaxCharacterCount$_() {
                    return this._$_drawMaxCharCount$_;
                }
                _$_GetFontString$_(t, e) {
                    let s = [];
                    (this._$_isBold$_ || e._$HasStyleTag$_("b")) && s.push("bold"), 
                    (this._$_isItalic$_ || e._$HasStyleTag$_("i")) && s.push("italic");
                    const i = e._$GetStyleTag$_("size"), r = (i ? parseFloat(i.param) : this._$_fontSize$_) * this._$_fontSizeScale$_;
                    s.push(t ? r + "pt" : r * this._$GetDrawScale$_() + "pt");
                    let n = this._$_fontName$_, h = e._$GetStyleTag$_("font");
                    return h && h.param && (n = h.param, this._$onloadfont$_) && !this._$_alreadyLoadedFonts$_.has(n) && (this._$onloadfont$_(n), 
                    this._$_alreadyLoadedFonts$_.add(n)), n && (GENERIC_FONT_FAMILIES.has(n) ? s.push(n) : s.push('"' + n + '"')), 
                    s.join(" ");
                }
                _$SetColor$_(t) {
                    t instanceof C33._$Color$_ && (t = t._$getCssRgb$_()), this._$_colorStr$_ !== t && (this._$_colorStr$_ = t, 
                    this._$_SetDrawChanged$_());
                }
                _$SetColorRgb$_(t, e, s) {
                    tempColor._$setRgb$_(t, e, s), this._$SetColor$_(tempColor);
                }
                _$SetHorizontalAlignment$_(t) {
                    if (!VALID_HORIZ_ALIGNMENTS.has(t)) throw new Error("invalid horizontal alignment");
                    this._$_horizontalAlign$_ !== t && (this._$_horizontalAlign$_ = t, 
                    this._$_SetTextLayoutChanged$_());
                }
                _$GetHorizontalAlignment$_() {
                    return this._$_horizontalAlign$_;
                }
                _$SetVerticalAlignment$_(t) {
                    if (!VALID_VERT_ALIGNMENTS.has(t)) throw new Error("invalid vertical alignment");
                    this._$_verticalAlign$_ !== t && (this._$_verticalAlign$_ = t, 
                    this._$_SetTextLayoutChanged$_());
                }
                _$GetVerticalAlignment$_() {
                    return this._$_verticalAlign$_;
                }
                _$SetWordWrapMode$_(t) {
                    if (!VALID_WORD_WRAP_MODES.has(t)) throw new Error("invalid word wrap mode");
                    this._$_wrapMode$_ !== t && (this._$_wrapMode$_ = t, this._$_SetWordWrapChanged$_());
                }
                _$GetWordWrapMode$_() {
                    return this._$_wrapMode$_;
                }
                _$SetTextDirection$_(t) {
                    if (!VALID_TEXT_DIRECTIONS.has(t)) throw new Error("invalid text direction");
                    this._$_textDirection$_ !== t && (this._$_textDirection$_ = t, 
                    this._$_textContext$_ && (this._$_textContext$_.direction = this._$_textDirection$_), 
                    this._$_measureContext$_ && (this._$_measureContext$_.direction = this._$_textDirection$_), 
                    this._$_SetWordWrapChanged$_());
                }
                _$GetTextDirection$_() {
                    return this._$_textDirection$_;
                }
                _$SetText$_(t) {
                    this._$_text$_ !== t && (this._$_text$_ = t, this._$_SetWordWrapChanged$_());
                }
                _$GetText$_() {
                    return this._$_text$_;
                }
                _$GetDrawScale$_() {
                    return this._$_scaleFactor$_ * this._$_zoom$_ * self.devicePixelRatio;
                }
                _$SetSize$_(n, h, o) {
                    if (void 0 === o && (o = 1), !(n <= 0 || this._$_cssWidth$_ === n && this._$_cssHeight$_ === h && this._$_zoom$_ === o)) {
                        let t = this._$_cssWidth$_, e = (this._$_cssWidth$_ = n, 
                        this._$_cssHeight$_ = h, this._$_zoom$_ = o, self.devicePixelRatio), s = (this._$_width$_ = this._$_cssWidth$_ * this._$_zoom$_ * e, 
                        this._$_height$_ = this._$_cssHeight$_ * this._$_zoom$_ * e, 
                        Math.max(this._$_width$_, this._$_height$_)), i = Math.min(this._$_renderer$_._$GetMaxTextureSize$_(), MAX_TEXTURE_SIZE), r = 1;
                        i < s && (r = i / s, this._$_width$_ = Math.min(this._$_width$_ * r, i), 
                        this._$_height$_ = Math.min(this._$_height$_ * r, i)), this._$_scaleFactor$_ = r, 
                        this._$_cssWidth$_ !== t ? this._$_SetWordWrapChanged$_() : this._$_SetTextLayoutChanged$_();
                    }
                }
                _$GetWidth$_() {
                    return this._$_width$_;
                }
                _$GetHeight$_() {
                    return this._$_height$_;
                }
                _$GetZoom$_() {
                    return this._$_zoom$_;
                }
                _$GetTextWidth$_() {
                    return this._$_UpdateTextMeasurements$_(), this._$_wrappedText$_._$GetMaxLineWidth$_();
                }
                _$GetTextHeight$_() {
                    return this._$_UpdateTextMeasurements$_(), this._$_wrappedText$_._$GetTotalLineHeight$_() + this._$_wrappedText$_._$GetLineCount$_() * (this._$_lineHeight$_ + EXTRA_LINE_HEIGHT) - this._$_lineHeight$_;
                }
                _$GetLengthInGraphemes$_() {
                    this._$_UpdateTextMeasurements$_();
                    let t = 0;
                    for (const e of this._$_wrappedText$_._$GetLines$_()) for (const s of e._$fragments$_()) t += s._$GetLength$_();
                    return t;
                }
                _$GetTexture$_() {
                    return this._$_textureTimeout$_._$Reset$_(), this._$_MaybeUpdate$_(), 
                    this._$_texture$_;
                }
                _$HitTestFragment$_(t, e) {
                    this._$_UpdateTextMeasurements$_();
                    const s = this._$GetDrawScale$_(), i = this._$_wrappedText$_._$GetLines$_();
                    for (const r of i) {
                        const n = r._$GetFontBoundingBoxDescent$_() * s;
                        if (e >= r._$GetPosY$_() - r._$GetHeight$_() * s + n && e < r._$GetPosY$_() + n) for (const h of r._$fragments$_()) if (t >= h._$GetPosX$_() && t < h._$GetPosX$_() + h._$GetWidth$_() * s) return h;
                    }
                    return null;
                }
                *_$fragmentsWithTag$_(t) {
                    this._$_UpdateTextMeasurements$_();
                    const e = this._$_wrappedText$_._$GetLines$_();
                    for (const s of e) for (const i of s._$fragments$_()) {
                        const r = i._$GetStyleTag$_("tag");
                        r && C33._$equalsNoCase$_(r.param, t) && (yield i);
                    }
                }
                _$FindFragmentWithTag$_(t, e) {
                    for (const s of this._$fragmentsWithTag$_(t)) {
                        if (0 === e) return s;
                        --e;
                    }
                    return null;
                }
                _$CountFragmentsWithTag$_(t) {
                    let e = 0;
                    for (const s of this._$fragmentsWithTag$_(t)) ++e;
                    return e;
                }
                _$_MaybeUpdate$_() {
                    this._$_texture$_ && !this._$_drawChanged$_ && !this._$_textLayoutChanged$_ && !this._$_wordWrapChanged$_ || this._$_wasReleased$_ || this._$_width$_ <= 0 || this._$_height$_ <= 0 || (this._$_drawChanged$_ = !1, 
                    this._$_DoUpdate$_());
                }
                _$_DoUpdate$_() {
                    this._$_wasReleased$_ || (this._$_UpdateTextMeasurements$_(), 
                    this._$_SetTextCanvasSize$_(Math.max(C33._$nextHighestPowerOfTwo$_(Math.ceil(this._$_width$_)), 128), Math.max(C33._$nextHighestPowerOfTwo$_(Math.ceil(this._$_height$_)), 64)), 
                    this._$_DrawTextToCanvas$_(), this._$_UpdateTexture$_(), this._$_textureTimeout$_._$Reset$_());
                }
                _$_SetTextCanvasSize$_(t, e) {
                    this._$_textCanvas$_ || (this._$_textCanvas$_ = C33._$CreateCanvas$_(16, 16));
                    let s = !1;
                    this._$_lastCanvasWidth$_ === t && this._$_lastCanvasHeight$_ === e || (this._$_lastCanvasWidth$_ = t, 
                    this._$_lastCanvasHeight$_ = e, this._$_textCanvas$_.width = t, 
                    this._$_textCanvas$_.height = e, s = !0), this._$_textContext$_ || (this._$_textContext$_ = this._$_textCanvas$_.getContext("2d"), 
                    s = !0), s ? (this._$_textContext$_.textBaseline = this._$_isBBcodeEnabled$_ ? "alphabetic" : "top", 
                    this._$_textContext$_.direction = this._$_textDirection$_, this._$_textContext$_.font = this._$_lastTextCanvasFont$_, 
                    this._$_textContext$_.fillStyle = this._$_lastTextCanvasFillStyle$_, 
                    this._$_textContext$_.strokeStyle = this._$_lastTextCanvasFillStyle$_, 
                    this._$_textContext$_.globalAlpha = this._$_lastTextCanvasOpacity$_, 
                    this._$_textContext$_.lineWidth = this._$_lastTextCanvasLineWidth$_) : this._$_textContext$_.clearRect(0, 0, t, e);
                }
                _$_MaybeCreateMeasureContext$_() {
                    this._$_measureContext$_ || (this._$_measureContext$_ = C33._$CreateCanvas$_(16, 16).getContext("2d"), 
                    this._$_measureContextTop$_ = C33._$CreateCanvas$_(16, 16).getContext("2d"), 
                    this._$_measureContext$_.textBaseline = this._$_isBBcodeEnabled$_ ? "alphabetic" : "top", 
                    this._$_measureContextTop$_.textBaseline = "top", this._$_measureContext$_.direction = this._$_textDirection$_, 
                    this._$_measureContextTop$_.direction = this._$_textDirection$_);
                }
                _$_SetMeasureFontString$_(t) {
                    this._$_lastMeasureCanvasFont$_ !== t && (this._$_lastMeasureCanvasFont$_ = t, 
                    this._$_measureContext$_.font = t, this._$_measureContextTop$_.font = t);
                }
                _$_SupportsFontBoundingBoxMeasurements$_() {
                    if (!didCheckFoundBoundingBoxSupport) {
                        didCheckFoundBoundingBoxSupport = !0, this._$_MaybeCreateMeasureContext$_();
                        const t = this._$_measureContext$_.measureText("test");
                        supportsFontBoundingBoxMeasurements = "number" == typeof t.fontBoundingBoxAscent && "number" == typeof t.fontBoundingBoxDescent;
                    }
                    return supportsFontBoundingBoxMeasurements;
                }
                _$_UpdateTextMeasurements$_() {
                    this._$_UpdateWordWrap$_(), this._$_UpdateTextLayout$_();
                }
                _$_UpdateWordWrap$_() {
                    this._$_wordWrapChanged$_ && (this._$_MaybeCreateMeasureContext$_(), 
                    !this._$_isBBcodeEnabled$_ || this._$_bbString$_ && this._$_bbString$_.toString() === this._$_text$_ || (this._$_bbString$_ = new C33._$BBString$_(this._$_text$_, {
                        _$noEscape$_: !0
                    })), this._$_wrappedText$_._$WordWrap$_(this._$_isBBcodeEnabled$_ ? this._$_bbString$_._$toFragmentList$_() : this._$_text$_, this._$_measureTextCallback$_, this._$_cssWidth$_, this._$_wrapMode$_, 0), 
                    this._$_wordWrapChanged$_ = !1);
                }
                _$_UpdateTextLayout$_() {
                    this._$_textLayoutChanged$_ && (this._$_LayoutText$_(), this._$_textLayoutChanged$_ = !1);
                }
                _$_MeasureText$_(t) {
                    let e = t._$IsText$_() ? t._$GetCharacterArray$_().join("") : " ", s = (this._$_SetMeasureFontString$_(this._$_GetFontString$_(!0, t)), 
                    t._$GetStyleTag$_("size")), i = (s ? parseFloat(s.param) : this._$_fontSize$_) * this._$_fontSizeScale$_, r = this._$_measureContext$_.measureText(e), n = 0;
                    if (this._$_isBBcodeEnabled$_ && this._$_SupportsFontBoundingBoxMeasurements$_()) {
                        const h = this._$_measureContextTop$_.measureText(e);
                        n = r.fontBoundingBoxAscent - h.fontBoundingBoxAscent;
                    }
                    return {
                        width: r.width,
                        height: ptToPx2(i),
                        fontBoundingBoxAscent: r.fontBoundingBoxAscent || 0,
                        fontBoundingBoxDescent: r.fontBoundingBoxDescent || 0,
                        _$topToAlphabeticDistance$_: n
                    };
                }
                _$_SetDrawFontString$_(t) {
                    this._$_lastTextCanvasFont$_ !== t && (this._$_lastTextCanvasFont$_ = t, 
                    this._$_textContext$_.font = t);
                }
                _$_SetDrawCanvasColor$_(t) {
                    this._$_lastTextCanvasFillStyle$_ !== t && (this._$_lastTextCanvasFillStyle$_ = t, 
                    this._$_textContext$_.fillStyle = t, this._$_textContext$_.strokeStyle = t);
                }
                _$_SetDrawCanvasOpacity$_(t) {
                    this._$_lastTextCanvasOpacity$_ !== t && (this._$_lastTextCanvasOpacity$_ = t, 
                    this._$_textContext$_.globalAlpha = t);
                }
                _$_SetDrawCanvasLineWith$_(t) {
                    this._$_lastTextCanvasLineWidth$_ !== t && (this._$_lastTextCanvasLineWidth$_ = t, 
                    this._$_textContext$_.lineWidth = t);
                }
                _$_LayoutText$_() {
                    let i = this._$GetDrawScale$_(), r = (EXTRA_LINE_HEIGHT + this._$_lineHeight$_) * i, n = 0, h = this._$_wrappedText$_._$GetLines$_();
                    if (0 !== h.length) {
                        for (const e of h) {
                            e._$SetPosX$_(NaN), e._$SetPosY$_(NaN);
                            for (const o of e._$fragments$_()) o._$SetPosX$_(NaN), 
                            o._$SetPosY$_(NaN);
                        }
                        let t = this._$_isBBcodeEnabled$_ && this._$_SupportsFontBoundingBoxMeasurements$_(), s = h[0]._$GetHeight$_() * i;
                        if ("center" === this._$_verticalAlign$_) {
                            const a = h.reduce((t, e) => t + e._$GetHeight$_() * i + r, 0) - r;
                            n = Math.max(this._$_height$_ / 2 - a / 2, 0), t && (s = h[0]._$GetTopToAlphabeticDistance$_() * i);
                        } else if ("bottom" === this._$_verticalAlign$_) {
                            const l = h.reduce((t, e) => t + e._$GetHeight$_() * i + r, 0) - this._$_lineHeight$_ * i, u = t ? h.at(-1)._$GetFontBoundingBoxDescent$_() * i : 0;
                            n = this._$_height$_ - l - u - 2;
                        }
                        for (let t = 0, e = h.length; t < e; ++t) {
                            const c = h[t], f = c._$GetHeight$_() * i, d = n;
                            if (this._$_isBBcodeEnabled$_) {
                                if (n += 0 === t ? s : f, 0 < t && n > this._$_height$_ - EXTRA_LINE_HEIGHT * i) break;
                            } else if (0 < t && n >= this._$_height$_ - f) break;
                            0 <= d && this._$_LayoutTextLine$_(c, n, i), this._$_isBBcodeEnabled$_ || (n += f), 
                            n += r;
                        }
                    }
                }
                _$_LayoutTextLine$_(t, e, s) {
                    let i = 0;
                    "center" === this._$_horizontalAlign$_ ? i = Math.floor((this._$_width$_ - t._$GetWidth$_() * s) / 2) : "right" === this._$_horizontalAlign$_ && (i = this._$_width$_ - t._$GetWidth$_() * s), 
                    t._$SetPosX$_(i), t._$SetPosY$_(e);
                    for (const r of "ltr" === this._$_textDirection$_ ? t._$fragments$_() : t._$fragmentsReverse$_()) this._$_LayoutFragment$_(r, i, e, s), 
                    i += r._$GetWidth$_() * s;
                }
                _$_LayoutFragment$_(t, e, s, i) {
                    const r = t._$GetStyleTag$_("offsetx"), n = (e += r ? getOffsetParam2(r.param, t._$GetHeight$_()) * i : 0, 
                    t._$GetStyleTag$_("offsety"));
                    if (s += n ? getOffsetParam2(n.param, t._$GetHeight$_()) * i : 0, 
                    t._$IsIcon$_()) {
                        const h = t._$GetStyleTag$_("iconoffsety");
                        s += h ? getOffsetParam2(h.param, t._$GetHeight$_()) * i : .2 * t._$GetHeight$_() * i;
                    }
                    t._$SetPosX$_(e), t._$SetPosY$_(s);
                }
                _$_DrawTextToCanvas$_() {
                    this._$_textContext$_.imageSmoothingEnabled = this._$_iconSmoothing$_, 
                    this._$_textContext$_.imageSmoothingQuality = "high", this._$_drawCharCount$_ = 0;
                    const t = this._$GetDrawScale$_(), e = this._$_wrappedText$_._$GetLines$_();
                    for (const s of e) this._$_DrawTextLine$_(s, t);
                }
                _$_DrawTextLine$_(t, e) {
                    const s = t._$GetPosX$_(), i = t._$GetPosY$_();
                    if (Number.isFinite(s) && Number.isFinite(i)) for (const r of "ltr" === this._$_textDirection$_ ? t._$fragments$_() : t._$fragmentsReverse$_()) this._$_DrawFragment$_(r, e, t._$GetHeight$_());
                }
                _$_DrawFragment$_(h, o, a) {
                    const l = this._$_textContext$_, u = h._$GetPosX$_(), c = h._$GetPosY$_();
                    if (Number.isFinite(u) && Number.isFinite(c)) {
                        let t = a / 16, e = h._$GetWidth$_() * o, s = h._$GetHeight$_() * o, i = h._$GetHeight$_() / 16, r = (EXTRA_LINE_HEIGHT + this._$_lineHeight$_) * o, n = h._$IsText$_() ? h._$GetCharacterArray$_() : null;
                        if (-1 !== this._$_drawMaxCharCount$_) {
                            if (this._$_drawCharCount$_ >= this._$_drawMaxCharCount$_) return;
                            h._$IsText$_() && this._$_drawCharCount$_ + n.length > this._$_drawMaxCharCount$_ && (n = n.slice(0, this._$_drawMaxCharCount$_ - this._$_drawCharCount$_), 
                            e = this._$_MeasureText$_(h).width * o), this._$_drawCharCount$_ += h._$GetLength$_();
                        }
                        const f = h._$GetStyleTag$_("background"), d = h._$HasStyleTag$_("u"), p = h._$HasStyleTag$_("s");
                        if ((!h._$IsText$_() || !C33._$IsCharArrayAllWhitespace$_(n) || f || d || p) && !h._$HasStyleTag$_("hide")) {
                            const m = h._$GetStyleTag$_("color"), C = h._$GetStyleTag$_("opacity"), g = (this._$_SetDrawCanvasOpacity$_(C ? parseFloat(C.param) / 100 : 1), 
                            f && (this._$_SetDrawCanvasColor$_(f.param), l.fillRect(u, c - s, e, s + r)), 
                            h._$GetStyleTag$_("linethickness")), S = g ? parseFloat(g.param) : 1, _ = h._$HasStyleTag$_("stroke");
                            if (_ && this._$_SetDrawCanvasLineWith$_(.5 * i * S * this._$GetDrawScale$_()), 
                            h._$IsText$_()) {
                                const T = n.join("");
                                if (this._$_SetDrawFontString$_(this._$_GetFontString$_(!1, h)), 
                                !_) {
                                    this._$_SetDrawCanvasLineWith$_(.5 * i * S * this._$GetDrawScale$_());
                                    const y = h._$GetStyleTag$_("outlineback");
                                    y && (this._$_SetDrawCanvasColor$_(y.param), 
                                    this._$_FillOrStrokeText$_(!0, T, u, c, e));
                                }
                                if (this._$_SetDrawCanvasColor$_(m ? m.param : this._$_colorStr$_), 
                                this._$_FillOrStrokeText$_(_, T, u, c, e), !_) {
                                    this._$_SetDrawCanvasLineWith$_(.5 * i * S * this._$GetDrawScale$_());
                                    const E = h._$GetStyleTag$_("outline");
                                    E && (this._$_SetDrawCanvasColor$_(E.param), 
                                    this._$_FillOrStrokeText$_(!0, T, u, c, e));
                                }
                            } else if (h._$IsIcon$_() && 0 < h._$GetWidth$_()) {
                                const A = h._$GetDrawable$_(this._$_iconSet$_);
                                A && l.drawImage(A, u, c - s, e, s);
                            }
                            if (this._$_SetDrawCanvasColor$_(m ? m.param : this._$_colorStr$_), 
                            d && fillOrStrokeRect2(l, _, u, c + o * t, e, o * t * S), 
                            p) {
                                const I = c - s / 4, M = o * i, w = I + M / 2;
                                l.fillRect(u, w - M * S / 2, e, M * S);
                            }
                        }
                    }
                }
                _$_FillOrStrokeText$_(t, e, s, i, r) {
                    "rtl" === this._$_textDirection$_ && (s += r), t ? "Gecko" === C33._$Platform$_._$BrowserEngine$_ ? this._$_textContext$_.strokeText(e, s, i, r) : this._$_textContext$_.strokeText(e, s, i) : "Gecko" === C33._$Platform$_._$BrowserEngine$_ ? this._$_textContext$_.fillText(e, s, i, r) : this._$_textContext$_.fillText(e, s, i);
                }
                _$_UpdateTexture$_() {
                    this._$_renderer$_._$IsContextLost$_() || (this._$_texture$_ || (this._$_texture$_ = this._$_renderer$_._$CreateDynamicTexture$_(this._$_textCanvas$_.width, this._$_textCanvas$_.height, {
                        _$mipMap$_: !0,
                        _$mipMapQuality$_: "high"
                    })), this._$_renderer$_._$UpdateTexture$_(this._$_textCanvas$_, this._$_texture$_), 
                    this._$_rcTex$_.set(0, 0, this._$_width$_ / this._$_texture$_._$GetWidth$_(), this._$_height$_ / this._$_texture$_._$GetHeight$_()), 
                    this._$ontextureupdate$_ && this._$ontextureupdate$_());
                }
                _$GetTexRect$_() {
                    return this._$_rcTex$_;
                }
                _$ReleaseTexture$_() {
                    this._$_texture$_ && (this._$_renderer$_._$IsContextLost$_() || this._$_renderer$_._$DeleteTexture$_(this._$_texture$_), 
                    this._$_texture$_ = null);
                }
                static _$OnContextLost$_() {
                    for (const t of allRendererTexts) t._$ReleaseTexture$_();
                }
                static _$GetAll$_() {
                    return allRendererTexts.values();
                }
            };
        }
        {
            const C33 = self._$C3$_;
            class WebGLRealTimeElapsedQuery {
                constructor(t) {
                    this._$_gl$_ = t._$GetContext$_(), this._$_version$_ = t._$GetWebGLVersionNumber$_(), 
                    this._$_timerExt$_ = t._$_GetDisjointTimerQueryExtension$_(), 
                    this._$_query$_ = null, this._$_isActive$_ = !1, this._$_hasResult$_ = !1, 
                    this._$_result$_ = 0, 1 === this._$_version$_ ? this._$_query$_ = this._$_timerExt$_.createQueryEXT() : this._$_query$_ = this._$_gl$_.createQuery();
                }
                _$Release$_() {
                    this._$_DeleteQueryObject$_(), this._$_gl$_ = null, this._$_timerExt$_ = null, 
                    this._$_hasResult$_ = !1;
                }
                _$_DeleteQueryObject$_() {
                    this._$_query$_ && (1 === this._$_version$_ ? this._$_timerExt$_.deleteQueryEXT(this._$_query$_) : this._$_gl$_.deleteQuery(this._$_query$_), 
                    this._$_query$_ = null);
                }
                _$BeginTimeElapsed$_() {
                    if (this._$_isActive$_) throw new Error("query already active");
                    1 === this._$_version$_ ? this._$_timerExt$_.beginQueryEXT(this._$_timerExt$_.TIME_ELAPSED_EXT, this._$_query$_) : this._$_gl$_.beginQuery(this._$_timerExt$_.TIME_ELAPSED_EXT, this._$_query$_), 
                    this._$_isActive$_ = !0;
                }
                _$EndTimeElapsed$_() {
                    if (!this._$_isActive$_) throw new Error("query not active");
                    1 === this._$_version$_ ? this._$_timerExt$_.endQueryEXT(this._$_timerExt$_.TIME_ELAPSED_EXT) : this._$_gl$_.endQuery(this._$_timerExt$_.TIME_ELAPSED_EXT), 
                    this._$_isActive$_ = !1;
                }
                _$CheckForResult$_() {
                    if (this._$_query$_ && !this._$_hasResult$_ && !this._$_isActive$_) {
                        let t;
                        t = 1 === this._$_version$_ ? this._$_timerExt$_.getQueryObjectEXT(this._$_query$_, this._$_timerExt$_.QUERY_RESULT_AVAILABLE_EXT) : this._$_gl$_.getQueryParameter(this._$_query$_, this._$_gl$_.QUERY_RESULT_AVAILABLE);
                        const e = this._$_gl$_.getParameter(this._$_timerExt$_.GPU_DISJOINT_EXT);
                        t && !e && (1 === this._$_version$_ ? this._$_result$_ = this._$_timerExt$_.getQueryObjectEXT(this._$_query$_, this._$_timerExt$_.QUERY_RESULT_EXT) : this._$_result$_ = this._$_gl$_.getQueryParameter(this._$_query$_, this._$_gl$_.QUERY_RESULT), 
                        this._$_result$_ /= 1e9, this._$_hasResult$_ = !0), (t || e) && this._$_DeleteQueryObject$_();
                    }
                }
                _$HasResult$_() {
                    return this._$_hasResult$_;
                }
                _$GetResult$_() {
                    if (this._$_hasResult$_) return this._$_result$_;
                    throw new Error("no result available");
                }
            }
            C33._$Gfx$_._$WebGLTimeElapsedQuery$_ = class {
                constructor(t) {
                    this._$_renderer$_ = t, this._$_frameNumber$_ = t._$GetFrameNumber$_(), 
                    this._$_isActive$_ = !1, this._$_parentQuery$_ = null, this._$_isNested$_ = !1, 
                    this._$_realQuery$_ = null, this._$_queries$_ = [];
                }
                _$Release$_() {
                    for (const t of this._$_queries$_) t instanceof WebGLRealTimeElapsedQuery && t._$Release$_();
                    C33._$clearArray$_(this._$_queries$_), this._$_parentQuery$_ = null, 
                    this._$_realQuery$_ = null, this._$_renderer$_ = null;
                }
                _$BeginTimeElapsed$_() {
                    if (this._$_isActive$_) throw new Error("query already active");
                    const t = this._$_renderer$_._$_GetTimeQueryStack$_();
                    0 < t.length ? (this._$_isNested$_ = !0, this._$_parentQuery$_ = t.at(-1), 
                    this._$_parentQuery$_._$_EndReal$_(), this._$_parentQuery$_._$_queries$_.push(this)) : (this._$_isNested$_ = !1, 
                    this._$_parentQuery$_ = null), this._$_isActive$_ = !0, t.push(this), 
                    this._$_StartReal$_();
                }
                _$EndTimeElapsed$_() {
                    if (!this._$_isActive$_) throw new Error("query not active");
                    const t = this._$_renderer$_._$_GetTimeQueryStack$_().pop();
                    if (t !== this) throw new Error("can only end most nested query");
                    this._$_isActive$_ = !1, this._$_EndReal$_(), this._$_parentQuery$_ && (this._$_parentQuery$_._$_StartReal$_(), 
                    this._$_parentQuery$_ = null);
                }
                _$_StartReal$_() {
                    this._$_realQuery$_ = C33._$New$_(WebGLRealTimeElapsedQuery, this._$_renderer$_), 
                    this._$_queries$_.push(this._$_realQuery$_), this._$_realQuery$_._$BeginTimeElapsed$_();
                }
                _$_EndReal$_() {
                    this._$_realQuery$_._$EndTimeElapsed$_(), this._$_realQuery$_ = null;
                }
                _$CheckForResult$_() {
                    for (const t of this._$_queries$_) t._$CheckForResult$_();
                }
                _$IsNested$_() {
                    return this._$_isNested$_;
                }
                _$HasResult$_() {
                    return this._$_queries$_.every(t => t._$HasResult$_());
                }
                _$GetResult$_() {
                    return this._$_queries$_.reduce((t, e) => t + e._$GetResult$_(), 0);
                }
                _$GetFrameNumber$_() {
                    return this._$_frameNumber$_;
                }
            };
        }
        {
            const C33 = self._$C3$_;
            C33._$Gfx$_._$WebGLQueryResultBuffer$_ = class {
                constructor(t, e = 1e3) {
                    this._$_renderer$_ = t, this._$_maxQueries$_ = e, this._$_buffer$_ = [], 
                    this._$_renderer$_._$_AddQueryResultBuffer$_(this);
                }
                _$Release$_() {
                    this._$Clear$_(), this._$_renderer$_._$_RemoveQueryResultBuffer$_(this), 
                    this._$_renderer$_ = null;
                }
                _$Clear$_() {
                    for (const t of this._$_buffer$_) t._$Release$_();
                    C33._$clearArray$_(this._$_buffer$_);
                }
                _$AddTimeElapsedQuery$_() {
                    const t = new C33._$Gfx$_._$WebGLTimeElapsedQuery$_(this._$_renderer$_);
                    if (this._$_buffer$_.push(t), this._$_buffer$_.length > this._$_maxQueries$_) {
                        const e = this._$_buffer$_.shift();
                        e._$Release$_();
                    }
                    return t;
                }
                _$CheckForResults$_(t) {
                    for (const e of this._$_buffer$_) {
                        if (e._$GetFrameNumber$_() >= t) return;
                        if (e._$IsNested$_()) return;
                        e._$CheckForResult$_();
                    }
                }
                _$GetFrameRangeResultSum$_(t, e) {
                    if (e <= t) return NaN;
                    let s = 0;
                    for (const i of this._$_buffer$_) {
                        if (i._$GetFrameNumber$_() >= e) break;
                        if (!(i._$GetFrameNumber$_() < t)) {
                            if (!i._$HasResult$_()) return NaN;
                            s += i._$GetResult$_();
                        }
                    }
                    return s;
                }
                _$DeleteAllBeforeFrameNumber$_(s) {
                    for (let t = 0, e = this._$_buffer$_.length; t < e; ++t) {
                        const i = this._$_buffer$_[t];
                        if (!(i._$GetFrameNumber$_() < s)) return void (0 < t && this._$_buffer$_.splice(0, t));
                        i._$Release$_();
                    }
                }
            };
        }
        {
            let CheckPendingPolls2 = function() {
                pollRafId = -1;
                for (const t of pendingPolls) t._$checkFunc$_() && (t.resolve(), 
                pendingPolls.delete(t));
                0 < pendingPolls.size && (pollRafId = self.requestAnimationFrame(CheckPendingPolls2));
            }, C33 = (CheckPendingPolls = CheckPendingPolls2, self._$C3$_), assert = self.assert, glMatrix = self._$glMatrix$_, vec32 = glMatrix._$vec3$_, vec42 = glMatrix._$vec4$_, mat42 = glMatrix._$mat4$_, DEFAULT_WEBGLRENDERER_OPTS = {
                powerPreference: "default",
                _$enableGpuProfiling$_: !0,
                alpha: !1,
                depth: !1,
                _$canSampleDepth$_: !1,
                _$maxWebGLVersion$_: 2,
                failIfMajorPerformanceCaveat: !1
            }, VALID_POWER_PREFERENCES = new Set([ "default", "low-power", "high-performance" ]), MAX_VERTICES = 8e3, MAX_INDICES = MAX_VERTICES / 2 * 3, MAX_POINTS = 8e3, LAST_POINT = MAX_POINTS - 4, PARTIAL_TEXTURE_UPLOAD_CHUNK_SIZE = 262144, defaultTexCoordsQuad = new C33._$Quad$_(0, 0, 1, 0, 1, 1, 0, 1), tmpProjection = mat42.create(), tmpModelView = mat42.create(), tmpQuad = new C33._$Quad$_(), tmpRect = new C33.Rect(), loseContextExtension = null, pendingPolls = (C33.isDebug && (self._$debug_lose_webgl_context$_ = function() {
                loseContextExtension ? loseContextExtension.loseContext() : console.warn("WEBGL_lose_context not supported");
            }, self._$debug_restore_webgl_context$_ = function() {
                loseContextExtension ? loseContextExtension.restoreContext() : console.warn("WEBGL_lose_context not supported");
            }), new Set()), pollRafId = -1;
            C33._$Gfx$_._$WebGLRenderer$_ = class extends C33._$Gfx$_._$RendererBase$_ {
                constructor(t, e) {
                    if (super(e), e = Object.assign({}, DEFAULT_WEBGLRENDERER_OPTS, e), 
                    !VALID_POWER_PREFERENCES.has(e.powerPreference)) throw new Error("invalid power preference");
                    let s = {
                        alpha: !!e.alpha,
                        depth: !1,
                        antialias: !1,
                        powerPreference: e.powerPreference,
                        failIfMajorPerformanceCaveat: !!e.failIfMajorPerformanceCaveat
                    }, i = null, r = 0;
                    if (2 <= e._$maxWebGLVersion$_ && (i = t.getContext("webgl2", s), 
                    r = 2), i || (i = t.getContext("webgl", s), r = 1), !i) throw new Error("renderer-unavailable (could not get WebGL context)");
                    this._$_gl$_ = i, this._$_attribs$_ = i.getContextAttributes(), 
                    this._$_versionString$_ = i.getParameter(i.VERSION), this._$_version$_ = r, 
                    this._$_viewport$_ = vec42.create(), this._$_didChangeTransform$_ = !1, 
                    this._$_bbProjectionMatrix$_ = mat42.create(), this._$_usesDepthBuffer$_ = !!e.depth, 
                    this._$_canSampleDepth$_ = !(!e.depth || !e._$canSampleDepth$_), 
                    this._$_isDepthEnabled$_ = this._$_usesDepthBuffer$_, this._$_isDepthSamplingEnabled$_ = !1, 
                    this._$_depthBuffer$_ = null, this._$_isAutoSizeDepthBuffer$_ = !0, 
                    this._$_depthBufferWidth$_ = 0, this._$_depthBufferHeight$_ = 0, 
                    this._$_vertexBuffer$_ = null, this._$_texcoordBuffer$_ = null, 
                    this._$_indexBuffer$_ = null, this._$_pointBuffer$_ = null, 
                    this._$_vertexData$_ = new Float32Array(MAX_VERTICES * this._$GetNumVertexComponents$_()), 
                    this._$_indexData$_ = new Uint16Array(MAX_INDICES), this._$_texcoordData$_ = new Float32Array(2 * MAX_VERTICES), 
                    this._$_pointData$_ = new Float32Array(4 * MAX_POINTS), this._$_vertexPtr$_ = 0, 
                    this._$_texPtr$_ = 0, this._$_pointPtr$_ = 0, this._$_lastVertexPtr$_ = 0, 
                    this._$_lastProgram$_ = null, this._$_spDeviceTransformTextureFill$_ = null, 
                    this._$_batch$_ = [], this._$_batchPtr$_ = 0, this._$_topOfBatch$_ = 0, 
                    this._$_currentRenderTarget$_ = null, this._$_lastPointZ$_ = 0, 
                    this._$_batchState$_ = C33._$New$_(C33._$Gfx$_._$BatchState$_, this), 
                    this._$_lastColor$_ = C33._$New$_(C33._$Color$_, 1, 1, 1, 1), 
                    this._$_lastTexture0$_ = null, this._$_lastTexture1$_ = null, 
                    this._$_lastSrcBlend$_ = 0, this._$_lastDestBlend$_ = 0, this._$_lastPointTexCoords$_ = new C33.Rect(), 
                    this._$_lastScissorRect$_ = C33._$New$_(C33.Rect, 0, 0, -1, -1), 
                    this._$_coplanarMode$_ = 0, this._$_maxTextureSize$_ = -1, this._$_minPointSize$_ = 0, 
                    this._$_maxPointSize$_ = 0, this._$_highpPrecision$_ = 0, this._$_unmaskedVendor$_ = "(unavailable)", 
                    this._$_unmaskedRenderer$_ = "(unavailable)", this._$_extensions$_ = [], 
                    this._$_isInitialisingAfterContextRestored$_ = !1, this._$_parallelShaderCompileExt$_ = null, 
                    this._$_anisotropicExt$_ = null, this._$_depthTextureExt$_ = null, 
                    this._$_fragDepthExt$_ = null, this._$_stdDerivativesExt$_ = null, 
                    this._$_textureLodExt$_ = null, this._$_maxAnisotropy$_ = 0, 
                    this._$_isGpuProfilingEnabled$_ = !!e._$enableGpuProfiling$_, 
                    this._$_timerExt$_ = null, this._$_allQueryResultBuffers$_ = new Set(), 
                    this._$_timeQueryStack$_ = [], this._$FillIndexBufferData$_(this._$_indexData$_);
                }
                _$IsWebGL$_() {
                    return !0;
                }
                async _$InitState$_() {
                    super._$InitState$_();
                    const t = this._$_gl$_, e = this._$GetNumVertexComponents$_(), s = (this._$_lastColor$_._$setRgba$_(1, 1, 1, 1), 
                    this._$_lastTexture0$_ = null, this._$_lastTexture1$_ = null, 
                    this._$_vertexPtr$_ = 0, this._$_pointPtr$_ = 0, this._$_lastVertexPtr$_ = MAX_VERTICES * e - 4 * e, 
                    C33._$clearArray$_(this._$_batch$_), this._$_batchPtr$_ = 0, 
                    this._$_topOfBatch$_ = 0, this._$_lastProgram$_ = null, this._$_currentRenderTarget$_ = null, 
                    this._$_lastPointTexCoords$_.set(0, 0, 1, 1), this._$_lastPointZ$_ = 0, 
                    this._$_batchState$_), i = (s._$currentShader$_ = null, s._$currentFramebuffer$_ = null, 
                    s._$currentFramebufferNoDepth$_ = null, vec42.set(s._$currentColor$_, 1, 1, 1, 1), 
                    s.clearColor._$setRgba$_(0, 0, 0, 0), s._$pointTexCoords$_.set(0, 0, 1, 1), 
                    t.clearColor(0, 0, 0, 0), t.clear(t.COLOR_BUFFER_BIT), t.enable(t.BLEND), 
                    t.blendFunc(t.ONE, t.ONE_MINUS_SRC_ALPHA), this._$_lastSrcBlend$_ = t.ONE, 
                    this._$_lastDestBlend$_ = t.ONE_MINUS_SRC_ALPHA, this._$_InitBlendModes$_(t), 
                    t.disable(t.CULL_FACE), t.disable(t.STENCIL_TEST), t.disable(t.DITHER), 
                    this._$_usesDepthBuffer$_ ? (t.enable(t.DEPTH_TEST), t.depthMask(!0), 
                    t.depthFunc(t.LEQUAL)) : (t.disable(t.DEPTH_TEST), t.depthMask(!1)), 
                    this._$_isDepthEnabled$_ = this._$_usesDepthBuffer$_, this._$_isDepthSamplingEnabled$_ = !1, 
                    this._$_pointBuffer$_ = t.createBuffer(), t.bindBuffer(t.ARRAY_BUFFER, this._$_pointBuffer$_), 
                    t.bufferData(t.ARRAY_BUFFER, this._$_pointData$_.byteLength, t.DYNAMIC_DRAW), 
                    this._$_vertexBuffer$_ = t.createBuffer(), t.bindBuffer(t.ARRAY_BUFFER, this._$_vertexBuffer$_), 
                    t.bufferData(t.ARRAY_BUFFER, this._$_vertexData$_.byteLength, t.DYNAMIC_DRAW), 
                    this._$_texcoordBuffer$_ = t.createBuffer(), t.bindBuffer(t.ARRAY_BUFFER, this._$_texcoordBuffer$_), 
                    t.bufferData(t.ARRAY_BUFFER, this._$_texcoordData$_.byteLength, t.DYNAMIC_DRAW), 
                    this._$_indexBuffer$_ = t.createBuffer(), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this._$_indexBuffer$_), 
                    t.bufferData(t.ELEMENT_ARRAY_BUFFER, this._$_indexData$_, t.STATIC_DRAW), 
                    t.activeTexture(t.TEXTURE0), t.bindTexture(t.TEXTURE_2D, null), 
                    this._$_maxTextureSize$_ = t.getParameter(t.MAX_TEXTURE_SIZE), 
                    t.getParameter(t.ALIASED_POINT_SIZE_RANGE)), r = (this._$_minPointSize$_ = i[0], 
                    this._$_maxPointSize$_ = i[1], t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.HIGH_FLOAT)), n = t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT), h = (this._$_highpPrecision$_ = r && n ? Math.min(r.precision, n.precision) : 0, 
                    2048 < this._$_maxPointSize$_ && (this._$_maxPointSize$_ = 2048), 
                    this._$_extensions$_ = t.getSupportedExtensions(), t.getExtension("WEBGL_debug_renderer_info"));
                    if (h && (this._$_unmaskedVendor$_ = t.getParameter(h.UNMASKED_VENDOR_WEBGL), 
                    this._$_unmaskedRenderer$_ = t.getParameter(h.UNMASKED_RENDERER_WEBGL)), 
                    this._$_parallelShaderCompileExt$_ = t.getExtension("KHR_parallel_shader_compile"), 
                    C33.isDebug && (loseContextExtension = t.getExtension("WEBGL_lose_context")), 
                    this._$_isGpuProfilingEnabled$_ && (1 === this._$GetWebGLVersionNumber$_() ? this._$_timerExt$_ = t.getExtension("EXT_disjoint_timer_query") : this._$_timerExt$_ = t.getExtension("EXT_disjoint_timer_query_webgl2") || t.getExtension("EXT_disjoint_timer_query")), 
                    this._$_anisotropicExt$_ = t.getExtension("EXT_texture_filter_anisotropic"), 
                    this._$_anisotropicExt$_ ? this._$_maxAnisotropy$_ = t.getParameter(this._$_anisotropicExt$_.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : this._$_maxAnisotropy$_ = 0, 
                    this._$GetWebGLVersionNumber$_() < 2 && this._$_usesDepthBuffer$_ && this._$_canSampleDepth$_ && (this._$_depthTextureExt$_ = t.getExtension("WEBGL_depth_texture"), 
                    !this._$_depthTextureExt$_)) throw new Error("no depth texture support");
                    this._$GetWebGLVersionNumber$_() < 2 && (this._$_fragDepthExt$_ = t.getExtension("EXT_frag_depth"), 
                    this._$_stdDerivativesExt$_ = t.getExtension("OES_standard_derivatives"), 
                    this._$_textureLodExt$_ = t.getExtension("EXT_shader_texture_lod"));
                    let o = C33._$Gfx$_._$WebGLShaderProgram$_, a = o._$GetDefaultVertexShaderSource$_(!1), l = o._$GetTextureFillFragmentShaderSource_WebGL1_NoFragDepth$_(), u = a, c = o._$GetPointFragmentShaderSource_WebGL1_NoFragDepth$_(), f = o._$GetPointVertexShaderSource_WebGL1$_(), d = o._$GetTilemapFragmentShaderSource_WebGL1_NoFragDepth$_(), p = o._$GetDefaultVertexShaderSource$_(!0), m = !1;
                    this._$_usesDepthBuffer$_ && (this._$GetWebGLVersionNumber$_() < 2 ? this._$_fragDepthExt$_ && (l = o._$GetTextureFillFragmentShaderSource_WebGL1_FragDepthEXT$_(), 
                    c = o._$GetPointFragmentShaderSource_WebGL1_FragDepthEXT$_(), 
                    d = o._$GetTilemapFragmentShaderSource_WebGL1_FragDepthEXT$_(), 
                    m = !0) : (u = o._$GetDefaultVertexShaderSource_WebGL2$_(), 
                    l = o._$GetTextureFillFragmentShaderSource_WebGL2$_(), c = o._$GetPointFragmentShaderSource_WebGL2$_(), 
                    f = o._$GetPointVertexShaderSource_WebGL2$_(), d = o._$GetTilemapFragmentShaderSource_WebGL2$_(), 
                    p = o._$GetDefaultVertexShaderSource_WebGL2$_(!0)));
                    const C = o._$GetTileRandomizationFragmentShaderSource$_(this._$GetWebGLVersionNumber$_(), m, this._$_stdDerivativesExt$_ && this._$_textureLodExt$_), g = 2 <= this._$GetWebGLVersionNumber$_() ? o._$GetDefaultVertexShaderSource_WebGL2$_() : a, S = [ [ l, u, "<default>" ], [ l, u, "<default-device-transform>" ], [ c, f, "<point>" ], [ o._$GetColorFillFragmentShaderSource$_(), a, "<fill>" ], [ o._$GetLinearGradientFillFragmentShaderSource$_(), a, "<lineargradient>" ], [ o._$GetPenumbraFillFragmentShaderSource$_(), a, "<penumbra>" ], [ o._$GetHardEllipseFillFragmentShaderSource$_(), a, "<hardellipse>" ], [ o._$GetHardEllipseOutlineFragmentShaderSource$_(), a, "<hardellipseoutline>" ], [ o._$GetSmoothEllipseFillFragmentShaderSource$_(), a, "<smoothellipse>" ], [ o._$GetSmoothEllipseOutlineFragmentShaderSource$_(), a, "<smoothellipseoutline>" ], [ o._$GetSmoothLineFillFragmentShaderSource$_(), a, "<smoothline>" ], [ d, p, "<tilemap>" ], [ C, g, "<tilerandomization>" ] ], _ = await Promise.all(S.map(t => this._$CreateShaderProgram$_({
                        src: t[0],
                        _$vertexSrc$_: t[1],
                        name: t[2]
                    })));
                    this._$_spTextureFill$_ = _[0], this._$_spDeviceTransformTextureFill$_ = _[1], 
                    this._$_spPoints$_ = _[2], this._$_spColorFill$_ = _[3], this._$_spLinearGradientFill$_ = _[4], 
                    this._$_spPenumbraFill$_ = _[5], this._$_spHardEllipseFill$_ = _[6], 
                    this._$_spHardEllipseOutline$_ = _[7], this._$_spSmoothEllipseFill$_ = _[8], 
                    this._$_spSmoothEllipseOutline$_ = _[9], this._$_spSmoothLineFill$_ = _[10], 
                    this._$_spTilemapFill$_ = _[11], this._$_spTileRandomization$_ = _[12], 
                    this._$SetTextureFillMode$_();
                }
                async _$CreateShaderProgram$_(t) {
                    const e = await C33._$Gfx$_._$WebGLShaderProgram$_._$Create$_(this, t);
                    return this._$_AddShaderProgram$_(e), e;
                }
                _$ResetLastProgram$_() {
                    this._$_lastProgram$_ = null;
                }
                _$SetSize$_(t, e, s) {
                    if (this._$_width$_ !== t || this._$_height$_ !== e || s) {
                        this._$EndBatch$_();
                        const i = this._$_gl$_, r = this._$_batchState$_;
                        this._$_width$_ = t, this._$_height$_ = e, this._$_SetViewport$_(0, 0, t, e), 
                        this._$CalculatePerspectiveMatrix$_(this._$_bbProjectionMatrix$_, t / e), 
                        this._$SetProjectionMatrix$_(this._$_bbProjectionMatrix$_), 
                        this._$_spDeviceTransformTextureFill$_ && (i.useProgram(this._$_spDeviceTransformTextureFill$_._$GetShaderProgram$_()), 
                        this._$_spDeviceTransformTextureFill$_._$_UpdateDeviceTransformUniforms$_(this._$_matP$_), 
                        this._$_lastProgram$_ = this._$_spDeviceTransformTextureFill$_, 
                        this._$_batchState$_._$currentShader$_ = this._$_spDeviceTransformTextureFill$_), 
                        i.bindTexture(i.TEXTURE_2D, null), i.activeTexture(i.TEXTURE1), 
                        i.bindTexture(i.TEXTURE_2D, null), i.activeTexture(i.TEXTURE0), 
                        this._$_lastTexture0$_ = null, this._$_lastTexture1$_ = null, 
                        this._$_usesDepthBuffer$_ && this._$_isAutoSizeDepthBuffer$_ && this._$_SetDepthBufferSize$_(this._$_width$_, this._$_height$_), 
                        this._$_currentRenderTarget$_ && this._$_currentRenderTarget$_._$_Resize$_(this._$_width$_, this._$_height$_), 
                        i.bindFramebuffer(i.FRAMEBUFFER, null), this._$_currentRenderTarget$_ = null, 
                        r._$currentFramebuffer$_ = null, r._$currentFramebufferNoDepth$_ = null;
                    }
                }
                _$_SetDepthBufferSize$_(t, e) {
                    const s = this._$_gl$_;
                    this._$_depthBuffer$_ && this._$_depthBufferWidth$_ === t && this._$_depthBufferHeight$_ === e || (this._$_canSampleDepth$_ ? (this._$_depthBuffer$_ && s.deleteTexture(this._$_depthBuffer$_), 
                    this._$_depthBuffer$_ = s.createTexture(), s.bindTexture(s.TEXTURE_2D, this._$_depthBuffer$_), 
                    s.texParameteri(s.TEXTURE_2D, s.TEXTURE_MAG_FILTER, s.NEAREST), 
                    s.texParameteri(s.TEXTURE_2D, s.TEXTURE_MIN_FILTER, s.NEAREST), 
                    s.texParameteri(s.TEXTURE_2D, s.TEXTURE_WRAP_S, s.CLAMP_TO_EDGE), 
                    s.texParameteri(s.TEXTURE_2D, s.TEXTURE_WRAP_T, s.CLAMP_TO_EDGE), 
                    2 <= this._$GetWebGLVersionNumber$_() ? s.texImage2D(s.TEXTURE_2D, 0, s.DEPTH24_STENCIL8, t, e, 0, s.DEPTH_STENCIL, s.UNSIGNED_INT_24_8, null) : this._$_depthTextureExt$_ && s.texImage2D(s.TEXTURE_2D, 0, s.DEPTH_STENCIL, t, e, 0, s.DEPTH_STENCIL, this._$_depthTextureExt$_.UNSIGNED_INT_24_8_WEBGL, null), 
                    s.bindTexture(s.TEXTURE_2D, null)) : (this._$_depthBuffer$_ && s.deleteRenderbuffer(this._$_depthBuffer$_), 
                    this._$_depthBuffer$_ = s.createRenderbuffer(), s.bindRenderbuffer(s.RENDERBUFFER, this._$_depthBuffer$_), 
                    s.renderbufferStorage(s.RENDERBUFFER, 2 <= this._$_version$_ ? s.DEPTH24_STENCIL8 : s.DEPTH_STENCIL, t, e), 
                    s.bindRenderbuffer(s.RENDERBUFFER, null)), this._$_depthBufferWidth$_ = t, 
                    this._$_depthBufferHeight$_ = e);
                }
                _$SetFixedSizeDepthBuffer$_(t, e) {
                    this._$_usesDepthBuffer$_ && (this._$_isAutoSizeDepthBuffer$_ = !1, 
                    this._$_SetDepthBufferSize$_(t, e));
                }
                _$SetAutoSizeDepthBuffer$_() {
                    this._$_usesDepthBuffer$_ && (this._$_isAutoSizeDepthBuffer$_ = !0, 
                    this._$_SetDepthBufferSize$_(this._$_width$_, this._$_height$_));
                }
                _$_SetViewport$_(t, e, s, i) {
                    const r = this._$_viewport$_;
                    if (r[0] !== t || r[1] !== e || r[2] !== s || r[3] !== i) {
                        const n = this._$PushBatch$_();
                        n._$InitSetViewport$_(t, e, s, i), vec42.set(r, t, e, s, i), 
                        this._$_topOfBatch$_ = 0;
                    }
                }
                _$SetFovY$_(t) {
                    super._$SetFovY$_(t), this._$CalculatePerspectiveMatrix$_(this._$_bbProjectionMatrix$_, this._$_width$_ / this._$_height$_);
                }
                _$SetNearZ$_(t) {
                    super._$SetNearZ$_(t), this._$CalculatePerspectiveMatrix$_(this._$_bbProjectionMatrix$_, this._$_width$_ / this._$_height$_);
                }
                _$SetFarZ$_(t) {
                    super._$SetFarZ$_(t), this._$CalculatePerspectiveMatrix$_(this._$_bbProjectionMatrix$_, this._$_width$_ / this._$_height$_);
                }
                _$SetProjectionMatrix$_(t) {
                    if (!mat42._$exactEquals$_(this._$_matP$_, t)) {
                        const e = this._$PushBatch$_();
                        e._$InitSetProjection$_(t), mat42._$copy$_(this._$_matP$_, t), 
                        this._$_topOfBatch$_ = 0, this._$_didChangeTransform$_ = !0;
                    }
                }
                _$SetDefaultRenderTargetProjectionState$_() {
                    let t, e, s, i = this._$_currentRenderTarget$_;
                    s = (null === i ? (t = this._$_bbProjectionMatrix$_, e = this._$GetWidth$_(), 
                    this) : (t = i._$GetProjectionMatrix$_(), e = i._$GetWidth$_(), 
                    i))._$GetHeight$_(), this._$SetProjectionMatrix$_(t), this._$_SetViewport$_(0, 0, e, s);
                }
                _$SetModelViewMatrix$_(t) {
                    if (!mat42._$exactEquals$_(this._$_matMV$_, t)) {
                        const e = this._$PushBatch$_();
                        e._$InitSetModelView$_(t), mat42._$copy$_(this._$_matMV$_, t), 
                        this._$_topOfBatch$_ = 0, this._$_didChangeTransform$_ = !0;
                    }
                }
                _$ResetDidChangeTransformFlag$_() {
                    this._$_didChangeTransform$_ = !1;
                }
                _$DidChangeTransform$_() {
                    return this._$_didChangeTransform$_;
                }
                _$GetBatchState$_() {
                    return this._$_batchState$_;
                }
                _$PushBatch$_() {
                    const t = this._$_batch$_;
                    return this._$_batchPtr$_ === t.length && t.push(new C33._$Gfx$_._$WebGLBatchJob$_(this._$_batchState$_)), 
                    t[this._$_batchPtr$_++];
                }
                _$EndBatch$_() {
                    0 === this._$_batchPtr$_ || this._$IsContextLost$_() || (this._$_WriteBuffers$_(), 
                    this._$_ExecuteBatch$_(), this._$_batchPtr$_ = 0, this._$_vertexPtr$_ = 0, 
                    this._$_texPtr$_ = 0, this._$_pointPtr$_ = 0, this._$_topOfBatch$_ = 0);
                }
                _$_WriteBuffers$_() {
                    const t = this._$_gl$_;
                    0 < this._$_pointPtr$_ && (t.bindBuffer(t.ARRAY_BUFFER, this._$_pointBuffer$_), 
                    t.bufferSubData(t.ARRAY_BUFFER, 0, this._$_pointData$_.subarray(0, this._$_pointPtr$_))), 
                    0 < this._$_vertexPtr$_ && (t.bindBuffer(t.ARRAY_BUFFER, this._$_vertexBuffer$_), 
                    t.bufferSubData(t.ARRAY_BUFFER, 0, this._$_vertexData$_.subarray(0, this._$_vertexPtr$_)), 
                    t.bindBuffer(t.ARRAY_BUFFER, this._$_texcoordBuffer$_), t.bufferSubData(t.ARRAY_BUFFER, 0, this._$_texcoordData$_.subarray(0, this._$_texPtr$_)));
                }
                _$_ExecuteBatch$_() {
                    const s = this._$_batch$_;
                    for (let t = 0, e = this._$_batchPtr$_; t < e; ++t) s[t]._$Run$_();
                }
                _$GetOpacity$_() {
                    return this._$_lastColor$_._$getA$_();
                }
                _$SetColorRgba$_(t, e, s, i) {
                    const r = this._$_lastColor$_;
                    if (!r._$equalsRgba$_(t, e, s, i)) {
                        r._$setRgba$_(t, e, s, i);
                        const n = this._$PushBatch$_();
                        n._$InitSetColor$_(r), this._$_topOfBatch$_ = 0, this._$_currentStateGroup$_ = null;
                    }
                }
                _$SetOpacity$_(t) {
                    const e = this._$_lastColor$_;
                    if (e._$getA$_() !== t) {
                        e._$setA$_(t);
                        const s = this._$PushBatch$_();
                        s._$InitSetColor$_(e), this._$_topOfBatch$_ = 0, this._$_currentStateGroup$_ = null;
                    }
                }
                _$SetColor$_(t) {
                    const e = this._$_lastColor$_;
                    if (!e.equals(t)) {
                        e.set(t);
                        const s = this._$PushBatch$_();
                        s._$InitSetColor$_(e), this._$_topOfBatch$_ = 0, this._$_currentStateGroup$_ = null;
                    }
                }
                _$ResetColor$_() {
                    this._$SetColorRgba$_(1, 1, 1, 1);
                }
                _$GetColor$_() {
                    return this._$_lastColor$_;
                }
                _$SetTexture$_(t) {
                    if (t !== this._$_lastTexture0$_) {
                        const e = this._$PushBatch$_();
                        e._$InitSetTexture$_(t), this._$_lastTexture0$_ = t, this._$_topOfBatch$_ = 0;
                    }
                }
                _$_ResetLastTexture$_() {
                    this._$_lastTexture0$_ = null;
                }
                _$SetBlendMode$_(t) {
                    const e = this._$_GetBlendByIndex$_(t);
                    this._$_SetBlend$_(e[0], e[1]);
                }
                _$SetNamedBlendMode$_(t) {
                    const e = this._$GetNamedBlend$_(t);
                    this._$_SetBlend$_(e._$srcBlend$_, e._$destBlend$_);
                }
                _$_SetBlend$_(t, e) {
                    if (t !== this._$_lastSrcBlend$_ || e !== this._$_lastDestBlend$_) {
                        const s = this._$PushBatch$_();
                        s._$InitSetBlend$_(t, e), this._$_lastSrcBlend$_ = t, this._$_lastDestBlend$_ = e, 
                        this._$_topOfBatch$_ = 0, this._$_currentStateGroup$_ = null;
                    }
                }
                _$IsPremultipliedAlphaBlend$_() {
                    return this._$_lastSrcBlend$_ === this._$_gl$_.ONE && this._$_lastDestBlend$_ === this._$_gl$_.ONE_MINUS_SRC_ALPHA;
                }
                _$SetAlphaBlend$_() {
                    this._$_SetBlend$_(this._$_gl$_.ONE, this._$_gl$_.ONE_MINUS_SRC_ALPHA);
                }
                _$SetNoPremultiplyAlphaBlend$_() {
                    this._$_SetBlend$_(this._$_gl$_.SRC_ALPHA, this._$_gl$_.ONE_MINUS_SRC_ALPHA);
                }
                _$SetCopyBlend$_() {
                    this._$_SetBlend$_(this._$_gl$_.ONE, this._$_gl$_.ZERO);
                }
                Rect(t) {
                    this._$Rect2$_(t._$getLeft$_(), t._$getTop$_(), t._$getRight$_(), t._$getBottom$_());
                }
                _$Rect2$_(t, e, s, i) {
                    this._$Quad2$_(t, e, s, e, s, i, t, i);
                }
                _$_ExtendQuadBatch$_() {
                    let t = this._$_vertexPtr$_;
                    if (t >= this._$_lastVertexPtr$_ && (this._$EndBatch$_(), t = 0), 
                    1 === this._$_topOfBatch$_) this._$_batch$_[this._$_batchPtr$_ - 1]._$_indexCount$_ += 6; else {
                        const e = this._$PushBatch$_();
                        e._$InitQuad$_(t, 6), this._$_topOfBatch$_ = 1;
                    }
                }
                _$_WriteQuadToVertexBuffer$_(t) {
                    t._$writeToTypedArray3D$_(this._$_vertexData$_, this._$_vertexPtr$_, this._$_baseZ$_ + this._$_currentZ$_), 
                    this._$_vertexPtr$_ += 12;
                }
                _$Quad$_(t) {
                    this._$_ExtendQuadBatch$_(), this._$_WriteQuadToVertexBuffer$_(t), 
                    defaultTexCoordsQuad._$writeToTypedArray$_(this._$_texcoordData$_, this._$_texPtr$_), 
                    this._$_texPtr$_ += 8;
                }
                _$Quad2$_(t, e, s, i, r, n, h, o) {
                    this._$_ExtendQuadBatch$_();
                    let a = this._$_vertexData$_, l = this._$_vertexPtr$_, u = this._$_baseZ$_ + this._$_currentZ$_;
                    a[l++] = t, a[l++] = e, a[l++] = u, a[l++] = s, a[l++] = i, 
                    a[l++] = u, a[l++] = r, a[l++] = n, a[l++] = u, a[l++] = h, 
                    a[l++] = o, a[l++] = u, this._$_vertexPtr$_ = l, defaultTexCoordsQuad._$writeToTypedArray$_(this._$_texcoordData$_, this._$_texPtr$_), 
                    this._$_texPtr$_ += 8;
                }
                _$Quad3$_(t, e) {
                    this._$_ExtendQuadBatch$_(), this._$_WriteQuadToVertexBuffer$_(t), 
                    e._$writeAsQuadToTypedArray$_(this._$_texcoordData$_, this._$_texPtr$_), 
                    this._$_texPtr$_ += 8;
                }
                _$Quad4$_(t, e) {
                    this._$_ExtendQuadBatch$_(), this._$_WriteQuadToVertexBuffer$_(t), 
                    e._$writeToTypedArray$_(this._$_texcoordData$_, this._$_texPtr$_), 
                    this._$_texPtr$_ += 8;
                }
                _$Quad3D$_(t, e, s, i, r, n, h, o, a, l, u, c, f) {
                    this._$_ExtendQuadBatch$_();
                    let d = this._$_vertexData$_, p = this._$_vertexPtr$_, m = this._$_baseZ$_ + this._$_currentZ$_;
                    d[p++] = t, d[p++] = e, d[p++] = m + s, d[p++] = i, d[p++] = r, 
                    d[p++] = m + n, d[p++] = h, d[p++] = o, d[p++] = m + a, d[p++] = l, 
                    d[p++] = u, d[p++] = m + c, this._$_vertexPtr$_ = p, f._$writeAsQuadToTypedArray$_(this._$_texcoordData$_, this._$_texPtr$_), 
                    this._$_texPtr$_ += 8;
                }
                _$Quad3D2$_(t, e, s, i, r, n, h, o, a, l, u, c, f) {
                    this._$_ExtendQuadBatch$_();
                    let d = this._$_vertexData$_, p = this._$_vertexPtr$_, m = this._$_baseZ$_ + this._$_currentZ$_;
                    d[p++] = t, d[p++] = e, d[p++] = m + s, d[p++] = i, d[p++] = r, 
                    d[p++] = m + n, d[p++] = h, d[p++] = o, d[p++] = m + a, d[p++] = l, 
                    d[p++] = u, d[p++] = m + c, this._$_vertexPtr$_ = p, f._$writeToTypedArray$_(this._$_texcoordData$_, this._$_texPtr$_), 
                    this._$_texPtr$_ += 8;
                }
                _$DrawMesh$_(i, r, n) {
                    const h = this._$_vertexData$_, o = this._$_texcoordData$_;
                    if (n.length % 3 != 0) throw new Error("invalid index buffer length");
                    for (let s = 0, t = n.length; s < t; ) {
                        const a = n[s++], l = n[s++], u = n[s++], c = 3 * a, f = 3 * l, d = 3 * u, p = 2 * a, m = 2 * l, C = 2 * u;
                        this._$_ExtendQuadBatch$_();
                        let t = this._$_vertexPtr$_, e = this._$_texPtr$_;
                        h[t++] = i[0 + c], h[t++] = i[1 + c], h[t++] = i[2 + c], 
                        h[t++] = i[0 + f], h[t++] = i[1 + f], h[t++] = i[2 + f], 
                        h[t++] = i[0 + d], h[t++] = i[1 + d], h[t++] = i[2 + d], 
                        h[t++] = i[0 + d], h[t++] = i[1 + d], h[t++] = i[2 + d], 
                        o[e++] = r[0 + p], o[e++] = r[1 + p], o[e++] = r[0 + m], 
                        o[e++] = r[1 + m], o[e++] = r[0 + C], o[e++] = r[1 + C], 
                        o[e++] = r[0 + C], o[e++] = r[1 + C], this._$_vertexPtr$_ = t, 
                        this._$_texPtr$_ = e;
                    }
                }
                _$FullscreenQuad$_(t, e) {
                    this._$SetCurrentZ$_(0), mat42._$copy$_(tmpProjection, this._$_matP$_), 
                    mat42._$copy$_(tmpModelView, this._$_matMV$_), this._$SetDefaultRenderTargetProjectionState$_();
                    const [ s, i ] = this._$GetRenderTargetSize$_(this._$_currentRenderTarget$_), r = this._$CalculateLookAtModelView2$_(0, 0, this._$GetDefaultCameraZ$_(i), 0, 0, 0, i);
                    if (this._$SetModelViewMatrix$_(r), "crop" === t && this._$_currentRenderTarget$_ && e) {
                        const n = this._$_width$_ / 2, h = this._$_height$_ / 2, o = e._$GetWidth$_(), a = e._$GetHeight$_(), l = this._$_currentRenderTarget$_._$GetWidth$_(), u = this._$_currentRenderTarget$_._$GetHeight$_(), c = Math.min(l, o), f = Math.min(u, a), d = Math.max(a - u, 0), p = Math.max(u - a, 0);
                        tmpRect.set(-n, h - p, -n + c, h - f - p), tmpQuad._$setFromRect$_(tmpRect), 
                        tmpRect.set(0, d, c, f + d), tmpRect._$divide$_(o, a), this._$Quad3$_(tmpQuad, tmpRect);
                    } else {
                        const m = s / 2, C = i / 2;
                        this._$Rect2$_(-m, C, m, -C);
                    }
                    this._$SetProjectionMatrix$_(tmpProjection), this._$SetModelViewMatrix$_(tmpModelView);
                }
                _$StartRenderingPoints$_(t) {
                    if (!this._$_lastPointTexCoords$_.equals(t)) {
                        this._$_lastPointTexCoords$_._$copy$_(t);
                        const e = this._$PushBatch$_();
                        e._$InitSetPointTexCoords$_(t), this._$_topOfBatch$_ = 0;
                    }
                }
                _$FinishRenderingPoints$_() {}
                _$Point$_(t, e, s, i) {
                    this._$_pointPtr$_ >= LAST_POINT && this._$EndBatch$_();
                    let r = this._$_pointPtr$_, n = this._$_baseZ$_ + this._$_currentZ$_;
                    if (2 === this._$_topOfBatch$_ && this._$_lastPointZ$_ === n) this._$_batch$_[this._$_batchPtr$_ - 1]._$_indexCount$_++; else {
                        const o = this._$PushBatch$_();
                        o._$InitPoints$_(r, n), this._$_topOfBatch$_ = 2, this._$_lastPointZ$_ = n;
                    }
                    const h = this._$_pointData$_;
                    h[r++] = t, h[r++] = e, h[r++] = s, h[r++] = i, this._$_pointPtr$_ = r;
                }
                _$SetProgram$_(t) {
                    if (this._$_lastProgram$_ !== t) {
                        const e = this._$PushBatch$_();
                        e._$InitSetProgram$_(t), this._$_lastProgram$_ = t, this._$_topOfBatch$_ = 0, 
                        this._$_currentStateGroup$_ = null;
                    }
                }
                _$GetProgram$_() {
                    return this._$_lastProgram$_;
                }
                _$SetDeviceTransformTextureFillMode$_() {
                    this._$SetProgram$_(this._$_spDeviceTransformTextureFill$_);
                }
                _$SetGradientColor$_(t) {
                    const e = this._$PushBatch$_();
                    e._$InitSetGradientColor$_(t), this._$_topOfBatch$_ = 0;
                }
                _$SetEllipseParams$_(t, e, s = 1) {
                    const i = this._$PushBatch$_();
                    i._$InitSetEllipseParams$_(t, e, s), this._$_topOfBatch$_ = 0;
                }
                _$SetTilemapInfo$_(t, e, s, i, r, n, h) {
                    if (this._$_lastProgram$_ !== this._$_spTilemapFill$_) throw new Error("must set tilemap fill mode first");
                    const o = this._$PushBatch$_();
                    o._$InitSetTilemapInfo$_(t, e, s, i, r, n, h), this._$_topOfBatch$_ = 0;
                }
                _$SetTileRandomizationInfo$_(t, e, s, i, r, n, h) {
                    if (this._$_lastProgram$_ !== this._$_spTileRandomization$_) throw new Error("must set tile randomization mode first");
                    const o = this._$PushBatch$_();
                    o._$InitSetTileRandomizationInfo$_(t, e, s, i, r, n, h), this._$_topOfBatch$_ = 0;
                }
                _$SetProgramParameters$_(t, e, s, i, r, n, h, o, a, l, u) {
                    const c = this._$_lastProgram$_;
                    if (u %= 10800, c._$_hasAnyOptionalUniforms$_ && !c._$AreOptionalUniformsAlreadySetInBatch$_(e, s, i, r, n, h, o, a, l, u)) {
                        const f = this._$PushBatch$_(), d = (f._$InitSetProgramParameters$_(), 
                        c._$SetOptionalUniformsInBatch$_(e, s, i, r, n, h, o, a, l, u), 
                        f._$_mat4param$_), p = (d[0] = n, d[1] = h, e._$writeToTypedArray$_(d, 2), 
                        d[6] = a, d[7] = l, s._$writeToTypedArray$_(d, 12), f._$_colorParam$_), m = (r._$writeToTypedArray$_(p, 0), 
                        p[1]);
                        p[1] = p[3], p[3] = m, i._$writeToTypedArray$_(f._$_srcOriginRect$_, 0), 
                        f._$_startIndex$_ = u, f._$_indexCount$_ = o, c._$_uSamplerBack$_._$IsUsed$_() ? f._$_texParam$_ = t ? t._$GetTexture$_() : null : f._$_texParam$_ = null, 
                        this._$_topOfBatch$_ = 0;
                    }
                }
                _$SetProgramCustomParameters$_(t) {
                    const e = this._$_lastProgram$_;
                    if (0 !== t.length && !e._$AreCustomParametersAlreadySetInBatch$_(t)) {
                        const s = this._$PushBatch$_();
                        s._$InitSetProgramCustomParameters$_(), e._$SetCustomParametersInBatch$_(t), 
                        C33._$shallowAssignArray$_(s._$_shaderParams$_, t), this._$_topOfBatch$_ = 0;
                    }
                }
                _$ClearRgba$_(t, e, s, i) {
                    const r = this._$PushBatch$_();
                    r._$InitClearSurface2$_(t, e, s, i), this._$_topOfBatch$_ = 0;
                }
                _$Clear$_(t) {
                    const e = this._$PushBatch$_();
                    e._$InitClearSurface$_(t), this._$_topOfBatch$_ = 0;
                }
                _$Start$_() {}
                _$Finish$_() {
                    super._$Finish$_(), this._$_gl$_.flush();
                }
                _$ClearDepth$_() {
                    if (this._$_usesDepthBuffer$_ && this._$_currentRenderTarget$_ && this._$_currentRenderTarget$_._$HasDepthBuffer$_()) {
                        const t = this._$PushBatch$_();
                        t._$InitClearDepth$_(this._$_isDepthEnabled$_), this._$_topOfBatch$_ = 0;
                    }
                }
                _$SetDepthEnabled$_(t) {
                    if (this._$_isDepthEnabled$_ !== (t = !!t) && this._$_usesDepthBuffer$_) {
                        this._$_isDepthEnabled$_ = t;
                        const e = this._$PushBatch$_();
                        e._$InitSetDepthEnabled$_(t), this._$_topOfBatch$_ = 0;
                    }
                }
                _$IsDepthEnabled$_() {
                    return this._$_isDepthEnabled$_;
                }
                _$_GetDepthBuffer$_() {
                    return this._$_depthBuffer$_;
                }
                _$_CanSampleDepth$_() {
                    return this._$_canSampleDepth$_;
                }
                _$SetDepthSamplingEnabled$_(t) {
                    if (t = !!t, this._$_canSampleDepth$_ && this._$_isDepthSamplingEnabled$_ !== t) {
                        if (t && this._$IsDepthEnabled$_()) throw new Error("depth still enabled");
                        this._$_isDepthSamplingEnabled$_ = t;
                        const e = this._$PushBatch$_();
                        e._$InitSetDepthSamplingEnabled$_(t), this._$_topOfBatch$_ = 0;
                    }
                }
                _$SetScissorRect$_(t, e, s, i, r = 0) {
                    if (t = Math.floor(t), e = Math.floor(e), s = Math.floor(s), 
                    i = Math.floor(i), !this._$_lastScissorRect$_._$equalsWH$_(t, e, s, i)) {
                        this._$_lastScissorRect$_._$setWH$_(t, e, s, i);
                        const n = r || this._$GetRenderTargetSize$_(this._$GetRenderTarget$_())[1], h = (e = n - e - i, 
                        this._$PushBatch$_());
                        h._$InitSetScissor$_(!0, t, e, s, i), this._$_topOfBatch$_ = 0;
                    }
                }
                _$RemoveScissorRect$_() {
                    if (-1 !== this._$_lastScissorRect$_._$getRight$_()) {
                        this._$_lastScissorRect$_.set(0, 0, -1, -1);
                        const t = this._$PushBatch$_();
                        t._$InitSetScissor$_(!1, 0, 0, 0, 0), this._$_topOfBatch$_ = 0;
                    }
                }
                _$CheckForQueryResults$_() {
                    for (const t of this._$_allQueryResultBuffers$_) t._$CheckForResults$_(this._$_frameNumber$_);
                }
                _$IsContextLost$_() {
                    return !this._$_gl$_ || this._$_gl$_.isContextLost() || this._$_isInitialisingAfterContextRestored$_;
                }
                _$OnContextLost$_() {
                    super._$OnDeviceOrContextLost$_(), C33._$Gfx$_._$WebGLRendererTexture$_._$OnContextLost$_(), 
                    C33._$Gfx$_._$WebGLRenderTarget$_._$OnContextLost$_(), C33._$Gfx$_._$RendererText$_._$OnContextLost$_();
                    for (const t of this._$_allQueryResultBuffers$_) t._$Clear$_();
                    this._$_extensions$_ = [], this._$_timerExt$_ = null, this._$_parallelShaderCompileExt$_ = null, 
                    this._$_anisotropicExt$_ = null, this._$_depthTextureExt$_ = null, 
                    this._$_fragDepthExt$_ = null, this._$_stdDerivativesExt$_ = null, 
                    this._$_textureLodExt$_ = null, this._$_maxAnisotropy$_ = 0, 
                    this._$_unmaskedVendor$_ = "(unavailable)", this._$_unmaskedRenderer$_ = "(unavailable)", 
                    this._$_lastProgram$_ = null, this._$_spDeviceTransformTextureFill$_ = null, 
                    this._$_depthBuffer$_ = null;
                    for (const e of this._$_stateGroups$_.values()) e._$OnContextLost$_();
                }
                async _$OnContextRestored$_() {
                    this._$_isInitialisingAfterContextRestored$_ = !0, await this._$InitState$_(), 
                    this._$_isInitialisingAfterContextRestored$_ = !1;
                    for (const t of this._$_stateGroups$_.values()) t._$OnContextRestored$_(this);
                    this._$SetSize$_(this._$_width$_, this._$_height$_, !0);
                }
                _$CreateStaticTexture$_(t, e) {
                    if (this._$IsContextLost$_()) throw new Error("context lost");
                    this._$EndBatch$_();
                    const s = C33._$New$_(C33._$Gfx$_._$WebGLRendererTexture$_, this);
                    return s._$_CreateStatic$_(t, e), s;
                }
                async _$CreateStaticTextureAsync$_(i, r) {
                    if (this._$IsContextLost$_()) throw new Error("context lost");
                    if (r = Object.assign({}, r), C33._$Supports$_.ImageBitmapOptions) {
                        let t = await createImageBitmap(i, {
                            premultiplyAlpha: "premultiply"
                        }), e = r._$wrapX$_ && "clamp-to-edge" !== r._$wrapX$_ || r._$wrapY$_ && "clamp-to-edge" !== r._$wrapY$_, s = C33._$isPOT$_(t.width) && C33._$isPOT$_(t.height);
                        return this._$SupportsNPOTTextures$_() || s || !e ? r.premultiplyAlpha = !1 : C33._$Supports$_._$ImageBitmapOptionsResize$_ ? (t = await createImageBitmap(i, {
                            premultiplyAlpha: "premultiply",
                            resizeWidth: C33._$nextHighestPowerOfTwo$_(t.width),
                            resizeHeight: C33._$nextHighestPowerOfTwo$_(t.height)
                        }), r.premultiplyAlpha = !1) : t = await createImageBitmap(i, {
                            premultiplyAlpha: "none"
                        }), C33._$Asyncify$_(() => this._$CreateStaticTexture$_(t, r));
                    }
                    if (i instanceof Blob) {
                        if ("undefined" == typeof Image) throw new Error("texture upload variant not supported in worker");
                        const t = await C33._$BlobToImage$_(i);
                        i = t;
                    }
                    return C33._$Asyncify$_(() => this._$CreateStaticTexture$_(i, r));
                }
                _$CreateDynamicTexture$_(t, e, s) {
                    this._$EndBatch$_();
                    const i = C33._$New$_(C33._$Gfx$_._$WebGLRendererTexture$_, this);
                    return i._$_CreateDynamic$_(t, e, s), i;
                }
                _$UpdateTexture$_(t, e, s) {
                    this._$EndBatch$_(), e._$_Update$_(t, s);
                }
                _$DeleteTexture$_(t) {
                    t && (t._$SubtractReference$_(), 0 < t._$GetReferenceCount$_() || (this._$EndBatch$_(), 
                    t === this._$_lastTexture0$_ && (this._$_gl$_.bindTexture(this._$_gl$_.TEXTURE_2D, null), 
                    this._$_lastTexture0$_ = null), t === this._$_lastTexture1$_ && (this._$_gl$_.activeTexture(this._$_gl$_.TEXTURE1), 
                    this._$_gl$_.bindTexture(this._$_gl$_.TEXTURE_2D, null), this._$_gl$_.activeTexture(this._$_gl$_.TEXTURE0), 
                    this._$_lastTexture1$_ = null), t._$_Delete$_()));
                }
                _$CreateRenderTarget$_(t) {
                    let e = this._$_width$_, s = this._$_height$_, i = !0;
                    if (t && ("number" == typeof t.width && (e = Math.floor(t.width), 
                    i = !1), "number" == typeof t.height) && (s = Math.floor(t.height), 
                    i = !1), e <= 0 || s <= 0) throw new Error("invalid size");
                    this._$EndBatch$_();
                    const r = C33._$New$_(C33._$Gfx$_._$WebGLRenderTarget$_, this);
                    return r._$_Create$_(e, s, Object.assign({
                        _$isDefaultSize$_: i
                    }, t)), this._$_currentRenderTarget$_ = null, this._$_batchState$_._$currentFramebuffer$_ = null, 
                    this._$_batchState$_._$currentFramebufferNoDepth$_ = null, r;
                }
                _$SetRenderTarget$_(t, e = !0) {
                    if (t !== this._$_currentRenderTarget$_) {
                        t && t._$IsDefaultSize$_() && t._$_Resize$_(this._$_width$_, this._$_height$_);
                        const s = this._$PushBatch$_();
                        s._$InitSetRenderTarget$_(t), this._$_currentRenderTarget$_ = t, 
                        this._$_topOfBatch$_ = 0, e && this._$SetDefaultRenderTargetProjectionState$_();
                    }
                }
                _$GetRenderTarget$_() {
                    return this._$_currentRenderTarget$_;
                }
                _$GetRenderTargetSize$_(t) {
                    return t ? [ t._$GetWidth$_(), t._$GetHeight$_() ] : [ this._$_width$_, this._$_height$_ ];
                }
                _$CopyRenderTarget$_(t, e = "stretch") {
                    if (this._$_version$_ < 2 || this._$_currentRenderTarget$_ && 0 < this._$_currentRenderTarget$_._$GetMultisampling$_()) this._$SetCopyBlend$_(), 
                    this._$ResetColor$_(), this._$DrawRenderTarget$_(t, e); else {
                        const s = this._$PushBatch$_();
                        s._$InitBlitFramebuffer$_(t, this._$_currentRenderTarget$_, e), 
                        this._$_topOfBatch$_ = 0;
                    }
                }
                _$DrawRenderTarget$_(t, e = "stretch") {
                    const s = t._$GetTexture$_();
                    if (!s) throw new Error("not a texture-backed render target");
                    this._$SetTexture$_(s), this._$FullscreenQuad$_(e, s);
                }
                _$InvalidateRenderTarget$_(t) {
                    if (!(this._$_version$_ < 2)) {
                        const e = this._$PushBatch$_();
                        e._$InitInvalidateFramebuffer$_(t._$_GetFramebuffer$_()), 
                        this._$_topOfBatch$_ = 0;
                    }
                }
                _$DeleteRenderTarget$_(t) {
                    this._$SetRenderTarget$_(null), this._$EndBatch$_();
                    const e = t._$GetTexture$_();
                    e === this._$_lastTexture0$_ && (this._$_gl$_.bindTexture(this._$_gl$_.TEXTURE_2D, null), 
                    this._$_lastTexture0$_ = null), e === this._$_lastTexture1$_ && (this._$_gl$_.activeTexture(this._$_gl$_.TEXTURE1), 
                    this._$_gl$_.bindTexture(this._$_gl$_.TEXTURE_2D, null), this._$_gl$_.activeTexture(this._$_gl$_.TEXTURE0), 
                    this._$_lastTexture1$_ = null), t._$_Delete$_();
                }
                async _$ReadBackRenderTargetToImageData$_(t, e, s) {
                    this._$EndBatch$_();
                    let i = this._$_currentRenderTarget$_, r, n, h, o = (h = t ? (r = t._$GetWidth$_(), 
                    n = t._$GetHeight$_(), t._$_GetFramebuffer$_()) : (r = this._$GetWidth$_(), 
                    n = this._$GetHeight$_(), null), 0), a = 0, l = r, u = n;
                    if (s) {
                        o = C33._$clamp$_(Math.floor(s._$getLeft$_()), 0, r - 1), 
                        a = C33._$clamp$_(Math.floor(s._$getTop$_()), 0, n - 1);
                        let t = s.width(), e = (t = 0 === t ? r - o : C33._$clamp$_(Math.floor(t), 0, r - o), 
                        s.height());
                        e = 0 === e ? n - a : C33._$clamp$_(Math.floor(e), 0, n - a), 
                        l = t, u = e, a = n - (a + u);
                    }
                    let c = this._$_gl$_, f = (c.bindFramebuffer(c.FRAMEBUFFER, h), 
                    () => {
                        c.bindFramebuffer(c.FRAMEBUFFER, null), this._$_currentRenderTarget$_ = null, 
                        this._$_batchState$_._$currentFramebuffer$_ = null, this._$_batchState$_._$currentFramebufferNoDepth$_ = null, 
                        this._$SetRenderTarget$_(i);
                    }), d;
                    if (!e && 2 <= this._$GetWebGLVersionNumber$_()) {
                        c.bindFramebuffer(c.READ_FRAMEBUFFER, h);
                        const p = c.createBuffer(), m = l * u * 4, C = c.PIXEL_PACK_BUFFER, g = (c.bindBuffer(C, p), 
                        c.bufferData(C, m, c.STREAM_READ), c.readPixels(o, a, l, u, c.RGBA, c.UNSIGNED_BYTE, 0), 
                        c.bindFramebuffer(c.READ_FRAMEBUFFER, null), c.bindBuffer(C, null), 
                        f(), c.fenceSync(c.SYNC_GPU_COMMANDS_COMPLETE, 0));
                        await this._$_WaitForObjectReady$_(() => c.getSyncParameter(g, c.SYNC_STATUS) === c.SIGNALED), 
                        c.deleteSync(g), d = new ImageData(l, u), c.bindBuffer(C, p), 
                        c.getBufferSubData(C, 0, new Uint8Array(d.data.buffer), 0, m), 
                        c.bindBuffer(C, null), c.deleteBuffer(p);
                    } else d = new ImageData(l, u), c.readPixels(o, a, l, u, c.RGBA, c.UNSIGNED_BYTE, new Uint8Array(d.data.buffer)), 
                    f();
                    return d;
                }
                _$CoplanarStartStencilPass$_() {
                    this._$SetDepthEnabled$_(!0);
                    const t = this._$PushBatch$_();
                    t._$InitCoplanarStartStencilPass$_(), this._$_topOfBatch$_ = 0, 
                    this._$_coplanarMode$_ = 1;
                }
                _$CoplanarStartColorPass$_() {
                    this._$SetDepthEnabled$_(!1);
                    const t = this._$PushBatch$_();
                    t._$InitCoplanarStartColorPass$_(), this._$_topOfBatch$_ = 0, 
                    this._$_coplanarMode$_ = 2;
                }
                _$IsCoplanarColorPass$_() {
                    return 2 === this._$_coplanarMode$_;
                }
                _$CoplanarRestoreStandardRendering$_() {
                    this._$SetDepthEnabled$_(!0);
                    const t = this._$PushBatch$_();
                    t._$InitCoplanarRestore$_(), this._$_topOfBatch$_ = 0, this._$_coplanarMode$_ = 0;
                }
                _$StartQuery$_(t) {
                    if (this._$SupportsGPUProfiling$_()) {
                        const e = this._$PushBatch$_();
                        e._$InitStartQuery$_(t), this._$_topOfBatch$_ = 0;
                    }
                }
                _$EndQuery$_(t) {
                    if (this._$SupportsGPUProfiling$_()) {
                        const e = this._$PushBatch$_();
                        e._$InitEndQuery$_(t), this._$_topOfBatch$_ = 0;
                    }
                }
                _$_WaitForObjectReady$_(e) {
                    const t = new Promise(t => pendingPolls.add({
                        resolve: t,
                        _$checkFunc$_: e
                    }));
                    return -1 === pollRafId && (pollRafId = self.requestAnimationFrame(CheckPendingPolls2)), 
                    t;
                }
                _$GetEstimatedBackBufferMemoryUsage$_() {
                    return this._$_width$_ * this._$_height$_ * (this._$_attribs$_.alpha ? 4 : 3);
                }
                _$GetEstimatedRenderBufferMemoryUsage$_() {
                    let t = 0;
                    for (const e of C33._$Gfx$_._$WebGLRenderTarget$_._$allRenderTargets$_()) e._$GetTexture$_() || (t += e._$GetEstimatedMemoryUsage$_());
                    return t;
                }
                _$GetEstimatedTextureMemoryUsage$_() {
                    let t = 0;
                    for (const e of C33._$Gfx$_._$WebGLRendererTexture$_._$allTextures$_()) t += e._$GetEstimatedMemoryUsage$_();
                    return t;
                }
                _$GetWebGLVersionString$_() {
                    return this._$_versionString$_;
                }
                _$GetWebGLVersionNumber$_() {
                    return this._$_version$_;
                }
                _$GetDisplayName$_() {
                    return "webgl" + this._$GetWebGLVersionNumber$_();
                }
                _$SupportsNPOTTextures$_() {
                    return 2 <= this._$GetWebGLVersionNumber$_();
                }
                _$GetMaxTextureSize$_() {
                    return this._$_maxTextureSize$_;
                }
                _$GetMinPointSize$_() {
                    return this._$_minPointSize$_;
                }
                _$GetMaxPointSize$_() {
                    return this._$_maxPointSize$_;
                }
                _$SupportsHighP$_() {
                    return 0 !== this._$_highpPrecision$_;
                }
                _$GetHighPPrecision$_() {
                    return this._$_highpPrecision$_;
                }
                _$GetUnmaskedVendor$_() {
                    return this._$_unmaskedVendor$_;
                }
                _$GetUnmaskedRenderer$_() {
                    return this._$_unmaskedRenderer$_;
                }
                _$GetWebGLExtensionsAnalyticsString$_() {
                    if (2 <= this._$GetWebGLVersionNumber$_()) return "webgl2";
                    {
                        const t = [];
                        return this._$_fragDepthExt$_ && t.push("EXT_frag_depth"), 
                        this._$_stdDerivativesExt$_ && t.push("OES_standard_derivatives"), 
                        this._$_textureLodExt$_ && t.push("EXT_shader_texture_lod"), 
                        0 < t.length ? "webgl1:" + t.join(",") : "webgl1:none";
                    }
                }
                _$GetExtensions$_() {
                    return this._$_extensions$_;
                }
                _$SupportsGPUProfiling$_() {
                    return !!this._$_timerExt$_;
                }
                _$_GetDisjointTimerQueryExtension$_() {
                    return this._$_timerExt$_;
                }
                _$_GetParallelShaderCompileExtension$_() {
                    return this._$_parallelShaderCompileExt$_;
                }
                _$_GetAnisotropicExtension$_() {
                    return this._$_anisotropicExt$_;
                }
                _$_GetMaxAnisotropy$_() {
                    return this._$_maxAnisotropy$_;
                }
                _$_AddQueryResultBuffer$_(t) {
                    this._$_allQueryResultBuffers$_.add(t);
                }
                _$_RemoveQueryResultBuffer$_(t) {
                    this._$_allQueryResultBuffers$_.delete(t);
                }
                _$_GetTimeQueryStack$_() {
                    return this._$_timeQueryStack$_;
                }
                _$GetContext$_() {
                    return this._$_gl$_;
                }
                _$_InitBlendModes$_(t) {
                    this._$_InitBlendModeData$_([ [ "normal", t.ONE, t.ONE_MINUS_SRC_ALPHA ], [ "additive", t.ONE, t.ONE ], [ "xor", t.ONE, t.ONE_MINUS_SRC_ALPHA ], [ "copy", t.ONE, t.ZERO ], [ "destination-over", t.ONE_MINUS_DST_ALPHA, t.ONE ], [ "source-in", t.DST_ALPHA, t.ZERO ], [ "destination-in", t.ZERO, t.SRC_ALPHA ], [ "source-out", t.ONE_MINUS_DST_ALPHA, t.ZERO ], [ "destination-out", t.ZERO, t.ONE_MINUS_SRC_ALPHA ], [ "source-atop", t.DST_ALPHA, t.ONE_MINUS_SRC_ALPHA ], [ "destination-atop", t.ONE_MINUS_DST_ALPHA, t.SRC_ALPHA ] ]);
                }
                _$CreateWebGLText$_() {
                    return this._$CreateRendererText$_();
                }
            };
        }
        {
            let DebugLog2 = function(t) {
                console.log("[WebGPU] " + t);
            }, C33 = (DebugLog = DebugLog2, self._$C3$_), glMatrix = self._$glMatrix$_, vec32 = glMatrix._$vec3$_, mat42 = glMatrix._$mat4$_, assert = self.assert, GPUBufferUsage = self.GPUBufferUsage, GPUShaderStage = self.GPUShaderStage, GPUMapMode = self.GPUMapMode, GPUTextureUsage = self.GPUTextureUsage, DEFAULT_WEBGPURENDERER_OPTS = {
                powerPreference: "default",
                depth: !1,
                failIfMajorPerformanceCaveat: !1,
                _$canSampleBackbuffer$_: !1,
                _$usesBackgroundBlending$_: !1,
                _$canSampleDepth$_: !1,
                _$isMultiTexturingAllowed$_: !0
            }, MAX_VERTICES = 42e3, MAX_INDICES = MAX_VERTICES / 2 * 3, NUM_VERTEX_COMPONENTS = 3, MAX_POINTS = MAX_VERTICES / 4, MAX_COLORS = MAX_VERTICES / 4, LAST_QUAD_PTR = MAX_VERTICES / 4 - 1, LAST_POINT_PTR = 4 * MAX_POINTS - 16, FLAG_IN_DRAW = 1, FLAG_DRAWING_POINTS = 2, FLAG_SCISSOR_ENABLED = 4, FLAG_SCISSOR_CHANGED = 8, FLAG_DRAW_STATE_CHANGED = 16, FLAG_PIPELINE_CHANGED = 32, FLAG_TEX_BINDGROUP_CHANGED = 64, FLAG_BACKTEX_BINDGROUP_CHANGED = 128, FLAG_DEPTHTEX_BINDGROUP_CHANGED = 256, FLAG_TRANSFORM_CHANGED = 512, FLAG_VERTEX_UNIFORM_CHANGED = 1024, FLAG_FRAG_UNIFORM_CHANGED = 2048, FLAG_FRAG_C3PARAMS_CHANGED = 4096, FLAG_BUFFER_BINDGROUP_CHANGED = 8192, FLAG_DID_ADD_COMMAND = 16384, FLAG_CONTEXT_LOST = 32768, FLAG_MULTITEXTURE_ALLOWED = 65536, FLAG_MULTITEXTURE_ENABLED = 1 << 17, FLAG_MULTITEXTURE_ACTIVE = 1 << 18, FLAG_USE_DEPTH_BUFFER = 1 << 19, FLAG_DEPTH_ENABLED = 1 << 20, FLAG_RENDERTARGET_HAS_DEPTH = 1 << 21, FLAG_CLEAR_DEPTH = 1 << 22, FLAG_COPLANAR_STENCIL_PASS = 1 << 23, FLAG_COPLANAR_COLOR_PASS = 1 << 24, FLAG_CLEAR_STENCIL = 1 << 25, FLAG_AUTOSIZE_DEPTH_BUFFER = 1 << 26, FLAG_SUPPORTS_TIMESTAMP_QUERY = 1 << 27, FLAG_SUPPORTS_F16 = 1 << 28, FLAG_USE_NORMALIZED_COORDS = 1 << 29, FLAG_DID_CHANGE_TRANSFORM = 1 << 30, CHANGED_FLAGS_MASK = FLAG_DRAW_STATE_CHANGED | FLAG_PIPELINE_CHANGED | FLAG_BUFFER_BINDGROUP_CHANGED | FLAG_TEX_BINDGROUP_CHANGED | FLAG_BACKTEX_BINDGROUP_CHANGED | FLAG_DEPTHTEX_BINDGROUP_CHANGED, END_DRAW_FLAGS_MASK = CHANGED_FLAGS_MASK | FLAG_SCISSOR_CHANGED | FLAG_IN_DRAW, NEW_RENDERPASS_FLAGS = CHANGED_FLAGS_MASK | FLAG_DID_ADD_COMMAND, CHANGED_UNIFORM_BUFFER_MASK = FLAG_TRANSFORM_CHANGED | FLAG_VERTEX_UNIFORM_CHANGED | FLAG_FRAG_UNIFORM_CHANGED | FLAG_FRAG_C3PARAMS_CHANGED, SIZEOF_F32 = 4, defaultTexCoordsQuad = new C33._$Quad$_(0, 0, 1, 0, 1, 1, 0, 1), tempVec2 = C33._$New$_(C33._$Vector2$_), tempRect = C33._$New$_(C33.Rect), tempRect2 = C33._$New$_(C33.Rect), tempQuad = C33._$New$_(C33._$Quad$_), DEBUG = !1;
            C33._$Gfx$_._$WebGPURenderer$_ = class extends C33._$Gfx$_._$RendererBase$_ {
                constructor(t) {
                    super(t), this._$_adapterOpts$_ = null, this._$_adapter$_ = null, 
                    this._$_adapterInfo$_ = null, this._$_device$_ = null, this._$_canvas$_ = null, 
                    this._$_presentCtx$_ = null, this._$_swapChainFormat$_ = "", 
                    this._$_swapChainTexture$_ = null, this._$_swapChainTexView$_ = null, 
                    this._$_viewportWidth$_ = 0, this._$_viewportHeight$_ = 0, this._$_matTransform$_ = mat42.create(), 
                    this._$_depthBuffer$_ = null, this._$_nullDepthBuffer$_ = null, 
                    this._$_depthBufferView$_ = null, this._$_nullDepthBufferView$_ = null, 
                    this._$_depthBufferBindGroup$_ = null, this._$_nullDepthBufferBindGroup$_ = null, 
                    this._$_depthBufferWidth$_ = 0, this._$_depthBufferHeight$_ = 0, 
                    this._$_vertexUniformBuffer$_ = null, this._$_fragmentUniformBuffer$_ = null, 
                    this._$_fragmentC3ParamsBuffer$_ = null, this._$_fragmentDefaultCustomParamsBuffer$_ = null, 
                    this._$_vertexBuffer$_ = null, this._$_texcoordBuffer$_ = null, 
                    this._$_colorBuffer$_ = null, this._$_indexBuffer$_ = null, 
                    this._$_pointBuffer$_ = null, this._$_vertexUniformBufferLayout$_ = C33._$Gfx$_._$WebGPUShaderProgram$_._$GetVertexUniformBufferLayout$_(), 
                    this._$_vertexUniformBufferSize$_ = C33._$Gfx$_._$WebGPUShaderProgram$_._$GetVertexUniformBufferSize$_(), 
                    this._$_vertexUniformArrayBuffer$_ = null, this._$_vertexUniformf32$_ = null, 
                    this._$_fragUniformBufferLayout$_ = C33._$Gfx$_._$WebGPUShaderProgram$_._$GetFragmentUniformBufferLayout$_(), 
                    this._$_fragUniformBufferSize$_ = C33._$Gfx$_._$WebGPUShaderProgram$_._$GetFragmentUniformBufferSize$_(), 
                    this._$_fragUniformArrayBuffer$_ = null, this._$_fragUniformf32$_ = null, 
                    this._$_fragC3ParamsLayout$_ = C33._$Gfx$_._$WebGPUShaderProgram$_._$GetFragmentC3ParamsBufferLayout$_(), 
                    this._$_fragC3ParamsSize$_ = C33._$Gfx$_._$WebGPUShaderProgram$_._$GetFragmentC3ParamsBufferSize$_(), 
                    this._$_fragC3ParamsArrayBuffer$_ = null, this._$_fragC3Paramsf32$_ = null, 
                    this._$_fragC3Paramsu32$_ = null, this._$_vertexData$_ = new Float32Array(MAX_VERTICES * NUM_VERTEX_COMPONENTS), 
                    this._$_texcoordData$_ = new Float32Array(3 * MAX_VERTICES), 
                    this._$_colorData$_ = new Float32Array(4 * MAX_COLORS), this._$_indexData$_ = new Uint16Array(MAX_INDICES), 
                    this._$_pointData$_ = new Float32Array(4 * MAX_POINTS), this._$_quadPtr$_ = 0, 
                    this._$_currentMultiTextureIndex$_ = 0, this._$_currentColor$_ = C33._$New$_(C33._$Color$_, 1, 1, 1, 1), 
                    this._$_pointPtr$_ = 0, this._$_bufferManager$_ = C33._$New$_(C33._$Gfx$_._$WebGPUBufferManager$_, this), 
                    this._$_flags$_ = FLAG_CONTEXT_LOST, this._$_drawFirstIndex$_ = 0, 
                    this._$_drawIndexCount$_ = 0, this._$_vertexUniformUpdateStart$_ = 0, 
                    this._$_vertexUniformUpdateEnd$_ = 0, this._$_fragUniformUpdateStart$_ = 0, 
                    this._$_fragUniformUpdateEnd$_ = 0, this._$_fragC3ParamsUpdateStart$_ = 0, 
                    this._$_fragC3ParamsUpdateEnd$_ = 0, this._$_scissorRect$_ = C33._$New$_(C33.Rect, 0, 0, 0, 0), 
                    this._$_currentColor2$_ = C33._$New$_(C33._$Color$_, 1, 1, 1, 1), 
                    this._$_currentPointColor$_ = C33._$New$_(C33._$Color$_, 1, 1, 1, 1), 
                    this._$_currentPointTexCoords$_ = C33._$New$_(C33.Rect, 0, 0, 0, 0), 
                    this._$_currentVertexZElevation$_ = 0, this._$_textureFormat$_ = "", 
                    this._$_bufferBindGroupLayout$_ = null, this._$_defaultBufferBindGroup$_ = null, 
                    this._$_textureBindGroupLayout$_ = null, this._$_backTextureBindGroupLayout$_ = null, 
                    this._$_depthTextureBindGroupLayout$_ = null, this._$_nullTexture$_ = null, 
                    this._$_currentTexture$_ = null, this._$_currentTextureBindGroup$_ = null, 
                    this._$_currentBackTexture$_ = null, this._$_currentBackTextureBindGroup$_ = null, 
                    this._$_currentDepthTextureBindGroup$_ = null, this._$_currentBufferBindGroup$_ = null, 
                    this._$_mipmapGeneratorPipeline$_ = null, this._$_availableMultiTextures$_ = new Set(), 
                    this._$_nonFullMultiTexGroups$_ = new Set(), this._$_maxTextureSize$_ = 8192, 
                    this._$_pipelineLayout$_ = null, this._$_defaultVertexModule$_ = null, 
                    this._$_normVertexModule$_ = null, this._$_currentProgram$_ = null, 
                    this._$_currentBlendMode$_ = 0, this._$_currentMultisampleCount$_ = 0, 
                    this._$_mipmapGeneratorProgram$_ = null, this._$_spSingleTextureFill$_ = null, 
                    this._$_samplerMap$_ = new Map(), this._$_commandEncoder$_ = null, 
                    this._$_currentRenderPass$_ = null, this._$_commandBuffers$_ = [], 
                    this._$_backbufferRenderTarget$_ = null, this._$_currentRenderTarget$_ = null, 
                    this._$_canSampleBackbuffer$_ = !1, this._$_usesBackgroundBlending$_ = !1, 
                    this._$_canSampleDepth$_ = !1, this._$_frameTimeQuerySet$_ = null, 
                    this._$_timestampIsMeasuring$_ = !1, this._$_timestampStartIndex$_ = -1, 
                    this._$_timestampEndIndex$_ = -1, this._$_timestampStartedIndices$_ = new Set(), 
                    this._$ondevicelost$_ = null, this._$ondevicerestored$_ = null, 
                    this._$_InitBlendModes$_();
                }
                _$IsWebGPU$_() {
                    return !0;
                }
                _$_SetFlag$_(t, e) {
                    e ? this._$_flags$_ |= t : this._$_flags$_ &= ~t;
                }
                _$_IsFlagSet$_(t) {
                    return 0 != (this._$_flags$_ & t);
                }
                async _$Create$_(t, e) {
                    if (e = Object.assign({}, DEFAULT_WEBGPURENDERER_OPTS, e), !navigator.gpu) throw new Error("renderer-unavailable (WebGPU not supported)");
                    e.depth && (this._$_flags$_ |= FLAG_USE_DEPTH_BUFFER), e._$isMultiTexturingAllowed$_ && (this._$_flags$_ |= FLAG_MULTITEXTURE_ALLOWED), 
                    this._$_canSampleBackbuffer$_ = !!e._$canSampleBackbuffer$_, 
                    this._$_usesBackgroundBlending$_ = !!e._$usesBackgroundBlending$_, 
                    this._$_adapterOpts$_ = {}, this._$_canSampleDepth$_ = !(!e.depth || !e._$canSampleDepth$_), 
                    "default" !== e.powerPreference && (this._$_adapterOpts$_.powerPreference = e.powerPreference), 
                    this._$_canvas$_ = t, this._$FillIndexBufferData$_(this._$_indexData$_), 
                    await this._$_InitDevice$_(e.failIfMajorPerformanceCaveat);
                }
                async _$_InitDevice$_(t) {
                    for (this._$_device$_ = null, await this._$_TryGetDeviceOnCurrentAdapter$_(t); !this._$_device$_; ) this._$_adapter$_ = null, 
                    await this._$_TryGetDeviceOnCurrentAdapter$_(t);
                    await this._$InitState$_();
                }
                async _$_TryGetDeviceOnCurrentAdapter$_(t) {
                    if (!this._$_adapter$_) {
                        if (this._$_adapter$_ = await navigator.gpu.requestAdapter(this._$_adapterOpts$_), 
                        !this._$_adapter$_) throw new Error("renderer-unavailable (no WebGPU adapter available)");
                        if (t && this._$_adapter$_.isFallbackAdapter) throw new Error("renderer-unavailable (WebGPU provided fallback adapter)");
                        if ("adreno-7xx" === this._$_adapter$_.info.architecture) throw new Error("WebGPU disabled on adreno-7xx devices - see https://issues.chromium.org/issues/329702056");
                    }
                    const e = [];
                    if (this._$_adapter$_.features.has("timestamp-query") && e.push("timestamp-query"), 
                    this._$_adapter$_.features.has("shader-f16") && e.push("shader-f16"), 
                    this._$_device$_ = await this._$_adapter$_.requestDevice({
                        requiredFeatures: e
                    }), !this._$_device$_) return null;
                    this._$_maxTextureSize$_ = this._$_device$_.limits.maxTextureDimension2D, 
                    this._$_SetFlag$_(FLAG_SUPPORTS_TIMESTAMP_QUERY, this._$_device$_.features.has("timestamp-query")), 
                    this._$_SetFlag$_(FLAG_SUPPORTS_F16, this._$_device$_.features.has("shader-f16")), 
                    this._$_device$_.lost.then(t => this._$_OnDeviceLost$_(t)), 
                    this._$_SetFlag$_(FLAG_CONTEXT_LOST, !1);
                }
                async _$_OnDeviceLost$_(t) {
                    console.log("[WebGPU] Device lost: ", t), super._$OnDeviceOrContextLost$_(), 
                    this._$_bufferManager$_._$OnContextLost$_(), C33._$Gfx$_._$WebGPURendererTexture$_._$OnContextLost$_(), 
                    C33._$Gfx$_._$WebGPURenderTarget$_._$OnContextLost$_(), C33._$Gfx$_._$RendererText$_._$OnContextLost$_(), 
                    this._$_swapChainFormat$_ = "", this._$_swapChainTexture$_ = null, 
                    this._$_swapChainTexView$_ = null, this._$_depthBuffer$_ = null, 
                    this._$_depthBufferView$_ = null, this._$_nullDepthBuffer$_ = null, 
                    this._$_nullDepthBufferView$_ = null, this._$_depthBufferBindGroup$_ = null, 
                    this._$_nullDepthBufferBindGroup$_ = null, this._$_vertexBuffer$_ = null, 
                    this._$_texcoordBuffer$_ = null, this._$_colorBuffer$_ = null, 
                    this._$_indexBuffer$_ = null, this._$_pointBuffer$_ = null, 
                    this._$_vertexUniformBuffer$_ = null, this._$_fragmentUniformBuffer$_ = null, 
                    this._$_fragmentC3ParamsBuffer$_ = null, this._$_fragmentDefaultCustomParamsBuffer$_ = null, 
                    this._$_defaultBufferBindGroup$_ = null, this._$_bufferBindGroupLayout$_ = null, 
                    this._$_currentBufferBindGroup$_ = null, this._$_textureBindGroupLayout$_ = null, 
                    this._$_backTextureBindGroupLayout$_ = null, this._$_depthTextureBindGroupLayout$_ = null, 
                    this._$_pipelineLayout$_ = null, this._$_currentProgram$_ = null, 
                    this._$_nullTexture$_ = null, this._$_currentTexture$_ = null, 
                    this._$_currentTextureBindGroup$_ = null, this._$_currentBackTexture$_ = null, 
                    this._$_currentBackTextureBindGroup$_ = null, this._$_currentDepthTextureBindGroup$_ = null, 
                    this._$_defaultVertexModule$_ = null, this._$_normVertexModule$_ = null, 
                    this._$_backbufferRenderTarget$_ = null, this._$_currentRenderTarget$_ = null, 
                    this._$_mipmapGeneratorPipeline$_ = null, this._$_frameTimeQuerySet$_ = null, 
                    this._$_mipmapGeneratorProgram$_ = null, this._$_spSingleTextureFill$_ = null, 
                    this._$_availableMultiTextures$_.clear(), this._$_nonFullMultiTexGroups$_.clear(), 
                    this._$_samplerMap$_.clear();
                    for (const e of this._$_stateGroups$_.values()) e._$OnContextLost$_();
                    this._$_device$_ = null, this._$_adapter$_ = null, this._$_adapterInfo$_ = null, 
                    this._$_flags$_ |= FLAG_CONTEXT_LOST, this._$ondevicelost$_ && this._$ondevicelost$_(), 
                    await this._$_InitDevice$_();
                    for (const s of this._$_stateGroups$_.values()) s._$OnContextRestored$_(this);
                    this._$SetSize$_(this._$_width$_, this._$_height$_, !0), this._$ondevicerestored$_ && this._$ondevicerestored$_();
                }
                async _$InitState$_() {
                    super._$InitState$_();
                    const t = this._$_device$_;
                    this._$_swapChainFormat$_ = navigator.gpu.getPreferredCanvasFormat(), 
                    this._$_swapChainTexture$_ = null, this._$_swapChainTexView$_ = null;
                    let e = GPUTextureUsage.RENDER_ATTACHMENT;
                    this._$_canSampleBackbuffer$_ && (e |= GPUTextureUsage.TEXTURE_BINDING), 
                    this._$_usesBackgroundBlending$_ && (e |= GPUTextureUsage.COPY_SRC), 
                    this._$_swapChainFormat$_.startsWith("rgba8") || this._$_swapChainFormat$_.startsWith("bgra8") ? this._$_textureFormat$_ = this._$_swapChainFormat$_ : this._$_textureFormat$_ = "rgba8unorm", 
                    this._$_flags$_ &= FLAG_USE_DEPTH_BUFFER | FLAG_SUPPORTS_TIMESTAMP_QUERY | FLAG_SUPPORTS_F16 | FLAG_MULTITEXTURE_ALLOWED, 
                    this._$_flags$_ |= CHANGED_UNIFORM_BUFFER_MASK, this._$_IsFlagSet$_(FLAG_USE_DEPTH_BUFFER) && (this._$_flags$_ |= FLAG_DEPTH_ENABLED | FLAG_RENDERTARGET_HAS_DEPTH | FLAG_AUTOSIZE_DEPTH_BUFFER), 
                    this._$_quadPtr$_ = 0, this._$_currentBlendMode$_ = 0, this._$_currentMultisampleCount$_ = 0, 
                    this._$_currentColor$_._$setRgba$_(1, 1, 1, 1), this._$_currentColor2$_._$setRgba$_(1, 1, 1, 1), 
                    this._$_currentPointColor$_._$setRgba$_(1, 1, 1, 1), this._$_vertexUniformArrayBuffer$_ = new ArrayBuffer(this._$_vertexUniformBufferSize$_), 
                    this._$_vertexUniformf32$_ = new Float32Array(this._$_vertexUniformArrayBuffer$_), 
                    this._$_fragUniformArrayBuffer$_ = new ArrayBuffer(this._$_fragUniformBufferSize$_), 
                    this._$_fragUniformf32$_ = new Float32Array(this._$_fragUniformArrayBuffer$_), 
                    this._$_fragC3ParamsArrayBuffer$_ = new ArrayBuffer(this._$_fragC3ParamsSize$_), 
                    this._$_fragC3Paramsf32$_ = new Float32Array(this._$_fragC3ParamsArrayBuffer$_), 
                    this._$_fragC3Paramsu32$_ = new Uint32Array(this._$_fragC3ParamsArrayBuffer$_), 
                    this._$_vertexBuffer$_ = t.createBuffer({
                        label: "vertexbuffer",
                        size: this._$_vertexData$_.byteLength,
                        usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
                    }), this._$_texcoordBuffer$_ = t.createBuffer({
                        label: "texcoordbuffer",
                        size: this._$_texcoordData$_.byteLength,
                        usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
                    }), this._$_colorBuffer$_ = t.createBuffer({
                        label: "colorbuffer",
                        size: this._$_colorData$_.byteLength,
                        usage: GPUBufferUsage.VERTEX | GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
                    }), this._$_indexBuffer$_ = t.createBuffer({
                        label: "indexbuffer",
                        mappedAtCreation: !0,
                        size: this._$_indexData$_.byteLength,
                        usage: GPUBufferUsage.INDEX
                    });
                    const s = this._$_indexBuffer$_.getMappedRange(), i = (new Uint16Array(s).set(this._$_indexData$_), 
                    this._$_indexBuffer$_.unmap(), this._$_pointBuffer$_ = t.createBuffer({
                        label: "pointbuffer",
                        size: this._$_pointData$_.byteLength,
                        usage: GPUBufferUsage.VERTEX | GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
                    }), this._$_bufferBindGroupLayout$_ = t.createBindGroupLayout({
                        label: "bufferbindgrouplayout",
                        entries: [ {
                            binding: 0,
                            visibility: GPUShaderStage.VERTEX,
                            buffer: {
                                type: "uniform",
                                minBindingSize: this._$_vertexUniformBufferSize$_
                            }
                        }, {
                            binding: 1,
                            visibility: GPUShaderStage.FRAGMENT,
                            buffer: {
                                type: "uniform",
                                minBindingSize: this._$_fragUniformBufferSize$_
                            }
                        }, {
                            binding: 2,
                            visibility: GPUShaderStage.VERTEX,
                            buffer: {
                                type: "read-only-storage",
                                minBindingSize: this._$_colorData$_.byteLength
                            }
                        }, {
                            binding: 3,
                            visibility: GPUShaderStage.VERTEX,
                            buffer: {
                                type: "read-only-storage",
                                minBindingSize: this._$_pointData$_.byteLength
                            }
                        }, {
                            binding: 4,
                            visibility: GPUShaderStage.FRAGMENT,
                            buffer: {
                                type: "uniform",
                                minBindingSize: this._$_fragC3ParamsSize$_
                            }
                        }, {
                            binding: 5,
                            visibility: GPUShaderStage.FRAGMENT,
                            buffer: {
                                type: "uniform"
                            }
                        } ]
                    }), []), r = C33._$Gfx$_._$WebGPUMultiTextureGroup$_._$GetMultiTextureLimit$_();
                    for (let t = 0; t < r; ++t) i.push({
                        binding: 2 * t,
                        visibility: GPUShaderStage.FRAGMENT,
                        sampler: {
                            type: "filtering"
                        }
                    }, {
                        binding: 2 * t + 1,
                        visibility: GPUShaderStage.FRAGMENT,
                        texture: {
                            sampleType: "float",
                            viewDimension: "2d"
                        }
                    });
                    this._$_textureBindGroupLayout$_ = t.createBindGroupLayout({
                        label: "texturebindgrouplayout",
                        entries: i
                    }), this._$_backTextureBindGroupLayout$_ = t.createBindGroupLayout({
                        label: "backtexturebindgrouplayout",
                        entries: [ {
                            binding: 0,
                            visibility: GPUShaderStage.FRAGMENT,
                            sampler: {
                                type: "non-filtering"
                            }
                        }, {
                            binding: 1,
                            visibility: GPUShaderStage.FRAGMENT,
                            texture: {
                                sampleType: "float",
                                viewDimension: "2d"
                            }
                        } ]
                    }), this._$_depthTextureBindGroupLayout$_ = t.createBindGroupLayout({
                        label: "depthtexturebindgrouplayout",
                        entries: [ {
                            binding: 0,
                            visibility: GPUShaderStage.FRAGMENT,
                            sampler: {
                                type: "non-filtering"
                            }
                        }, {
                            binding: 1,
                            visibility: GPUShaderStage.FRAGMENT,
                            texture: {
                                sampleType: "depth",
                                viewDimension: "2d"
                            }
                        } ]
                    }), this._$_pipelineLayout$_ = t.createPipelineLayout({
                        bindGroupLayouts: [ this._$_bufferBindGroupLayout$_, this._$_textureBindGroupLayout$_, this._$_backTextureBindGroupLayout$_, this._$_depthTextureBindGroupLayout$_ ]
                    });
                    const n = C33._$Gfx$_._$WebGPUShaderProgram$_, h = this._$SupportsF16$_(), o = (this._$_defaultVertexModule$_ = t.createShaderModule({
                        label: "<default vertex module>",
                        code: n._$_PreprocessVertexShaderCode$_(n._$GetDefaultVertexShaderSource$_(), h)
                    }), this._$_defaultVertexModule$_.getCompilationInfo().then(t => n._$ReportShaderCompilationInfo$_("<default>", "vertex", t)), 
                    this._$_normVertexModule$_ = t.createShaderModule({
                        label: "<normalized vertex module>",
                        code: n._$_PreprocessVertexShaderCode$_(n._$GetNormalizedVertexShaderSource$_(), h)
                    }), this._$_normVertexModule$_.getCompilationInfo().then(t => n._$ReportShaderCompilationInfo$_("<normalized>", "vertex", t)), 
                    await Promise.all([ n._$Create$_(this, {
                        name: "<default>",
                        src: n._$GetMultiTextureFillFragmentShaderSource$_(!1),
                        _$srcFragDepth$_: n._$GetMultiTextureFillFragmentShaderSource$_(!0),
                        _$vertexSrc$_: n._$GetTextureFillVertexShaderSource$_(),
                        _$normVertexSrc$_: n._$GetNormalizedTextureFillVertexShaderSource$_()
                    }), n._$Create$_(this, {
                        name: "<single-texture-fill>",
                        src: n._$GetSingleTextureFillFragmentShaderSource$_(!1),
                        _$srcFragDepth$_: n._$GetSingleTextureFillFragmentShaderSource$_(!0),
                        _$vertexSrc$_: n._$GetTextureFillVertexShaderSource$_(),
                        _$normVertexSrc$_: n._$GetNormalizedTextureFillVertexShaderSource$_()
                    }), n._$Create$_(this, {
                        name: "<generate-mipmap>",
                        src: n._$_GetMipmapGeneratorFragmentSource$_(),
                        _$vertexSrc$_: n._$_GetMipmapGeneratorVertexSource$_()
                    }), n._$Create$_(this, {
                        name: "<point>",
                        src: n._$_GetPointFragmentSource$_(!1),
                        _$srcFragDepth$_: n._$_GetPointFragmentSource$_(!0),
                        _$vertexSrc$_: n._$_GetPointVertexSource$_()
                    }), n._$Create$_(this, {
                        name: "<tilemap>",
                        src: n._$_GetTilemapFragmentShaderSource$_(!1),
                        _$srcFragDepth$_: n._$_GetTilemapFragmentShaderSource$_(!0)
                    }), n._$Create$_(this, {
                        name: "<fill>",
                        src: n._$_GetColorFillFragmentShaderSource$_()
                    }), n._$Create$_(this, {
                        name: "<lineargradient>",
                        src: n._$_GetLinearGradientFillFragmentShaderSource$_()
                    }), n._$Create$_(this, {
                        name: "<penumbra>",
                        src: n._$_GetPenumbraFillFragmentShaderSource$_()
                    }), n._$Create$_(this, {
                        name: "<hardellipse>",
                        src: n._$_GetHardEllipseFillFragmentShaderSource$_()
                    }), n._$Create$_(this, {
                        name: "<hardellipseoutline>",
                        src: n._$_GetHardEllipseOutlineFragmentShaderSource$_()
                    }), n._$Create$_(this, {
                        name: "<smoothellipse>",
                        src: n._$_GetSmoothEllipseFillFragmentShaderSource$_()
                    }), n._$Create$_(this, {
                        name: "<smoothellipseoutline>",
                        src: n._$_GetSmoothEllipseOutlineFragmentShaderSource$_()
                    }), n._$Create$_(this, {
                        name: "<tilerandomization>",
                        src: n._$GetTileRandomizationFragmentShaderSource$_(!1),
                        _$srcFragDepth$_: n._$GetTileRandomizationFragmentShaderSource$_(!0)
                    }), n._$Create$_(this, {
                        name: "<smoothline>",
                        src: n._$_GetSmoothLineFillFragmentShaderSource$_()
                    }) ]));
                    this._$_spTextureFill$_ = o[0], this._$_spSingleTextureFill$_ = o[1], 
                    this._$_mipmapGeneratorProgram$_ = o[2], this._$_spPoints$_ = o[3], 
                    this._$_spTilemapFill$_ = o[4], this._$_spColorFill$_ = o[5], 
                    this._$_spLinearGradientFill$_ = o[6], this._$_spPenumbraFill$_ = o[7], 
                    this._$_spHardEllipseFill$_ = o[8], this._$_spHardEllipseOutline$_ = o[9], 
                    this._$_spSmoothEllipseFill$_ = o[10], this._$_spSmoothEllipseOutline$_ = o[11], 
                    this._$_spTileRandomization$_ = o[12], this._$_spSmoothLineFill$_ = o[13];
                    for (const l of o) this._$_AddShaderProgram$_(l);
                    this._$_currentProgram$_ = this._$_spTextureFill$_, 0 != (this._$_flags$_ & FLAG_MULTITEXTURE_ALLOWED) && (this._$_flags$_ |= FLAG_MULTITEXTURE_ENABLED | FLAG_MULTITEXTURE_ACTIVE), 
                    this._$_mipmapGeneratorPipeline$_ = this._$_mipmapGeneratorProgram$_._$_GetMipmapGeneratorPipeline$_(), 
                    this._$_vertexUniformBuffer$_ = t.createBuffer({
                        label: "vertexuniformbuffer",
                        size: this._$_vertexUniformBufferSize$_,
                        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
                    }), this._$_fragmentUniformBuffer$_ = t.createBuffer({
                        label: "fragmentuniformbuffer",
                        size: this._$_fragUniformBufferSize$_,
                        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
                    }), this._$_fragmentC3ParamsBuffer$_ = t.createBuffer({
                        label: "fragmentc3paramsuniformbuffer",
                        size: this._$_fragC3ParamsSize$_,
                        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
                    }), this._$_fragmentDefaultCustomParamsBuffer$_ = t.createBuffer({
                        label: "fragmentdefaultcustomparamsbuffer",
                        size: 16,
                        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
                    }), this._$_vertexUniformUpdateStart$_ = 0, this._$_vertexUniformUpdateEnd$_ = this._$_vertexUniformBufferSize$_, 
                    this._$_UpdateTransformUniform$_(), this._$_UpdatePointTexCoordsUniform$_(), 
                    this._$_UpdateZElevationUniform$_(), this._$_fragUniformUpdateStart$_ = 0, 
                    this._$_fragUniformUpdateEnd$_ = this._$_fragUniformBufferSize$_, 
                    this._$_UpdateColor2Uniform$_(), this._$_UpdatePointColorUniform$_(), 
                    this._$_defaultBufferBindGroup$_ = this._$_CreateBufferBindGroup$_(this._$_fragmentDefaultCustomParamsBuffer$_), 
                    this._$_currentBufferBindGroup$_ = this._$_defaultBufferBindGroup$_;
                    const a = C33._$CreateCanvas$_(32, 32);
                    a.getContext("2d"), this._$_nullTexture$_ = await this._$CreateStaticTextureAsync$_(a), 
                    this._$_currentTexture$_ = null, this._$_currentTextureBindGroup$_ = this._$_nullTexture$_._$_GetOwnTextureBindGroup$_(), 
                    this._$_currentMultiTextureIndex$_ = 0, this._$_currentBackTexture$_ = null, 
                    this._$_currentBackTextureBindGroup$_ = this._$_nullTexture$_._$_GetBackTextureBindGroup$_(), 
                    this._$_nullTexture$_._$_DisableMultiTexture$_(), this._$_nullDepthBuffer$_ = this._$_device$_.createTexture({
                        label: "nulldepthbuffer",
                        size: [ 8, 8, 1 ],
                        format: this._$_GetDepthBufferFormat$_(),
                        usage: GPUTextureUsage.TEXTURE_BINDING
                    }), this._$_nullDepthBufferView$_ = this._$_nullDepthBuffer$_.createView({
                        label: "nulldepthbufferview",
                        aspect: "depth-only"
                    }), this._$_nullDepthBufferBindGroup$_ = this._$_device$_.createBindGroup({
                        label: "nulldepthbufferbindgroup",
                        layout: this._$_depthTextureBindGroupLayout$_,
                        entries: [ {
                            binding: 0,
                            resource: this._$_GetSampler$_({
                                _$sampling$_: "nearest"
                            })
                        }, {
                            binding: 1,
                            resource: this._$_nullDepthBufferView$_
                        } ]
                    }), this._$_currentDepthTextureBindGroup$_ = this._$_nullDepthBufferBindGroup$_, 
                    this._$_backbufferRenderTarget$_ = C33._$New$_(C33._$Gfx$_._$WebGPURenderTarget$_, this, !0), 
                    this._$_backbufferRenderTarget$_._$GetTexture$_()._$_BackbufferTextureSetProperties$_(e, this._$_swapChainFormat$_), 
                    this._$_currentRenderTarget$_ = this._$_backbufferRenderTarget$_, 
                    this._$_CreateCommandEncoder$_(), this._$_adapterInfo$_ = this._$_adapter$_.info, 
                    this._$_presentCtx$_ || (this._$_presentCtx$_ = this._$_canvas$_.getContext("webgpu")), 
                    this._$_presentCtx$_.configure({
                        device: t,
                        format: this._$_swapChainFormat$_,
                        usage: e,
                        alphaMode: "premultiplied"
                    }), DEBUG && DebugLog2("Initialised state");
                }
                _$_CreateBufferBindGroup$_(t) {
                    return this._$_device$_.createBindGroup({
                        layout: this._$_bufferBindGroupLayout$_,
                        entries: [ {
                            binding: 0,
                            resource: {
                                buffer: this._$_vertexUniformBuffer$_
                            }
                        }, {
                            binding: 1,
                            resource: {
                                buffer: this._$_fragmentUniformBuffer$_
                            }
                        }, {
                            binding: 2,
                            resource: {
                                buffer: this._$_colorBuffer$_
                            }
                        }, {
                            binding: 3,
                            resource: {
                                buffer: this._$_pointBuffer$_
                            }
                        }, {
                            binding: 4,
                            resource: {
                                buffer: this._$_fragmentC3ParamsBuffer$_
                            }
                        }, {
                            binding: 5,
                            resource: {
                                buffer: t
                            }
                        } ]
                    });
                }
                _$_GetDevice$_() {
                    return this._$_device$_;
                }
                _$_GetDefaultVertexModule$_() {
                    return this._$_defaultVertexModule$_;
                }
                _$_GetNormalizedVertexModule$_() {
                    return this._$_normVertexModule$_;
                }
                async _$CreateShaderProgram$_(t) {
                    DEBUG && DebugLog2(`Creating shader program '${t.name}'`);
                    const e = await C33._$Gfx$_._$WebGPUShaderProgram$_._$Create$_(this, t);
                    return this._$_AddShaderProgram$_(e), e;
                }
                _$GetDisplayName$_() {
                    return "webgpu";
                }
                _$GetSwapChainFormat$_() {
                    return this._$_swapChainFormat$_;
                }
                _$_GetDepthBufferFormat$_() {
                    return "depth24plus-stencil8";
                }
                _$_GetSwapChainTexture$_() {
                    return this._$_swapChainTexture$_;
                }
                _$_GetSwapChainTexView$_() {
                    return this._$_swapChainTexView$_;
                }
                _$_CanSampleBackbuffer$_() {
                    return this._$_canSampleBackbuffer$_;
                }
                _$UsesBackgroundBlending$_() {
                    return this._$_usesBackgroundBlending$_;
                }
                _$_GetPipelineLayout$_() {
                    return this._$_pipelineLayout$_;
                }
                _$_GetTextureBindGroupLayout$_() {
                    return this._$_textureBindGroupLayout$_;
                }
                _$_GetBackTextureBindGroupLayout$_() {
                    return this._$_backTextureBindGroupLayout$_;
                }
                _$GetTextureFormat$_() {
                    return this._$_textureFormat$_;
                }
                _$GetMaxTextureSize$_() {
                    return this._$_maxTextureSize$_;
                }
                _$IsContextLost$_() {
                    return this._$_IsFlagSet$_(FLAG_CONTEXT_LOST);
                }
                _$SupportsGPUProfiling$_() {
                    return this._$_IsFlagSet$_(FLAG_SUPPORTS_TIMESTAMP_QUERY);
                }
                _$SupportsF16$_() {
                    return this._$_IsFlagSet$_(FLAG_SUPPORTS_F16);
                }
                _$GetEstimatedBackBufferMemoryUsage$_() {
                    let t = this._$GetWidth$_() * this._$GetHeight$_(), e = t * C33._$Gfx$_._$WebGPURendererTexture$_._$GetFormatByteSize$_(this._$_swapChainFormat$_);
                    return this._$UsesDepthBuffer$_() && (e += t * C33._$Gfx$_._$WebGPURendererTexture$_._$GetFormatByteSize$_(this._$_GetDepthBufferFormat$_())), 
                    e;
                }
                _$GetEstimatedRenderBufferMemoryUsage$_() {
                    let t = 0;
                    for (const e of C33._$Gfx$_._$WebGPURenderTarget$_._$allRenderTargets$_()) e._$IsBackBuffer$_() || (t += e._$GetTexture$_()._$GetEstimatedMemoryUsage$_());
                    return t;
                }
                _$GetEstimatedTextureMemoryUsage$_() {
                    let t = 0;
                    for (const e of C33._$Gfx$_._$WebGPURendererTexture$_._$allTextures$_()) e._$IsRenderTarget$_() || (t += e._$GetEstimatedMemoryUsage$_());
                    return t;
                }
                _$SupportsNPOTTextures$_() {
                    return !0;
                }
                _$GetBufferManager$_() {
                    return this._$_bufferManager$_;
                }
                _$SetSize$_(t, e, s) {
                    (this._$_width$_ !== t || this._$_height$_ !== e || s) && (DEBUG && DebugLog2(`Setting size to ${t} x ` + e), 
                    this._$EndBatch$_(), this._$_width$_ = t, this._$_height$_ = e, 
                    this._$_viewportWidth$_ = t, this._$_viewportHeight$_ = e, this._$_backbufferRenderTarget$_._$_CalculateProjection$_(), 
                    this._$SetProjectionMatrix$_(this._$_backbufferRenderTarget$_._$GetProjectionMatrix$_()), 
                    this._$_currentRenderTarget$_ && this._$_currentRenderTarget$_._$_Resize$_(this._$_width$_, this._$_height$_), 
                    this._$_IsFlagSet$_(FLAG_USE_DEPTH_BUFFER)) && this._$_IsFlagSet$_(FLAG_AUTOSIZE_DEPTH_BUFFER) && this._$_SetDepthBufferSize$_(t, e);
                }
                _$_SetDepthBufferSize$_(t, e) {
                    if (this._$_depthBuffer$_) {
                        if (this._$_depthBufferWidth$_ === t && this._$_depthBufferHeight$_ === e) return;
                        this._$_depthBuffer$_.destroy();
                    }
                    let s = GPUTextureUsage.RENDER_ATTACHMENT;
                    this._$_canSampleDepth$_ && (s |= GPUTextureUsage.TEXTURE_BINDING), 
                    this._$_depthBuffer$_ = this._$_device$_.createTexture({
                        label: "depthbuffer",
                        size: [ t, e, 1 ],
                        format: this._$_GetDepthBufferFormat$_(),
                        usage: s
                    }), this._$_depthBufferView$_ = this._$_depthBuffer$_.createView({
                        label: "depthbufferview"
                    }), this._$_canSampleDepth$_ && (this._$_depthBufferBindGroup$_ = this._$_device$_.createBindGroup({
                        label: "depthbufferbindgroup",
                        layout: this._$_depthTextureBindGroupLayout$_,
                        entries: [ {
                            binding: 0,
                            resource: this._$_GetSampler$_({
                                _$sampling$_: "nearest"
                            })
                        }, {
                            binding: 1,
                            resource: this._$_depthBuffer$_.createView({
                                label: "depthbufferview",
                                aspect: "depth-only"
                            })
                        } ]
                    })), this._$_depthBufferWidth$_ = t, this._$_depthBufferHeight$_ = e;
                }
                _$SetFixedSizeDepthBuffer$_(t, e) {
                    this._$UsesDepthBuffer$_() && (this._$_SetFlag$_(FLAG_AUTOSIZE_DEPTH_BUFFER, !1), 
                    this._$_SetDepthBufferSize$_(t, e));
                }
                _$SetAutoSizeDepthBuffer$_() {
                    this._$UsesDepthBuffer$_() && (this._$_SetFlag$_(FLAG_AUTOSIZE_DEPTH_BUFFER, !0), 
                    this._$_SetDepthBufferSize$_(this._$_width$_, this._$_height$_));
                }
                _$SetProjectionMatrix$_(t) {
                    mat42._$exactEquals$_(this._$_matP$_, t) || (mat42._$copy$_(this._$_matP$_, t), 
                    this._$_UpdateTransformUniform$_());
                }
                _$SetDefaultRenderTargetProjectionState$_() {
                    this._$SetProjectionMatrix$_(this._$_currentRenderTarget$_._$GetProjectionMatrix$_());
                }
                _$SetModelViewMatrix$_(t) {
                    mat42._$exactEquals$_(this._$_matMV$_, t) || (mat42._$copy$_(this._$_matMV$_, t), 
                    this._$_UpdateTransformUniform$_());
                }
                _$ResetDidChangeTransformFlag$_() {
                    this._$_SetFlag$_(FLAG_DID_CHANGE_TRANSFORM, !1);
                }
                _$DidChangeTransform$_() {
                    return this._$_IsFlagSet$_(FLAG_DID_CHANGE_TRANSFORM);
                }
                _$CreateStaticTexture$_(t, e) {
                    if (t && !C33._$Gfx$_._$WebGPURendererTexture$_._$IsGPUImageCopyExternalImageSource$_(t)) {
                        const i = t.width || t.videoWidth, r = t.height || t.videoHeight, n = C33._$CreateCanvas$_(i, r), h = n.getContext("2d");
                        h.drawImage(t, 0, 0, i, r), t = n;
                    }
                    this._$EndBatch$_(), DEBUG && DebugLog2(`Creating texture ${(t || e).width} x ` + (t || e).height);
                    const s = C33._$New$_(C33._$Gfx$_._$WebGPURendererTexture$_, this);
                    return s._$_Create$_(t, e), s;
                }
                async _$CreateStaticTextureAsync$_(t, e) {
                    if (C33._$Gfx$_._$WebGPURendererTexture$_._$IsGPUImageCopyExternalImageSource$_(t)) return this._$CreateStaticTexture$_(t, e);
                    {
                        if (!C33._$Supports$_.ImageBitmapOptions) throw new Error("no support for ImageBitmapOptions");
                        const s = await createImageBitmap(t, {
                            premultiplyAlpha: "premultiply"
                        });
                        return this._$CreateStaticTexture$_(s, e);
                    }
                }
                _$_GetSampler$_(t) {
                    let e = t._$wrapX$_ || "clamp-to-edge", s = t._$wrapY$_ || "clamp-to-edge", i = t._$sampling$_, r = t._$anisotropy$_ || 0, n = e + `,${s},${i},` + (r = "trilinear" !== i ? 0 : r), h = this._$_samplerMap$_.get(n);
                    if (!h) {
                        const o = {
                            addressModeU: e,
                            addressModeV: s,
                            magFilter: "nearest",
                            minFilter: "nearest",
                            mipmapFilter: "nearest"
                        };
                        "bilinear" !== i && "trilinear" !== i || (o.magFilter = "linear", 
                        o.minFilter = "linear"), "trilinear" === i && (o.mipmapFilter = "linear", 
                        1 < r) && (o.maxAnisotropy = r), h = this._$_device$_.createSampler(o), 
                        this._$_samplerMap$_.set(n, h);
                    }
                    return h;
                }
                _$_GetMipmapGeneratorPipeline$_() {
                    return this._$_mipmapGeneratorPipeline$_;
                }
                _$CreateDynamicTexture$_(t, e, s) {
                    this._$EndBatch$_();
                    const i = C33._$New$_(C33._$Gfx$_._$WebGPURendererTexture$_, this);
                    return i._$_CreateDynamic$_(t, e, s), i;
                }
                _$UpdateTexture$_(t, e, s) {
                    return e._$_Update$_(t, s);
                }
                _$DeleteTexture$_(t) {
                    t && (t._$SubtractReference$_(), 0 < t._$GetReferenceCount$_() || (this._$IsContextLost$_() || (this._$EndBatch$_(), 
                    this._$_currentTexture$_ === t && this._$SetTexture$_(null), 
                    this._$_currentBackTexture$_ === t && this._$SetBackTexture$_(null)), 
                    t._$_Delete$_()));
                }
                _$_SetMultiTextureAvailable$_(t, e) {
                    this._$IsContextLost$_() || (e ? this._$_availableMultiTextures$_.add(t) : this._$_availableMultiTextures$_.delete(t));
                }
                _$_SetMultiTextureGroupNonFull$_(t, e) {
                    e ? this._$_nonFullMultiTexGroups$_.add(t) : this._$_nonFullMultiTexGroups$_.delete(t);
                }
                _$_TryCreateMultiTextureGroup$_(t) {
                    const e = [ t ], s = C33._$Gfx$_._$WebGPUMultiTextureGroup$_._$GetMultiTextureLimit$_();
                    for (const i of this._$_nonFullMultiTexGroups$_) i._$Release$_();
                    for (const r of this._$_availableMultiTextures$_) {
                        if (s <= e.length) break;
                        r !== t && e.push(r);
                    }
                    e.length < 2 || C33._$New$_(C33._$Gfx$_._$WebGPUMultiTextureGroup$_, this, e);
                }
                _$Start$_() {
                    DEBUG && DebugLog2("================== START FRAME ==================="), 
                    this._$_UpdateSwapChainTexture$_();
                }
                _$Restart$_() {
                    this._$_UpdateSwapChainTexture$_();
                }
                _$_UpdateSwapChainTexture$_() {
                    this._$_swapChainTexture$_ = this._$_presentCtx$_.getCurrentTexture(), 
                    this._$_swapChainTexView$_ = this._$_swapChainTexture$_.createView({
                        label: "swapchaintextureview"
                    }), this._$_backbufferRenderTarget$_._$GetTexture$_()._$_BackbufferTextureStartFrame$_();
                }
                _$Finish$_() {
                    null === this._$_currentRenderPass$_ && this._$_backbufferRenderTarget$_._$_IsAwaitingClear$_() && this._$_BeginRenderPass$_(), 
                    super._$Finish$_(), this._$_bufferManager$_._$MaybeCollectUnusedBuffers$_(this._$_frameNumber$_), 
                    this._$_backbufferRenderTarget$_._$GetTexture$_()._$_BackbufferTextureEndFrame$_(), 
                    this._$_swapChainTexture$_ = null, this._$_swapChainTexView$_ = null, 
                    DEBUG && DebugLog2("End of frame"), 10 <= this._$_frameNumber$_ && (DEBUG = !1);
                }
                _$_CreateCommandEncoder$_() {
                    this._$_commandEncoder$_ = this._$_device$_.createCommandEncoder(), 
                    this._$_flags$_ &= ~FLAG_DID_ADD_COMMAND;
                }
                _$StartFrameTiming$_(t) {
                    if (!this._$SupportsGPUProfiling$_()) throw new Error("GPU profiling not supported");
                    if (this._$_frameTimeQuerySet$_) throw new Error("already started frame timing");
                    return this._$_timestampIsMeasuring$_ = !1, this._$_timestampStartedIndices$_.clear(), 
                    this._$_frameTimeQuerySet$_ = C33._$New$_(C33._$Gfx$_._$WebGPUTimeQuerySet$_, this, t), 
                    this._$_frameTimeQuerySet$_;
                }
                _$StartMeasuringRenderPassTime$_(t, e) {
                    if (this._$SupportsGPUProfiling$_()) {
                        if (!this._$_frameTimeQuerySet$_) throw new Error("not started frame timing");
                        if (t < 0 || e < 0 || t === e) throw new Error("invalid timestamp index");
                        this._$_MaybeEndRenderPass$_(), this._$_timestampIsMeasuring$_ = !0, 
                        this._$_timestampStartIndex$_ = t, this._$_timestampEndIndex$_ = e;
                    }
                }
                _$StopMeasuringRenderPassTime$_() {
                    this._$_timestampIsMeasuring$_ && (this._$_MaybeEndRenderPass$_(), 
                    this._$_timestampIsMeasuring$_ = !1);
                }
                _$_AddQuadToDrawBatch$_() {
                    let t = this._$_quadPtr$_;
                    if (t > LAST_QUAD_PTR) this._$EndBatch$_(), t = 0; else if (0 != (this._$_flags$_ & FLAG_IN_DRAW)) return void (this._$_drawIndexCount$_ += 6);
                    null === this._$_currentRenderPass$_ && this._$_BeginRenderPass$_(), 
                    this._$_flags$_ |= FLAG_IN_DRAW, this._$_drawFirstIndex$_ = 6 * t, 
                    this._$_drawIndexCount$_ = 6;
                }
                _$_MaybeEndDrawBatch$_() {
                    const s = this._$_flags$_;
                    if (0 != (s & FLAG_IN_DRAW)) {
                        if (DEBUG) {
                            const e = [];
                            s & FLAG_DRAW_STATE_CHANGED && e.push("draw state"), 
                            s & FLAG_PIPELINE_CHANGED && e.push("pipeline"), s & FLAG_TEX_BINDGROUP_CHANGED && e.push("texture"), 
                            s & FLAG_BACKTEX_BINDGROUP_CHANGED && e.push("background texture"), 
                            s & FLAG_DEPTHTEX_BINDGROUP_CHANGED && e.push("depth texture"), 
                            s & FLAG_BUFFER_BINDGROUP_CHANGED && e.push("buffer"), 
                            s & FLAG_SCISSOR_CHANGED && e.push("scissor");
                            let t = "";
                            0 < e.length && (t += `(Updated ${e.join(", ")}) `), 
                            0 != (s & FLAG_DRAWING_POINTS) ? t += `Drawing ${this._$_drawIndexCount$_ / 6} points` : t += `Drawing ${this._$_drawIndexCount$_ / 6} quads`, 
                            DebugLog2(t);
                        }
                        const i = this._$_currentRenderPass$_;
                        if (0 != (s & FLAG_DRAW_STATE_CHANGED)) {
                            const t = this._$_currentRenderTarget$_;
                            i.setViewport(0, 0, t._$GetWidth$_(), t._$GetHeight$_(), 0, 1), 
                            i.setIndexBuffer(this._$_indexBuffer$_, "uint16"), i.setVertexBuffer(0, this._$_vertexBuffer$_), 
                            i.setVertexBuffer(1, this._$_texcoordBuffer$_), 0 != (s & (FLAG_COPLANAR_STENCIL_PASS | FLAG_COPLANAR_COLOR_PASS)) && i.setStencilReference(1), 
                            0 != (s & FLAG_SCISSOR_ENABLED) && this._$_DoSetRenderPassScissorRect$_(i, this._$_scissorRect$_, t);
                        }
                        if (0 != (s & FLAG_PIPELINE_CHANGED)) {
                            let t = 0, e = (0 != (s & FLAG_USE_NORMALIZED_COORDS) ? t = 4 : 0 != (s & FLAG_COPLANAR_STENCIL_PASS) ? t = 2 : 0 != (s & FLAG_COPLANAR_COLOR_PASS) ? t = 3 : (s & (FLAG_DEPTH_ENABLED | FLAG_RENDERTARGET_HAS_DEPTH)) == (FLAG_DEPTH_ENABLED | FLAG_RENDERTARGET_HAS_DEPTH) && (t = 1), 
                            this._$_currentProgram$_);
                            e === this._$_spTextureFill$_ && 0 == (s & FLAG_MULTITEXTURE_ACTIVE) && (e = this._$_spSingleTextureFill$_), 
                            i.setPipeline(e._$GetRenderPipelineForState$_(this._$_currentBlendMode$_, t, this._$_currentMultisampleCount$_));
                        }
                        if (0 != (s & FLAG_BUFFER_BINDGROUP_CHANGED) && i.setBindGroup(0, this._$_currentBufferBindGroup$_), 
                        0 != (s & FLAG_TEX_BINDGROUP_CHANGED) && i.setBindGroup(1, this._$_currentTextureBindGroup$_), 
                        0 != (s & FLAG_BACKTEX_BINDGROUP_CHANGED) && i.setBindGroup(2, this._$_currentBackTextureBindGroup$_), 
                        0 != (s & FLAG_DEPTHTEX_BINDGROUP_CHANGED) && i.setBindGroup(3, this._$_currentDepthTextureBindGroup$_), 
                        0 != (s & FLAG_SCISSOR_CHANGED)) {
                            const r = this._$_currentRenderTarget$_;
                            0 != (s & FLAG_SCISSOR_ENABLED) ? this._$_DoSetRenderPassScissorRect$_(i, this._$_scissorRect$_, r) : i.setScissorRect(0, 0, r._$GetWidth$_(), r._$GetHeight$_());
                        }
                        i.drawIndexed(this._$_drawIndexCount$_, 1, this._$_drawFirstIndex$_, 0, 0), 
                        this._$_flags$_ &= ~END_DRAW_FLAGS_MASK;
                    }
                }
                _$_DoSetRenderPassScissorRect$_(t, e, s) {
                    let i = s._$GetWidth$_(), r = s._$GetHeight$_(), n = C33._$clamp$_(e._$getLeft$_(), 0, i), h = C33._$clamp$_(e._$getTop$_(), 0, r), o = C33._$clamp$_(e._$getRight$_(), n, i), a = C33._$clamp$_(e._$getBottom$_(), h, r);
                    Number.isNaN(n) && (n = 0), Number.isNaN(h) && (h = 0), Number.isNaN(o) && (o = i), 
                    Number.isNaN(a) && (a = r), t.setScissorRect(n, h, o - n, a - h);
                }
                _$_BeginRenderPass$_() {
                    const t = this._$_flags$_;
                    0 != (t & CHANGED_UNIFORM_BUFFER_MASK) && this._$_WriteUniformBuffers$_();
                    let e;
                    e = 0 != (t & FLAG_COPLANAR_STENCIL_PASS) ? this._$_GetCoplanarStencilRenderPassOpts$_() : 0 != (t & FLAG_COPLANAR_COLOR_PASS) ? this._$_GetCoplanarColorRenderPassOpts$_() : this._$_GetStandardRenderPassOpts$_(), 
                    this._$_currentRenderPass$_ = this._$_commandEncoder$_.beginRenderPass(e), 
                    this._$_flags$_ |= NEW_RENDERPASS_FLAGS;
                }
                _$_GetStandardRenderPassOpts$_() {
                    const t = this._$_flags$_, e = this._$_currentRenderTarget$_, s = {
                        colorAttachments: [ {
                            view: e._$_GetTextureView$_(),
                            loadOp: e._$_IsAwaitingClear$_() ? "clear" : "load",
                            clearValue: e._$_GetClearColor$_().toJSON(),
                            storeOp: "store"
                        } ]
                    };
                    return this._$_MaybeSetTimestampRenderPassOption$_(s), e._$_SetIsAwaitingClear$_(!1), 
                    (t & (FLAG_RENDERTARGET_HAS_DEPTH | FLAG_DEPTH_ENABLED)) == (FLAG_RENDERTARGET_HAS_DEPTH | FLAG_DEPTH_ENABLED) && (s.depthStencilAttachment = {
                        view: this._$_depthBufferView$_,
                        depthLoadOp: 0 != (t & FLAG_CLEAR_DEPTH) ? "clear" : "load",
                        depthClearValue: 1,
                        depthStoreOp: "store",
                        stencilLoadOp: "clear",
                        stencilClearValue: 0,
                        stencilStoreOp: "discard"
                    }, this._$_flags$_ &= ~FLAG_CLEAR_DEPTH), DEBUG && DebugLog2(`Starting render pass to ${e._$IsBackBuffer$_() ? "backbuffer" : "texture"}, depth ${s.depthStencilAttachment ? "enabled" : "disabled"}, ${"load" === s.colorAttachments[0].loadOp ? "continue" : "clear"} color` + (s.depthStencilAttachment && "load" !== s.depthStencilAttachment.depthLoadOp ? ", clear depth" : "")), 
                    s;
                }
                _$_GetCoplanarStencilRenderPassOpts$_() {
                    const t = this._$_flags$_, e = {
                        colorAttachments: [],
                        depthStencilAttachment: {
                            view: this._$_depthBufferView$_,
                            depthLoadOp: 0 != (t & FLAG_CLEAR_DEPTH) ? "clear" : "load",
                            depthClearValue: 1,
                            depthStoreOp: "store",
                            stencilLoadOp: 0 != (t & FLAG_CLEAR_STENCIL) ? "clear" : "load",
                            stencilClearValue: 0,
                            stencilStoreOp: "store"
                        }
                    };
                    return this._$_MaybeSetTimestampRenderPassOption$_(e), this._$_flags$_ &= ~(FLAG_CLEAR_DEPTH | FLAG_CLEAR_STENCIL), 
                    DEBUG && DebugLog2("Starting coplanar stencil renderpass" + ("load" === e.depthStencilAttachment.depthLoadOp ? "" : ", clear depth") + ("load" === e.depthStencilAttachment.stencilLoadOp ? "" : ", clear stencil")), 
                    e;
                }
                _$_GetCoplanarColorRenderPassOpts$_() {
                    const t = this._$_currentRenderTarget$_, e = {
                        colorAttachments: [ {
                            view: t._$_GetTextureView$_(),
                            loadOp: t._$_IsAwaitingClear$_() ? "clear" : "load",
                            clearValue: t._$_GetClearColor$_().toJSON(),
                            storeOp: "store"
                        } ],
                        depthStencilAttachment: {
                            view: this._$_depthBufferView$_,
                            depthReadOnly: !0,
                            stencilReadOnly: !0
                        }
                    };
                    return this._$_MaybeSetTimestampRenderPassOption$_(e), t._$_SetIsAwaitingClear$_(!1), 
                    DEBUG && DebugLog2(`Starting coplanar color renderpass to ${t._$IsBackBuffer$_() ? "backbuffer" : "texture"}, ${"load" === e.colorAttachments[0].loadOp ? "continue" : "clear"} color`), 
                    e;
                }
                _$_MaybeSetTimestampRenderPassOption$_(t) {
                    if (this._$_timestampIsMeasuring$_) {
                        const e = {
                            querySet: this._$_frameTimeQuerySet$_._$_GetQuerySet$_(),
                            endOfPassWriteIndex: this._$_timestampEndIndex$_
                        };
                        this._$_timestampStartedIndices$_.has(this._$_timestampStartIndex$_) || (e.beginningOfPassWriteIndex = this._$_timestampStartIndex$_, 
                        this._$_timestampStartedIndices$_.add(this._$_timestampStartIndex$_)), 
                        t.timestampWrites = e;
                    }
                }
                _$_MaybeDoPendingClearRenderPass$_(t) {
                    if (t._$_IsAwaitingClear$_()) {
                        this._$_MaybeEndRenderPass$_();
                        const e = this._$_commandEncoder$_.beginRenderPass({
                            colorAttachments: [ {
                                view: t._$_GetTextureView$_(),
                                loadOp: "clear",
                                clearValue: t._$_GetClearColor$_().toJSON(),
                                storeOp: "store"
                            } ]
                        });
                        e.end(), this._$_flags$_ |= FLAG_DID_ADD_COMMAND, t._$_SetIsAwaitingClear$_(!1);
                    }
                }
                _$_MaybeEndRenderPass$_() {
                    null !== this._$_currentRenderPass$_ && (this._$_MaybeEndDrawBatch$_(), 
                    DEBUG && DebugLog2(`Ending render pass (to ${this._$_currentRenderTarget$_._$IsBackBuffer$_() ? "backbuffer" : "texture"})`), 
                    this._$_currentRenderPass$_.end(), this._$_currentRenderPass$_ = null);
                }
                _$EndBatch$_(t = !1) {
                    this._$_MaybeEndRenderPass$_(), this._$_frameTimeQuerySet$_ && t && (this._$_frameTimeQuerySet$_._$Resolve$_(this._$_commandEncoder$_), 
                    this._$_flags$_ |= FLAG_DID_ADD_COMMAND), 0 != (this._$_flags$_ & FLAG_DID_ADD_COMMAND) && (this._$_commandBuffers$_.push(this._$_commandEncoder$_.finish()), 
                    this._$_CreateCommandEncoder$_()), 0 !== this._$_commandBuffers$_.length && (DEBUG && DebugLog2("Ending batch"), 
                    this._$_WriteBuffers$_(), DEBUG && DebugLog2(`Submitting ${this._$_commandBuffers$_.length} commands`), 
                    this._$_device$_.queue.submit(this._$_commandBuffers$_), C33._$clearArray$_(this._$_commandBuffers$_), 
                    this._$_bufferManager$_._$AfterSubmit$_(), this._$_frameTimeQuerySet$_) && t && (this._$_frameTimeQuerySet$_._$ReadResult$_(), 
                    this._$_frameTimeQuerySet$_ = null);
                }
                _$_WriteBuffers$_() {
                    const t = this._$_device$_.queue;
                    if (0 < this._$_quadPtr$_) {
                        const e = this._$_quadPtr$_;
                        DEBUG && DebugLog2("Writing vertex buffers"), t.writeBuffer(this._$_vertexBuffer$_, 0, this._$_vertexData$_.buffer, 0, 12 * e * SIZEOF_F32), 
                        t.writeBuffer(this._$_texcoordBuffer$_, 0, this._$_texcoordData$_.buffer, 0, 12 * e * SIZEOF_F32), 
                        t.writeBuffer(this._$_colorBuffer$_, 0, this._$_colorData$_.buffer, 0, 4 * e * SIZEOF_F32), 
                        this._$_quadPtr$_ = 0;
                    }
                    0 < this._$_pointPtr$_ && (DEBUG && DebugLog2("Writing point buffer"), 
                    t.writeBuffer(this._$_pointBuffer$_, 0, this._$_pointData$_.buffer, 0, this._$_pointPtr$_ * SIZEOF_F32), 
                    this._$_pointPtr$_ = 0);
                }
                _$_UpdateTransformUniform$_() {
                    this._$_flags$_ |= FLAG_TRANSFORM_CHANGED | FLAG_DID_CHANGE_TRANSFORM, 
                    this._$_MarkVertexUniformBufferRangeChanged$_(this._$_vertexUniformBufferLayout$_.transform);
                }
                _$_UpdatePointTexCoordsUniform$_() {
                    const t = this._$_vertexUniformBufferLayout$_._$pointTex$_;
                    this._$_currentPointTexCoords$_._$writeToTypedArray$_(this._$_vertexUniformf32$_, t.offset / 4), 
                    this._$_MarkVertexUniformBufferRangeChanged$_(t);
                }
                _$_UpdateZElevationUniform$_() {
                    const t = this._$_vertexUniformBufferLayout$_._$zElevation$_;
                    this._$_vertexUniformf32$_[t.offset / 4] = this._$_currentVertexZElevation$_, 
                    this._$_MarkVertexUniformBufferRangeChanged$_(t);
                }
                _$_MarkVertexUniformBufferRangeChanged$_(t) {
                    const e = t.offset, s = t.end;
                    0 != (this._$_flags$_ & FLAG_VERTEX_UNIFORM_CHANGED) ? (this._$_vertexUniformUpdateStart$_ = Math.min(this._$_vertexUniformUpdateStart$_, e), 
                    this._$_vertexUniformUpdateEnd$_ = Math.max(this._$_vertexUniformUpdateEnd$_, s)) : (this._$_flags$_ |= FLAG_VERTEX_UNIFORM_CHANGED, 
                    this._$_vertexUniformUpdateStart$_ = e, this._$_vertexUniformUpdateEnd$_ = s, 
                    this._$_MaybeEndRenderPass$_());
                }
                _$_UpdateColor2Uniform$_() {
                    this._$_UpdateFragmentUniformColor$_(this._$_currentColor2$_, this._$_fragUniformBufferLayout$_._$color2$_);
                }
                _$_UpdatePointColorUniform$_() {
                    this._$_UpdateFragmentUniformColor$_(this._$_currentPointColor$_, this._$_fragUniformBufferLayout$_._$pointColor$_);
                }
                _$_UpdateFragmentUniformColor$_(t, e) {
                    t._$writeToTypedArray$_(this._$_fragUniformf32$_, e.offset / 4), 
                    this._$_MarkFragUniformBufferRangeChanged$_(e);
                }
                _$_UpdateFragmentUniformVec2$_(t, e) {
                    t._$writeToTypedArray$_(this._$_fragUniformf32$_, e.offset / 4), 
                    this._$_MarkFragUniformBufferRangeChanged$_(e);
                }
                _$_MarkFragUniformBufferRangeChanged$_(t) {
                    const e = t.offset, s = t.end;
                    0 != (this._$_flags$_ & FLAG_FRAG_UNIFORM_CHANGED) ? (this._$_fragUniformUpdateStart$_ = Math.min(this._$_fragUniformUpdateStart$_, e), 
                    this._$_fragUniformUpdateEnd$_ = Math.max(this._$_fragUniformUpdateEnd$_, s)) : (this._$_flags$_ |= FLAG_FRAG_UNIFORM_CHANGED, 
                    this._$_fragUniformUpdateStart$_ = e, this._$_fragUniformUpdateEnd$_ = s, 
                    this._$_MaybeEndRenderPass$_());
                }
                _$_MaybeUpdateFragmentC3ParamsFloat$_(t, e) {
                    this._$_fragC3Paramsf32$_[e.offset / 4] !== Math.fround(t) && (this._$_fragC3Paramsf32$_[e.offset / 4] = t, 
                    this._$_MarkFragC3ParamsRangeChanged$_(e));
                }
                _$_MaybeUpdateFragmentC3ParamsUint$_(t, e) {
                    this._$_fragC3Paramsu32$_[e.offset / 4] !== t && (this._$_fragC3Paramsu32$_[e.offset / 4] = t, 
                    this._$_MarkFragC3ParamsRangeChanged$_(e));
                }
                _$_MaybeUpdateFragmentC3ParamsRect$_(t, e) {
                    t._$equalsF32Array$_(this._$_fragC3Paramsf32$_, e.offset / 4) || (t._$writeToTypedArray$_(this._$_fragC3Paramsf32$_, e.offset / 4), 
                    this._$_MarkFragC3ParamsRangeChanged$_(e));
                }
                _$_MarkFragC3ParamsRangeChanged$_(t) {
                    const e = t.offset, s = t.end;
                    0 != (this._$_flags$_ & FLAG_FRAG_C3PARAMS_CHANGED) ? (this._$_fragC3ParamsUpdateStart$_ = Math.min(this._$_fragC3ParamsUpdateStart$_, e), 
                    this._$_fragC3ParamsUpdateEnd$_ = Math.max(this._$_fragC3ParamsUpdateEnd$_, s)) : (this._$_flags$_ |= FLAG_FRAG_C3PARAMS_CHANGED, 
                    this._$_fragC3ParamsUpdateStart$_ = e, this._$_fragC3ParamsUpdateEnd$_ = s, 
                    this._$_MaybeEndRenderPass$_());
                }
                _$_WriteUniformBuffers$_() {
                    const t = this._$_flags$_;
                    0 != (t & FLAG_TRANSFORM_CHANGED) && (DEBUG && DebugLog2("Updating transform"), 
                    mat42.multiply(this._$_matTransform$_, this._$_matP$_, this._$_matMV$_), 
                    this._$_vertexUniformf32$_.set(this._$_matTransform$_, this._$_vertexUniformBufferLayout$_.transform.offset / 4)), 
                    0 != (t & FLAG_VERTEX_UNIFORM_CHANGED) && (DEBUG && DebugLog2("Updating vertex uniform buffer"), 
                    this._$_bufferManager$_._$UpdateBufferSubData$_(this._$_commandEncoder$_, this._$_vertexUniformBuffer$_, this._$_vertexUniformArrayBuffer$_, this._$_vertexUniformUpdateStart$_, this._$_vertexUniformUpdateEnd$_ - this._$_vertexUniformUpdateStart$_)), 
                    0 != (t & FLAG_FRAG_UNIFORM_CHANGED) && (DEBUG && DebugLog2("Updating fragment uniform buffer"), 
                    this._$_bufferManager$_._$UpdateBufferSubData$_(this._$_commandEncoder$_, this._$_fragmentUniformBuffer$_, this._$_fragUniformArrayBuffer$_, this._$_fragUniformUpdateStart$_, this._$_fragUniformUpdateEnd$_ - this._$_fragUniformUpdateStart$_)), 
                    0 != (t & FLAG_FRAG_C3PARAMS_CHANGED) && (DEBUG && DebugLog2("Updating fragment C3Params buffer"), 
                    this._$_bufferManager$_._$UpdateBufferSubData$_(this._$_commandEncoder$_, this._$_fragmentC3ParamsBuffer$_, this._$_fragC3ParamsArrayBuffer$_, this._$_fragC3ParamsUpdateStart$_, this._$_fragC3ParamsUpdateEnd$_ - this._$_fragC3ParamsUpdateStart$_)), 
                    this._$_flags$_ = t & ~CHANGED_UNIFORM_BUFFER_MASK | FLAG_DID_ADD_COMMAND;
                }
                _$CreateRenderTarget$_(t) {
                    let e = this._$_width$_, s = this._$_height$_, i = !0;
                    if (t && ("number" == typeof t.width && (e = Math.floor(t.width), 
                    i = !1), "number" == typeof t.height) && (s = Math.floor(t.height), 
                    i = !1), e <= 0 || s <= 0) throw new Error("invalid size");
                    this._$EndBatch$_();
                    const r = C33._$New$_(C33._$Gfx$_._$WebGPURenderTarget$_, this);
                    return r._$_Create$_(e, s, Object.assign({
                        _$isDefaultSize$_: i
                    }, t)), r;
                }
                _$SetRenderTarget$_(t, e = !0) {
                    null === t && (t = this._$_backbufferRenderTarget$_), this._$_currentRenderTarget$_ !== t && (this._$_MaybeEndRenderPass$_(), 
                    this._$_currentRenderTarget$_ = t, this._$_SetFlag$_(FLAG_RENDERTARGET_HAS_DEPTH, t._$HasDepthBuffer$_()), 
                    t._$IsDefaultSize$_() && !t._$IsBackBuffer$_() && t._$_Resize$_(this._$_width$_, this._$_height$_), 
                    e) && this._$SetDefaultRenderTargetProjectionState$_();
                }
                _$InvalidateRenderTarget$_(t) {}
                _$GetRenderTarget$_() {
                    return this._$_currentRenderTarget$_ === this._$_backbufferRenderTarget$_ ? null : this._$_currentRenderTarget$_;
                }
                _$GetRenderTargetSize$_(t) {
                    return null === t ? [ this._$_width$_, this._$_height$_ ] : [ t._$GetWidth$_(), t._$GetHeight$_() ];
                }
                _$GetBackbufferRenderTarget$_() {
                    return this._$_backbufferRenderTarget$_;
                }
                _$DeleteRenderTarget$_(t) {
                    this._$EndBatch$_(), this._$_currentRenderTarget$_ === t && this._$SetRenderTarget$_(null);
                    const e = t._$GetTexture$_();
                    this._$_currentTexture$_ === e && this._$SetTexture$_(null), 
                    this._$_currentBackTexture$_ === e && this._$SetBackTexture$_(null), 
                    t._$_Delete$_();
                }
                async _$ReadBackRenderTargetToImageData$_(t, e, s) {
                    this._$_MaybeDoPendingClearRenderPass$_(t), this._$EndBatch$_(), 
                    null === t && (t = this._$_backbufferRenderTarget$_);
                    let i = this._$_device$_, r = t._$GetWidth$_(), n = t._$GetHeight$_(), h = 0, o = 0, a = r, l = n;
                    if (s) {
                        h = C33._$clamp$_(Math.floor(s._$getLeft$_()), 0, r - 1), 
                        o = C33._$clamp$_(Math.floor(s._$getTop$_()), 0, n - 1);
                        let t = s.width(), e = (t = 0 === t ? r - h : C33._$clamp$_(Math.floor(t), 0, r - h), 
                        s.height());
                        e = 0 === e ? n - o : C33._$clamp$_(Math.floor(e), 0, n - o), 
                        a = t, l = e;
                    }
                    let u = i.createCommandEncoder(), c = t._$GetTexture$_(), f = c._$_GetTexture$_(), d = null, p = ("rgba8unorm" === c._$_GetFormat$_() ? c._$CanReadPixels$_() || C33._$NotYetImplemented$_() : (d = this._$_ConvertTextureFormat$_(c, "rgba8unorm", u), 
                    f = d), 4 * a), m = 256 * Math.ceil(p / 256), C = i.createBuffer({
                        size: m * l,
                        usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST
                    }), g = (u.copyTextureToBuffer({
                        texture: f,
                        origin: [ h, o, 0 ]
                    }, {
                        buffer: C,
                        bytesPerRow: m
                    }, [ a, l, 1 ]), u.finish()), S = (i.queue.submit([ g ]), d && d.destroy(), 
                    await C.mapAsync(self.GPUMapMode.READ), C.getMappedRange().slice(0)), _;
                    if (m == p) _ = new ImageData(new Uint8ClampedArray(S), a, l); else {
                        const T = new ArrayBuffer(p * l), y = new Uint8Array(T);
                        for (let t = 0; t < l; ++t) {
                            const E = t * m, A = t * p;
                            y.set(new Uint8Array(S, E, p), A);
                        }
                        _ = new ImageData(new Uint8ClampedArray(T), a, l);
                    }
                    return C.destroy(), _;
                }
                _$_ConvertTextureFormat$_(t, e, s) {
                    const i = this._$_device$_, r = t._$GetWidth$_(), n = t._$GetHeight$_();
                    if (t._$_GetFormat$_() === e) throw new Error("no conversion necessary");
                    t._$IsSampled$_() || C33._$NotYetImplemented$_();
                    const h = i.createTexture({
                        size: [ r, n, 1 ],
                        format: e,
                        usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT
                    }), o = this._$_mipmapGeneratorProgram$_._$_GetMipmapGeneratorPipeline$_(e), a = o.getBindGroupLayout(0), l = this._$_GetSampler$_({
                        _$sampling$_: "nearest"
                    }), u = t._$_GetTexture$_().createView({
                        baseMipLevel: 0,
                        mipLevelCount: 1
                    }), c = h.createView({
                        baseMipLevel: 0,
                        mipLevelCount: 1
                    }), f = s.beginRenderPass({
                        colorAttachments: [ {
                            view: c,
                            loadOp: "clear",
                            clearValue: [ 0, 0, 0, 0 ],
                            storeOp: "store"
                        } ]
                    }), d = i.createBindGroup({
                        layout: a,
                        entries: [ {
                            binding: 0,
                            resource: l
                        }, {
                            binding: 1,
                            resource: u
                        } ]
                    });
                    return f.setPipeline(o), f.setBindGroup(0, d), f.draw(4), f.end(), 
                    h;
                }
                _$SetDepthEnabled$_(t) {
                    0 != (this._$_flags$_ & FLAG_USE_DEPTH_BUFFER) && (t = !!t, 
                    0 != (this._$_flags$_ & FLAG_DEPTH_ENABLED) !== t) && (0 != (this._$_flags$_ & FLAG_RENDERTARGET_HAS_DEPTH) && this._$_MaybeEndRenderPass$_(), 
                    this._$_SetFlag$_(FLAG_DEPTH_ENABLED, t));
                }
                _$IsDepthEnabled$_() {
                    return this._$_IsFlagSet$_(FLAG_DEPTH_ENABLED);
                }
                _$UsesDepthBuffer$_() {
                    return this._$_IsFlagSet$_(FLAG_USE_DEPTH_BUFFER);
                }
                _$SetDepthSamplingEnabled$_(t) {
                    if (this._$_canSampleDepth$_) {
                        if (t && this._$IsDepthEnabled$_()) throw new Error("depth still enabled");
                        const e = t ? this._$_depthBufferBindGroup$_ : this._$_nullDepthBufferBindGroup$_;
                        this._$_currentDepthTextureBindGroup$_ !== e && (this._$_MaybeEndDrawBatch$_(), 
                        this._$_currentDepthTextureBindGroup$_ = e, this._$_flags$_ |= FLAG_DEPTHTEX_BINDGROUP_CHANGED);
                    }
                }
                _$Clear$_(t) {
                    this._$_MaybeEndRenderPass$_(), this._$_currentRenderTarget$_._$_SetIsAwaitingClear$_(!0), 
                    this._$_currentRenderTarget$_._$_GetClearColor$_().set(t);
                }
                _$ClearRgba$_(t, e, s, i) {
                    this._$_MaybeEndRenderPass$_(), this._$_currentRenderTarget$_._$_SetIsAwaitingClear$_(!0), 
                    this._$_currentRenderTarget$_._$_GetClearColor$_()._$setRgba$_(t, e, s, i);
                }
                _$ClearDepth$_() {
                    (this._$_flags$_ & (FLAG_USE_DEPTH_BUFFER | FLAG_RENDERTARGET_HAS_DEPTH)) == (FLAG_USE_DEPTH_BUFFER | FLAG_RENDERTARGET_HAS_DEPTH) && (this._$_MaybeEndRenderPass$_(), 
                    this._$_flags$_ |= FLAG_CLEAR_DEPTH);
                }
                _$SetScissorRect$_(t, e, s, i) {
                    t = Math.floor(t), e = Math.floor(e), s = Math.floor(s), i = Math.floor(i), 
                    0 != (this._$_flags$_ & FLAG_SCISSOR_ENABLED) && this._$_scissorRect$_._$equalsWH$_(t, e, s, i) || (this._$_MaybeEndDrawBatch$_(), 
                    this._$_flags$_ |= FLAG_SCISSOR_ENABLED | FLAG_SCISSOR_CHANGED, 
                    this._$_scissorRect$_._$setWH$_(t, e, s, i));
                }
                _$RemoveScissorRect$_() {
                    0 != (this._$_flags$_ & FLAG_SCISSOR_ENABLED) && (this._$_MaybeEndDrawBatch$_(), 
                    this._$_flags$_ &= ~FLAG_SCISSOR_ENABLED, this._$_flags$_ |= FLAG_SCISSOR_CHANGED);
                }
                _$SetProgram$_(t) {
                    this._$_currentProgram$_ !== t && (this._$_MaybeEndDrawBatch$_(), 
                    this._$_currentProgram$_ = t, this._$_currentStateGroup$_ = null, 
                    this._$_flags$_ |= FLAG_PIPELINE_CHANGED, this._$_SetMultiTexturingEnabled$_(t === this._$_spTextureFill$_));
                }
                _$GetProgram$_() {
                    return this._$_currentProgram$_;
                }
                _$_SetMultiTexturingEnabled$_(t) {
                    if (t = !!t, 0 != (this._$_flags$_ & FLAG_MULTITEXTURE_ENABLED) !== t) {
                        this._$_SetFlag$_(FLAG_MULTITEXTURE_ENABLED, t);
                        const e = null === this._$_currentTexture$_ ? this._$_nullTexture$_ : this._$_currentTexture$_;
                        this._$_ApplyTextureBindGroup$_(e);
                    }
                }
                _$_SetMultiTexturingActive$_(t) {
                    t = !!t, 0 != (this._$_flags$_ & FLAG_MULTITEXTURE_ACTIVE) !== t && (this._$_MaybeEndDrawBatch$_(), 
                    this._$_SetFlag$_(FLAG_MULTITEXTURE_ACTIVE, t), this._$_SetFlag$_(FLAG_PIPELINE_CHANGED, !0));
                }
                _$SetNormalizedCoordsProgramVariant$_(t) {
                    t = !!t, 0 != (this._$_flags$_ & FLAG_USE_NORMALIZED_COORDS) !== t && (this._$_MaybeEndDrawBatch$_(), 
                    this._$_SetFlag$_(FLAG_USE_NORMALIZED_COORDS, t), this._$_flags$_ |= FLAG_PIPELINE_CHANGED);
                }
                _$IsNormalizedCoordsProgramVariant$_() {
                    return this._$_IsFlagSet$_(FLAG_USE_NORMALIZED_COORDS);
                }
                _$SetTexture$_(t) {
                    t !== this._$_currentTexture$_ && (null === (this._$_currentTexture$_ = t) && (t = this._$_nullTexture$_), 
                    this._$_ApplyTextureBindGroup$_(t));
                }
                _$_ApplyTextureBindGroup$_(t) {
                    if (0 != (this._$_flags$_ & FLAG_MULTITEXTURE_ENABLED)) {
                        const e = t._$_GetMultiTextureBindGroup$_();
                        if (null !== e) return this._$_SetTextureBindGroup$_(e), 
                        this._$_currentMultiTextureIndex$_ = t._$_GetMultiTextureIndex$_(), 
                        void this._$_SetMultiTexturingActive$_(!0);
                    }
                    this._$_SetTextureBindGroup$_(t._$_GetOwnTextureBindGroup$_()), 
                    this._$_currentMultiTextureIndex$_ = 0, this._$_SetMultiTexturingActive$_(!1);
                }
                _$_SetTextureBindGroup$_(t) {
                    t !== this._$_currentTextureBindGroup$_ && (this._$_MaybeEndDrawBatch$_(), 
                    this._$_currentTextureBindGroup$_ = t, this._$_flags$_ |= FLAG_TEX_BINDGROUP_CHANGED);
                }
                _$_OnTextureBindGroupChanged$_(t) {
                    this._$_currentTexture$_ === t && (this._$_MaybeEndDrawBatch$_(), 
                    this._$_currentTextureBindGroup$_ = t._$_GetOwnTextureBindGroup$_(), 
                    this._$_flags$_ |= FLAG_TEX_BINDGROUP_CHANGED);
                }
                _$_OnMultiTextureBindGroupReleased$_(t) {
                    if (this._$_currentTextureBindGroup$_ === t) {
                        this._$_MaybeEndDrawBatch$_();
                        const e = null === this._$_currentTexture$_ ? this._$_nullTexture$_ : this._$_currentTexture$_;
                        this._$_currentTextureBindGroup$_ = e._$_GetOwnTextureBindGroup$_(), 
                        this._$_currentMultiTextureIndex$_ = 0, this._$_flags$_ |= FLAG_TEX_BINDGROUP_CHANGED;
                    }
                }
                _$SetBackTexture$_(t) {
                    t !== this._$_currentBackTexture$_ && (null === (this._$_currentBackTexture$_ = t) && (t = this._$_nullTexture$_), 
                    this._$_MaybeEndDrawBatch$_(), this._$_currentBackTextureBindGroup$_ = t._$_GetBackTextureBindGroup$_(), 
                    this._$_flags$_ |= FLAG_BACKTEX_BINDGROUP_CHANGED);
                }
                _$CopyTextureToTexture$_(t, e, s, i, r, n) {
                    const h = t._$_GetUsage$_(), o = e._$_GetUsage$_();
                    if (0 == (h & GPUTextureUsage.COPY_SRC)) throw new Error("source texture missing COPY_SRC usage");
                    if (0 == (o & GPUTextureUsage.COPY_DST)) throw new Error("destination texture missing COPY_DST usage");
                    if (t === e) throw new Error("invalid destination");
                    const a = Math.min(t._$GetWidth$_(), e._$GetWidth$_()), l = Math.min(t._$GetHeight$_(), e._$GetHeight$_());
                    r = Math.min(r, a - s), n = Math.min(n, l - i), r <= 0 || n <= 0 || (this._$_MaybeEndRenderPass$_(), 
                    DEBUG && DebugLog2(`Copying texture to texture, from (${s}, ${i}), size ${r} x ` + n), 
                    this._$_commandEncoder$_.copyTextureToTexture({
                        texture: t._$_GetTexture$_(),
                        origin: [ s, i ]
                    }, {
                        texture: e._$_GetTexture$_(),
                        origin: [ s, i ]
                    }, [ r, n ]), this._$_flags$_ |= FLAG_DID_ADD_COMMAND);
                }
                _$_ClampToSupportedMultisampleValues$_(t) {
                    return 2 <= t ? 4 : 1;
                }
                _$SetRenderingToMultisampleCount$_(t) {
                    t = this._$_ClampToSupportedMultisampleValues$_(t), this._$_currentMultisampleCount$_ !== t && (this._$_MaybeEndDrawBatch$_(), 
                    this._$_currentMultisampleCount$_ = t, this._$_flags$_ |= FLAG_PIPELINE_CHANGED);
                }
                _$SetBlendMode$_(t) {
                    t !== this._$_currentBlendMode$_ && (this._$_MaybeEndDrawBatch$_(), 
                    this._$_currentBlendMode$_ = t, this._$_currentStateGroup$_ = null, 
                    this._$_flags$_ |= FLAG_PIPELINE_CHANGED);
                }
                _$SetNamedBlendMode$_(t) {
                    this._$SetBlendMode$_(this._$NamedBlendToNumber$_(t));
                }
                _$SetAlphaBlend$_() {
                    this._$SetBlendMode$_(0);
                }
                _$SetCopyBlend$_() {
                    this._$SetBlendMode$_(3);
                }
                _$SetColorRgba$_(t, e, s, i) {
                    const r = this._$_currentColor$_;
                    r._$equalsRgba$_(t, e, s, i) || (r._$setRgba$_(t, e, s, i), 
                    this._$_currentStateGroup$_ = null);
                }
                _$SetOpacity$_(t) {
                    const e = this._$_currentColor$_;
                    e._$getA$_() !== t && (e._$setA$_(t), this._$_currentStateGroup$_ = null);
                }
                _$GetOpacity$_() {
                    return this._$_currentColor$_._$getA$_();
                }
                _$SetColor$_(t) {
                    const e = this._$_currentColor$_;
                    e.equals(t) || (e.set(t), this._$_currentStateGroup$_ = null);
                }
                _$ResetColor$_() {
                    this._$SetColorRgba$_(1, 1, 1, 1);
                }
                _$GetColor$_() {
                    return this._$_currentColor$_;
                }
                Rect(t) {
                    this._$Rect2$_(t._$getLeft$_(), t._$getTop$_(), t._$getRight$_(), t._$getBottom$_());
                }
                _$Rect2$_(t, e, s, i) {
                    this._$Quad2$_(t, e, s, e, s, i, t, i);
                }
                _$Quad$_(t) {
                    this._$Quad4$_(t, defaultTexCoordsQuad);
                }
                _$Quad2$_(t, e, s, i, r, n, h, o) {
                    this._$_AddQuadToDrawBatch$_();
                    let a = this._$_vertexData$_, l = this._$_quadPtr$_++, u = 12 * l, c = this._$_baseZ$_ + this._$_currentZ$_;
                    a[u++] = t, a[u++] = e, a[u++] = c, a[u++] = s, a[u++] = i, 
                    a[u++] = c, a[u++] = r, a[u++] = n, a[u++] = c, a[u++] = h, 
                    a[u++] = o, a[u] = c, defaultTexCoordsQuad._$writeToTypedArray3D$_(this._$_texcoordData$_, 12 * l, this._$_currentMultiTextureIndex$_), 
                    this._$_currentColor$_._$writeToTypedArray$_(this._$_colorData$_, 4 * l);
                }
                _$Quad3$_(t, e) {
                    this._$_AddQuadToDrawBatch$_();
                    const s = this._$_quadPtr$_++;
                    t._$writeToTypedArray3D$_(this._$_vertexData$_, 12 * s, this._$_baseZ$_ + this._$_currentZ$_), 
                    e._$writeAsQuadToTypedArray3D$_(this._$_texcoordData$_, 12 * s, this._$_currentMultiTextureIndex$_), 
                    this._$_currentColor$_._$writeToTypedArray$_(this._$_colorData$_, 4 * s);
                }
                _$Quad4$_(t, e) {
                    this._$_AddQuadToDrawBatch$_();
                    const s = this._$_quadPtr$_++;
                    t._$writeToTypedArray3D$_(this._$_vertexData$_, 12 * s, this._$_baseZ$_ + this._$_currentZ$_), 
                    e._$writeToTypedArray3D$_(this._$_texcoordData$_, 12 * s, this._$_currentMultiTextureIndex$_), 
                    this._$_currentColor$_._$writeToTypedArray$_(this._$_colorData$_, 4 * s);
                }
                _$Quad3D$_(t, e, s, i, r, n, h, o, a, l, u, c, f) {
                    this._$_AddQuadToDrawBatch$_();
                    let d = this._$_vertexData$_, p = this._$_quadPtr$_++, m = 12 * p, C = this._$_baseZ$_ + this._$_currentZ$_;
                    d[m++] = t, d[m++] = e, d[m++] = C + s, d[m++] = i, d[m++] = r, 
                    d[m++] = C + n, d[m++] = h, d[m++] = o, d[m++] = C + a, d[m++] = l, 
                    d[m++] = u, d[m] = C + c, f._$writeAsQuadToTypedArray3D$_(this._$_texcoordData$_, 12 * p, this._$_currentMultiTextureIndex$_), 
                    this._$_currentColor$_._$writeToTypedArray$_(this._$_colorData$_, 4 * p);
                }
                _$Quad3D2$_(t, e, s, i, r, n, h, o, a, l, u, c, f) {
                    this._$_AddQuadToDrawBatch$_();
                    let d = this._$_vertexData$_, p = this._$_quadPtr$_++, m = 12 * p, C = this._$_baseZ$_ + this._$_currentZ$_;
                    d[m++] = t, d[m++] = e, d[m++] = C + s, d[m++] = i, d[m++] = r, 
                    d[m++] = C + n, d[m++] = h, d[m++] = o, d[m++] = C + a, d[m++] = l, 
                    d[m++] = u, d[m] = C + c, f._$writeToTypedArray3D$_(this._$_texcoordData$_, 12 * p, this._$_currentMultiTextureIndex$_), 
                    this._$_currentColor$_._$writeToTypedArray$_(this._$_colorData$_, 4 * p);
                }
                _$DrawMesh$_(p, m, C) {
                    const g = this._$_vertexData$_, S = this._$_texcoordData$_, _ = this._$_colorData$_;
                    if (C.length % 3 != 0) throw new Error("invalid index buffer length");
                    const T = this._$_currentMultiTextureIndex$_, t = this._$_currentColor$_, y = t._$getR$_(), E = t._$getG$_(), A = t._$getB$_(), I = t._$getA$_();
                    for (let d = 0, t = C.length; d < t; ) {
                        let t = C[d++], e = C[d++], s = C[d++], i = 3 * t, r = 3 * e, n = 3 * s, h = 2 * t, o = 2 * e, a = 2 * s, l = (this._$_AddQuadToDrawBatch$_(), 
                        this._$_quadPtr$_++), u = 12 * l, c = 12 * l, f = 4 * l;
                        g[u++] = p[0 + i], g[u++] = p[1 + i], g[u++] = p[2 + i], 
                        g[u++] = p[0 + r], g[u++] = p[1 + r], g[u++] = p[2 + r], 
                        g[u++] = p[0 + n], g[u++] = p[1 + n], g[u++] = p[2 + n], 
                        g[u++] = p[0 + n], g[u++] = p[1 + n], g[u] = p[2 + n], S[c++] = m[0 + h], 
                        S[c++] = m[1 + h], S[c++] = T, S[c++] = m[0 + o], S[c++] = m[1 + o], 
                        S[c++] = T, S[c++] = m[0 + a], S[c++] = m[1 + a], S[c++] = T, 
                        S[c++] = m[0 + a], S[c++] = m[1 + a], S[c] = T, _[f++] = y, 
                        _[f++] = E, _[f++] = A, _[f] = I;
                    }
                }
                _$StartRenderingPoints$_(t) {
                    this._$_currentPointTexCoords$_.equals(t) || (this._$_currentPointTexCoords$_._$copy$_(t), 
                    this._$_UpdatePointTexCoordsUniform$_());
                    const e = this._$_baseZ$_ + this._$_currentZ$_;
                    this._$_currentVertexZElevation$_ !== e && (this._$_currentVertexZElevation$_ = e, 
                    this._$_UpdateZElevationUniform$_()), this._$_currentPointColor$_._$equalsIgnoringAlpha$_(this._$_currentColor$_) || (this._$_currentPointColor$_._$copyRgb$_(this._$_currentColor$_), 
                    this._$_UpdatePointColorUniform$_()), this._$SetProgram$_(this._$GetPointsRenderingProgram$_()), 
                    this._$_drawIndexCount$_ = 0, this._$_flags$_ |= FLAG_DRAWING_POINTS;
                }
                _$FinishRenderingPoints$_() {
                    0 < this._$_drawIndexCount$_ && this._$_MaybeEndDrawBatch$_(), 
                    this._$_flags$_ &= ~FLAG_DRAWING_POINTS;
                }
                _$Point$_(t, e, s, i) {
                    let r = this._$_pointPtr$_;
                    r > LAST_POINT_PTR && (this._$EndBatch$_(), r = 0), 0 != (this._$_flags$_ & FLAG_IN_DRAW) ? this._$_drawIndexCount$_ += 6 : (null === this._$_currentRenderPass$_ && this._$_BeginRenderPass$_(), 
                    this._$_flags$_ |= FLAG_IN_DRAW, this._$_drawFirstIndex$_ = r / 4 * 6, 
                    this._$_drawIndexCount$_ = 6);
                    const n = this._$_pointData$_;
                    n[r++] = t, n[r++] = e, n[r++] = s, n[r++] = i, this._$_pointPtr$_ = r;
                }
                _$SetGradientColor$_(t) {
                    this._$_currentColor2$_.equals(t) || (this._$_currentColor2$_._$copy$_(t), 
                    this._$_UpdateColor2Uniform$_());
                }
                _$SetEllipseParams$_(t, e, s = 1) {
                    const i = this._$_fragUniformBufferLayout$_, r = this._$_fragUniformf32$_;
                    tempVec2.set(t, e), tempVec2._$equalsF32Array$_(r, i._$pixelSize$_.offset / 4) || this._$_UpdateFragmentUniformVec2$_(tempVec2, i._$pixelSize$_), 
                    r[i._$outlineThickness$_.offset / 4] !== Math.fround(s) && (r[i._$outlineThickness$_.offset / 4] = s, 
                    this._$_MarkFragUniformBufferRangeChanged$_(i._$outlineThickness$_));
                }
                _$SetTilemapInfo$_(t, e, s, i, r, n, h) {
                    const o = this._$_fragUniformBufferLayout$_, a = this._$_fragUniformf32$_;
                    t._$equalsF32Array$_(a, o._$srcRect$_.offset / 4) || (t._$writeToTypedArray$_(a, o._$srcRect$_.offset / 4), 
                    this._$_MarkFragUniformBufferRangeChanged$_(o._$srcRect$_)), 
                    tempVec2.set(i / e, r / s), tempVec2._$equalsF32Array$_(a, o._$tileSize$_.offset / 4) || this._$_UpdateFragmentUniformVec2$_(tempVec2, o._$tileSize$_), 
                    tempVec2.set(n / e, h / s), tempVec2._$equalsF32Array$_(a, o._$tileSpacing$_.offset / 4) || this._$_UpdateFragmentUniformVec2$_(tempVec2, o._$tileSpacing$_);
                }
                _$SetTileRandomizationInfo$_(t, e, s, i, r, n, h) {
                    const o = this._$_fragUniformBufferLayout$_, a = this._$_fragUniformf32$_;
                    tempVec2.set(s, i), tempVec2._$equalsF32Array$_(a, o._$tileSize$_.offset / 4) || this._$_UpdateFragmentUniformVec2$_(tempVec2, o._$tileSize$_), 
                    a[o._$outlineThickness$_.offset / 4] !== Math.fround(r) && (a[o._$outlineThickness$_.offset / 4] = r, 
                    this._$_MarkFragUniformBufferRangeChanged$_(o._$outlineThickness$_)), 
                    tempVec2.set(n, h), tempVec2._$equalsF32Array$_(a, o._$tileSpacing$_.offset / 4) || this._$_UpdateFragmentUniformVec2$_(tempVec2, o._$tileSpacing$_);
                }
                _$SetProgramParameters$_(t, e, s, i, r, n, h, o, a, l, u) {
                    const c = this._$_fragC3ParamsLayout$_, f = this._$_currentProgram$_;
                    u %= 10800, f._$BlendsBackground$_() && this._$SetBackTexture$_(t), 
                    f._$UsesAnyC3ParamRect$_() && (this._$_MaybeUpdateFragmentC3ParamsRect$_(e, c._$destRect$_), 
                    this._$_MaybeUpdateFragmentC3ParamsRect$_(s, c._$srcRect$_), 
                    this._$_MaybeUpdateFragmentC3ParamsRect$_(i, c._$srcOriginRect$_), 
                    this._$_MaybeUpdateFragmentC3ParamsRect$_(r, c._$layoutRect$_)), 
                    this._$_MaybeUpdateFragmentC3ParamsFloat$_(o, c.devicePixelRatio), 
                    this._$_MaybeUpdateFragmentC3ParamsFloat$_(a, c._$layerScale$_), 
                    this._$_MaybeUpdateFragmentC3ParamsFloat$_(l, c._$layerAngle$_), 
                    this._$_MaybeUpdateFragmentC3ParamsFloat$_(u, c._$seconds$_), 
                    this._$_MaybeUpdateFragmentC3ParamsFloat$_(this._$GetNearZ$_(), c._$zNear$_), 
                    this._$_MaybeUpdateFragmentC3ParamsFloat$_(this._$GetFarZ$_(), c._$zFar$_);
                }
                _$SetProgramCustomParameters$_(t) {
                    t && (t._$IsChanged$_() && (this._$_MaybeEndRenderPass$_(), 
                    t._$UpdateBuffer$_(this._$_commandEncoder$_)), this._$_SetBufferBindGroup$_(t._$GetBufferBindGroup$_()));
                }
                _$SetProgramParameter_IsSrcTexRotated$_(t) {
                    this._$_MaybeUpdateFragmentC3ParamsUint$_(t ? 1 : 0, this._$_fragC3ParamsLayout$_._$isSrcTexRotated$_);
                }
                _$_SetBufferBindGroup$_(t) {
                    t !== this._$_currentBufferBindGroup$_ && (this._$_MaybeEndDrawBatch$_(), 
                    this._$_currentBufferBindGroup$_ = t, this._$_flags$_ |= FLAG_BUFFER_BINDGROUP_CHANGED);
                }
                _$_OnBufferBindGroupDestroyed$_(t) {
                    this._$_currentBufferBindGroup$_ === t && this._$_SetBufferBindGroup$_(this._$_defaultBufferBindGroup$_);
                }
                _$CopyRenderTarget$_(t) {
                    t._$_IsAwaitingClear$_() ? (this._$_currentRenderTarget$_._$_SetIsAwaitingClear$_(!0), 
                    this._$_currentRenderTarget$_._$_GetClearColor$_().set(t._$_GetClearColor$_())) : 2 <= t._$GetMultisampling$_() && this._$_currentRenderTarget$_._$GetMultisampling$_() < 2 ? this._$_ResolveMultisampledRenderTarget$_(t) : (this._$ClearRgba$_(0, 0, 0, 0), 
                    this._$SetCopyBlend$_(), this._$ResetColor$_(), this._$DrawRenderTarget$_(t));
                }
                _$DrawRenderTarget$_(t) {
                    this._$_MaybeDoPendingClearRenderPass$_(t);
                    const e = t._$GetTexture$_();
                    this._$SetTexture$_(e), this._$FullscreenQuad$_();
                }
                _$FullscreenQuad$_() {
                    const t = this._$IsNormalizedCoordsProgramVariant$_(), e = (t || this._$SetNormalizedCoordsProgramVariant$_(!0), 
                    this._$SetCurrentZ$_(0), tempQuad), s = tempRect;
                    e.set(0, -1, 0, -1, 2, 1, 0, 1), s.set(0, -1, 2, 1), this._$Quad3$_(e, s), 
                    t || this._$SetNormalizedCoordsProgramVariant$_(!1);
                }
                _$_ResolveMultisampledRenderTarget$_(t) {
                    this._$_MaybeDoPendingClearRenderPass$_(t), this._$_MaybeEndRenderPass$_();
                    const e = this._$_commandEncoder$_.beginRenderPass({
                        colorAttachments: [ {
                            view: t._$GetTexture$_()._$_GetTextureView$_(),
                            resolveTarget: this._$_currentRenderTarget$_._$GetTexture$_()._$_GetTextureView$_(),
                            loadOp: "load",
                            storeOp: "store"
                        } ]
                    });
                    e.end(), this._$_flags$_ |= FLAG_DID_ADD_COMMAND;
                }
                _$CoplanarStartStencilPass$_() {
                    this._$_MaybeEndRenderPass$_(), this._$SetDepthEnabled$_(!0), 
                    this._$_flags$_ |= FLAG_COPLANAR_STENCIL_PASS | FLAG_CLEAR_STENCIL;
                }
                _$CoplanarStartColorPass$_() {
                    this._$_MaybeEndRenderPass$_(), this._$SetDepthEnabled$_(!1), 
                    this._$_flags$_ &= ~FLAG_COPLANAR_STENCIL_PASS, this._$_flags$_ |= FLAG_COPLANAR_COLOR_PASS;
                }
                _$IsCoplanarColorPass$_() {
                    return this._$_IsFlagSet$_(FLAG_COPLANAR_COLOR_PASS);
                }
                _$CoplanarRestoreStandardRendering$_() {
                    this._$_MaybeEndRenderPass$_(), this._$SetDepthEnabled$_(!0), 
                    this._$_flags$_ &= ~FLAG_COPLANAR_COLOR_PASS;
                }
                _$_InitBlendModes$_() {
                    this._$_InitBlendModeData$_([ [ "normal", "one", "one-minus-src-alpha" ], [ "additive", "one", "one" ], [ "xor", "one", "one-minus-src-alpha" ], [ "copy", "one", "zero" ], [ "destination-over", "one-minus-dst-alpha", "one" ], [ "source-in", "dst-alpha", "zero" ], [ "destination-in", "zero", "src-alpha" ], [ "source-out", "one-minus-dst-alpha", "zero" ], [ "destination-out", "zero", "one-minus-src-alpha" ], [ "source-atop", "dst-alpha", "one-minus-src-alpha" ], [ "destination-atop", "one-minus-dst-alpha", "src-alpha" ] ]);
                }
                _$GetAvailableAdapterFeatures$_() {
                    return this._$_adapter$_ ? [ ...this._$_adapter$_.features ] : [];
                }
                _$GetAdapterInfo$_() {
                    return this._$_adapterInfo$_;
                }
                _$GetAdapterInfoString$_() {
                    const t = this._$_adapterInfo$_;
                    if (!t) return "unknown/unknown";
                    const e = t.vendor || "unknown", s = t.architecture || "unknown", i = [], r = (t.device && i.push(t.device), 
                    t.description && i.push(t.description), t.type && i.push(t.type), 
                    t.backend && i.push(t.backend), 0 < i.length ? ` (${i.join(", ")})` : "");
                    return e + "/" + s + r;
                }
            };
        }
        {
            const C33 = self._$C3$_, ENABLE_RECYCLING = !0;
            C33._$Gfx$_._$WebGPUBufferManager$_ = class {
                constructor(t) {
                    this._$_renderer$_ = t, this._$_buffers$_ = new Map(), this._$_recycleAfterSubmit$_ = [], 
                    this._$_releaseAfterSubmit$_ = [], this._$_destroyAfterSubmit$_ = [], 
                    this._$_totalBufferCount$_ = 0, this._$_totalBufferSize$_ = 0, 
                    this._$_totalCreated$_ = 0, this._$_totalReleased$_ = 0, this._$_totalReturned$_ = 0, 
                    this._$_totalRecycled$_ = 0;
                }
                _$GetRenderer$_() {
                    return this._$_renderer$_;
                }
                _$OnContextLost$_() {
                    this._$_buffers$_.clear(), C33._$clearArray$_(this._$_recycleAfterSubmit$_), 
                    C33._$clearArray$_(this._$_releaseAfterSubmit$_), C33._$clearArray$_(this._$_destroyAfterSubmit$_);
                }
                _$_RoundBufferSizeClass$_(t) {
                    return Math.max(C33._$nextHighestPowerOfTwo$_(t), 16);
                }
                _$GetRecyclableBuffer$_(t) {
                    this._$_totalReturned$_++;
                    const e = this._$_RoundBufferSizeClass$_(t);
                    if (ENABLE_RECYCLING) {
                        const s = this._$_buffers$_.get(e);
                        if (void 0 !== s && 0 < s.length) {
                            const i = s.pop();
                            return i._$MarkInUse$_(), 0 === s.length && this._$_buffers$_.delete(e), 
                            i;
                        }
                    }
                    return this._$_totalBufferCount$_++, this._$_totalBufferSize$_ += e, 
                    this._$_totalCreated$_++, C33._$New$_(C33._$Gfx$_._$WebGPURecyclableBuffer$_, this, e);
                }
                _$_AddRecycledBuffer$_(t) {
                    this._$_totalRecycled$_++;
                    const e = t._$GetSize$_(), s = this._$_buffers$_.get(e);
                    void 0 === s ? this._$_buffers$_.set(e, [ t ]) : s.push(t);
                }
                _$_DestroyAfterSubmit$_(t) {
                    this._$_destroyAfterSubmit$_.push(t);
                }
                _$AfterSubmit$_() {
                    for (const t of this._$_recycleAfterSubmit$_) t._$Recycle$_();
                    C33._$clearArray$_(this._$_recycleAfterSubmit$_);
                    for (const e of this._$_releaseAfterSubmit$_) this._$_totalBufferCount$_--, 
                    this._$_totalBufferSize$_ -= e._$GetSize$_(), e._$Release$_();
                    C33._$clearArray$_(this._$_releaseAfterSubmit$_);
                    for (const s of this._$_destroyAfterSubmit$_) s.destroy();
                    C33._$clearArray$_(this._$_destroyAfterSubmit$_);
                }
                _$MaybeCollectUnusedBuffers$_(t) {
                    t % 30 == 0 && this._$_CollectUnusedBuffers$_(t);
                }
                _$_CollectUnusedBuffers$_(i) {
                    for (const [ t, r ] of this._$_buffers$_.entries()) {
                        let s = 0;
                        for (let t = 0, e = r.length; t < e; ++t) {
                            const n = r[t];
                            n._$_ShouldCollect$_(i) ? (this._$_totalBufferCount$_--, 
                            this._$_totalBufferSize$_ -= n._$GetSize$_(), n._$Release$_(), 
                            this._$_totalReleased$_++) : (r[s] = n, ++s);
                        }
                        0 === s ? this._$_buffers$_.delete(t) : C33._$truncateArray$_(r, s);
                    }
                    this._$_DebugLogBufferMap$_();
                }
                _$UpdateBufferSubData$_(t, e, s, i, r) {
                    const n = this._$GetRecyclableBuffer$_(r), h = n._$GetBuffer$_(), o = h.getMappedRange(0, r);
                    new Uint8Array(o).set(new Uint8Array(s, i, r)), h.unmap(), t.copyBufferToBuffer(h, 0, e, i, r), 
                    (ENABLE_RECYCLING ? this._$_recycleAfterSubmit$_ : (n._$Discard$_(), 
                    this._$_releaseAfterSubmit$_)).push(n);
                }
                _$_DebugLogBufferMap$_() {
                    this._$_totalCreated$_ = 0, this._$_totalReleased$_ = 0, this._$_totalReturned$_ = 0, 
                    this._$_totalRecycled$_ = 0;
                }
            };
        }
        {
            const C33 = self._$C3$_, GPUBufferUsage = self.GPUBufferUsage, GPUMapMode = self.GPUMapMode, assert = self.assert, STATE_AVAILABLE = 0, STATE_IN_USE = 1, STATE_RECYCLING = 2;
            C33._$Gfx$_._$WebGPURecyclableBuffer$_ = class {
                constructor(t, e) {
                    this._$_bufferManager$_ = t, this._$_state$_ = STATE_IN_USE, 
                    this._$_size$_ = e, this._$_buffer$_ = this._$GetRenderer$_()._$_GetDevice$_().createBuffer({
                        mappedAtCreation: !0,
                        size: e,
                        usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.MAP_WRITE
                    }), this._$_recycledFrameNumber$_ = 0;
                }
                _$GetRenderer$_() {
                    return this._$_bufferManager$_._$GetRenderer$_();
                }
                _$GetState$_() {
                    return this._$_state$_;
                }
                _$GetSize$_() {
                    return this._$_size$_;
                }
                _$GetBuffer$_() {
                    return this._$_buffer$_;
                }
                _$MarkInUse$_() {
                    this._$_state$_ = STATE_IN_USE;
                }
                async _$Recycle$_() {
                    this._$_state$_ = STATE_RECYCLING;
                    try {
                        await this._$_buffer$_.mapAsync(GPUMapMode.WRITE);
                    } catch (t) {
                        return void console.warn("[WebGPU] Error recycling buffer, assuming device was lost: ", t);
                    }
                    this._$GetRenderer$_()._$IsContextLost$_() || (this._$_state$_ = STATE_AVAILABLE, 
                    this._$_recycledFrameNumber$_ = this._$GetRenderer$_()._$GetFrameNumber$_(), 
                    this._$_bufferManager$_._$_AddRecycledBuffer$_(this));
                }
                _$Discard$_() {
                    this._$_state$_ = STATE_AVAILABLE;
                }
                _$_ShouldCollect$_(t) {
                    return this._$_recycledFrameNumber$_ <= t - 25;
                }
                _$Release$_() {
                    this._$_buffer$_.destroy(), this._$_buffer$_ = null, this._$_bufferManager$_ = null;
                }
            };
        }
        {
            const C33 = self._$C3$_, assert = self.assert, GPUBufferUsage = self.GPUBufferUsage;
            C33._$Gfx$_._$WebGPUEffectCustomParamsBuffer$_ = class {
                constructor(t) {
                    const e = t._$GetRenderer$_();
                    this._$_shaderProgram$_ = t, this._$_byteSize$_ = t._$GetCustomParametersByteSize$_(), 
                    this._$_arrayBuffer$_ = new ArrayBuffer(this._$_byteSize$_), 
                    this._$_f32arr$_ = new Float32Array(this._$_arrayBuffer$_), 
                    this._$_isChanged$_ = !1, this._$_buffer$_ = e._$_GetDevice$_().createBuffer({
                        size: this._$_byteSize$_,
                        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
                    }), this._$_bufferBindGroup$_ = e._$_CreateBufferBindGroup$_(this._$_buffer$_);
                }
                _$Release$_() {
                    const t = this._$GetRenderer$_();
                    t._$_OnBufferBindGroupDestroyed$_(this._$_bufferBindGroup$_), 
                    this._$GetRenderer$_()._$GetBufferManager$_()._$_DestroyAfterSubmit$_(this._$_buffer$_), 
                    this._$_buffer$_ = null, this._$_shaderProgram$_ = null, this._$_arrayBuffer$_ = null, 
                    this._$_f32arr$_ = null, this._$_bufferBindGroup$_ = null;
                }
                _$GetRenderer$_() {
                    return this._$_shaderProgram$_._$GetRenderer$_();
                }
                _$GetShaderProgram$_() {
                    return this._$_shaderProgram$_;
                }
                _$GetBufferBindGroup$_() {
                    return this._$_bufferBindGroup$_;
                }
                _$SetParameterValue$_(t, e) {
                    const s = this._$_shaderProgram$_._$_GetCustomParameterInfo$_(t), i = s.type, r = s.offset / 4, n = this._$_f32arr$_;
                    if ("color" === i) e._$equalsRGBF32Array$_(n, r) || (e._$writeRGBToTypedArray$_(n, r), 
                    this._$_isChanged$_ = !0); else {
                        if ("float" !== i && "percent" !== i) throw new Error(`unexpected shader param type '${i}'`);
                        n[r] !== Math.fround(e) && (n[r] = e, this._$_isChanged$_ = !0);
                    }
                }
                _$IsChanged$_() {
                    return this._$_isChanged$_;
                }
                _$UpdateBuffer$_(t) {
                    this._$GetRenderer$_()._$GetBufferManager$_()._$UpdateBufferSubData$_(t, this._$_buffer$_, this._$_arrayBuffer$_, 0, this._$_byteSize$_), 
                    this._$_isChanged$_ = !1;
                }
            };
        }
        {
            let UpdateLayoutEndValues2 = function(t) {
                for (const e of Object.values(t)) e.end = e.offset + e.size;
            }, makeNullFilledArray2 = function(e) {
                const s = [];
                for (let t = 0; t < e; ++t) s.push(null);
                return s;
            };
            UpdateLayoutEndValues = UpdateLayoutEndValues2, makeNullFilledArray = makeNullFilledArray2;
            const C33 = self._$C3$_, SIZEOF_F32 = 4, SIZEOF_U32 = 4, SIZEOF_VEC2_F32 = 2 * SIZEOF_F32, SIZEOF_VEC4_F32 = 4 * SIZEOF_F32, SIZEOF_MAT4_F32 = 16 * SIZEOF_F32, vertexUniformBufferDeclaration = `
struct Uniforms {
	transform		: mat4x4<f32>,
	pointTexStart	: vec2<f32>,
	pointTexEnd		: vec2<f32>,
	zElevation		: f32
};
@binding(0) @group(0) var<uniform> uniforms : Uniforms;
`, vubLayout = {
                transform: {
                    offset: 0,
                    size: SIZEOF_MAT4_F32,
                    end: 0
                },
                _$pointTex$_: {
                    offset: 64,
                    size: SIZEOF_VEC4_F32,
                    end: 0
                },
                _$pointTexStart$_: {
                    offset: 64,
                    size: SIZEOF_VEC2_F32,
                    end: 0
                },
                _$pointTexEnd$_: {
                    offset: 72,
                    size: SIZEOF_VEC2_F32,
                    end: 0
                },
                _$zElevation$_: {
                    offset: 80,
                    size: SIZEOF_F32,
                    end: 0
                }
            }, vubSize = (UpdateLayoutEndValues2(vubLayout), vubLayout._$zElevation$_.end), fragmentUniformBufferDeclaration = `
struct Uniforms {
	color2				: vec4<f32>,
	pointColor 			: vec4<f32>,
	tileSize			: vec2<f32>,
	tileSpacing			: vec2<f32>,
	srcRectStart		: vec2<f32>,
	srcRectEnd			: vec2<f32>,
	pixelSize			: vec2<f32>,
	outlineThickness	: f32
};
@binding(1) @group(0) var<uniform> uniforms : Uniforms;
`, fubLayout = {
                _$color2$_: {
                    offset: 0,
                    size: SIZEOF_VEC4_F32,
                    end: 0
                },
                _$pointColor$_: {
                    offset: 16,
                    size: SIZEOF_VEC4_F32,
                    end: 0
                },
                _$tileSize$_: {
                    offset: 32,
                    size: SIZEOF_VEC2_F32,
                    end: 0
                },
                _$tileSpacing$_: {
                    offset: 40,
                    size: SIZEOF_VEC2_F32,
                    end: 0
                },
                _$srcRect$_: {
                    offset: 48,
                    size: SIZEOF_VEC4_F32,
                    end: 0
                },
                _$srcRectStart$_: {
                    offset: 48,
                    size: SIZEOF_VEC2_F32,
                    end: 0
                },
                _$srcRectEnd$_: {
                    offset: 56,
                    size: SIZEOF_VEC2_F32,
                    end: 0
                },
                _$pixelSize$_: {
                    offset: 64,
                    size: SIZEOF_VEC2_F32,
                    end: 0
                },
                _$outlineThickness$_: {
                    offset: 72,
                    size: SIZEOF_F32,
                    end: 0
                }
            }, fubSize = (UpdateLayoutEndValues2(fubLayout), fubLayout._$outlineThickness$_.end), c3ParamsUniformBufferDeclaration = `
struct C3Params {
	srcStart			: vec2<f32>,
	srcEnd				: vec2<f32>,
	srcOriginStart		: vec2<f32>,
	srcOriginEnd		: vec2<f32>,
	layoutStart			: vec2<f32>,
	layoutEnd			: vec2<f32>,
	destStart			: vec2<f32>,
	destEnd				: vec2<f32>,
	devicePixelRatio	: f32,
	layerScale			: f32,
	layerAngle			: f32,
	seconds				: f32,
	zNear				: f32,
	zFar				: f32,
	isSrcTexRotated		: u32
};
@binding(4) @group(0) var<uniform> c3Params : C3Params;

fn c3_srcToNorm(p : vec2<f32>) -> vec2<f32>
{
	return (p - c3Params.srcStart) / (c3Params.srcEnd - c3Params.srcStart);
}

fn c3_normToSrc(p : vec2<f32>) -> vec2<f32>
{
	return fma(p, c3Params.srcEnd - c3Params.srcStart, c3Params.srcStart);
}

fn c3_clampToSrc(p : vec2<f32>) -> vec2<f32>
{
	return clamp(p, min(c3Params.srcStart, c3Params.srcEnd), max(c3Params.srcStart, c3Params.srcEnd));
}

fn c3_srcOriginToNorm(p : vec2<f32>) -> vec2<f32>
{
	return (p - c3Params.srcOriginStart) / (c3Params.srcOriginEnd - c3Params.srcOriginStart);
}

fn c3_normToSrcOrigin(p : vec2<f32>) -> vec2<f32>
{
	return fma(p, c3Params.srcOriginEnd - c3Params.srcOriginStart, c3Params.srcOriginStart);
}

fn c3_clampToSrcOrigin(p : vec2<f32>) -> vec2<f32>
{
	return clamp(p, min(c3Params.srcOriginStart, c3Params.srcOriginEnd), max(c3Params.srcOriginStart, c3Params.srcOriginEnd));
}

fn c3_getLayoutPos(p : vec2<f32>) -> vec2<f32>
{
	return fma(p - c3Params.srcOriginStart, (c3Params.layoutEnd - c3Params.layoutStart) / (c3Params.srcOriginEnd - c3Params.srcOriginStart), c3Params.layoutStart);
}

fn c3_srcToDest(p : vec2<f32>) -> vec2<f32>
{
	return fma(p - c3Params.srcStart, (c3Params.destEnd - c3Params.destStart) / (c3Params.srcEnd - c3Params.srcStart), c3Params.destStart);
}

fn c3_clampToDest(p : vec2<f32>) -> vec2<f32>
{
	return clamp(p, min(c3Params.destStart, c3Params.destEnd), max(c3Params.destStart, c3Params.destEnd));
}

fn c3_linearizeDepth(depthSample : f32) -> f32
{
	return c3Params.zNear * c3Params.zFar / (c3Params.zFar + depthSample * (c3Params.zNear - c3Params.zFar));
}
`, C3PARAMS_TERMS_REFERENCING_SRC_RECTS = [ "srcStart", "srcEnd", "srcOriginStart", "srcOriginEnd", "c3_srcToNorm", "c3_normToSrc", "c3_clampToSrc", "c3_srcOriginToNorm", "c3_normToSrcOrigin", "c3_clampToSrcOrigin", "c3_getLayoutPos", "c3_srcToDest" ], C3PARAMS_TERMS_REFERENCING_OTHER_RECTS = [ "layoutStart", "layoutEnd", "destStart", "destEnd", "c3_clampToDest" ], c3ParamsLayout = {
                _$srcRect$_: {
                    offset: 0,
                    size: SIZEOF_VEC4_F32,
                    end: 0
                },
                _$srcStart$_: {
                    offset: 0,
                    size: SIZEOF_VEC2_F32,
                    end: 0
                },
                _$srcEnd$_: {
                    offset: 8,
                    size: SIZEOF_VEC2_F32,
                    end: 0
                },
                _$srcOriginRect$_: {
                    offset: 16,
                    size: SIZEOF_VEC4_F32,
                    end: 0
                },
                _$srcOriginStart$_: {
                    offset: 16,
                    size: SIZEOF_VEC2_F32,
                    end: 0
                },
                _$srcOriginEnd$_: {
                    offset: 24,
                    size: SIZEOF_VEC2_F32,
                    end: 0
                },
                _$layoutRect$_: {
                    offset: 32,
                    size: SIZEOF_VEC4_F32,
                    end: 0
                },
                _$layoutStart$_: {
                    offset: 32,
                    size: SIZEOF_VEC2_F32,
                    end: 0
                },
                _$layoutEnd$_: {
                    offset: 40,
                    size: SIZEOF_VEC2_F32,
                    end: 0
                },
                _$destRect$_: {
                    offset: 48,
                    size: SIZEOF_VEC4_F32,
                    end: 0
                },
                _$destStart$_: {
                    offset: 48,
                    size: SIZEOF_VEC2_F32,
                    end: 0
                },
                _$destEnd$_: {
                    offset: 56,
                    size: SIZEOF_VEC2_F32,
                    end: 0
                },
                devicePixelRatio: {
                    offset: 64,
                    size: SIZEOF_F32,
                    end: 0
                },
                _$layerScale$_: {
                    offset: 68,
                    size: SIZEOF_F32,
                    end: 0
                },
                _$layerAngle$_: {
                    offset: 72,
                    size: SIZEOF_F32,
                    end: 0
                },
                _$seconds$_: {
                    offset: 76,
                    size: SIZEOF_F32,
                    end: 0
                },
                _$zNear$_: {
                    offset: 80,
                    size: SIZEOF_F32,
                    end: 0
                },
                _$zFar$_: {
                    offset: 84,
                    size: SIZEOF_F32,
                    end: 0
                },
                _$isSrcTexRotated$_: {
                    offset: 88,
                    size: SIZEOF_U32,
                    end: 0
                }
            }, c3ParamsSize = (UpdateLayoutEndValues2(c3ParamsLayout), c3ParamsLayout._$isSrcTexRotated$_.end), fragmentInputStructDeclaration = `
struct FragmentInput {
	@location(0) fragUV : vec2<f32>,
	@location(1) fragColor : vec4<f32>,
	@builtin(position) fragPos : vec4<f32>
};

fn c3_getBackUV(fragPos : vec2<f32>, texBack : texture_2d<f32>) -> vec2<f32>
{
	return fragPos / vec2<f32>(textureDimensions(texBack));
}

fn c3_getDepthUV(fragPos : vec2<f32>, texDepth : texture_depth_2d) -> vec2<f32>
{
	return fragPos / vec2<f32>(textureDimensions(texDepth));
}
`, fragmentOutputStructDeclaration = `
struct FragmentOutput {
	@location(0) color : vec4<f32>
};
`, shaderCustomParamSizes = new Map([ [ "float", 4 ], [ "percent", 4 ], [ "color", 12 ] ]), shaderCustomParamAlignSizes = new Map([ [ "float", 4 ], [ "percent", 4 ], [ "color", 16 ] ]), c3WGSLUtilityFunctionsLib = `
fn c3_premultiply(c : vec4<f32>) -> vec4<f32>
{
	return vec4<f32>(c.rgb * c.a, c.a);
}

fn c3_unpremultiply(c : vec4<f32>) -> vec4<f32>
{
	if (c.a == 0.0)
	{
		return vec4<f32>(0.0);
	}
	
	return vec4<f32>(c.rgb / c.a, c.a);
}

fn c3_grayscale(rgb : vec3<f32>) -> f32
{
	return dot(rgb, vec3<f32>(0.299, 0.587, 0.114));
}

fn c3_getPixelSize(t : texture_2d<f32>) -> vec2<f32>
{
	return vec2<f32>(1.0) / vec2<f32>(textureDimensions(t));
}

fn c3_clamp2(v : vec2<f32>, l : f32, u : f32) -> vec2<f32>
{
	return clamp(v, vec2<f32>(l), vec2<f32>(u));
}

fn c3_mod(x : f32, y : f32) -> f32
{
	return x - y * floor(x / y);
}

fn c3_mod2(x : vec2<f32>, y : vec2<f32>) -> vec2<f32>
{
	return x - y * floor(x / y);
}

fn c3_RGBtoHSL(color : vec3<f32>) -> vec3<f32>
{
	var hsl : vec3<f32> = vec3<f32>(0.0);
	
	var fmin : f32 = min(min(color.r, color.g), color.b);
	var fmax : f32 = max(max(color.r, color.g), color.b);
	var delta : f32 = fmax - fmin;

	hsl.z = (fmax + fmin) / 2.0;

	if (delta == 0.0)
	{
		hsl.x = 0.0;
		hsl.y = 0.0;
	}
	else 
	{
		if (hsl.z < 0.5)
		{
			hsl.y = delta / (fmax + fmin);
		}
		else
		{
			hsl.y = delta / (2.0 - fmax - fmin);
		}
		
		var dR : f32 = (((fmax - color.r) / 6.0) + (delta / 2.0)) / delta;
		var dG : f32 = (((fmax - color.g) / 6.0) + (delta / 2.0)) / delta;
		var dB : f32 = (((fmax - color.b) / 6.0) + (delta / 2.0)) / delta;

		if (color.r == fmax)
		{
			hsl.x = dB - dG;
		}
		else if (color.g == fmax)
		{
			hsl.x = (1.0 / 3.0) + dR - dB;
		}
		else if (color.b == fmax)
		{
			hsl.x = (2.0 / 3.0) + dG - dR;
		}

		if (hsl.x < 0.0)
		{
			hsl.x = hsl.x + 1.0;
		}
		else if (hsl.x > 1.0)
		{
			hsl.x = hsl.x - 1.0;
		}
	}

	return hsl;
}

fn c3_hueToRGB(f1 : f32, f2 : f32, hue_ : f32) -> f32
{
	var hue : f32 = hue_;
	if (hue < 0.0)
	{
		hue = hue + 1.0;
	}
	else if (hue > 1.0)
	{
		hue = hue - 1.0;
	}
		
	var ret : f32;
	
	if ((6.0 * hue) < 1.0)
	{
		ret = f1 + (f2 - f1) * 6.0 * hue;
	}
	else if ((2.0 * hue) < 1.0)
	{
		ret = f2;
	}
	else if ((3.0 * hue) < 2.0)
	{
		ret = f1 + (f2 - f1) * ((2.0 / 3.0) - hue) * 6.0;
	}
	else
	{
		ret = f1;
	}
	
	return ret;
}

fn c3_HSLtoRGB(hsl : vec3<f32>) -> vec3<f32>
{
	var rgb : vec3<f32> = vec3<f32>(hsl.z);
	
	if (hsl.y != 0.0)
	{
		var f2 : f32;
		
		if (hsl.z < 0.5)
		{
			f2 = hsl.z * (1.0 + hsl.y);
		}
		else
		{
			f2 = (hsl.z + hsl.y) - (hsl.y * hsl.z);
		}
			
		var f1 : f32 = 2.0 * hsl.z - f2;
		
		rgb.r = c3_hueToRGB(f1, f2, hsl.x + (1.0 / 3.0));
		rgb.g = c3_hueToRGB(f1, f2, hsl.x);
		rgb.b = c3_hueToRGB(f1, f2, hsl.x - (1.0 / 3.0));
	}
	
	return rgb;
}
`;
            C33._$Gfx$_._$WebGPUShaderProgram$_ = class extends C33._$Gfx$_._$ShaderProgramBase$_ {
                constructor(t, e) {
                    if (super(t, e), this._$_fragmentModule$_ = e._$fragmentModule$_, 
                    this._$_fragmentModuleFragDepth$_ = e._$fragmentModuleFragDepth$_, 
                    this._$_vertexModule$_ = e._$vertexModule$_, this._$_normVertexModule$_ = e._$normVertexModule$_, 
                    this._$_renderPipelines$_ = makeNullFilledArray2(55), this._$_multisampleRenderPipelines$_ = new Map(), 
                    this._$_mipmapPipelineCache$_ = new Map(), this._$_usesAnyC3ParamRect$_ = !1, 
                    this._$_usesIsSrcTexRotated$_ = !1, this._$_parameters$_ = [], 
                    this._$_customParamsByteSize$_ = 0, e.parameters) {
                        let t = 0;
                        for (const s of e.parameters) {
                            const i = s[2];
                            if (!shaderCustomParamSizes.has(i)) throw new Error(`unrecognized effect param type '${i}'`);
                            const r = shaderCustomParamSizes.get(i), n = shaderCustomParamAlignSizes.get(i), h = t % n;
                            0 != h && (t += n - h), this._$_parameters$_.push({
                                type: i,
                                offset: t,
                                size: r,
                                end: t + r
                            }), t += r;
                        }
                        this._$_customParamsByteSize$_ = 16 * Math.ceil(t / 16);
                    }
                }
                static async _$Create$_(s, t) {
                    let e = s._$_GetDevice$_(), i = t.name, r = s._$SupportsF16$_(), n = t.src, h = C33._$Gfx$_._$WebGPUShaderProgram$_._$_PreprocessFragmentShaderCode$_(n, r), o = e.createShaderModule({
                        label: i,
                        code: h
                    }), a = null;
                    if (t._$srcFragDepth$_) {
                        const p = C33._$Gfx$_._$WebGPUShaderProgram$_._$_PreprocessFragmentShaderCode$_(t._$srcFragDepth$_, r);
                        a = e.createShaderModule({
                            label: i,
                            code: p
                        });
                    }
                    o.getCompilationInfo().then(t => C33._$Gfx$_._$WebGPUShaderProgram$_._$ReportShaderCompilationInfo$_(i, "fragment", t));
                    let l, u = C33._$Gfx$_._$WebGPUShaderProgram$_._$_PreprocessVertexShaderCode$_(t._$vertexSrc$_, r);
                    u ? (l = e.createShaderModule({
                        label: i,
                        code: u
                    })).getCompilationInfo().then(t => C33._$Gfx$_._$WebGPUShaderProgram$_._$ReportShaderCompilationInfo$_(i, "vertex", t)) : l = s._$_GetDefaultVertexModule$_();
                    let c, f = C33._$Gfx$_._$WebGPUShaderProgram$_._$_PreprocessVertexShaderCode$_(t._$normVertexSrc$_, r), d = (f ? (c = e.createShaderModule({
                        label: i,
                        code: f
                    })).getCompilationInfo().then(t => C33._$Gfx$_._$WebGPUShaderProgram$_._$ReportShaderCompilationInfo$_(i, "vertex (norm)", t)) : c = s._$_GetNormalizedVertexModule$_(), 
                    C33._$New$_(C33._$Gfx$_._$WebGPUShaderProgram$_, s, Object.assign({
                        _$fragmentModule$_: o,
                        _$fragmentModuleFragDepth$_: a,
                        _$vertexModule$_: l,
                        _$normVertexModule$_: c
                    }, t)));
                    if (d._$_usesAnySrcRectOrPixelSize$_ = n.includes("%%C3PARAMS_STRUCT%%") && C3PARAMS_TERMS_REFERENCING_SRC_RECTS.some(t => n.includes(t)), 
                    d._$_usesAnyC3ParamRect$_ = d._$_usesAnySrcRectOrPixelSize$_ || n.includes("%%C3PARAMS_STRUCT%%") && C3PARAMS_TERMS_REFERENCING_OTHER_RECTS.some(t => n.includes(t)), 
                    d._$_usesIsSrcTexRotated$_ = n.includes("%%C3PARAMS_STRUCT%%") && n.includes("isSrcTexRotated"), 
                    "<generate-mipmap>" !== i) {
                        let t = d._$_CreateRenderPipelineAsync$_(0, 0, 0), e = null;
                        s._$UsesDepthBuffer$_() && (e = d._$_CreateRenderPipelineAsync$_(0, 1, 0));
                        const [ m, C ] = await Promise.all([ t, e ]);
                        d._$_renderPipelines$_[0] = m, C && (d._$_renderPipelines$_[1] = C);
                    }
                    return d;
                }
                static _$_PreprocessShaderCode$_(t, e) {
                    if (!t) return t;
                    return (e ? `enable f16;
alias f16or32 = f16;
` : "alias f16or32 = f32;\n") + t;
                }
                static _$_PreprocessFragmentShaderCode$_(t, e) {
                    return t = C33._$Gfx$_._$WebGPUShaderProgram$_._$_PreprocessShaderCode$_(t, e), 
                    C33._$StringSubstituteMap$_(t, {
                        "%%SAMPLERFRONT_BINDING%%": "@binding(0) @group(1)",
                        "%%TEXTUREFRONT_BINDING%%": "@binding(1) @group(1)",
                        "%%SAMPLERBACK_BINDING%%": "@binding(0) @group(2)",
                        "%%TEXTUREBACK_BINDING%%": "@binding(1) @group(2)",
                        "%%SAMPLERDEPTH_BINDING%%": "@binding(0) @group(3)",
                        "%%TEXTUREDEPTH_BINDING%%": "@binding(1) @group(3)",
                        "%%SHADERPARAMS_BINDING%%": "@binding(5) @group(0)",
                        "%%FRAGMENTINPUT_STRUCT%%": fragmentInputStructDeclaration,
                        "%%FRAGMENTOUTPUT_STRUCT%%": fragmentOutputStructDeclaration,
                        "%%C3PARAMS_STRUCT%%": c3ParamsUniformBufferDeclaration,
                        "%%C3_UTILITY_FUNCTIONS%%": c3WGSLUtilityFunctionsLib
                    });
                }
                static _$_PreprocessVertexShaderCode$_(t, e) {
                    return C33._$Gfx$_._$WebGPUShaderProgram$_._$_PreprocessShaderCode$_(t, e);
                }
                static _$ReportShaderCompilationInfo$_(t, e, s) {
                    for (const i of s.messages) {
                        const r = `[WebGPU] Message (${i.type}) compiling ${e} shader '${t}': ${i.message} (line ${i.lineNum}, pos ${i.linePos})`;
                        "error" === i.type ? console.error(r) : "warning" === i.type ? console.warn(r) : console.log(r);
                    }
                }
                _$Release$_() {
                    this._$_fragmentModule$_ = null, this._$_fragmentModuleFragDepth$_ = null, 
                    this._$_vertexModule$_ = null, this._$_normVertexModule$_ = null;
                    for (let t = 0, e = this._$_renderPipelines$_.length; t < e; ++t) this._$_renderPipelines$_[t] = null;
                    this._$_multisampleRenderPipelines$_.clear(), this._$_mipmapPipelineCache$_.clear(), 
                    super._$Release$_();
                }
                _$_GetDevice$_() {
                    return this._$_renderer$_._$_GetDevice$_();
                }
                _$_GetPipelineLayout$_() {
                    return this._$_renderer$_._$_GetPipelineLayout$_();
                }
                _$GetRenderer$_() {
                    return this._$_renderer$_;
                }
                _$UsesAnyC3ParamRect$_() {
                    return this._$_usesAnyC3ParamRect$_;
                }
                _$UsesIsSrcTexRotated$_() {
                    return this._$_usesIsSrcTexRotated$_;
                }
                _$GetParameterCount$_() {
                    return this._$_parameters$_.length;
                }
                _$GetParameterType$_(t) {
                    return t < 0 || t >= this._$_parameters$_.length ? null : this._$_parameters$_[t].type;
                }
                _$GetCustomParametersByteSize$_() {
                    return this._$_customParamsByteSize$_;
                }
                _$_GetCustomParameterInfo$_(t) {
                    return this._$_parameters$_[t];
                }
                _$_GetRenderPipelineDescriptor$_(t, e, s) {
                    const [ i, r ] = this._$_renderer$_._$_GetBlendByIndex$_(t), n = {
                        label: this._$GetName$_() + ` blendMode ${t} variant ${e} multisampleCount ` + s,
                        layout: this._$_GetPipelineLayout$_(),
                        vertex: {
                            module: 4 === e ? this._$_normVertexModule$_ : this._$_vertexModule$_,
                            entryPoint: "main",
                            buffers: [ {
                                arrayStride: 3 * SIZEOF_F32,
                                attributes: [ {
                                    shaderLocation: 0,
                                    offset: 0,
                                    format: "float32x3"
                                } ]
                            }, {
                                arrayStride: 3 * SIZEOF_F32,
                                attributes: [ {
                                    shaderLocation: 1,
                                    offset: 0,
                                    format: "float32x3"
                                } ]
                            } ]
                        },
                        fragment: {
                            module: this._$_fragmentModule$_,
                            entryPoint: "main",
                            targets: [ {
                                format: this._$_renderer$_._$GetSwapChainFormat$_(),
                                blend: {
                                    color: {
                                        srcFactor: i,
                                        dstFactor: r
                                    },
                                    alpha: {
                                        srcFactor: i,
                                        dstFactor: r
                                    }
                                }
                            } ]
                        }
                    };
                    if (2 <= s && (n.multisample = {
                        count: s
                    }), 1 === e) n.fragment.module = this._$_fragmentModuleFragDepth$_ || this._$_fragmentModule$_, 
                    n.depthStencil = {
                        format: this._$_renderer$_._$_GetDepthBufferFormat$_(),
                        depthWriteEnabled: !0,
                        depthCompare: "less-equal"
                    }; else if (2 === e) {
                        n.fragment.module = this._$_fragmentModuleFragDepth$_ || this._$_fragmentModule$_, 
                        n.fragment.targets = [];
                        const h = {
                            compare: "always",
                            failOp: "keep",
                            depthFailOp: "keep",
                            passOp: "replace"
                        };
                        n.depthStencil = {
                            format: this._$_renderer$_._$_GetDepthBufferFormat$_(),
                            depthWriteEnabled: !0,
                            depthCompare: "less-equal",
                            stencilFront: h,
                            stencilBack: h,
                            stencilReadMask: 1,
                            stencilWriteMask: 1
                        };
                    } else if (3 === e) {
                        n.fragment.module = this._$_fragmentModuleFragDepth$_ || this._$_fragmentModule$_;
                        const o = {
                            compare: "equal",
                            failOp: "keep",
                            depthFailOp: "keep",
                            passOp: "keep"
                        };
                        n.depthStencil = {
                            format: this._$_renderer$_._$_GetDepthBufferFormat$_(),
                            depthWriteEnabled: !1,
                            depthCompare: "always",
                            stencilFront: o,
                            stencilBack: o,
                            stencilReadMask: 1,
                            stencilWriteMask: 0
                        };
                    }
                    return n;
                }
                _$_CreateRenderPipeline$_(t, e, s) {
                    return this._$_GetDevice$_().createRenderPipeline(this._$_GetRenderPipelineDescriptor$_(t, e, s));
                }
                _$_CreateRenderPipelineAsync$_(t, e, s) {
                    return this._$_GetDevice$_().createRenderPipelineAsync(this._$_GetRenderPipelineDescriptor$_(t, e, s));
                }
                _$GetRenderPipelineForState$_(s, i, r) {
                    const n = 5 * s + i;
                    if (r < 2) {
                        let t = this._$_renderPipelines$_[n];
                        return null === t && (t = this._$_CreateRenderPipeline$_(s, i, r), 
                        this._$_renderPipelines$_[n] = t), t;
                    }
                    {
                        let t = this._$_multisampleRenderPipelines$_.get(r), e = (Array.isArray(t) || (t = makeNullFilledArray2(55), 
                        this._$_multisampleRenderPipelines$_.set(r, t)), t[n]);
                        return null === e && (e = this._$_CreateRenderPipeline$_(s, i, r), 
                        t[n] = e), e;
                    }
                }
                static _$GetVertexUniformBufferLayout$_() {
                    return vubLayout;
                }
                static _$GetVertexUniformBufferSize$_() {
                    return 16 * Math.ceil(vubSize / 16);
                }
                static _$GetFragmentUniformBufferLayout$_() {
                    return fubLayout;
                }
                static _$GetFragmentUniformBufferSize$_() {
                    return 16 * Math.ceil(fubSize / 16);
                }
                static _$GetFragmentC3ParamsBufferLayout$_() {
                    return c3ParamsLayout;
                }
                static _$GetFragmentC3ParamsBufferSize$_() {
                    return 16 * Math.ceil(c3ParamsSize / 16);
                }
                static _$GetDefaultVertexShaderSource$_() {
                    return `
		${vertexUniformBufferDeclaration}

		struct ColorData {
			data : array<vec4<f32>>
		};
		@binding(2) @group(0) var<storage> colorBuffer : ColorData;

		struct VertexInput {
			@builtin(vertex_index) VertexIndex : u32,
			@location(0) position : vec3<f32>,
			@location(1) uv : vec3<f32>
		};

		struct VertexOutput {
			@builtin(position) Position : vec4<f32>,
			@location(0) fragUV : vec2<f32>,
			@location(1) fragColor : vec4<f32>
		};

		@vertex
		fn main(input : VertexInput) -> VertexOutput {
			var output : VertexOutput;
			output.Position = uniforms.transform * vec4<f32>(input.position, 1.0);
			output.fragUV = input.uv.xy;
			output.fragColor = colorBuffer.data[input.VertexIndex / u32(4)];
			return output;
		}`;
                }
                static _$GetNormalizedVertexShaderSource$_() {
                    return `
		struct ColorData {
			data : array<vec4<f32>>
		};
		@binding(2) @group(0) var<storage> colorBuffer : ColorData;

		struct VertexInput {
			@builtin(vertex_index) VertexIndex : u32,
			@location(0) position : vec3<f32>,
			@location(1) uv : vec3<f32>
		};

		struct VertexOutput {
			@builtin(position) Position : vec4<f32>,
			@location(0) fragUV : vec2<f32>,
			@location(1) fragColor : vec4<f32>
		};

		@vertex
		fn main(input : VertexInput) -> VertexOutput {
			var output : VertexOutput;
			var p = input.position;
			p.y = 1.0 - p.y;
			output.Position = vec4<f32>(p.xy * 2.0 - 1.0, p.z, 1.0);
			output.fragUV = input.uv.xy;
			output.fragColor = colorBuffer.data[input.VertexIndex / u32(4)];
			return output;
		}`;
                }
                static _$GetTextureFillVertexShaderSource$_() {
                    return `
		${vertexUniformBufferDeclaration}

		struct ColorData {
			data : array<vec4<f32>>
		};
		@binding(2) @group(0) var<storage> colorBuffer : ColorData;

		struct VertexInput {
			@builtin(vertex_index) VertexIndex : u32,
			@location(0) position : vec3<f32>,
			@location(1) uv : vec3<f32>
		};

		struct VertexOutput {
			@builtin(position) Position : vec4<f32>,
			@location(0) fragUV : vec3<f32>,
			@location(1) fragColor : vec4<f32>
		};

		@vertex
		fn main(input : VertexInput) -> VertexOutput {
			var output : VertexOutput;
			output.Position = uniforms.transform * vec4<f32>(input.position, 1.0);
			output.fragUV = input.uv;
			output.fragColor = colorBuffer.data[input.VertexIndex / u32(4)];
			return output;
		}`;
                }
                static _$GetNormalizedTextureFillVertexShaderSource$_() {
                    return `
		struct ColorData {
			data : array<vec4<f32>>
		};
		@binding(2) @group(0) var<storage> colorBuffer : ColorData;

		struct VertexInput {
			@builtin(vertex_index) VertexIndex : u32,
			@location(0) position : vec3<f32>,
			@location(1) uv : vec3<f32>
		};

		struct VertexOutput {
			@builtin(position) Position : vec4<f32>,
			@location(0) fragUV : vec3<f32>,
			@location(1) fragColor : vec4<f32>
		};

		@vertex
		fn main(input : VertexInput) -> VertexOutput {
			var output : VertexOutput;
			var p = input.position;
			p.y = 1.0 - p.y;
			output.Position = vec4<f32>(p.xy * 2.0 - 1.0, p.z, 1.0);
			output.fragUV = input.uv;
			output.fragColor = colorBuffer.data[input.VertexIndex / u32(4)];
			return output;
		}`;
                }
                static _$GetMultiTextureFillFragmentShaderSource$_(t) {
                    return `
		@binding(0) @group(1) var sampler0 : sampler;
		@binding(1) @group(1) var texture0 : texture_2d<f32>;
		@binding(2) @group(1) var sampler1 : sampler;
		@binding(3) @group(1) var texture1 : texture_2d<f32>;
		@binding(4) @group(1) var sampler2 : sampler;
		@binding(5) @group(1) var texture2 : texture_2d<f32>;
		@binding(6) @group(1) var sampler3 : sampler;
		@binding(7) @group(1) var texture3 : texture_2d<f32>;
		@binding(8) @group(1) var sampler4 : sampler;
		@binding(9) @group(1) var texture4 : texture_2d<f32>;
		@binding(10) @group(1) var sampler5 : sampler;
		@binding(11) @group(1) var texture5 : texture_2d<f32>;
		@binding(12) @group(1) var sampler6 : sampler;
		@binding(13) @group(1) var texture6 : texture_2d<f32>;
		@binding(14) @group(1) var sampler7 : sampler;
		@binding(15) @group(1) var texture7 : texture_2d<f32>;
		@binding(16) @group(1) var sampler8 : sampler;
		@binding(17) @group(1) var texture8 : texture_2d<f32>;
		@binding(18) @group(1) var sampler9 : sampler;
		@binding(19) @group(1) var texture9 : texture_2d<f32>;
		@binding(20) @group(1) var sampler10 : sampler;
		@binding(21) @group(1) var texture10 : texture_2d<f32>;
		@binding(22) @group(1) var sampler11 : sampler;
		@binding(23) @group(1) var texture11 : texture_2d<f32>;
		@binding(24) @group(1) var sampler12 : sampler;
		@binding(25) @group(1) var texture12 : texture_2d<f32>;
		@binding(26) @group(1) var sampler13 : sampler;
		@binding(27) @group(1) var texture13 : texture_2d<f32>;

		struct FragmentInput {
			@location(0) fragUV : vec3<f32>,
			@location(1) fragColor : vec4<f32>,
			${t ? "@builtin(position) fragPos: vec4<f32>" : ""}
		};

		struct FragmentOutput {
			@location(0) color : vec4<f32>,
			${t ? "@builtin(frag_depth) fragDepth: f32" : ""} 
		};

		@fragment
		fn main(input : FragmentInput) -> FragmentOutput {
			var output : FragmentOutput;
			var texXy : vec2<f32> = input.fragUV.xy;
			var texIndex : f32 = input.fragUV.z;
			var c : vec4<f32>;

			let dx = dpdx(texXy);
			let dy = dpdy(texXy);
			
			if (texIndex < 6.5)
			{
				if (texIndex < 2.5)
				{
					if (texIndex < 0.5)			{	c = textureSampleGrad(texture0, sampler0, texXy, dx, dy);	}
					else
					{
						if (texIndex < 1.5)		{	c = textureSampleGrad(texture1, sampler1, texXy, dx, dy);	}
						else					{	c = textureSampleGrad(texture2, sampler2, texXy, dx, dy);	}
					}						
				}
				else
				{
					if (texIndex < 4.5)
					{
						if (texIndex < 3.5)		{	c = textureSampleGrad(texture3, sampler3, texXy, dx, dy);	}
						else					{	c = textureSampleGrad(texture4, sampler4, texXy, dx, dy);	}
					}
					else
					{
						if (texIndex < 5.5)		{	c = textureSampleGrad(texture5, sampler5, texXy, dx, dy);	}
						else					{	c = textureSampleGrad(texture6, sampler6, texXy, dx, dy);	}
					}
				}
			}
			else
			{
				if (texIndex < 9.5)
				{
					if (texIndex < 7.5)			{	c = textureSampleGrad(texture7, sampler7, texXy, dx, dy);	}
					else
					{
						if (texIndex < 8.5)		{	c = textureSampleGrad(texture8, sampler8, texXy, dx, dy);	}
						else					{	c = textureSampleGrad(texture9, sampler9, texXy, dx, dy);	}
					}						
				}
				else
				{
					if (texIndex < 11.5)
					{
						if (texIndex < 10.5)	{	c = textureSampleGrad(texture10, sampler10, texXy, dx, dy);	}
						else					{	c = textureSampleGrad(texture11, sampler11, texXy, dx, dy);	}
					}
					else
					{
						if (texIndex < 12.5)	{	c = textureSampleGrad(texture12, sampler12, texXy, dx, dy);	}
						else					{	c = textureSampleGrad(texture13, sampler13, texXy, dx, dy);	}
					}
				}
			}

			output.color = c * input.fragColor;
			${t ? "output.fragDepth = select(input.fragPos.z, 1.0, output.color.a == 0.0);" : ""}
			return output;
		}`;
                }
                static _$GetSingleTextureFillFragmentShaderSource$_(t) {
                    return `
		@binding(0) @group(1) var sampler0 : sampler;
		@binding(1) @group(1) var texture0 : texture_2d<f32>;

		struct FragmentInput {
			@location(0) fragUV : vec3<f32>,
			@location(1) fragColor : vec4<f32>,
			${t ? "@builtin(position) fragPos: vec4<f32>" : ""}
		};

		struct FragmentOutput {
			@location(0) color : vec4<f32>,
			${t ? "@builtin(frag_depth) fragDepth: f32" : ""} 
		};

		@fragment
		fn main(input : FragmentInput) -> FragmentOutput {
			var output : FragmentOutput;
			output.color = textureSample(texture0, sampler0, input.fragUV.xy) * input.fragColor;
			${t ? "output.fragDepth = select(input.fragPos.z, 1.0, output.color.a == 0.0);" : ""}
			return output;
		}`;
                }
                static _$_GetMipmapGeneratorVertexSource$_() {
                    return `
		struct VertexInput {
			@builtin(vertex_index) VertexIndex : u32
		};
		
		struct VertexOutput {
			@builtin(position) Position : vec4<f32>,
			@location(0) fragUV : vec2<f32>
		};

		@vertex
		fn main(input : VertexInput) -> VertexOutput {

			var pos : array<vec2<f32>, 4> = array<vec2<f32>, 4>(
				vec2<f32>(-1.0, 1.0),
				vec2<f32>(1.0, 1.0),
				vec2<f32>(-1.0, -1.0),
				vec2<f32>(1.0, -1.0));
			
			var output : VertexOutput;
			var p : vec2<f32> = pos[input.VertexIndex];
			output.Position = vec4<f32>(p, 0.0, 1.0);
			output.fragUV = p / 2.0 + 0.5;
			return output;
		}`;
                }
                static _$_GetMipmapGeneratorFragmentSource$_() {
                    return `
		@binding(0) @group(0) var sampler0 : sampler;
		@binding(1) @group(0) var texture0 : texture_2d<f32>;

		struct FragmentInput {
			@location(0) fragUV : vec2<f32>
		};

		struct FragmentOutput {
			@location(0) color : vec4<f32>
		};

		@fragment
		fn main(input : FragmentInput) -> FragmentOutput {
			var output : FragmentOutput;
			output.color = textureSample(texture0, sampler0, vec2<f32>(input.fragUV.x, 1.0 - input.fragUV.y));
			return output;
		}`;
                }
                _$_GetMipmapGeneratorPipeline$_(t) {
                    t = t || this._$_renderer$_._$GetTextureFormat$_();
                    let e = this._$_mipmapPipelineCache$_.get(t);
                    return e || (e = this._$_GetDevice$_().createRenderPipeline({
                        label: "<mipmap generator>",
                        layout: "auto",
                        vertex: {
                            module: this._$_vertexModule$_,
                            entryPoint: "main"
                        },
                        primitive: {
                            topology: "triangle-strip",
                            stripIndexFormat: "uint16"
                        },
                        fragment: {
                            module: this._$_fragmentModule$_,
                            entryPoint: "main",
                            targets: [ {
                                format: t,
                                blend: {
                                    color: {
                                        srcFactor: "one",
                                        dstFactor: "zero"
                                    },
                                    alpha: {
                                        srcFactor: "one",
                                        dstFactor: "zero"
                                    }
                                }
                            } ]
                        }
                    }), this._$_mipmapPipelineCache$_.set(t, e)), e;
                }
                static _$_GetPointVertexSource$_() {
                    return `
		${vertexUniformBufferDeclaration}

		struct PointData {
			data : array<vec4<f32>>
		};
		@binding(3) @group(0) var<storage> pointBuffer : PointData;

		struct VertexInput {
			@builtin(vertex_index) VertexIndex : u32
		};

		struct VertexOutput {
			@builtin(position) Position : vec4<f32>,
			@location(0) fragUV : vec2<f32>,
			@location(1) pointOpacity : f32
		};

		@vertex
		fn main(input : VertexInput) -> VertexOutput {

			var normPos : array<vec2<f32>, 4> = array<vec2<f32>, 4>(
				vec2<f32>(-0.5, -0.5),
				vec2<f32>(0.5, -0.5),
				vec2<f32>(0.5, 0.5),
				vec2<f32>(-0.5, 0.5));
			
			var output : VertexOutput;
			var p : vec2<f32> = normPos[input.VertexIndex % u32(4)];
			var pointData : vec4<f32> = pointBuffer.data[input.VertexIndex / u32(4)];

			var size : f32 = pointData.z;
			output.Position = uniforms.transform * vec4<f32>(p * size + pointData.xy, uniforms.zElevation, 1.0);
			output.pointOpacity = pointData.w;

			var pointTexMin : vec2<f32> = min(uniforms.pointTexStart, uniforms.pointTexEnd);
			var pointTexMax : vec2<f32> = max(uniforms.pointTexStart, uniforms.pointTexEnd);
			var pn : vec2<f32> = p + vec2<f32>(0.5, 0.5);
			var pointCoord : vec2<f32> = select(vec2<f32>(1.0 - pn.y, pn.x), pn, uniforms.pointTexEnd.x > uniforms.pointTexStart.x);

			output.fragUV = mix(pointTexMin, pointTexMax, pointCoord);
			return output;
		}`;
                }
                static _$_GetPointFragmentSource$_(t) {
                    return `
		${fragmentUniformBufferDeclaration}

		%%SAMPLERFRONT_BINDING%% var sampler0 : sampler;
		%%TEXTUREFRONT_BINDING%% var texture0 : texture_2d<f32>;

		struct FragmentInput {
			@location(0) fragUV : vec2<f32>,
			@location(1) pointOpacity : f32,
			@builtin(position) fragPos : vec4<f32>
		};
		
		struct FragmentOutput {
			@location(0) color : vec4<f32>,
			${t ? "@builtin(frag_depth) fragDepth: f32" : ""} 
		};

		@fragment
		fn main(input : FragmentInput) -> FragmentOutput {
			var output : FragmentOutput;
			output.color = textureSample(texture0, sampler0, input.fragUV) * uniforms.pointColor * input.pointOpacity;
			${t ? "output.fragDepth = select(input.fragPos.z, 1.0, output.color.a == 0.0);" : ""}
			return output;
		}`;
                }
                static _$_GetTilemapFragmentShaderSource$_(t) {
                    return `
		${fragmentUniformBufferDeclaration}

		%%SAMPLERFRONT_BINDING%% var sampler0 : sampler;
		%%TEXTUREFRONT_BINDING%% var texture0 : texture_2d<f32>;

		%%FRAGMENTINPUT_STRUCT%%
		
		struct FragmentOutput {
			@location(0) color : vec4<f32>,
			${t ? "@builtin(frag_depth) fragDepth: f32" : ""} 
		};

		@fragment
		fn main(input : FragmentInput) -> FragmentOutput {
			var output : FragmentOutput;
			var halfPixelSize : vec2<f32> = vec2<f32>(0.5, 0.5) / vec2<f32>(textureDimensions(texture0));

			var tile : vec2<f32> = floor(input.fragUV);
			var tex : vec2<f32> = fract(input.fragUV);
			var tileOrigin : vec2<f32> = uniforms.srcRectStart + tile * (uniforms.tileSize + uniforms.tileSpacing);
			var lowerBound : vec2<f32> = tileOrigin + halfPixelSize;
			var upperBound : vec2<f32> = tileOrigin + uniforms.tileSize - halfPixelSize;

			output.color = textureSampleLevel(texture0, sampler0, clamp(tex, lowerBound, upperBound), 0.0) * input.fragColor;
			${t ? "output.fragDepth = select(input.fragPos.z, 1.0, output.color.a == 0.0);" : ""}
			return output;
		}`;
                }
                static _$GetTileRandomizationFragmentShaderSource$_(t) {
                    return `
${fragmentUniformBufferDeclaration}

%%SAMPLERFRONT_BINDING%% var sampler0 : sampler;
%%TEXTUREFRONT_BINDING%% var texture0 : texture_2d<f32>;

%%FRAGMENTINPUT_STRUCT%%

struct FragmentOutput {
	@location(0) color : vec4<f32>,
	${t ? "@builtin(frag_depth) fragDepth: f32" : ""} 
};

%%C3_UTILITY_FUNCTIONS%%

const PI : f32 = 3.1415926;

fn cospVec4(a : vec4<f32>, b : vec4<f32>, x : f32) -> vec4<f32>
{
	return (a + b + (a - b) * cos(x * PI)) / 2.0;
}

fn randVec3(seed : vec2<f32>) -> vec3<f32>
{
	return vec3<f32>(
		fract(sin(dot(seed.xy, vec2<f32>(12.9898,78.233))) * 43758.5453),
		fract(sin(dot(seed.yx, vec2<f32>(12.9898,-78.233))) * 43758.5453),
		fract(sin(dot(seed.xy, vec2<f32>(-12.9898,-78.233))) * 43758.5453));
}

fn sampleTile(tile : vec2<f32>, uv : vec2<f32>, ddx : vec2<f32>, ddy : vec2<f32>) -> vec4<f32>
{
	var posRandom = uniforms.tileSize;
	var angleRandom = uniforms.outlineThickness;
	var pixelSize = c3_getPixelSize(texture0);
	
	var rand = (randVec3(round(tile)) - 0.5) * 2.0;
	
	var angle = angleRandom * rand.z * PI;
	var sin_a = sin(angle);
	var cos_a = cos(angle);
	var aspect = pixelSize.x / pixelSize.y;

	var mid = tile + vec2<f32>(0.5, 0.5);
	var dp = uv - mid;
	dp.x /= aspect;
	var r = vec2<f32>(dp.x * cos_a - dp.y * sin_a,
					  dp.y * cos_a + dp.x * sin_a);
	r.x *= aspect;

	var p = mid + r + (posRandom * rand.xy / 2.0);
	
	return textureSampleGrad(texture0, sampler0, p, ddx, ddy);
}

@fragment
fn main(input : FragmentInput) -> FragmentOutput
{
	var output : FragmentOutput;
	
	var blendMarginX = uniforms.tileSpacing.x;
	var blendMarginY = uniforms.tileSpacing.y;
	
	var tile = floor(input.fragUV);
	var tex = fract(input.fragUV);
	var ddx = dpdx(input.fragUV);
	var ddy = dpdy(input.fragUV);
	
	var curTile = sampleTile(tile, input.fragUV, ddx, ddy);
	
	var inLeftMargin = (tex.x < blendMarginX);
	var inRightMargin = (tex.x > 1.0 - blendMarginX);
	var inTopMargin = (tex.y < blendMarginY);
	var inBottomMargin = (tex.y > 1.0 - blendMarginY);
	
	if (inLeftMargin)
	{
		var leftTile = sampleTile(tile + vec2<f32>(-1.0, 0.0), input.fragUV, ddx, ddy);
		var leftMix = (tex.x / (blendMarginX * 2.0)) + 0.5;
		var leftMixedTile = cospVec4(leftTile, curTile, leftMix);
		
		if (inTopMargin)
		{
			var topTile =     sampleTile(tile + vec2<f32>(0.0,  -1.0), input.fragUV, ddx, ddy);
			var topLeftTile = sampleTile(tile + vec2<f32>(-1.0, -1.0), input.fragUV, ddx, ddy);
			var topLeftMixedTile = cospVec4(topLeftTile, topTile, leftMix);
			
			output.color = cospVec4(topLeftMixedTile, leftMixedTile, (tex.y / (blendMarginY * 2.0)) + 0.5);
		}
		else if (inBottomMargin)
		{
			var bottomTile =     sampleTile(tile + vec2<f32>(0.0,  1.0), input.fragUV, ddx, ddy);
			var bottomLeftTile = sampleTile(tile + vec2<f32>(-1.0, 1.0), input.fragUV, ddx, ddy);
			var bottomLeftMixedTile = cospVec4(bottomLeftTile, bottomTile, leftMix);
			
			output.color = cospVec4(leftMixedTile, bottomLeftMixedTile, (tex.y - (1.0 - blendMarginY)) / (blendMarginY * 2.0));
		}
		else
		{
			output.color = leftMixedTile;
		}
	}
	else if (inRightMargin)
	{
		var rightTile = sampleTile(tile + vec2(1.0, 0.0), input.fragUV, ddx, ddy);
		var rightMix = (tex.x - (1.0 - blendMarginX)) / (blendMarginX * 2.0);
		var rightMixedTile = cospVec4(curTile, rightTile, rightMix);
		
		if (inTopMargin)
		{
			var topTile =      sampleTile(tile + vec2<f32>(0.0, -1.0), input.fragUV, ddx, ddy);
			var topRightTile = sampleTile(tile + vec2<f32>(1.0, -1.0), input.fragUV, ddx, ddy);
			var topRightMixedTile = cospVec4(topTile, topRightTile, rightMix);
			
			output.color = cospVec4(topRightMixedTile, rightMixedTile, (tex.y / (blendMarginY * 2.0)) + 0.5);
		}
		else if (inBottomMargin)
		{
			var bottomTile =      sampleTile(tile + vec2<f32>(0.0, 1.0), input.fragUV, ddx, ddy);
			var bottomRightTile = sampleTile(tile + vec2<f32>(1.0, 1.0), input.fragUV, ddx, ddy);
			var bottomRightMixedTile = cospVec4(bottomTile, bottomRightTile, rightMix);
			
			output.color = cospVec4(rightMixedTile, bottomRightMixedTile, (tex.y - (1.0 - blendMarginY)) / (blendMarginY * 2.0));
		}
		else
		{
			output.color = rightMixedTile;
		}
	}
	else if (inTopMargin)
	{
		var topTile = sampleTile(tile + vec2<f32>(0.0, -1.0), input.fragUV, ddx, ddy);
		output.color = cospVec4(topTile, curTile, (tex.y / (blendMarginY * 2.0)) + 0.5);
	}
	else if (inBottomMargin)
	{
		var bottomTile = sampleTile(tile + vec2<f32>(0.0, 1.0), input.fragUV, ddx, ddy);
		output.color = cospVec4(curTile, bottomTile, (tex.y - (1.0 - blendMarginY)) / (blendMarginY * 2.0));
	}
	else
	{
		output.color = curTile;
	}
	
	output.color *= input.fragColor;
	${t ? "output.fragDepth = select(input.fragPos.z, 1.0, output.color.a == 0.0);" : ""}
	return output;
}
`;
                }
                static _$_GetColorFillFragmentShaderSource$_() {
                    return `
		%%FRAGMENTINPUT_STRUCT%%
		%%FRAGMENTOUTPUT_STRUCT%%

		@fragment
		fn main(input : FragmentInput) -> FragmentOutput {
			var output : FragmentOutput;
			output.color = input.fragColor;
			return output;
		}`;
                }
                static _$_GetLinearGradientFillFragmentShaderSource$_() {
                    return `
		${fragmentUniformBufferDeclaration}

		%%FRAGMENTINPUT_STRUCT%%
		%%FRAGMENTOUTPUT_STRUCT%%

		fn fromLinear(linearRGB : vec3<f32>) -> vec3<f32>
		{
			var cutoff : vec3<bool> = (linearRGB < vec3<f32>(0.0031308));
			var higher : vec3<f32> = vec3<f32>(1.055) * pow(abs(linearRGB), vec3<f32>(1.0/2.4)) - 0.055;
			var lower : vec3<f32> = linearRGB * 12.92;
			return select(higher, lower, cutoff);
		}

		fn toLinear(sRGB : vec3<f32>) -> vec3<f32>
		{
			var cutoff : vec3<bool> = (sRGB < vec3<f32>(0.04045));
			var higher : vec3<f32> = pow(abs((sRGB + 0.055) / 1.055), vec3<f32>(2.4));
			var lower : vec3<f32> = sRGB / 12.92;
			return select(higher, lower, cutoff);
		}

		@fragment
		fn main(input : FragmentInput) -> FragmentOutput {
			var output : FragmentOutput;
			var linearGrad : vec3<f32> = mix(toLinear(input.fragColor.rgb), toLinear(uniforms.color2.rgb), vec3<f32>(input.fragUV.x));

			var a : f32 = mix(input.fragColor.a, uniforms.color2.a, input.fragUV.x);
			output.color = vec4<f32>(fromLinear(linearGrad) * a, a);
			return output;
		}
		`;
                }
                static _$_GetPenumbraFillFragmentShaderSource$_() {
                    return `
		${fragmentUniformBufferDeclaration}

		%%FRAGMENTINPUT_STRUCT%%
		%%FRAGMENTOUTPUT_STRUCT%%

		@fragment
		fn main(input : FragmentInput) -> FragmentOutput {
			var output : FragmentOutput;
			var grad : f32 = input.fragUV.x / (1.0 - input.fragUV.y);
			output.color = input.fragColor * (1.0 - (cos(grad * 3.141592653589793) + 1.0) / 2.0);
			return output;
		}
		`;
                }
                static _$_GetHardEllipseFillFragmentShaderSource$_() {
                    return `
		%%FRAGMENTINPUT_STRUCT%%
		%%FRAGMENTOUTPUT_STRUCT%%

		@fragment
		fn main(input : FragmentInput) -> FragmentOutput {
			var output : FragmentOutput;
			var diff : vec2<f32> = input.fragUV - 0.5;
			var diffSq : vec2<f32> = diff * diff;

			var f : f32 = step(diffSq.x + diffSq.y, 0.25);

			output.color = input.fragColor * f;
			return output;
		}`;
                }
                static _$_GetHardEllipseOutlineFragmentShaderSource$_() {
                    return `
		${fragmentUniformBufferDeclaration}

		%%FRAGMENTINPUT_STRUCT%%
		%%FRAGMENTOUTPUT_STRUCT%%

		@fragment
		fn main(input : FragmentInput) -> FragmentOutput {
			var output : FragmentOutput;
			var diff : vec2<f32> = input.fragUV - 0.5;
			var diffSq : vec2<f32> = diff * diff;
			var distSq : f32 = diffSq.x + diffSq.y;
			var norm : vec2<f32> = normalize(diff);
			var halfNorm : vec2<f32> = norm * 0.5;

			var innerF : f32 = step(distSq, 0.25);

			var innerEdge : vec2<f32> = halfNorm - uniforms.pixelSize * norm * uniforms.outlineThickness;
			var innerEdgeSq : vec2<f32> = innerEdge * innerEdge;
			var outerF : f32 = step(innerEdgeSq.x + innerEdgeSq.y, distSq);
			
			output.color = input.fragColor * innerF * outerF;
			return output;
		}`;
                }
                static _$_GetSmoothEllipseFillFragmentShaderSource$_() {
                    return `
		${fragmentUniformBufferDeclaration}

		%%FRAGMENTINPUT_STRUCT%%
		%%FRAGMENTOUTPUT_STRUCT%%

		@fragment
		fn main(input : FragmentInput) -> FragmentOutput {
			var output : FragmentOutput;
			var diff : vec2<f32> = input.fragUV - 0.5;
			var diffSq : vec2<f32> = diff * diff;
			var norm : vec2<f32> = normalize(diff);
			var halfNorm : vec2<f32> = norm * 0.5;
			var halfNormSq : vec2<f32> = halfNorm * halfNorm;

			var innerEdge : vec2<f32> = halfNorm - uniforms.pixelSize * norm;
			var innerEdgeSq : vec2<f32> = innerEdge * innerEdge;

			var f : f32 = smoothstep(halfNormSq.x + halfNormSq.y, innerEdgeSq.x + innerEdgeSq.y, diffSq.x + diffSq.y);

			output.color = input.fragColor * f;
			return output;
		}`;
                }
                static _$_GetSmoothEllipseOutlineFragmentShaderSource$_() {
                    return `
		${fragmentUniformBufferDeclaration}

		%%FRAGMENTINPUT_STRUCT%%
		%%FRAGMENTOUTPUT_STRUCT%%

		@fragment
		fn main(input : FragmentInput) -> FragmentOutput {
			var output : FragmentOutput;
			var diff : vec2<f32> = input.fragUV - 0.5;
			var diffSq : vec2<f32> = diff * diff;
			var distSq : f32 = diffSq.x + diffSq.y;
			var norm : vec2<f32> = normalize(diff);
			var halfNorm : vec2<f32> = norm * 0.5;
			var halfNormSq : vec2<f32> = halfNorm * halfNorm;

			var pxNorm : vec2<f32> = uniforms.pixelSize * norm;
			var innerEdge1 : vec2<f32> = halfNorm - pxNorm;
			var innerEdge1Sq : vec2<f32> = innerEdge1 * innerEdge1;

			var innerF : f32 = smoothstep(halfNormSq.x + halfNormSq.y, innerEdge1Sq.x + innerEdge1Sq.y, distSq);

			var innerEdge2 : vec2<f32> = halfNorm - pxNorm * uniforms.outlineThickness;
			var innerEdge2Sq : vec2<f32> = innerEdge2 * innerEdge2;
			var innerEdge3 : vec2<f32> = halfNorm - pxNorm * (uniforms.outlineThickness + 1.0);
			var innerEdge3Sq : vec2<f32> = innerEdge3 * innerEdge3;

			var outerF : f32 = smoothstep(innerEdge3Sq.x + innerEdge3Sq.y, innerEdge2Sq.x + innerEdge2Sq.y, distSq);
			
			output.color = input.fragColor * innerF * outerF;
			return output;
		}`;
                }
                static _$_GetSmoothLineFillFragmentShaderSource$_() {
                    return `
		%%FRAGMENTINPUT_STRUCT%%
		%%FRAGMENTOUTPUT_STRUCT%%

		@fragment
		fn main(input : FragmentInput) -> FragmentOutput {
			var output : FragmentOutput;
			var f : f32 = 1.0 - abs(input.fragUV.y - 0.5) * 2.0;
			output.color = input.fragColor * f;
			return output;
		}`;
                }
            };
        }
        {
            const C33 = self._$C3$_, VALID_SAMPLINGS = new Set([ "nearest", "bilinear", "trilinear" ]), VALID_WRAP_MODES = new Set([ "clamp-to-edge", "repeat", "mirror-repeat" ]), GPUTextureUsage = self.GPUTextureUsage, DEFAULT_CREATE_OPTIONS = {
                _$wrapX$_: "clamp-to-edge",
                _$wrapY$_: "clamp-to-edge",
                _$sampling$_: "trilinear",
                _$anisotropy$_: 0,
                _$mipMap$_: !0,
                _$isRenderTarget$_: !1,
                _$isSampled$_: !1,
                _$canReadPixels$_: !1,
                _$canUpdate$_: !1,
                _$multisampling$_: 0,
                width: -1,
                height: -1
            }, TEXTURE_FORMAT_SIZE_DATA = [ [ 1, [ "r8unorm", "r8snorm", "r8uint", "r8sint", "stencil8" ] ], [ 2, [ "r16uint", "r16sint", "r16float", "rg8unorm", "rg8snorm", "rg8uint", "rg8sint", "depth16unorm" ] ], [ 3, [ "depth24plus" ] ], [ 4, [ "r32uint", "r32sint", "r32float", "rg16uint", "rg16sint", "rg16float", "rgba8unorm", "rgba8unorm-srgb", "rgba8snorm", "rgba8uint", "rgba8sint", "bgra8unorm", "bgra8unorm-srgb", "rgb9e5ufloat", "rgb10a2uint", "rgb10a2unorm", "rg11b10ufloat", "depth24plus-stencil8", "depth32float" ] ], [ 8, [ "rg32uint", "rg32sint", "rg32float", "rgba16uint", "rgba16sint", "rgba16float" ] ], [ 16, [ "rgba32uint", "rgba32sint", "rgba32float" ] ], [ 5, [ "depth32float-stencil8" ] ] ], TEXTURE_FORMAT_SIZE_MAP = new Map();
            for (const [ a, b ] of TEXTURE_FORMAT_SIZE_DATA) for (const c of b) TEXTURE_FORMAT_SIZE_MAP.set(c, a);
            const allTextures = new Set(), UPDATE_DEFAULT_OPTIONS = {
                premultiplyAlpha: !0,
                flipY: !1
            };
            C33._$Gfx$_._$WebGPURendererTexture$_ = class {
                constructor(t, e) {
                    this._$_renderer$_ = t, this._$_texture$_ = null, this._$_format$_ = "", 
                    this._$_textureView$_ = null, this._$_sampler$_ = null, this._$_ownTextureBindGroup$_ = null, 
                    this._$_backTextureBindGroup$_ = null, this._$_width$_ = 0, 
                    this._$_height$_ = 0, this._$_isStatic$_ = !0, this._$_wrapX$_ = "clamp-to-edge", 
                    this._$_wrapY$_ = "clamp-to-edge", this._$_sampling$_ = "trilinear", 
                    this._$_anisotropy$_ = 0, this._$_isMipMapped$_ = !1, this._$_refCount$_ = 0, 
                    this._$_isRenderTarget$_ = !1, this._$_isSampled$_ = !1, this._$_canReadPixels$_ = !1, 
                    this._$_canUpdate$_ = !1, this._$_multisampling$_ = 0, this._$_usage$_ = 0, 
                    this._$_multiTextureEnabled$_ = !0, this._$_multiTextureGroup$_ = null, 
                    this._$_multiTextureIndex$_ = 0, this._$_isForBackbuffer$_ = !!e, 
                    this._$_isForBackbuffer$_ && (this._$_format$_ = this._$_renderer$_._$GetSwapChainFormat$_(), 
                    this._$_isRenderTarget$_ = !0, this._$_isSampled$_ = !0, this._$_sampler$_ = this._$_renderer$_._$_GetSampler$_({
                        _$sampling$_: "nearest"
                    }));
                }
                _$_InitFromOpts$_(t) {
                    if (this._$_wrapX$_ = t._$wrapX$_, this._$_wrapY$_ = t._$wrapY$_, 
                    this._$_sampling$_ = t._$sampling$_, this._$_anisotropy$_ = t._$anisotropy$_, 
                    this._$_isMipMapped$_ = !!t._$mipMap$_ && this._$_renderer$_._$AreMipmapsEnabled$_() && "nearest" !== t._$sampling$_, 
                    this._$_isRenderTarget$_ = !!t._$isRenderTarget$_, this._$_isSampled$_ = !!t._$isSampled$_, 
                    this._$_canReadPixels$_ = !!t._$canReadPixels$_, this._$_canUpdate$_ = !!t._$canUpdate$_, 
                    this._$_multisampling$_ = this._$_renderer$_._$_ClampToSupportedMultisampleValues$_(t._$multisampling$_), 
                    !VALID_SAMPLINGS.has(this._$_sampling$_)) throw new Error("invalid sampling");
                    if (!VALID_WRAP_MODES.has(this._$_wrapX$_) || !VALID_WRAP_MODES.has(this._$_wrapY$_)) throw new Error("invalid wrap mode");
                    if (2 <= this._$_multisampling$_ && this._$_isSampled$_) throw new Error("invalid use of multisampling");
                    "nearest" === this._$_sampling$_ && (this._$_anisotropy$_ = 0), 
                    this._$_sampler$_ = this._$_renderer$_._$_GetSampler$_({
                        _$wrapX$_: this._$_wrapX$_,
                        _$wrapY$_: this._$_wrapY$_,
                        _$sampling$_: this._$_sampling$_,
                        _$anisotropy$_: this._$_anisotropy$_
                    }), this._$_CreateGPUResources$_(), this._$_refCount$_ = 1;
                }
                _$_CreateGPUResources$_() {
                    const t = this._$_renderer$_, e = t._$_GetDevice$_(), s = (this._$_usage$_ = 0, 
                    this._$_isRenderTarget$_ ? (this._$_usage$_ = GPUTextureUsage.RENDER_ATTACHMENT, 
                    this._$_isSampled$_ && (this._$_usage$_ |= GPUTextureUsage.TEXTURE_BINDING), 
                    this._$_canUpdate$_ && (this._$_usage$_ |= GPUTextureUsage.COPY_DST), 
                    this._$_format$_ = this._$_renderer$_._$GetSwapChainFormat$_()) : (this._$_usage$_ = GPUTextureUsage.COPY_DST | GPUTextureUsage.TEXTURE_BINDING, 
                    this._$_format$_ = this._$_renderer$_._$GetTextureFormat$_()), 
                    this._$_canReadPixels$_ && (this._$_usage$_ |= GPUTextureUsage.COPY_SRC), 
                    this._$_texture$_ = e.createTexture({
                        size: [ this._$_width$_, this._$_height$_, 1 ],
                        mipLevelCount: this._$_GetMipLevelCount$_(),
                        format: this._$_format$_,
                        usage: this._$_usage$_,
                        sampleCount: 2 <= this._$_multisampling$_ ? this._$_multisampling$_ : 1
                    }), this._$_textureView$_ = this._$_texture$_.createView(), 
                    []), i = C33._$Gfx$_._$WebGPUMultiTextureGroup$_._$GetMultiTextureLimit$_();
                    for (let t = 0; t < i; ++t) s.push({
                        binding: 2 * t,
                        resource: this._$_sampler$_
                    }, {
                        binding: 2 * t + 1,
                        resource: this._$_textureView$_
                    });
                    this._$_isRenderTarget$_ && !this._$_isSampled$_ || (this._$_ownTextureBindGroup$_ = e.createBindGroup({
                        layout: t._$_GetTextureBindGroupLayout$_(),
                        entries: s
                    }), this._$_backTextureBindGroup$_ = e.createBindGroup({
                        layout: t._$_GetBackTextureBindGroupLayout$_(),
                        entries: [ {
                            binding: 0,
                            resource: this._$_renderer$_._$_GetSampler$_({
                                _$sampling$_: "nearest"
                            })
                        }, {
                            binding: 1,
                            resource: this._$_textureView$_
                        } ]
                    })), this._$_CanMultiTexture$_() && this._$_SetMultiTextureAvailable$_(!0), 
                    allTextures.add(this);
                }
                _$_DeleteGPUResources$_() {
                    allTextures.delete(this), this._$_multiTextureGroup$_ && this._$_multiTextureGroup$_._$Release$_(), 
                    this._$_SetMultiTextureAvailable$_(!1), this._$_texture$_.destroy(), 
                    this._$_texture$_ = null, this._$_textureView$_ = null, this._$_ownTextureBindGroup$_ = null, 
                    this._$_backTextureBindGroup$_ = null;
                }
                static _$IsGPUImageCopyExternalImageSource$_(t) {
                    return t instanceof ImageBitmap || "undefined" != typeof HTMLVideoElement && t instanceof HTMLVideoElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof OffscreenCanvas && t instanceof OffscreenCanvas;
                }
                static _$IsCreateImageBitmapDataSource$_(t) {
                    return "undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || t instanceof ImageData;
                }
                _$_GetDataSize$_(t) {
                    return [ t.width || t.videoWidth, t.height || t.videoHeight ];
                }
                _$_Create$_(t, e) {
                    if (t && !C33._$Gfx$_._$WebGPURendererTexture$_._$IsGPUImageCopyExternalImageSource$_(t)) throw new TypeError("invalid texture source");
                    if (e = Object.assign({}, DEFAULT_CREATE_OPTIONS, e), this._$_texture$_) throw new Error("already created texture");
                    if (this._$_isStatic$_ = !0, t) {
                        const [ s, i ] = this._$_GetDataSize$_(t);
                        this._$_width$_ = s, this._$_height$_ = i;
                    } else if (this._$_width$_ = e.width, this._$_height$_ = e.height, 
                    this._$_width$_ <= 0 || this._$_height$_ <= 0) throw new Error("invalid texture size");
                    if (this._$_InitFromOpts$_(e), this._$_isRenderTarget$_ || this._$_isSampled$_) throw new Error("static texture cannot be render target");
                    t && this._$_UploadImage$_(t);
                }
                _$_UploadImage$_(t, e = !0) {
                    if (this._$_isMipMapped$_) this._$_GenerateMipmaps$_(t, this._$_GetMipLevelCount$_(), e); else {
                        const s = this._$_renderer$_._$_GetDevice$_(), i = s.createCommandEncoder(), r = s.createTexture({
                            size: [ this._$_width$_, this._$_height$_, 1 ],
                            mipLevelCount: 1,
                            format: this._$_format$_,
                            usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT
                        });
                        this._$_CopyImageToMipLevel$_(r, t, 0, e), i.copyTextureToTexture({
                            texture: r,
                            mipLevel: 0
                        }, {
                            texture: this._$_texture$_,
                            mipLevel: 0
                        }, [ this._$_width$_, this._$_height$_, 1 ]), s.queue.submit([ i.finish() ]), 
                        r.destroy();
                    }
                }
                _$_CopyImageToMipLevel$_(t, e, s, i = !0) {
                    const [ r, n ] = this._$_GetDataSize$_(e);
                    this._$_renderer$_._$_GetDevice$_().queue.copyExternalImageToTexture({
                        source: e
                    }, {
                        texture: t,
                        mipLevel: s,
                        premultipliedAlpha: !!i
                    }, [ r, n, 1 ]);
                }
                _$_GetMipLevelCount$_() {
                    return this._$_isMipMapped$_ ? Math.floor(Math.log2(Math.max(this._$_width$_, this._$_height$_)) + 1) : 1;
                }
                _$_GenerateMipmaps$_(t, e, s = !0) {
                    const i = this._$_renderer$_._$_GetDevice$_(), r = i.createTexture({
                        size: [ this._$_width$_, this._$_height$_, 1 ],
                        mipLevelCount: this._$_GetMipLevelCount$_(),
                        format: this._$_format$_,
                        usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT
                    }), n = this._$_renderer$_._$_GetMipmapGeneratorPipeline$_(), h = n.getBindGroupLayout(0), o = this._$_renderer$_._$_GetSampler$_({
                        _$sampling$_: "bilinear"
                    }), a = i.createCommandEncoder(), l = (this._$_CopyImageToMipLevel$_(r, t, 0, s), 
                    a.copyTextureToTexture({
                        texture: r,
                        mipLevel: 0
                    }, {
                        texture: this._$_texture$_,
                        mipLevel: 0
                    }, [ this._$_width$_, this._$_height$_, 1 ]), []);
                    for (let t = 0; t < e; ++t) l.push(r.createView({
                        baseMipLevel: t,
                        mipLevelCount: 1
                    }));
                    let u = this._$_width$_, c = this._$_height$_;
                    for (let t = 1; t < e; ++t) {
                        u /= 2, c /= 2;
                        const f = Math.max(Math.floor(u), 1), d = Math.max(Math.floor(c), 1), p = a.beginRenderPass({
                            colorAttachments: [ {
                                view: l[t],
                                loadOp: "clear",
                                clearValue: [ 0, 0, 0, 0 ],
                                storeOp: "store"
                            } ]
                        }), m = i.createBindGroup({
                            layout: h,
                            entries: [ {
                                binding: 0,
                                resource: o
                            }, {
                                binding: 1,
                                resource: l[t - 1]
                            } ]
                        });
                        p.setPipeline(n), p.setBindGroup(0, m), p.draw(4), p.end(), 
                        a.copyTextureToTexture({
                            texture: r,
                            mipLevel: t
                        }, {
                            texture: this._$_texture$_,
                            mipLevel: t
                        }, [ f, d, 1 ]);
                    }
                    i.queue.submit([ a.finish() ]), r.destroy();
                }
                _$_CreateDynamic$_(t, e, s) {
                    if (s = Object.assign({}, DEFAULT_CREATE_OPTIONS, s), this._$_texture$_) throw new Error("already created texture");
                    this._$_isStatic$_ = !1, this._$_width$_ = t, this._$_height$_ = e, 
                    this._$_InitFromOpts$_(s);
                }
                async _$_Update$_(t, e) {
                    if (!C33._$Gfx$_._$WebGPURendererTexture$_._$IsGPUImageCopyExternalImageSource$_(t) && !C33._$Gfx$_._$WebGPURendererTexture$_._$IsCreateImageBitmapDataSource$_(t)) throw new Error("invalid texture source");
                    if (!this._$_texture$_ || this._$_refCount$_ <= 0) throw new Error("texture not created");
                    if (this._$_isStatic$_) throw new Error("cannot update static texture");
                    if (e = Object.assign({}, UPDATE_DEFAULT_OPTIONS, e), !C33._$Gfx$_._$WebGPURendererTexture$_._$IsCreateImageBitmapDataSource$_(t) && !e.flipY && e.premultiplyAlpha || (t = await createImageBitmap(t, {
                        premultiplyAlpha: e.premultiplyAlpha ? "premultiply" : "none",
                        imageOrientation: e.flipY ? "flipY" : "none"
                    }), this._$_texture$_)) {
                        this._$_renderer$_._$EndBatch$_();
                        const [ s, i ] = this._$_GetDataSize$_(t);
                        this._$_width$_ === s && this._$_height$_ === i || (this._$_DeleteGPUResources$_(), 
                        this._$_width$_ = s, this._$_height$_ = i, this._$_CreateGPUResources$_(), 
                        this._$_renderer$_._$_OnTextureBindGroupChanged$_(this)), 
                        this._$_UploadImage$_(t, e.premultiplyAlpha);
                    }
                }
                _$_Delete$_() {
                    if (0 < this._$_refCount$_) throw new Error("texture still has references");
                    if (!this._$_texture$_) throw new Error("already deleted texture");
                    this._$_DeleteGPUResources$_();
                }
                _$_DisableMultiTexture$_() {
                    this._$_multiTextureEnabled$_ = !1, this._$_SetMultiTextureAvailable$_(!1);
                }
                _$_CanMultiTexture$_() {
                    return this._$_isStatic$_ && this._$_multiTextureEnabled$_ && !this._$_isRenderTarget$_;
                }
                _$_SetMultiTextureAvailable$_(t) {
                    this._$_renderer$_._$_SetMultiTextureAvailable$_(this, t);
                }
                _$_SetMultiTextureGroup$_(t, e) {
                    if (this._$_multiTextureGroup$_) throw new Error("already in a group");
                    this._$_multiTextureGroup$_ = t, this._$_multiTextureIndex$_ = e, 
                    this._$_SetMultiTextureAvailable$_(!1);
                }
                _$_ClearMultiTextureGroup$_() {
                    this._$_multiTextureGroup$_ = null, this._$_multiTextureIndex$_ = 0, 
                    this._$_CanMultiTexture$_() && this._$_SetMultiTextureAvailable$_(!0);
                }
                _$_GetOwnTextureBindGroup$_() {
                    return this._$_ownTextureBindGroup$_;
                }
                _$_GetBackTextureBindGroup$_() {
                    return this._$_backTextureBindGroup$_;
                }
                _$_GetMultiTextureBindGroup$_() {
                    return null !== this._$_multiTextureGroup$_ || this._$_CanMultiTexture$_() && (this._$_renderer$_._$_TryCreateMultiTextureGroup$_(this), 
                    null !== this._$_multiTextureGroup$_) ? this._$_multiTextureGroup$_._$_GetBindGroup$_() : null;
                }
                _$_GetMultiTextureIndex$_() {
                    return this._$_multiTextureIndex$_;
                }
                _$GetWidth$_() {
                    return this._$_isForBackbuffer$_ ? this._$_renderer$_._$GetWidth$_() : this._$_width$_;
                }
                _$GetHeight$_() {
                    return this._$_isForBackbuffer$_ ? this._$_renderer$_._$GetHeight$_() : this._$_height$_;
                }
                _$GetRenderer$_() {
                    return this._$_renderer$_;
                }
                _$_GetTexture$_() {
                    return this._$_texture$_;
                }
                _$_GetTextureView$_() {
                    return this._$_textureView$_;
                }
                _$_GetFormat$_() {
                    return this._$_format$_;
                }
                _$_GetSampler$_() {
                    return this._$_sampler$_;
                }
                _$GetSampling$_() {
                    return this._$_sampling$_;
                }
                _$IsLinearSampling$_() {
                    return "nearest" !== this._$_sampling$_;
                }
                _$IsRenderTarget$_() {
                    return this._$_isRenderTarget$_;
                }
                _$IsSampled$_() {
                    return this._$_isSampled$_;
                }
                _$CanReadPixels$_() {
                    return this._$_canReadPixels$_;
                }
                _$AddReference$_() {
                    this._$_refCount$_++;
                }
                _$SubtractReference$_() {
                    if (this._$_refCount$_ <= 0) throw new Error("no more references");
                    this._$_refCount$_--;
                }
                _$GetReferenceCount$_() {
                    return this._$_refCount$_;
                }
                _$_GetUsage$_() {
                    return this._$_usage$_;
                }
                _$_BackbufferTextureSetProperties$_(t, e) {
                    this._$_usage$_ = t, this._$_format$_ = e;
                }
                _$_BackbufferTextureStartFrame$_() {
                    const t = this._$_renderer$_, e = t._$_GetDevice$_();
                    this._$_texture$_ = t._$_GetSwapChainTexture$_(), this._$_textureView$_ = t._$_GetSwapChainTexView$_(), 
                    t._$_CanSampleBackbuffer$_() && (this._$_backTextureBindGroup$_ = e.createBindGroup({
                        layout: t._$_GetBackTextureBindGroupLayout$_(),
                        entries: [ {
                            binding: 0,
                            resource: this._$_sampler$_
                        }, {
                            binding: 1,
                            resource: this._$_textureView$_
                        } ]
                    }));
                }
                _$_BackbufferTextureEndFrame$_() {
                    this._$_texture$_ = null, this._$_textureView$_ = null, this._$_backTextureBindGroup$_ = null;
                }
                _$GetEstimatedMemoryUsage$_() {
                    let t = this._$GetWidth$_() * this._$GetHeight$_() * C33._$Gfx$_._$WebGPURendererTexture$_._$GetFormatByteSize$_(this._$_GetFormat$_());
                    return this._$_isMipMapped$_ && (t += Math.floor(t / 3)), t;
                }
                static _$OnContextLost$_() {}
                static _$allTextures$_() {
                    return allTextures.values();
                }
                static _$GetFormatByteSize$_(t) {
                    const e = TEXTURE_FORMAT_SIZE_MAP.get(t);
                    return "number" == typeof e ? e : NaN;
                }
            };
        }
        {
            const C33 = self._$C3$_;
            C33._$Gfx$_._$WebGPUMultiTextureGroup$_ = class {
                constructor(t, s) {
                    if (s.length < 2) throw new Error("invalid multi-texture group");
                    this._$_renderer$_ = t, this._$_textures$_ = s, this._$_multiTextureBindGroup$_ = null;
                    for (let t = 0, e = s.length; t < e; ++t) s[t]._$_SetMultiTextureGroup$_(this, t);
                    s.length < C33._$Gfx$_._$WebGPUMultiTextureGroup$_._$GetMultiTextureLimit$_() && this._$_renderer$_._$_SetMultiTextureGroupNonFull$_(this, !0), 
                    this._$_CreateBindGroup$_();
                }
                _$Release$_() {
                    this._$_renderer$_._$_SetMultiTextureGroupNonFull$_(this, !1);
                    for (const t of this._$_textures$_) t._$_ClearMultiTextureGroup$_();
                    this._$_DeleteBindGroup$_(), C33._$clearArray$_(this._$_textures$_), 
                    this._$_renderer$_ = null;
                }
                _$_CreateBindGroup$_() {
                    this._$_DeleteBindGroup$_();
                    const t = this._$_renderer$_._$_GetDevice$_(), e = [], s = C33._$Gfx$_._$WebGPUMultiTextureGroup$_._$GetMultiTextureLimit$_();
                    for (let t = 0; t < s; ++t) {
                        const i = this._$_textures$_[Math.min(t, this._$_textures$_.length - 1)];
                        e.push({
                            binding: 2 * t,
                            resource: i._$_GetSampler$_()
                        }, {
                            binding: 2 * t + 1,
                            resource: i._$_GetTextureView$_()
                        });
                    }
                    this._$_multiTextureBindGroup$_ = t.createBindGroup({
                        layout: this._$_renderer$_._$_GetTextureBindGroupLayout$_(),
                        entries: e
                    });
                }
                _$_DeleteBindGroup$_() {
                    null !== this._$_multiTextureBindGroup$_ && this._$_renderer$_._$_OnMultiTextureBindGroupReleased$_(this._$_multiTextureBindGroup$_), 
                    this._$_multiTextureBindGroup$_ = null;
                }
                _$_GetBindGroup$_() {
                    return this._$_multiTextureBindGroup$_;
                }
                static _$GetMultiTextureLimit$_() {
                    return 14;
                }
            };
        }
        {
            const C33 = self._$C3$_, glMatrix = self._$glMatrix$_, vec32 = glMatrix._$vec3$_, mat42 = glMatrix._$mat4$_, DEFAULT_RENDERTARGET_OPTIONS = {
                _$sampling$_: "trilinear",
                alpha: !0,
                depth: !1,
                _$isSampled$_: !0,
                _$canReadPixels$_: !1,
                _$canUpdate$_: !1,
                _$isDefaultSize$_: !0,
                _$multisampling$_: 0
            }, allRenderTargets = new Set();
            C33._$Gfx$_._$WebGPURenderTarget$_ = class {
                constructor(t, e) {
                    this._$_renderer$_ = t, this._$_isBackBuffer$_ = !!e, this._$_depth$_ = !!e && t._$UsesDepthBuffer$_(), 
                    this._$_rendererTexture$_ = null, this._$_isDefaultSize$_ = !0, 
                    this._$_multisampling$_ = 0, this._$_isAwaitingClear$_ = !1, 
                    this._$_clearColor$_ = C33._$New$_(C33._$Color$_), this._$_projectionMatrix$_ = mat42.create(), 
                    this._$_lastFov$_ = 0, this._$_lastNearZ$_ = 0, this._$_lastFarZ$_ = 0, 
                    this._$_isBackBuffer$_ && (this._$_rendererTexture$_ = C33._$New$_(C33._$Gfx$_._$WebGPURendererTexture$_, t, !0));
                }
                _$_Create$_(t, e, s) {
                    if (s = Object.assign({}, DEFAULT_RENDERTARGET_OPTIONS, s), 
                    this._$_rendererTexture$_) throw new Error("already created render target");
                    if (this._$_depth$_ = !!s.depth, this._$_isDefaultSize$_ = !!s._$isDefaultSize$_, 
                    this._$_multisampling$_ = this._$_renderer$_._$_ClampToSupportedMultisampleValues$_(s._$multisampling$_), 
                    2 <= this._$_multisampling$_ && s._$isSampled$_) throw new Error("invalid use of multisampling");
                    this._$_rendererTexture$_ = this._$_renderer$_._$CreateDynamicTexture$_(t, e, {
                        _$sampling$_: s._$sampling$_,
                        _$mipMap$_: !1,
                        _$isRenderTarget$_: !0,
                        _$isSampled$_: s._$isSampled$_,
                        _$canReadPixels$_: s._$canReadPixels$_,
                        _$canUpdate$_: s._$canUpdate$_,
                        _$multisampling$_: this._$_multisampling$_
                    }), this._$_CalculateProjection$_(), allRenderTargets.add(this);
                }
                _$_Delete$_() {
                    allRenderTargets.delete(this), this._$_rendererTexture$_._$_DeleteGPUResources$_(), 
                    this._$_rendererTexture$_ = null, this._$_renderer$_ = null;
                }
                _$_Resize$_(t, e) {
                    if (t !== this._$GetWidth$_() || e !== this._$GetHeight$_()) {
                        const s = this._$_rendererTexture$_._$GetSampling$_(), i = this._$_rendererTexture$_._$IsSampled$_(), r = this._$_rendererTexture$_._$CanReadPixels$_();
                        this._$_rendererTexture$_._$_DeleteGPUResources$_(), this._$_rendererTexture$_ = null, 
                        this._$_rendererTexture$_ = this._$_renderer$_._$CreateDynamicTexture$_(t, e, {
                            _$sampling$_: s,
                            _$mipMap$_: !1,
                            _$isRenderTarget$_: !0,
                            _$isSampled$_: i,
                            _$canReadPixels$_: r
                        }), this._$_CalculateProjection$_();
                    }
                }
                _$_GetTextureView$_() {
                    return this._$_isBackBuffer$_ ? this._$_renderer$_._$_GetSwapChainTexView$_() : this._$_rendererTexture$_._$_GetTextureView$_();
                }
                _$_CalculateProjection$_() {
                    this._$_renderer$_._$CalculatePerspectiveMatrix$_(this._$_projectionMatrix$_, this._$GetWidth$_() / this._$GetHeight$_()), 
                    this._$_lastFov$_ = this._$_renderer$_._$GetFovY$_(), this._$_lastNearZ$_ = this._$_renderer$_._$GetNearZ$_(), 
                    this._$_lastFarZ$_ = this._$_renderer$_._$GetFarZ$_();
                }
                _$IsDefaultSize$_() {
                    return this._$_isDefaultSize$_;
                }
                _$IsBackBuffer$_() {
                    return this._$_isBackBuffer$_;
                }
                _$HasDepthBuffer$_() {
                    return this._$_depth$_;
                }
                _$GetWidth$_() {
                    return (this._$_isBackBuffer$_ ? this._$_renderer$_ : this._$_rendererTexture$_)._$GetWidth$_();
                }
                _$GetHeight$_() {
                    return (this._$_isBackBuffer$_ ? this._$_renderer$_ : this._$_rendererTexture$_)._$GetHeight$_();
                }
                _$GetTexture$_() {
                    if (this._$_rendererTexture$_) return this._$_rendererTexture$_;
                    throw new Error("no texture");
                }
                _$GetRenderer$_() {
                    return this._$_renderer$_;
                }
                _$GetMultisampling$_() {
                    return this._$_multisampling$_;
                }
                _$GetProjectionMatrix$_() {
                    return this._$_renderer$_._$GetFovY$_() === this._$_lastFov$_ && this._$_renderer$_._$GetNearZ$_() === this._$_lastNearZ$_ && this._$_renderer$_._$GetFarZ$_() === this._$_lastFarZ$_ || this._$_CalculateProjection$_(), 
                    this._$_projectionMatrix$_;
                }
                _$IsLinearSampling$_() {
                    return this._$_rendererTexture$_._$IsLinearSampling$_();
                }
                _$IsSampled$_() {
                    return this._$_rendererTexture$_._$IsSampled$_();
                }
                _$CanReadPixels$_() {
                    return this._$_rendererTexture$_._$CanReadPixels$_();
                }
                _$IsCompatibleWithOptions$_(t) {
                    return "nearest" !== (t = Object.assign({}, DEFAULT_RENDERTARGET_OPTIONS, t))._$sampling$_ === this._$IsLinearSampling$_() && !!t._$isSampled$_ === this._$IsSampled$_() && !!t._$canReadPixels$_ === this._$CanReadPixels$_() && !!t.depth === this._$HasDepthBuffer$_() && ("number" == typeof t.width || "number" == typeof t.height ? !this._$IsDefaultSize$_() && this._$GetWidth$_() === Math.floor(t.width) && this._$GetHeight$_() === Math.floor(t.height) : this._$IsDefaultSize$_());
                }
                _$_SetIsAwaitingClear$_(t) {
                    this._$_isAwaitingClear$_ = !!t;
                }
                _$_IsAwaitingClear$_() {
                    return this._$_isAwaitingClear$_;
                }
                _$_GetClearColor$_() {
                    return this._$_clearColor$_;
                }
                static _$OnContextLost$_() {}
                static _$allRenderTargets$_() {
                    return allRenderTargets.values();
                }
            };
        }
        {
            const C33 = self._$C3$_;
            C33._$Gfx$_._$WebGPUTimeQuerySet$_ = class {
                constructor(t, e) {
                    this._$_renderer$_ = t, this._$_frameNumber$_ = this._$_renderer$_._$GetFrameNumber$_(), 
                    this._$_queryCount$_ = e;
                    const s = this._$_renderer$_._$_GetDevice$_(), i = (this._$_querySet$_ = s.createQuerySet({
                        count: this._$_queryCount$_,
                        type: "timestamp"
                    }), self.GPUBufferUsage);
                    this._$_resolveBuffer$_ = s.createBuffer({
                        size: this._$_GetBufferSize$_(),
                        usage: i.QUERY_RESOLVE | i.COPY_SRC
                    }), this._$_readbackBuffer$_ = s.createBuffer({
                        size: this._$_GetBufferSize$_(),
                        usage: i.COPY_DST | i.MAP_READ
                    }), this._$_result$_ = null;
                }
                _$_GetBufferSize$_() {
                    return 8 * this._$_queryCount$_;
                }
                _$_GetQuerySet$_() {
                    return this._$_querySet$_;
                }
                _$Resolve$_(t) {
                    t.resolveQuerySet(this._$_querySet$_, 0, this._$_queryCount$_, this._$_resolveBuffer$_, 0), 
                    t.copyBufferToBuffer(this._$_resolveBuffer$_, 0, this._$_readbackBuffer$_, 0, this._$_GetBufferSize$_());
                }
                async _$ReadResult$_() {
                    const t = this._$_GetBufferSize$_(), e = (await this._$_readbackBuffer$_.mapAsync(self.GPUMapMode.READ, 0, t), 
                    this._$_readbackBuffer$_.getMappedRange(0, t));
                    this._$_result$_ = new BigUint64Array(e.slice(0)), this._$_readbackBuffer$_.destroy(), 
                    this._$_readbackBuffer$_ = null, this._$_resolveBuffer$_.destroy(), 
                    this._$_resolveBuffer$_ = null, this._$_querySet$_.destroy(), 
                    this._$_querySet$_ = null;
                }
                _$HasResult$_() {
                    return null !== this._$_result$_;
                }
                _$GetResult$_() {
                    if (this._$_result$_) return this._$_result$_;
                    throw new Error("not yet got result");
                }
                _$GetFrameNumber$_() {
                    return this._$_frameNumber$_;
                }
            };
        }
        {
            const C33 = self._$C3$_, DEFAULT_CTOR_OPTS = {
                _$getDrawSize$_: null,
                _$getRenderTarget$_: null,
                _$releaseRenderTarget$_: null,
                getTime: null,
                _$redraw$_: null
            };
            C33._$Gfx$_._$EffectChainManager$_ = class {
                constructor(t) {
                    t = Object.assign({}, DEFAULT_CTOR_OPTS, t), this._$_cbGetDrawSize$_ = t._$getDrawSize$_, 
                    this._$_cbGetRenderTarget$_ = t._$getRenderTarget$_, this._$_cbReleaseRenderTarget$_ = t._$releaseRenderTarget$_, 
                    this._$_cbGetTime$_ = t.getTime, this._$_cbRedraw$_ = t._$redraw$_, 
                    this._$_webgpuBackTexture$_ = null, this._$_allEffectChains$_ = new Set();
                }
                _$_AddEffectChain$_(t) {
                    this._$_allEffectChains$_.add(t);
                }
                _$_RemoveEffectChain$_(t) {
                    this._$_allEffectChains$_.delete(t);
                }
                _$OnContextLost$_() {
                    this._$_webgpuBackTexture$_ = null;
                    for (const t of this._$_allEffectChains$_) t._$OnContextLost$_();
                }
                _$GetDrawSize$_(t) {
                    return this._$_cbGetDrawSize$_ ? this._$_cbGetDrawSize$_(t) : [ t._$GetWidth$_(), t._$GetHeight$_() ];
                }
                _$GetRenderTarget$_(t) {
                    return this._$_cbGetRenderTarget$_(t);
                }
                _$ReleaseRenderTarget$_(t, e) {
                    this._$_cbReleaseRenderTarget$_(t, e);
                }
                _$GetTime$_() {
                    return this._$_cbGetTime$_();
                }
                _$Redraw$_(t) {
                    this._$_cbRedraw$_(t);
                }
                _$_GetWebGPUBackTexture$_(t, e, s) {
                    return e = Math.floor(e), s = Math.floor(s), !this._$_webgpuBackTexture$_ || this._$_webgpuBackTexture$_._$GetWidth$_() === e && this._$_webgpuBackTexture$_._$GetHeight$_() === s || (t._$DeleteTexture$_(this._$_webgpuBackTexture$_), 
                    this._$_webgpuBackTexture$_ = null), null === this._$_webgpuBackTexture$_ && (this._$_webgpuBackTexture$_ = t._$CreateStaticTexture$_(null, {
                        width: e,
                        height: s,
                        _$sampling$_: "nearest",
                        _$mipMap$_: !1
                    })), this._$_webgpuBackTexture$_;
                }
            };
        }
        {
            const C33 = self._$C3$_, assert = self.assert, glMatrix = self._$glMatrix$_, mat42 = glMatrix._$mat4$_, tempRect = C33._$New$_(C33.Rect), tempRect2 = C33._$New$_(C33.Rect), tempRect3 = C33._$New$_(C33.Rect), tempRect4 = C33._$New$_(C33.Rect), tempMat4a = mat42.create(), tempMat4b = mat42.create(), DEFAULT_CTOR_OPTS = {
                _$drawContent$_: null,
                _$getSourceTextureInfo$_: null,
                _$getShaderParameters$_: null,
                _$invalidateRenderTargets$_: !1
            }, DEFAULT_BUILDSTEPS_OPTS = {
                _$indexMap$_: null,
                _$forcePreDraw$_: !1,
                _$forcePostDraw$_: !1,
                _$is3D$_: !1,
                _$isSourceTextureRotated$_: !1,
                _$isRotatedOrNegativeSizeInstance$_: !1,
                _$useFullSurface$_: !1
            };
            C33._$Gfx$_._$EffectChain$_ = class {
                constructor(t, e) {
                    e = Object.assign({}, DEFAULT_CTOR_OPTS, e), this._$_manager$_ = t, 
                    this._$_cbDrawContent$_ = e._$drawContent$_, this._$_cbGetSourceTextureInfo$_ = e._$getSourceTextureInfo$_, 
                    this._$_cbGetShaderParameters$_ = e._$getShaderParameters$_, 
                    this._$_cbDrawContentHook$_ = null, this._$_shaderProgramList$_ = [], 
                    this._$_shaderProgramIndices$_ = [], this._$_steps$_ = [], this._$_needsRebuild$_ = !1, 
                    this._$_blendMode$_ = 0, this._$_isAnyShaderAnimated$_ = !1, 
                    this._$_isAnyShaderDepthSampling$_ = !1, this._$_isAnyShaderBackgroundBlending$_ = !1, 
                    this._$_isAnyShaderCrossSampling$_ = !1, this._$_isAnyIsSrcTexRotated$_ = !1, 
                    this._$_useCopyTextureBackgroundSampling$_ = !1, this._$_didChangeTransform$_ = !1, 
                    this._$_depthEnabledAtStart$_ = !1, this._$_coplanarColorPassAtStart$_ = !1, 
                    this._$_canUseFastPath$_ = !1, this._$_useFullSurface$_ = !1, 
                    this._$_isSourceTextureRotated$_ = !1, this._$_numTempSurfacesRequired$_ = 0, 
                    this._$_renderTargets$_ = [ null, null, null ], this._$_invalidateRenderTargets$_ = !!e._$invalidateRenderTargets$_, 
                    this._$_boxExtendHorizontal$_ = 0, this._$_boxExtendVertical$_ = 0, 
                    this._$_drawWidth$_ = 0, this._$_drawHeight$_ = 0, this._$_contentObject$_ = null, 
                    this._$_contextObject$_ = null, this._$_layoutRect$_ = C33._$New$_(C33.Rect), 
                    this._$_drawSurfaceRect$_ = C33._$New$_(C33.Rect), this._$_rcTexOriginal$_ = C33._$New$_(C33.Rect), 
                    this._$_rcTexBounce$_ = C33._$New$_(C33.Rect), this._$_rcTexDest$_ = C33._$New$_(C33.Rect), 
                    this._$_devicePixelRatio$_ = 1, this._$_layerScale$_ = 1, this._$_layerAngle$_ = 0, 
                    this._$_time$_ = 0, this._$_destRenderTarget$_ = null, this._$_backTex$_ = null, 
                    this._$_compositOffX$_ = 0, this._$_compositOffY$_ = 0, this._$_updateOwnProjection$_ = !1, 
                    this._$_projectionMatrix$_ = mat42.create(), this._$_modelViewMatrix$_ = mat42.create(), 
                    this._$_manager$_._$_AddEffectChain$_(this);
                }
                _$Release$_() {
                    this._$_manager$_._$_RemoveEffectChain$_(this), C33._$clearArray$_(this._$_steps$_), 
                    C33._$clearArray$_(this._$_shaderProgramList$_), C33._$clearArray$_(this._$_shaderProgramIndices$_), 
                    this._$_contentObject$_ = null, this._$_contextObject$_ = null, 
                    this._$_cbDrawContent$_ = null, this._$_cbGetSourceTextureInfo$_ = null, 
                    this._$_cbGetShaderParameters$_ = null;
                }
                _$OnContextLost$_() {
                    this._$_needsRebuild$_ = !0, C33._$clearArray$_(this._$_steps$_), 
                    C33._$clearArray$_(this._$_shaderProgramList$_), C33._$clearArray$_(this._$_shaderProgramIndices$_);
                }
                _$NeedsRebuild$_() {
                    return this._$_needsRebuild$_;
                }
                _$BuildSteps$_(r, t) {
                    if (t = Object.assign({}, DEFAULT_BUILDSTEPS_OPTS, t), C33._$clearArray$_(this._$_steps$_), 
                    this._$_boxExtendHorizontal$_ = 0, this._$_boxExtendVertical$_ = 0, 
                    this._$_isAnyShaderAnimated$_ = !1, this._$_isAnyShaderDepthSampling$_ = !1, 
                    this._$_isAnyShaderBackgroundBlending$_ = !1, this._$_isAnyShaderCrossSampling$_ = !1, 
                    this._$_isAnyIsSrcTexRotated$_ = !1, this._$_useCopyTextureBackgroundSampling$_ = !1, 
                    this._$_numTempSurfacesRequired$_ = 0, this._$_isSourceTextureRotated$_ = !!t._$isSourceTextureRotated$_, 
                    this._$_useFullSurface$_ = !!t._$useFullSurface$_, this._$_needsRebuild$_ = !1, 
                    C33._$shallowAssignArray$_(this._$_shaderProgramList$_, r), 
                    0 !== r.length) {
                        if (t._$indexMap$_) {
                            if (t._$indexMap$_.length !== r.length) throw new Error("incorrect indexMap length");
                            C33._$shallowAssignArray$_(this._$_shaderProgramIndices$_, t._$indexMap$_);
                        } else {
                            C33._$clearArray$_(this._$_shaderProgramIndices$_);
                            for (let t = 0, e = r.length; t < e; ++t) this._$_shaderProgramIndices$_.push(t);
                        }
                        for (const e of r) this._$_boxExtendHorizontal$_ += e._$GetBoxExtendHorizontal$_(), 
                        this._$_boxExtendVertical$_ += e._$GetBoxExtendVertical$_(), 
                        e._$IsAnimated$_() && (this._$_isAnyShaderAnimated$_ = !0), 
                        e._$UsesDepth$_() && (this._$_isAnyShaderDepthSampling$_ = !0), 
                        e._$BlendsBackground$_() && (this._$_isAnyShaderBackgroundBlending$_ = !0), 
                        e._$UsesCrossSampling$_() && (this._$_isAnyShaderCrossSampling$_ = !0), 
                        e._$UsesIsSrcTexRotated$_() && (this._$_isAnyIsSrcTexRotated$_ = !0);
                        this._$_useCopyTextureBackgroundSampling$_ = this._$_ShouldUseCopyTextureBackgroundSampling$_(r[0]._$GetRenderer$_());
                        const n = this._$_ShouldPreDraw$_(r[0], t), h = this._$_ShouldPostDraw$_(r.at(-1), t);
                        if (1 !== r.length || n || h) {
                            this._$_canUseFastPath$_ = !1;
                            let i = 0;
                            n && (this._$_numTempSurfacesRequired$_ = 1, this._$_steps$_.push(C33._$New$_(C33._$Gfx$_._$EffectChain$_.Step._$PreDraw$_, this, -1, 1)), 
                            i = 1);
                            for (let e = 0, s = r.length; e < s; ++e) if (0 !== e || n) {
                                let t = 1 === i ? 2 : 1;
                                e !== s - 1 || h || (t = 0), this._$_numTempSurfacesRequired$_ = Math.max(this._$_numTempSurfacesRequired$_, t), 
                                this._$_steps$_.push(C33._$New$_(C33._$Gfx$_._$EffectChain$_.Step._$Bounce$_, this, i, t, e)), 
                                i = t;
                            } else this._$_numTempSurfacesRequired$_ = 1, this._$_steps$_.push(C33._$New$_(C33._$Gfx$_._$EffectChain$_.Step._$FirstBounce$_, this, -1, 1, e)), 
                            i = 1;
                            h && this._$_steps$_.push(C33._$New$_(C33._$Gfx$_._$EffectChain$_.Step._$PostDraw$_, this, i, 0));
                        } else this._$_canUseFastPath$_ = !0;
                    }
                }
                _$_ShouldPreDraw$_(t, e) {
                    return !!(e._$forcePreDraw$_ || t._$MustPreDraw$_() || e._$is3D$_ && !t._$Supports3DDirectRendering$_() || t._$UsesDepth$_() && !this._$_useFullSurface$_ || 0 !== this._$_boxExtendHorizontal$_ || 0 !== this._$_boxExtendVertical$_) || (t._$GetRenderer$_()._$IsWebGL$_() ? t._$BlendsBackground$_() && (e._$isRotatedOrNegativeSizeInstance$_ || e._$isSourceTextureRotated$_) || t._$UsesAnySrcRectOrPixelSize$_() && e._$isSourceTextureRotated$_ : t._$BlendsBackground$_() && !this._$_useCopyTextureBackgroundSampling$_ && e._$isRotatedOrNegativeSizeInstance$_);
                }
                _$_ShouldPostDraw$_(t, e) {
                    return !!e._$forcePostDraw$_ || (t._$GetRenderer$_()._$IsWebGL$_() ? t._$BlendsBackground$_() || t._$UsesCrossSampling$_() : (t._$BlendsBackground$_() || t._$UsesCrossSampling$_()) && this._$_UseRenderTargetBackgroundSampling$_());
                }
                _$_ShouldUseCopyTextureBackgroundSampling$_(t) {
                    return t._$IsWebGPU$_() && this._$_isAnyShaderBackgroundBlending$_ && !this._$_isAnyShaderCrossSampling$_;
                }
                _$Render$_(t, e, s) {
                    t._$IsWebGPU$_() && null === e && (e = t._$GetBackbufferRenderTarget$_()), 
                    this._$_destRenderTarget$_ = e, this._$_contentObject$_ = s._$contentObject$_ || null, 
                    this._$_contextObject$_ = s.contextObject || null, this._$_blendMode$_ = s._$blendMode$_ || 0, 
                    this._$_devicePixelRatio$_ = s.devicePixelRatio || 1, this._$_layerScale$_ = s._$layerScale$_ || 1, 
                    this._$_layerAngle$_ = s._$layerAngle$_ || 0, this._$_time$_ = "number" == typeof s.time ? s.time : this._$_manager$_._$GetTime$_(), 
                    this._$_didChangeTransform$_ = !1, t._$ResetDidChangeTransformFlag$_(), 
                    this._$_isAnyShaderAnimated$_ && this._$_Redraw$_();
                    let i = !1;
                    if (this._$_UseCopyTextureBackgroundSampling$_() && (this._$_CalculateDrawSizeAndRectangles$_(t, s), 
                    i = !0, this._$_backTex$_ = this._$_manager$_._$_GetWebGPUBackTexture$_(t, this._$_drawWidth$_, this._$_drawHeight$_), 
                    tempRect._$copy$_(this._$_drawSurfaceRect$_), tempRect._$roundOuter$_(), 
                    t._$IsWebGPU$_() && t._$_MaybeDoPendingClearRenderPass$_(this._$_destRenderTarget$_), 
                    t._$CopyTextureToTexture$_(this._$_destRenderTarget$_._$GetTexture$_(), this._$_backTex$_, tempRect._$getLeft$_(), tempRect._$getTop$_(), tempRect.width(), tempRect.height())), 
                    this._$_canUseFastPath$_) this._$_Render_FastPath$_(t, s); else if (i || this._$_CalculateDrawSizeAndRectangles$_(t, s), 
                    0 !== this._$_rcTexOriginal$_.width() || 0 !== this._$_rcTexOriginal$_.height()) {
                        t._$SetAlphaBlend$_(), t._$ResetColor$_(), t._$SetBaseZ$_(0), 
                        t._$SetCurrentZ$_(0), this._$_cbDrawContentHook$_ = s._$drawContentHook$_ || null, 
                        this._$_compositOffX$_ = s._$compositOffX$_ || 0, this._$_compositOffY$_ = s._$compositOffY$_ || 0, 
                        this._$_updateOwnProjection$_ = !!s._$updateOwnProjection$_, 
                        this._$_OnBeforeStartEffectChain$_(t), this._$_renderTargets$_[0] = e, 
                        this._$_renderTargets$_[1] = 1 <= this._$_numTempSurfacesRequired$_ ? this._$_GetRenderTarget$_() : null, 
                        this._$_renderTargets$_[2] = 2 === this._$_numTempSurfacesRequired$_ ? this._$_GetRenderTarget$_() : null;
                        for (const r of this._$_steps$_) {
                            const n = this._$_GetRenderTargetForId$_(r._$GetSrcTargetId$_()), h = this._$_GetRenderTargetForId$_(r._$GetDestTargetId$_());
                            t._$IsWebGPU$_() ? r._$Run_WebGPU$_(t, n, h) : r._$Run_WebGL$_(t, n, h);
                        }
                        t._$SetTexture$_(null), this._$_renderTargets$_[1] && this._$_ReleaseRenderTarget$_(this._$_renderTargets$_[1]), 
                        this._$_renderTargets$_[2] && this._$_ReleaseRenderTarget$_(this._$_renderTargets$_[2]), 
                        this._$_renderTargets$_.fill(null), this._$_OnAfterEndEffectChain$_(t), 
                        this._$_destRenderTarget$_ = null, this._$_backTex$_ = null, 
                        this._$_contentObject$_ = null, this._$_contextObject$_ = null, 
                        this._$_cbDrawContentHook$_ = null;
                    }
                }
                _$_CalculateDrawSizeAndRectangles$_(t, e) {
                    const [ s, i ] = this._$_manager$_._$GetDrawSize$_(t);
                    this._$_SetDrawSize$_(t, s, i), this._$_CalculateRectangles$_(e);
                }
                _$_SetDrawSize$_(t, e, s) {
                    if (e <= 0 || s <= 0) throw new Error("invalid draw size");
                    this._$_drawWidth$_ === e && this._$_drawHeight$_ === s || this._$_CalculateDeviceTransformMatrices$_(t, e, s, 0, 0, this._$_projectionMatrix$_, this._$_modelViewMatrix$_), 
                    this._$_drawWidth$_ = e, this._$_drawHeight$_ = s;
                }
                _$_CalculateDeviceTransformMatrices$_(t, e, s, i, r, n, h) {
                    const o = e / 2 + i, a = s / 2 + r, l = (t._$CalculatePerspectiveMatrix$_(n, e / s), 
                    t._$CalculateLookAtModelView2$_(o, a, t._$GetDefaultCameraZ$_(s), o, a, 0, s));
                    mat42._$copy$_(h, l);
                }
                _$_CalculateRectangles$_(t) {
                    this._$_layoutRect$_._$copy$_(t._$layoutRect$_), t._$drawSurfaceRect$_ ? this._$_drawSurfaceRect$_._$copy$_(t._$drawSurfaceRect$_) : this._$_drawSurfaceRect$_.set(0, 0, this._$_drawWidth$_, this._$_drawHeight$_), 
                    this._$_rcTexOriginal$_._$copy$_(this._$_drawSurfaceRect$_), 
                    this._$_rcTexOriginal$_._$divide$_(this._$_drawWidth$_, this._$_drawHeight$_);
                    const e = this._$_layerScale$_ * this._$_devicePixelRatio$_;
                    this._$_drawSurfaceRect$_._$inflate$_(this._$_boxExtendHorizontal$_ * e, this._$_boxExtendVertical$_ * e), 
                    this._$_rcTexDest$_._$copy$_(this._$_drawSurfaceRect$_), this._$_rcTexDest$_._$divide$_(this._$_drawWidth$_, this._$_drawHeight$_), 
                    this._$_drawSurfaceRect$_._$clampBoth$_(0, 0, this._$_drawWidth$_, this._$_drawHeight$_), 
                    this._$_rcTexBounce$_._$copy$_(this._$_drawSurfaceRect$_), this._$_rcTexBounce$_._$divide$_(this._$_drawWidth$_, this._$_drawHeight$_);
                }
                _$_OnBeforeStartEffectChain$_(t) {
                    if (this._$_depthEnabledAtStart$_ = t._$IsDepthEnabled$_(), 
                    this._$_coplanarColorPassAtStart$_ = t._$IsCoplanarColorPass$_(), 
                    this._$_useFullSurface$_) t._$SetDepthEnabled$_(!1), this._$_isAnyShaderDepthSampling$_ && t._$SetDepthSamplingEnabled$_(!0); else {
                        if (tempRect._$copy$_(this._$_drawSurfaceRect$_), t._$IsWebGL$_()) {
                            const e = this._$_layerScale$_ * this._$_devicePixelRatio$_;
                            tempRect._$inflate$_(Math.max(this._$_boxExtendHorizontal$_, 1) * e, Math.max(this._$_boxExtendVertical$_, 1) * e), 
                            tempRect._$roundOuter$_(), tempRect._$clamp$_(0, 0, this._$_drawWidth$_, this._$_drawHeight$_);
                        } else tempRect._$roundOuter$_();
                        t._$SetScissorRect$_(tempRect._$getLeft$_(), tempRect._$getTop$_(), tempRect.width(), tempRect.height(), this._$_drawHeight$_);
                    }
                }
                _$_OnAfterEffectChainDrawContent$_(t) {
                    t._$ResetColor$_(), this._$_useFullSurface$_ || (this._$_coplanarColorPassAtStart$_ && t._$CoplanarRestoreStandardRendering$_(), 
                    t._$SetDepthEnabled$_(!1), this._$_isAnyShaderDepthSampling$_ && t._$SetDepthSamplingEnabled$_(!0)), 
                    t._$IsWebGPU$_() && t._$SetNormalizedCoordsProgramVariant$_(!0);
                }
                _$_OnAfterEndEffectChain$_(t) {
                    t._$SetDepthSamplingEnabled$_(!1), this._$_coplanarColorPassAtStart$_ && t._$CoplanarStartColorPass$_(), 
                    t._$SetDepthEnabled$_(this._$_depthEnabledAtStart$_), this._$_useFullSurface$_ || t._$RemoveScissorRect$_(), 
                    t._$IsWebGPU$_() && t._$SetNormalizedCoordsProgramVariant$_(!1), 
                    this._$_didChangeTransform$_ = t._$DidChangeTransform$_();
                }
                _$_ClampRcTexDest$_() {
                    this._$_rcTexDest$_._$clamp$_(0, 0, 1, 1);
                }
                _$_GetRenderTargetForId$_(t) {
                    return t < 0 ? null : this._$_renderTargets$_[t];
                }
                _$_GetRenderTarget$_() {
                    return this._$_manager$_._$GetRenderTarget$_(this);
                }
                _$_GetDestRenderTarget$_() {
                    return this._$_destRenderTarget$_;
                }
                _$_ReleaseRenderTarget$_(t) {
                    this._$_manager$_._$ReleaseRenderTarget$_(t, this);
                }
                _$_GetShaderProgramAt$_(t) {
                    return this._$_shaderProgramList$_[t];
                }
                _$_DrawContent$_(t) {
                    this._$_cbDrawContentHook$_ ? this._$_cbDrawContentHook$_(this, t, () => this._$_cbDrawContent$_(t, this)) : this._$_cbDrawContent$_(t, this), 
                    this._$_canUseFastPath$_ || this._$_OnAfterEffectChainDrawContent$_(t);
                }
                _$_IsRenderTargetSameSizeAndOffset$_(t) {
                    if (this._$_useFullSurface$_) return !0;
                    if (0 !== this._$_compositOffX$_ || 0 !== this._$_compositOffY$_) return !1;
                    const [ e, s ] = t._$GetRenderTargetSize$_(t._$GetRenderTarget$_());
                    return e === this._$_drawWidth$_ && s === this._$_drawHeight$_;
                }
                _$_SetDeviceTransform$_(t, e) {
                    let s = this._$_projectionMatrix$_, i = this._$_modelViewMatrix$_;
                    if (e && !this._$_IsRenderTargetSameSizeAndOffset$_(t)) {
                        s = tempMat4a, i = tempMat4b;
                        const [ r, n ] = t._$GetRenderTargetSize$_(t._$GetRenderTarget$_());
                        this._$_CalculateDeviceTransformMatrices$_(t, r, n, this._$_compositOffX$_, this._$_compositOffY$_, s, i), 
                        this._$_useFullSurface$_ || t._$RemoveScissorRect$_();
                    }
                    t._$SetProjectionMatrix$_(s), t._$SetModelViewMatrix$_(i);
                }
                _$_Redraw$_() {
                    this._$_manager$_._$Redraw$_(this);
                }
                _$_GetShaderParameters$_(t, e) {
                    return this._$_cbGetShaderParameters$_(this._$_shaderProgramIndices$_[t], e);
                }
                _$_SetProgramParameters$_(t, e) {
                    let s = this._$_rcTexDest$_, i = this._$_rcTexBounce$_, r = this._$_rcTexOriginal$_;
                    t._$IsWebGL$_() && (tempRect2._$copy$_(s), tempRect2._$flipAround$_(1), 
                    s = tempRect2, tempRect3._$copy$_(i), tempRect3._$flipAround$_(1), 
                    i = tempRect3, tempRect4._$copy$_(r), tempRect4._$flipAround$_(1), 
                    r = tempRect4), this._$_DoSetProgramParameters$_(t, e, i, r, s, 1 / this._$_drawWidth$_, 1 / this._$_drawHeight$_);
                }
                _$_SetFirstBounceProgramParameters$_(t, e) {
                    let i = this._$_rcTexBounce$_, r = this._$_rcTexOriginal$_, n = 1 / this._$_drawWidth$_, h = 1 / this._$_drawHeight$_;
                    if (this._$_cbGetSourceTextureInfo$_) {
                        let {
                            _$srcTexRect$_: t,
                            _$srcWidth$_: e,
                            _$srcHeight$_: s
                        } = this._$_cbGetSourceTextureInfo$_(this._$_contentObject$_);
                        t || (tempRect.set(0, 0, 0, 0), t = tempRect), e = e || this._$_drawWidth$_, 
                        s = s || this._$_drawHeight$_, i = t, r = t, n = 1 / e, 
                        h = 1 / s;
                    } else t._$IsWebGL$_() && (tempRect3._$copy$_(i), tempRect3._$flipAround$_(1), 
                    i = tempRect3, tempRect4._$copy$_(r), tempRect4._$flipAround$_(1), 
                    r = tempRect4);
                    let s = this._$_rcTexDest$_;
                    t._$IsWebGL$_() && ((s = tempRect2)._$copy$_(this._$_rcTexDest$_), 
                    s._$flipAround$_(1)), this._$_DoSetProgramParameters$_(t, e, i, r, s, n, h), 
                    t._$IsWebGPU$_() && this._$_isAnyIsSrcTexRotated$_ && t._$SetProgramParameter_IsSrcTexRotated$_(this._$_isSourceTextureRotated$_);
                }
                _$_GetBackTex$_(t) {
                    return this._$_isAnyShaderBackgroundBlending$_ ? t._$IsWebGPU$_() ? this._$_UseCopyTextureBackgroundSampling$_() ? this._$_backTex$_ : this._$_destRenderTarget$_._$GetTexture$_() : this._$_destRenderTarget$_ : null;
                }
                _$_DoSetProgramParameters$_(t, e, s, i, r, n, h) {
                    t._$SetProgramParameters$_(this._$_GetBackTex$_(t), r, s, i, this._$_layoutRect$_, n, h, this._$_devicePixelRatio$_, this._$_layerScale$_, this._$_layerAngle$_, this._$_time$_), 
                    t._$SetProgramCustomParameters$_(this._$_GetShaderParameters$_(e, t));
                }
                _$_Render_FastPath$_(t, e) {
                    const s = this._$_shaderProgramList$_[0], i = t._$IsDepthEnabled$_(), r = s._$UsesDepth$_();
                    r && (t._$SetDepthEnabled$_(!1), t._$SetDepthSamplingEnabled$_(!0), 
                    this._$_rcTexDest$_.set(0, 0, 1, 1), this._$_rcTexOriginal$_.set(0, 0, 1, 1)), 
                    t._$SetProgram$_(s), t._$SetBlendMode$_(this._$_blendMode$_), 
                    t._$SetRenderTarget$_(this._$_destRenderTarget$_);
                    let n = 0, h = 1;
                    if (this._$_rcTexOriginal$_.set(0, 0, 1, 1), s._$UsesAnySrcRectOrPixelSize$_() && this._$_cbGetSourceTextureInfo$_) {
                        const {
                            _$srcTexRect$_: o,
                            _$srcWidth$_: a,
                            _$srcHeight$_: l
                        } = this._$_cbGetSourceTextureInfo$_(this._$_contentObject$_);
                        o && this._$_rcTexOriginal$_._$copy$_(o), n = Number.isFinite(a) ? 1 / a : 0, 
                        h = Number.isFinite(l) ? 1 / l : 0;
                    } else {
                        const [ u, c ] = this._$_manager$_._$GetDrawSize$_(t);
                        n = 1 / u, h = 1 / c;
                    }
                    e._$layoutRect$_ ? this._$_layoutRect$_._$copy$_(e._$layoutRect$_) : this._$_layoutRect$_.set(0, 0, 0, 0), 
                    t._$SetProgramParameters$_(this._$_GetBackTex$_(t), this._$_rcTexDest$_, this._$_rcTexOriginal$_, this._$_rcTexOriginal$_, this._$_layoutRect$_, n, h, this._$_devicePixelRatio$_, this._$_layerScale$_, this._$_layerAngle$_, this._$_time$_), 
                    t._$SetProgramCustomParameters$_(this._$_GetShaderParameters$_(0, t)), 
                    t._$IsWebGPU$_() && this._$_isAnyIsSrcTexRotated$_ && t._$SetProgramParameter_IsSrcTexRotated$_(this._$_isSourceTextureRotated$_), 
                    t._$SetBaseZ$_(0), this._$_DrawContent$_(t), r && (t._$SetDepthSamplingEnabled$_(!1), 
                    t._$SetDepthEnabled$_(i));
                }
                _$_UseCopyTextureBackgroundSampling$_() {
                    return this._$_useCopyTextureBackgroundSampling$_;
                }
                _$_UseRenderTargetBackgroundSampling$_() {
                    return !this._$_useCopyTextureBackgroundSampling$_;
                }
                _$IsAnyShaderBackgroundBlending$_() {
                    return this._$_isAnyShaderBackgroundBlending$_;
                }
                _$CanSkipCalculatingDrawSurfaceRect$_() {
                    return !!this._$_canUseFastPath$_ && !this._$_UseCopyTextureBackgroundSampling$_();
                }
                _$UseFullSurface$_() {
                    return this._$_useFullSurface$_;
                }
                _$GetContentObject$_() {
                    return this._$_contentObject$_;
                }
                _$GetContextObject$_() {
                    return this._$_contextObject$_;
                }
                _$_GetBlendMode$_() {
                    return this._$_blendMode$_;
                }
                _$_UpdateOwnProjection$_() {
                    return this._$_updateOwnProjection$_;
                }
                _$DidChangeTransform$_() {
                    return this._$_didChangeTransform$_;
                }
                _$_GetDrawSurfaceRect$_() {
                    return this._$_drawSurfaceRect$_;
                }
                _$_GetRcTexBounce$_() {
                    return this._$_rcTexBounce$_;
                }
                _$_ShouldInvalidateRenderTargets$_() {
                    return this._$_invalidateRenderTargets$_;
                }
                async _$DebugLogRenderTargetContents$_(t, e, s) {}
            };
        }
        {
            const C33 = self._$C3$_;
            C33._$Gfx$_._$EffectChain$_.Step = class {
                constructor(t, e, s, i = -1) {
                    this._$_effectChain$_ = t, this._$_srcTargetId$_ = e, this._$_destTargetId$_ = s, 
                    this._$_index$_ = i;
                }
                _$GetEffectChain$_() {
                    return this._$_effectChain$_;
                }
                _$GetSrcTargetId$_() {
                    return this._$_srcTargetId$_;
                }
                _$GetDestTargetId$_() {
                    return this._$_destTargetId$_;
                }
                _$GetIndex$_() {
                    return this._$_index$_;
                }
                _$GetShaderProgram$_() {
                    return this._$GetEffectChain$_()._$_GetShaderProgramAt$_(this._$GetIndex$_());
                }
                _$Run_WebGL$_(t, e, s) {}
                _$Run_WebGPU$_(t, e, s) {}
            };
        }
        {
            const C33 = self._$C3$_;
            C33._$Gfx$_._$EffectChain$_.Step._$PreDraw$_ = class extends C33._$Gfx$_._$EffectChain$_.Step {
                constructor(t, e, s, i) {
                    super(t, e, s, i);
                }
                _$Run_WebGL$_(t, e, s) {
                    const i = this._$GetEffectChain$_();
                    t._$SetAlphaBlend$_(), t._$SetTextureFillMode$_(), t._$SetRenderTarget$_(s, i._$_UpdateOwnProjection$_()), 
                    t._$ClearRgba$_(0, 0, 0, 0), i._$_DrawContent$_(t), i._$_ClampRcTexDest$_();
                }
                _$Run_WebGPU$_(t, e, s) {
                    const i = this._$GetEffectChain$_();
                    t._$SetAlphaBlend$_(), t._$SetTextureFillMode$_(), t._$SetRenderTarget$_(s, !1), 
                    t._$ClearRgba$_(0, 0, 0, 0), i._$_DrawContent$_(t), i._$_ClampRcTexDest$_();
                }
            };
        }
        {
            const C33 = self._$C3$_, tempRect = C33._$New$_(C33.Rect), tempQuad = C33._$New$_(C33._$Quad$_);
            C33._$Gfx$_._$EffectChain$_.Step._$PostDraw$_ = class extends C33._$Gfx$_._$EffectChain$_.Step {
                constructor(t, e, s, i) {
                    super(t, e, s, i);
                }
                _$Run_WebGL$_(t, e, s) {
                    const i = this._$GetEffectChain$_();
                    t._$SetTextureFillMode$_(), t._$SetRenderTarget$_(s), i._$_SetDeviceTransform$_(t, !0), 
                    t._$SetBlendMode$_(i._$_GetBlendMode$_()), t._$SetTexture$_(e._$GetTexture$_()), 
                    tempQuad._$setFromRect$_(i._$_GetDrawSurfaceRect$_()), tempRect._$copy$_(i._$_GetRcTexBounce$_()), 
                    tempRect._$flipAround$_(1), t._$Quad3$_(tempQuad, tempRect), 
                    i._$_ShouldInvalidateRenderTargets$_() && t._$InvalidateRenderTarget$_(e);
                }
                _$Run_WebGPU$_(t, e, s) {
                    const i = this._$GetEffectChain$_();
                    t._$SetTextureFillMode$_(), t._$SetRenderTarget$_(s, !1), i._$_IsRenderTargetSameSizeAndOffset$_(t) ? tempQuad._$setFromRect$_(i._$_GetRcTexBounce$_()) : (t._$SetNormalizedCoordsProgramVariant$_(!1), 
                    i._$_SetDeviceTransform$_(t, !0), tempQuad._$setFromRect$_(i._$_GetDrawSurfaceRect$_())), 
                    t._$SetBackTexture$_(null), t._$SetBlendMode$_(i._$_GetBlendMode$_()), 
                    t._$SetTexture$_(e._$GetTexture$_()), i._$UseFullSurface$_() ? t._$FullscreenQuad$_() : t._$Quad3$_(tempQuad, i._$_GetRcTexBounce$_());
                }
            };
        }
        {
            const C33 = self._$C3$_;
            C33._$Gfx$_._$EffectChain$_.Step._$FirstBounce$_ = class extends C33._$Gfx$_._$EffectChain$_.Step {
                constructor(t, e, s, i) {
                    super(t, e, s, i);
                }
                _$Run_WebGL$_(t, e, s) {
                    const i = this._$GetEffectChain$_();
                    t._$SetRenderTarget$_(s, i._$_UpdateOwnProjection$_()), t._$ClearRgba$_(0, 0, 0, 0), 
                    t._$SetCopyBlend$_(), t._$SetProgram$_(this._$GetShaderProgram$_()), 
                    i._$_SetFirstBounceProgramParameters$_(t, this._$GetIndex$_()), 
                    i._$_DrawContent$_(t), i._$_ClampRcTexDest$_();
                }
                _$Run_WebGPU$_(t, e, s) {
                    const i = this._$GetEffectChain$_();
                    t._$SetRenderTarget$_(s, !1), t._$ClearRgba$_(0, 0, 0, 0), t._$SetCopyBlend$_(), 
                    t._$SetProgram$_(this._$GetShaderProgram$_()), i._$_SetFirstBounceProgramParameters$_(t, this._$GetIndex$_()), 
                    i._$_DrawContent$_(t), i._$_ClampRcTexDest$_();
                }
            };
        }
        {
            const C33 = self._$C3$_, tempRect = C33._$New$_(C33.Rect), tempQuad = C33._$New$_(C33._$Quad$_);
            C33._$Gfx$_._$EffectChain$_.Step._$Bounce$_ = class extends C33._$Gfx$_._$EffectChain$_.Step {
                constructor(t, e, s, i) {
                    super(t, e, s, i);
                }
                _$Run_WebGL$_(t, e, s) {
                    const i = this._$GetEffectChain$_(), r = (t._$SetRenderTarget$_(s), 
                    0 === this._$GetDestTargetId$_());
                    r ? t._$SetBlendMode$_(i._$_GetBlendMode$_()) : (t._$ClearRgba$_(0, 0, 0, 0), 
                    t._$SetCopyBlend$_()), t._$SetProgram$_(this._$GetShaderProgram$_()), 
                    i._$_SetProgramParameters$_(t, this._$GetIndex$_()), t._$SetTexture$_(e._$GetTexture$_()), 
                    i._$_SetDeviceTransform$_(t, r), tempQuad._$setFromRect$_(i._$_GetDrawSurfaceRect$_()), 
                    tempRect._$copy$_(i._$_GetRcTexBounce$_()), tempRect._$flipAround$_(1), 
                    t._$Quad3$_(tempQuad, tempRect), i._$_ShouldInvalidateRenderTargets$_() && t._$InvalidateRenderTarget$_(e);
                }
                _$Run_WebGPU$_(t, e, s) {
                    const i = this._$GetEffectChain$_(), r = (t._$SetRenderTarget$_(s, !1), 
                    0 === this._$GetDestTargetId$_());
                    r ? (t._$SetBlendMode$_(i._$_GetBlendMode$_()), t._$SetBackTexture$_(null), 
                    i._$_IsRenderTargetSameSizeAndOffset$_(t) ? tempQuad._$setFromRect$_(i._$_GetRcTexBounce$_()) : (t._$SetNormalizedCoordsProgramVariant$_(!1), 
                    i._$_SetDeviceTransform$_(t, !0), tempQuad._$setFromRect$_(i._$_GetDrawSurfaceRect$_()))) : (t._$ClearRgba$_(0, 0, 0, 0), 
                    t._$SetCopyBlend$_(), tempQuad._$setFromRect$_(i._$_GetRcTexBounce$_())), 
                    t._$SetProgram$_(this._$GetShaderProgram$_()), i._$_SetProgramParameters$_(t, this._$GetIndex$_()), 
                    t._$SetTexture$_(e._$GetTexture$_()), i._$UseFullSurface$_() ? t._$FullscreenQuad$_() : t._$Quad3$_(tempQuad, i._$_GetRcTexBounce$_());
                }
            };
        }
        {
            let SortZOrderList2 = function(t, e) {
                const s = t[0], i = e[0], r = s - i;
                if (0 != r) return r;
                const n = t[1], h = e[1];
                return n - h;
            }, C33 = (SortZOrderList = SortZOrderList2, self._$C3$_), C3X = self._$C3X$_, runtime = null, keysDownByKey = new Set(), tempZOrderList = [], tempInstances = [], didWarnInAlertPolyfill = !1, didWarnFpsDeprecated = !1, VALID_FRAMERATE_MODES = new Set([ "vsync", "unlimited-tick", "unlimited-frame" ]);
            self._$IRuntime$_ = class {
                constructor(t) {
                    runtime = t, Object.defineProperties(this, {
                        _$assets$_: {
                            value: runtime._$GetAssetManager$_()._$GetIAssetManager$_(),
                            writable: !1
                        },
                        _$collisions$_: {
                            value: runtime._$GetCollisionEngine$_()._$GetICollisionEngine$_(),
                            writable: !1
                        },
                        _$objects$_: {
                            value: {},
                            writable: !1
                        },
                        _$globalVars$_: {
                            value: {},
                            writable: !1
                        },
                        _$projectName$_: {
                            value: runtime._$GetProjectName$_(),
                            writable: !1
                        },
                        _$projectVersion$_: {
                            value: runtime._$GetProjectVersion$_(),
                            writable: !1
                        },
                        _$exportDate$_: {
                            value: new Date(runtime._$GetExportTimestamp$_()),
                            writable: !1
                        },
                        storage: {
                            value: new self._$IStorage$_(runtime),
                            writable: !1
                        },
                        isInWorker: {
                            value: runtime._$IsInWorker$_(),
                            writable: !1
                        },
                        _$viewportWidth$_: {
                            value: runtime._$GetOriginalViewportWidth$_(),
                            writable: !1
                        },
                        _$viewportHeight$_: {
                            value: runtime._$GetOriginalViewportHeight$_(),
                            writable: !1
                        },
                        _$sampling$_: {
                            value: runtime._$GetSampling$_(),
                            writable: !1
                        },
                        _$isPixelRoundingEnabled$_: {
                            value: runtime._$IsPixelRoundingEnabled$_(),
                            writable: !1
                        },
                        _$platformInfo$_: {
                            value: new self._$IPlatformInfo$_(t),
                            writable: !1
                        },
                        _$sdk$_: {
                            value: new self._$ISDKUtils$_(t),
                            writable: !1
                        }
                    }), runtime._$UserScriptDispatcher$_().addEventListener("keydown", t => {
                        keysDownByKey.has(t.key) ? t.stopPropagation() : keysDownByKey.add(t.key);
                    }), runtime._$UserScriptDispatcher$_().addEventListener("keyup", t => keysDownByKey.delete(t.key)), 
                    runtime._$Dispatcher$_().addEventListener("window-blur", () => keysDownByKey.clear()), 
                    runtime._$IsInWorker$_() && (self.alert = t => (didWarnInAlertPolyfill || (didWarnInAlertPolyfill = !0, 
                    console.warn("[Construct] alert() was called from a Web Worker, because the project 'Use worker' setting is enabled. This method is not normally available in a Web Worker. Construct has implemented the alert for you, but note that other features may be missing in worker mode. You may wish to disable 'Use worker', or use a more convenient function like console.log(). For more information please refer to the scripting section of the manual.")), 
                    this.alert(t)));
                }
                _$_InitObjects$_(t) {
                    Object.defineProperties(this._$objects$_, t);
                }
                _$_InitGlobalVars$_(t) {
                    Object.defineProperties(this._$globalVars$_, t);
                }
                addEventListener(t, e) {
                    runtime._$UserScriptDispatcher$_().addEventListener(t, e);
                }
                removeEventListener(t, e) {
                    runtime._$UserScriptDispatcher$_().removeEventListener(t, e);
                }
                _$callFunction$_(t, ...e) {
                    C3X._$RequireString$_(t);
                    const s = runtime._$GetEventSheetManager$_(), i = s._$GetFunctionBlockByName$_(t);
                    if (!i) throw new Error(`cannot find function name '${t}'`);
                    if (!i._$IsEnabled$_()) return i._$GetDefaultReturnValue$_();
                    if (e.length < i._$GetFunctionParameterCount$_()) throw new Error(`not enough function parameters passed for '${t}' (${e.length} passed, ${i._$GetFunctionParameterCount$_()} expected)`);
                    let r = i._$GetEventBlock$_(), n = r._$GetSolModifiersIncludingParents$_(), h = s._$GetCurrentEvent$_();
                    if (h) {
                        n = n.slice(0);
                        const a = new Set(n);
                        for (const l of h._$GetSolModifiersIncludingParents$_()) a.has(l) || (n.push(l), 
                        a.add(l));
                        for (const u of s._$GetDynamicSolModifiersSet$_()) a.has(u) || (n.push(u), 
                        a.add(u));
                    }
                    const o = r._$RunAsExpressionFunctionCall$_(n, i._$IsCopyPicked$_(), i._$GetReturnType$_(), i._$GetDefaultReturnValue$_(), ...e);
                    return o;
                }
                _$setReturnValue$_(t) {
                    const e = runtime._$GetEventStack$_()._$GetCurrentExpFuncStackFrame$_();
                    if (!e) throw new Error("not in a function which returns a value");
                    switch (e._$GetFunctionReturnType$_()) {
                      case 1:
                        "number" == typeof t && e._$SetFunctionReturnValue$_(t);
                        break;

                      case 2:
                        "string" == typeof t && e._$SetFunctionReturnValue$_(t);
                        break;

                      case 3:
                        "number" != typeof t && "string" != typeof t || e._$SetFunctionReturnValue$_(t);
                    }
                }
                signal(t) {
                    C3X._$RequireString$_(t), runtime._$GetEventSheetManager$_()._$Signal$_(t);
                }
                _$waitForSignal$_(t) {
                    return C3X._$RequireString$_(t), runtime._$GetEventSheetManager$_()._$WaitForSignal$_(t);
                }
                _$getViewportSize$_() {
                    return [ runtime._$GetOriginalViewportWidth$_(), runtime._$GetOriginalViewportHeight$_() ];
                }
                get isSuspended() {
                    return runtime._$IsSuspended$_();
                }
                get dt() {
                    return runtime._$GetDt$_();
                }
                get _$dtRaw$_() {
                    return runtime._$GetDtRaw$_();
                }
                get gameTime() {
                    return runtime._$GetGameTime$_();
                }
                get _$wallTime$_() {
                    return runtime._$GetWallTime$_();
                }
                get timeScale() {
                    return runtime._$GetTimeScale$_();
                }
                set timeScale(t) {
                    C3X._$RequireFiniteNumber$_(t), runtime._$SetTimeScale$_(t);
                }
                get fps() {
                    return didWarnFpsDeprecated || (console.warn("IRuntime.fps is deprecated. Use IRuntime.framesPerSecond instead."), 
                    didWarnFpsDeprecated = !0), runtime._$GetFramesPerSecond$_();
                }
                get framesPerSecond() {
                    return runtime._$GetFramesPerSecond$_();
                }
                get _$ticksPerSecond$_() {
                    return runtime._$GetTicksPerSecond$_();
                }
                get _$cpuUtilisation$_() {
                    return runtime._$GetMainThreadTime$_();
                }
                get _$gpuUtilisation$_() {
                    return runtime._$GetGPUUtilisation$_();
                }
                get _$framerateMode$_() {
                    return runtime._$GetFramerateMode$_();
                }
                set _$framerateMode$_(t) {
                    if (!VALID_FRAMERATE_MODES.has(t)) throw new Error("invalid framerate mode");
                    runtime._$_SetFramerateMode$_(t);
                }
                get _$minDt$_() {
                    return runtime._$GetMinDt$_();
                }
                set _$minDt$_(t) {
                    C3X._$RequireFiniteNumber$_(t), runtime._$SetMinDt$_(t);
                }
                get _$maxDt$_() {
                    return runtime._$GetMaxDt$_();
                }
                set _$maxDt$_(t) {
                    runtime._$SetMaxDt$_(t);
                }
                get _$loadingProgress$_() {
                    return runtime._$GetAssetManager$_()._$GetLoadProgress$_();
                }
                get _$imageLoadingProgress$_() {
                    return runtime._$GetAssetManager$_()._$GetImageLoadProgress$_();
                }
                random() {
                    return runtime._$Random$_();
                }
                get layout() {
                    const t = runtime._$GetMainRunningLayout$_();
                    if (t) return t._$GetILayout$_();
                    throw new Error("no layout is running - make sure a layout is loaded before accessing");
                }
                _$getLayout$_(t) {
                    let e = runtime._$GetLayoutManager$_(), s = null;
                    if ("number" != typeof t && "string" != typeof t) throw new TypeError("expected string or number");
                    if (s = e._$GetLayout$_(t)) return s._$GetILayout$_();
                    throw new Error("invalid layout");
                }
                _$getAllLayouts$_() {
                    return runtime._$GetLayoutManager$_()._$GetAllLayouts$_().map(t => t._$GetILayout$_());
                }
                _$goToLayout$_(t) {
                    let e = runtime._$GetLayoutManager$_(), s;
                    if ("number" != typeof t && "string" != typeof t) throw new TypeError("expected string or number");
                    if (!(s = e._$GetLayout$_(t))) throw new Error("invalid layout");
                    e._$IsPendingChangeMainLayout$_() || e._$ChangeMainLayout$_(s);
                }
                get keyboard() {
                    const t = runtime._$_GetCommonScriptInterfaces$_().keyboard;
                    if (t) return t;
                    throw new Error("runtime.keyboard used but Keyboard object missing - add it to your project first");
                }
                get _$mouse$_() {
                    const t = runtime._$_GetCommonScriptInterfaces$_()._$mouse$_;
                    if (t) return t;
                    throw new Error("runtime.mouse used but Mouse object missing - add it to your project first");
                }
                get _$touch$_() {
                    const t = runtime._$_GetCommonScriptInterfaces$_()._$touch$_;
                    if (t) return t;
                    throw new Error("runtime.touch used but Touch object missing - add it to your project first");
                }
                get _$timelineController$_() {
                    const t = runtime._$_GetCommonScriptInterfaces$_()._$timelineController$_;
                    if (t) return t;
                    throw new Error("runtime.timelineController used but Timeline Controller object missing - add it to your project first");
                }
                _$invokeDownload$_(t, e) {
                    C3X._$RequireString$_(t), C3X._$RequireString$_(e), runtime._$InvokeDownload$_(t, e);
                }
                _$getInstanceByUid$_(t) {
                    C3X._$RequireFiniteNumber$_(t);
                    const e = runtime._$GetInstanceByUID$_(t);
                    return e ? e._$GetInterfaceClass$_() : null;
                }
                _$sortZOrder$_(t, i) {
                    C3X._$RequireFunction$_(i);
                    const r = runtime._$GetCurrentLayout$_();
                    for (const e of t) {
                        const s = runtime._$_UnwrapIWorldInstance$_(e), n = s._$GetWorldInfo$_();
                        tempZOrderList.push([ n._$GetLayer$_()._$GetIndex$_(), n._$GetZIndex$_() ]), 
                        tempInstances.push(s);
                    }
                    if (0 !== tempZOrderList.length) {
                        tempZOrderList.sort(SortZOrderList2), tempInstances.sort((t, e) => i(t._$GetInterfaceClass$_(), e._$GetInterfaceClass$_()));
                        let s = !1;
                        for (let t = 0, e = tempZOrderList.length; t < e; ++t) {
                            const h = tempInstances[t], o = r._$GetLayerByIndex$_(tempZOrderList[t][0]), a = tempZOrderList[t][1], l = o._$_GetInstances$_();
                            l[a] !== h && ((l[a] = h)._$GetWorldInfo$_()._$_SetLayer$_(o, !0), 
                            o._$SetZIndicesChanged$_(h), s = !0);
                        }
                        s && runtime._$UpdateRender$_(), C33._$clearArray$_(tempZOrderList), 
                        C33._$clearArray$_(tempInstances);
                    }
                }
                async _$createWorker$_(t, e) {
                    const s = new MessageChannel(), i = s.port1, r = s.port2;
                    return await runtime._$PostComponentMessageToDOMAsync$_("runtime", "script-create-worker", {
                        url: t,
                        opts: e,
                        port2: r
                    }, [ r ]), i;
                }
                alert(t) {
                    return runtime._$PostComponentMessageToDOMAsync$_("runtime", "alert", {
                        message: t + (runtime._$IsInWorker$_() ? " [via Web Worker]" : "")
                    });
                }
                _$getHTMLLayer$_(t) {
                    return C3X._$RequireFiniteNumber$_(t), runtime._$_GetHTMLLayerWrapElement$_(t);
                }
                _$addLoadPromise$_(t) {
                    runtime._$AddLoadPromise$_(t);
                }
            };
        }
        {
            let C33 = self._$C3$_, C3X = self._$C3X$_, assetManager = null;
            self._$IAssetManager$_ = class {
                constructor(t) {
                    assetManager = t, Object.defineProperties(this, {
                        _$isWebMOpusSupported$_: {
                            value: !0,
                            writable: !1
                        }
                    });
                }
                _$loadImageAsset$_(t) {
                    const e = self._$IImageInfo$_._$_Unwrap$_(t);
                    if (!e) throw new Error("invalid IImageInfo");
                    e._$LoadAsset$_(assetManager._$GetRuntime$_());
                }
                _$fetchText$_(t) {
                    return assetManager._$FetchText$_(t);
                }
                _$fetchJson$_(t) {
                    return assetManager._$FetchJson$_(t);
                }
                _$fetchBlob$_(t) {
                    return assetManager._$FetchBlob$_(t);
                }
                _$fetchArrayBuffer$_(t) {
                    return assetManager._$FetchArrayBuffer$_(t);
                }
                _$getProjectFileUrl$_(t) {
                    return assetManager._$GetProjectFileUrl$_(t);
                }
                _$getMediaFileUrl$_(t) {
                    return "flat" === assetManager._$GetFileStructure$_() && C33._$IsRelativeURL$_(t) && (t = t.toLowerCase()), 
                    assetManager._$GetMediaFileUrl$_(t);
                }
                get _$mediaFolder$_() {
                    return assetManager._$GetMediaSubfolder$_();
                }
                async _$decodeWebMOpus$_(t, e) {
                    throw new Error("decodeWebMOpus() is no longer supported - use Web Audio's decodeAudioData() directly as all supported platforms now support WebM Opus");
                }
                _$loadScripts$_(...t) {
                    return assetManager._$LoadScripts$_(...t);
                }
                _$compileWebAssembly$_(t) {
                    return assetManager._$CompileWebAssembly$_(t);
                }
                _$loadStyleSheet$_(t) {
                    return assetManager._$LoadStyleSheet$_(t);
                }
            };
        }
        {
            let C33 = self._$C3$_, C3X = self._$C3X$_, collisionEngine = null;
            self._$ICollisionEngine$_ = class {
                constructor(t) {
                    collisionEngine = t, Object.defineProperties(this, {
                        runtime: {
                            value: collisionEngine._$GetRuntime$_(),
                            writable: !1
                        }
                    });
                }
                _$testOverlap$_(t, e) {
                    const s = collisionEngine._$GetRuntime$_(), i = s._$_UnwrapIWorldInstance$_(t), r = s._$_UnwrapIWorldInstance$_(e);
                    return collisionEngine._$TestOverlap$_(i, r);
                }
                _$testOverlapAny$_(t, e) {
                    const s = collisionEngine._$GetRuntime$_(), i = s._$_UnwrapIWorldInstance$_(t);
                    for (const r of e) {
                        const n = s._$_UnwrapIWorldInstance$_(r);
                        if (collisionEngine._$TestOverlap$_(i, n)) return r;
                    }
                    return null;
                }
                _$testOverlapSolid$_(t) {
                    const e = collisionEngine._$GetRuntime$_()._$_UnwrapIWorldInstance$_(t), s = collisionEngine._$TestOverlapSolid$_(e);
                    return s ? s._$GetInterfaceClass$_() : null;
                }
                _$setCollisionCellSize$_(t, e) {
                    if (C3X._$RequireFiniteNumber$_(t), C3X._$RequireFiniteNumber$_(e), 
                    t = Math.floor(t), e = Math.floor(e), t <= 0 || e <= 0) throw new Error("invalid cell size");
                    collisionEngine._$SetCollisionCellSize$_(t, e);
                }
                _$getCollisionCellSize$_() {
                    return collisionEngine._$GetCollisionCellSize$_();
                }
                _$getCollisionCandidates$_(t, e) {
                    let s = collisionEngine._$GetRuntime$_(), i;
                    i = Array.isArray(t) ? t.map(t => s._$_UnwrapIObjectClass$_(t)) : [ s._$_UnwrapIObjectClass$_(t) ];
                    const r = C33.Rect._$FromObject$_(e), n = [];
                    return collisionEngine._$GetObjectClassesCollisionCandidates$_(null, i, r, n), 
                    n.map(t => t._$GetInterfaceClass$_());
                }
            };
        }
        {
            let C33 = self._$C3$_, C3X = self._$C3X$_, runtime = null, osMap = new Map([ [ "Windows", "windows" ], [ "macOS", "macos" ], [ "Linux", "linux" ], [ "Chrome OS", "chrome-os" ], [ "Android", "android" ], [ "iOS", "ios" ] ]), browserMap = new Map([ [ "Chrome", "chrome" ], [ "Chromium", "chromium" ], [ "Edge", "edge" ], [ "Opera", "opera" ], [ "NW.js", "nwjs" ], [ "Firefox", "firefox" ], [ "Safari", "safari" ] ]), browserEngineMap = new Map([ [ "Chromium", "chromium" ], [ "Gecko", "gecko" ], [ "WebKit", "webkit" ] ]);
            self._$IPlatformInfo$_ = class {
                constructor(t) {
                    runtime = t, Object.defineProperties(this, {
                        _$isMobile$_: {
                            value: C33._$Platform$_._$IsMobile$_,
                            writable: !1
                        },
                        _$os$_: {
                            value: osMap.get(C33._$Platform$_._$OS$_) || "unknown",
                            writable: !1
                        },
                        _$osVersion$_: {
                            value: C33._$Platform$_._$OSVersion$_,
                            writable: !1
                        },
                        _$browser$_: {
                            value: browserMap.get(C33._$Platform$_._$Browser$_) || "unknown",
                            writable: !1
                        },
                        _$browserVersion$_: {
                            value: C33._$Platform$_._$BrowserVersion$_,
                            writable: !1
                        },
                        _$browserEngine$_: {
                            value: browserEngineMap.get(C33._$Platform$_._$BrowserEngine$_) || "unknown",
                            writable: !1
                        }
                    });
                }
                get exportType() {
                    let t = runtime._$GetExportType$_();
                    return runtime._$IsNWjs$_() ? t = "nwjs" : runtime._$IsWindowsWebView2$_() ? t = "windows-webview2" : "cordova" === t ? t = "Android" === C33._$Platform$_._$OS$_ ? "cordova-android" : "cordova-ios" : "playable-ad-single-file" !== t && "playable-ad-zip" !== t || (t = "playable-ad"), 
                    t;
                }
                get renderer() {
                    return runtime._$GetCanvasManager$_()._$GetRendererString$_();
                }
                get _$rendererDetail$_() {
                    return runtime._$GetCanvasManager$_()._$GetRendererDetailString$_();
                }
                get _$canvasCssWidth$_() {
                    return runtime._$GetCanvasManager$_()._$GetCssWidth$_();
                }
                get _$canvasCssHeight$_() {
                    return runtime._$GetCanvasManager$_()._$GetCssHeight$_();
                }
                get _$canvasDeviceWidth$_() {
                    return runtime._$GetCanvasManager$_()._$GetDeviceWidth$_();
                }
                get _$canvasDeviceHeight$_() {
                    return runtime._$GetCanvasManager$_()._$GetDeviceHeight$_();
                }
                get devicePixelRatio() {
                    return runtime._$GetDevicePixelRatio$_();
                }
            };
        }
        {
            const C33 = self._$C3$_, C3X = self._$C3X$_;
            self._$IStorage$_ = class {
                constructor(t) {
                    this._$_storage$_ = t._$_GetProjectStorage$_();
                }
                getItem(t) {
                    return C3X._$RequireString$_(t), this._$_storage$_.getItem(t);
                }
                setItem(t, e) {
                    return C3X._$RequireString$_(t), this._$_storage$_.setItem(t, e);
                }
                removeItem(t) {
                    return C3X._$RequireString$_(t), this._$_storage$_.removeItem(t);
                }
                clear() {
                    return this._$_storage$_.clear();
                }
                keys() {
                    return this._$_storage$_.keys();
                }
            };
        }
        {
            const C33 = self._$C3$_, C3X = self._$C3X$_, internalApiToken = C33._$_GetInternalAPIToken$_();
            self._$IPlugin$_ = class {
                #_$#private$_;
                constructor() {
                    const t = C33._$AddonManager$_._$_GetInitObject2$_(internalApiToken);
                    this.#_$#private$_ = t, Object.defineProperties(this, {
                        runtime: {
                            value: t._$GetRuntime$_()._$GetIRuntime$_(),
                            writable: !1
                        },
                        _$isSingleGlobal$_: {
                            value: t._$IsSingleGlobal$_(),
                            writable: !1
                        },
                        _$isWorldType$_: {
                            value: t._$IsWorldType$_(),
                            writable: !1
                        },
                        _$isHTMLElementType$_: {
                            value: t._$IsHTMLElementType$_(),
                            writable: !1
                        },
                        _$isRotatable$_: {
                            value: t._$IsRotatable$_(),
                            writable: !1
                        },
                        _$hasEffects$_: {
                            value: t._$HasEffects$_(),
                            writable: !1
                        },
                        _$is3d$_: {
                            value: t._$Is3D$_(),
                            writable: !1
                        },
                        _$supportsHierarchies$_: {
                            value: t._$SupportsSceneGraph$_(),
                            writable: !1
                        },
                        _$supportsMesh$_: {
                            value: t._$SupportsMesh$_(),
                            writable: !1
                        }
                    });
                }
                static _$getByConstructor$_(t) {
                    if (!t) return null;
                    const e = C33._$AddonManager$_._$GetPluginByConstructorFunction$_(t);
                    return e ? e._$GetIPlugin$_() : null;
                }
                _$getSingleGlobalObjectType$_() {
                    return this.#_$#private$_._$GetSingleGlobalObjectClass$_()._$GetIObjectClass$_();
                }
                _$getSingleGlobalInstance$_() {
                    return this.#_$#private$_._$GetSingleGlobalInstance$_()._$GetInterfaceClass$_();
                }
            };
        }
        {
            const C33 = self._$C3$_, C3X = self._$C3X$_, internalApiToken = C33._$_GetInternalAPIToken$_();
            self._$IObjectClass$_ = class {
                #_$#private$_;
                constructor() {
                    const t = C33._$AddonManager$_._$_GetInitObject2$_(internalApiToken);
                    this.#_$#private$_ = t, Object.defineProperties(this, {
                        name: {
                            value: t._$GetName$_(),
                            writable: !1
                        },
                        runtime: {
                            value: t._$GetRuntime$_()._$GetIRuntime$_(),
                            writable: !1
                        },
                        _$plugin$_: {
                            value: t._$GetPlugin$_()._$GetIPlugin$_(),
                            writable: !1
                        }
                    }), t._$GetRuntime$_()._$_MapScriptInterface$_(this, t);
                }
                addEventListener(t, e) {
                    C3X._$RequireString$_(t), C3X._$RequireFunction$_(e), this.#_$#private$_._$UserScriptDispatcher$_().addEventListener(t, e);
                }
                removeEventListener(t, e) {
                    C3X._$RequireString$_(t), C3X._$RequireFunction$_(e), this.#_$#private$_._$UserScriptDispatcher$_().removeEventListener(t, e);
                }
                _$getAllInstances$_() {
                    return [ ...this.instances() ];
                }
                _$getFirstInstance$_() {
                    return C33.first(this.instances());
                }
                _$getPickedInstances$_() {
                    return [ ...this._$pickedInstances$_() ];
                }
                _$getFirstPickedInstance$_() {
                    return C33.first(this._$pickedInstances$_());
                }
                _$getPairedInstance$_(t) {
                    const e = this.#_$#private$_, s = e._$GetRuntime$_()._$_UnwrapIInstance$_(t), i = e._$GetPairedInstance$_(s);
                    return i ? i._$GetInterfaceClass$_() : null;
                }
                *instances() {
                    for (const t of this.#_$#private$_._$instancesIncludingPendingCreate$_()) yield t._$GetInterfaceClass$_();
                }
                *_$pickedInstances$_() {
                    for (const t of this.#_$#private$_._$GetCurrentSol$_()._$GetInstances$_()) yield t._$GetInterfaceClass$_();
                }
                _$setInstanceClass$_(t) {
                    C3X._$RequireFunction$_(t);
                    const e = this.#_$#private$_;
                    if (0 < e._$GetInstanceCount$_()) throw new Error("setInstanceClass() called too late, because instances have already been created - call in runOnStartup");
                    e._$_SetUserScriptInstanceClass$_(t);
                }
                _$createInstance$_(t, e, s, i, r) {
                    if (C3X._$RequireNumber$_(e), C3X._$RequireNumber$_(s), "number" != typeof t && "string" != typeof t) throw new TypeError("invalid layer parameter");
                    const n = this.#_$#private$_, h = n._$GetRuntime$_(), o = h._$GetMainRunningLayout$_()._$GetLayer$_(t);
                    if (!o) throw new Error("invalid layer");
                    const a = h._$CreateInstance$_(n, o, e, s, i, r), l = (i && o._$SortAndAddInstancesByZIndex$_(a), 
                    h._$GetEventSheetManager$_());
                    return l._$BlockFlushingInstances$_(!0), a._$_TriggerOnCreatedOnSelfAndRelated$_(), 
                    l._$BlockFlushingInstances$_(!1), l._$IsInEventEngine$_() || h._$GetLayoutManager$_()._$IsEndingLayout$_() || h._$FlushPendingInstances$_(), 
                    a._$GetInterfaceClass$_();
                }
            };
        }
        {
            const C33 = self._$C3$_, C3X = self._$C3X$_, map = new WeakMap(), VALID_WHERE_STRINGS = [ "above", "below", "top-sublayer", "bottom-sublayer" ];
            self._$ILayout$_ = class {
                constructor(t) {
                    map.set(this, t);
                    const e = [], s = t._$GetEffectList$_(), i = s._$GetAllEffectTypes$_().length;
                    for (let t = 0; t < i; ++t) e.push(new self._$IEffectInstance$_(s, t));
                    Object.defineProperties(this, {
                        name: {
                            value: t._$GetName$_(),
                            writable: !1
                        },
                        index: {
                            value: t._$GetIndex$_(),
                            writable: !1
                        },
                        effects: {
                            value: e,
                            writable: !1
                        }
                    });
                }
                addEventListener(t, e) {
                    C3X._$RequireString$_(t), C3X._$RequireFunction$_(e), map.get(this)._$UserScriptDispatcher$_().addEventListener(t, e);
                }
                removeEventListener(t, e) {
                    C3X._$RequireString$_(t), C3X._$RequireFunction$_(e), map.get(this)._$UserScriptDispatcher$_().removeEventListener(t, e);
                }
                get width() {
                    return map.get(this)._$GetWidth$_();
                }
                set width(t) {
                    C3X._$RequireFiniteNumber$_(t), map.get(this)._$SetWidth$_(t);
                }
                get height() {
                    return map.get(this)._$GetHeight$_();
                }
                set height(t) {
                    C3X._$RequireFiniteNumber$_(t), map.get(this)._$SetHeight$_(t);
                }
                _$setSize$_(t, e) {
                    C3X._$RequireFiniteNumber$_(t), C3X._$RequireFiniteNumber$_(e);
                    const s = map.get(this);
                    s._$SetWidth$_(t), s._$SetHeight$_(e);
                }
                getSize() {
                    const t = map.get(this);
                    return [ t._$GetWidth$_(), t._$GetHeight$_() ];
                }
                set scale(t) {
                    C3X._$RequireFiniteNumber$_(t), map.get(this)._$SetScale$_(t);
                }
                get scale() {
                    return map.get(this)._$GetScale$_();
                }
                set angle(t) {
                    C3X._$RequireFiniteNumber$_(t), map.get(this)._$SetAngle$_(t);
                }
                get angle() {
                    return map.get(this).GetAngle();
                }
                set scrollX(t) {
                    C3X._$RequireNumber$_(t), map.get(this)._$SetScrollX$_(t);
                }
                get scrollX() {
                    return map.get(this)._$GetScrollX$_();
                }
                set scrollY(t) {
                    C3X._$RequireNumber$_(t), map.get(this)._$SetScrollY$_(t);
                }
                get scrollY() {
                    return map.get(this)._$GetScrollY$_();
                }
                scrollTo(t, e) {
                    C3X._$RequireNumber$_(t), C3X._$RequireNumber$_(e);
                    const s = map.get(this);
                    s._$SetScrollX$_(t), s._$SetScrollY$_(e);
                }
                _$getScrollPosition$_() {
                    const t = map.get(this);
                    return [ t._$GetScrollX$_(), t._$GetScrollY$_() ];
                }
                _$getLayer$_(t) {
                    let e = map.get(this), s = null;
                    if ("number" != typeof t && "string" != typeof t) throw new TypeError("expected string or number");
                    return (s = e._$GetLayer$_(t)) ? s._$GetILayer$_() : null;
                }
                _$getAllLayers$_() {
                    return map.get(this)._$GetLayers$_().map(t => t._$GetILayer$_());
                }
                *_$allLayers$_() {
                    for (const t of map.get(this)._$allLayers$_()) yield t._$GetILayer$_();
                }
                _$addLayer$_(t, e, s) {
                    const i = map.get(this), r = self._$ILayer$_, n = (C3X._$RequireString$_(t), 
                    C3X._$RequireOptionalInstanceOf$_(e, r), e ? i._$GetRuntime$_()._$_UnwrapScriptInterface$_(e) : null), h = VALID_WHERE_STRINGS.indexOf(s);
                    if (h < 0) throw new Error("invalid location");
                    i._$AddLayer$_(t, n, h);
                }
                _$moveLayer$_(t, e, s) {
                    const i = map.get(this), r = i._$GetRuntime$_(), n = self._$ILayer$_, h = (C3X._$RequireInstanceOf$_(t, n), 
                    r._$_UnwrapScriptInterface$_(t));
                    if (!h) throw new Error("invalid layer");
                    C3X._$RequireOptionalInstanceOf$_(e, n);
                    const o = e ? r._$_UnwrapScriptInterface$_(e) : null, a = VALID_WHERE_STRINGS.indexOf(s);
                    if (a < 0) throw new Error("invalid location");
                    i._$MoveLayer$_(h, o, a);
                }
                _$removeLayer$_(t) {
                    const e = map.get(this), s = self._$ILayer$_, i = (C3X._$RequireInstanceOf$_(t, s), 
                    e._$GetRuntime$_()._$_UnwrapScriptInterface$_(t));
                    if (!i) throw new Error("invalid layer");
                    const r = i._$GetRuntime$_();
                    e._$RemoveLayer$_(i), r._$GetEventSheetManager$_()._$IsInEventEngine$_() || r._$FlushPendingInstances$_();
                }
                _$removeAllDynamicLayers$_() {
                    const t = map.get(this), e = t._$GetRuntime$_();
                    t._$RemoveAllDynamicLayers$_(), e._$GetEventSheetManager$_()._$IsInEventEngine$_() || e._$FlushPendingInstances$_();
                }
                _$setVanishingPoint$_(t, e) {
                    C3X._$RequireFiniteNumber$_(t), C3X._$RequireFiniteNumber$_(e), 
                    map.get(this)._$SetVanishingPointXY$_(t, e);
                }
                _$getVanishingPoint$_() {
                    return map.get(this)._$_GetVanishingPoint$_();
                }
                set _$projection$_(t) {
                    C3X._$RequireString$_(t);
                    const e = map.get(this);
                    if ("perspective" === t) e._$SetPerspectiveProjection$_(); else {
                        if ("orthographic" !== t) throw new Error("invalid projection");
                        e._$SetOrthographicProjection$_();
                    }
                }
                get _$projection$_() {
                    return map.get(this)._$IsOrthographicProjection$_() ? "orthographic" : "perspective";
                }
            };
        }
        {
            const C33 = self._$C3$_, C3X = self._$C3X$_, map = new WeakMap(), BLEND_MODE_TO_INDEX = new Map([ [ "normal", 0 ], [ "additive", 1 ], [ "copy", 3 ], [ "destination-over", 4 ], [ "source-in", 5 ], [ "destination-in", 6 ], [ "source-out", 7 ], [ "destination-out", 8 ], [ "source-atop", 9 ], [ "destination-atop", 10 ] ]), INDEX_TO_BLEND_MODE = new Map([ ...BLEND_MODE_TO_INDEX.entries() ].map(t => [ t[1], t[0] ])), tempColor = C33._$New$_(C33._$Color$_);
            self._$ILayer$_ = class {
                constructor(t) {
                    map.set(this, t);
                    const e = [], s = t._$GetEffectList$_(), i = s._$GetAllEffectTypes$_().length;
                    for (let t = 0; t < i; ++t) e.push(new self._$IEffectInstance$_(s, t));
                    Object.defineProperties(this, {
                        name: {
                            value: t._$GetName$_(),
                            writable: !1
                        },
                        layout: {
                            value: t._$GetLayout$_()._$GetILayout$_(),
                            writable: !1
                        },
                        effects: {
                            value: e,
                            writable: !1
                        }
                    }), t._$GetRuntime$_()._$_MapScriptInterface$_(this, t);
                }
                get _$parentLayer$_() {
                    const t = map.get(this)._$GetParentLayer$_();
                    return t ? t._$GetILayer$_() : null;
                }
                *_$parentLayers$_() {
                    for (const t of map.get(this)._$parentLayers$_()) yield t._$GetILayer$_();
                }
                *_$subLayers$_() {
                    for (const t of map.get(this)._$GetSubLayers$_()) yield t._$GetILayer$_();
                }
                *_$allSubLayers$_() {
                    for (const t of map.get(this)._$GetSubLayers$_()) for (const e of t._$selfAndAllSubLayers$_()) yield e._$GetILayer$_();
                }
                get index() {
                    return map.get(this)._$GetIndex$_();
                }
                get isVisible() {
                    return map.get(this)._$_IsVisibleFlagSet$_();
                }
                set isVisible(t) {
                    map.get(this)._$SetVisible$_(t);
                }
                get _$isSelfAndParentsVisible$_() {
                    return map.get(this)._$IsVisible$_();
                }
                get isInteractive() {
                    return map.get(this)._$IsInteractive$_();
                }
                set isInteractive(t) {
                    map.get(this)._$SetInteractive$_(t);
                }
                get _$isHTMLElementsLayer$_() {
                    return map.get(this)._$IsHTMLElementsLayer$_();
                }
                set _$isHTMLElementsLayer$_(t) {
                    map.get(this)._$SetIsHTMLElementsLayer$_(!!t);
                }
                get _$isSelfAndParentsInteractive$_() {
                    return map.get(this)._$IsSelfAndParentsInteractive$_();
                }
                get opacity() {
                    return map.get(this)._$GetOpacity$_();
                }
                set opacity(t) {
                    t = C33._$clamp$_(+t, 0, 1), isNaN(t) || map.get(this)._$SetOpacity$_(t);
                }
                set scale(t) {
                    C3X._$RequireFiniteNumber$_(t), map.get(this)._$SetOwnScale$_(t);
                }
                get scale() {
                    return map.get(this)._$GetOwnScale$_();
                }
                set scaleRate(t) {
                    C3X._$RequireFiniteNumber$_(t), map.get(this)._$SetScaleRate$_(t);
                }
                get scaleRate() {
                    return map.get(this)._$GetScaleRate$_();
                }
                set angle(t) {
                    C3X._$RequireFiniteNumber$_(t), map.get(this)._$SetAngle$_(t);
                }
                get angle() {
                    return map.get(this)._$GetOwnAngle$_();
                }
                set parallaxX(t) {
                    C3X._$RequireFiniteNumber$_(t), map.get(this)._$SetParallaxX$_(t);
                }
                get parallaxX() {
                    return map.get(this)._$GetParallaxX$_();
                }
                set parallaxY(t) {
                    C3X._$RequireFiniteNumber$_(t), map.get(this)._$SetParallaxY$_(t);
                }
                get parallaxY() {
                    return map.get(this)._$GetParallaxY$_();
                }
                set _$zElevation$_(t) {
                    C3X._$RequireFiniteNumber$_(t), map.get(this)._$SetZElevation$_(t);
                }
                get _$zElevation$_() {
                    return map.get(this)._$GetZElevation$_();
                }
                set _$isTransparent$_(t) {
                    map.get(this)._$SetTransparent$_(t);
                }
                get _$isTransparent$_() {
                    return map.get(this)._$IsTransparent$_();
                }
                set _$isForceOwnTexture$_(t) {
                    map.get(this)._$SetForceOwnTexture$_(t);
                }
                get _$isForceOwnTexture$_() {
                    return map.get(this)._$IsForceOwnTexture$_();
                }
                set _$blendMode$_(t) {
                    C3X._$RequireString$_(t);
                    const e = BLEND_MODE_TO_INDEX.get(t);
                    if ("number" != typeof e) throw new Error("invalid blend mode");
                    map.get(this)._$SetBlendMode$_(e);
                }
                get _$blendMode$_() {
                    return INDEX_TO_BLEND_MODE.get(map.get(this)._$GetBlendMode$_());
                }
                set backgroundColor(t) {
                    if (C3X._$RequireArray$_(t), t.length < 3) throw new Error("expected 3 elements");
                    tempColor._$setRgb$_(t[0], t[1], t[2]);
                    const e = map.get(this), s = e._$GetBackgroundColor$_();
                    s._$equalsIgnoringAlpha$_(tempColor) || (s._$copyRgb$_(tempColor), 
                    e._$GetRuntime$_()._$UpdateRender$_());
                }
                get backgroundColor() {
                    const t = map.get(this)._$GetBackgroundColor$_();
                    return [ t._$getR$_(), t._$getG$_(), t._$getB$_() ];
                }
                set scrollX(t) {
                    C3X._$RequireNumber$_(t);
                    const e = map.get(this);
                    e._$SetOwnScrollPositionEnabled$_(!0), e._$SetScrollX$_(t);
                }
                get scrollX() {
                    return map.get(this)._$GetScrollX$_();
                }
                set scrollY(t) {
                    C3X._$RequireNumber$_(t);
                    const e = map.get(this);
                    e._$SetOwnScrollPositionEnabled$_(!0), e._$SetScrollY$_(t);
                }
                get scrollY() {
                    return map.get(this)._$GetScrollY$_();
                }
                scrollTo(t, e) {
                    C3X._$RequireNumber$_(t), C3X._$RequireNumber$_(e);
                    const s = map.get(this);
                    s._$SetOwnScrollPositionEnabled$_(!0), s._$SetScrollX$_(t), 
                    s._$SetScrollY$_(e);
                }
                _$getScrollPosition$_() {
                    const t = map.get(this);
                    return [ t._$GetScrollX$_(), t._$GetScrollY$_() ];
                }
                _$restoreScrollPosition$_() {
                    map.get(this)._$SetOwnScrollPositionEnabled$_(!1);
                }
                getViewport() {
                    return map.get(this)._$GetViewport$_()._$toDOMRect$_();
                }
                _$cssPxToLayer$_(t, e, s = 0) {
                    C3X._$RequireNumber$_(t), C3X._$RequireNumber$_(e), C3X._$RequireNumber$_(s);
                    const i = map.get(this), r = i._$GetRuntime$_();
                    return i._$CanvasCssToLayer$_(t - r._$GetCanvasClientX$_(), e - r._$GetCanvasClientY$_(), s);
                }
                _$layerToCssPx$_(t, e, s = 0) {
                    C3X._$RequireNumber$_(t), C3X._$RequireNumber$_(e), C3X._$RequireNumber$_(s);
                    const i = map.get(this), r = i._$GetRuntime$_(), [ n, h ] = i._$LayerToCanvasCss$_(t, e, s);
                    return [ n + r._$GetCanvasClientX$_(), h + r._$GetCanvasClientY$_() ];
                }
                _$drawSurfaceToLayer$_(t, e, s = 0) {
                    return C3X._$RequireNumber$_(t), C3X._$RequireNumber$_(e), C3X._$RequireNumber$_(s), 
                    map.get(this)._$DrawSurfaceToLayer$_(t, e, s);
                }
                _$layerToDrawSurface$_(t, e, s = 0) {
                    return C3X._$RequireNumber$_(t), C3X._$RequireNumber$_(e), C3X._$RequireNumber$_(s), 
                    map.get(this)._$LayerToDrawSurface$_(t, e, s);
                }
                get _$renderScale$_() {
                    return map.get(this)._$GetRenderScale$_();
                }
            };
        }
        {
            let GetDispatcher2 = function(t) {
                let e = dispatchers.get(t);
                return e || (e = C33._$New$_(C33.Event._$Dispatcher$_), dispatchers.set(t, e)), 
                e;
            };
            GetDispatcher = GetDispatcher2;
            const C33 = self._$C3$_, C3X = self._$C3X$_, dispatchers = new WeakMap(), internalApiToken = C33._$_GetInternalAPIToken$_();
            self._$IInstance$_ = class {
                #_$#private$_;
                constructor() {
                    const t = C33._$AddonManager$_._$_GetInitObject2$_(internalApiToken), e = {
                        runtime: {
                            value: (this.#_$#private$_ = t)._$GetRuntime$_()._$GetIRuntime$_(),
                            writable: !1
                        },
                        _$objectType$_: {
                            value: t._$GetObjectClass$_()._$GetIObjectClass$_(),
                            writable: !1
                        },
                        _$plugin$_: {
                            value: t._$GetPlugin$_()._$GetIPlugin$_(),
                            writable: !1
                        }
                    };
                    t._$_GetInstVarsScriptDescriptor$_(e), t._$_GetBehaviorsScriptDescriptor$_(e), 
                    Object.defineProperties(this, e), t._$GetRuntime$_()._$_MapScriptInterface$_(this, t);
                }
                static _$_GetInitInst$_() {
                    return C33._$AddonManager$_._$_GetInitObject$_();
                }
                _$_release$_() {
                    const t = dispatchers.get(this);
                    t && (t._$Release$_(), dispatchers.delete(this));
                }
                addEventListener(t, e, s) {
                    C3X._$RequireString$_(t), C3X._$RequireFunction$_(e), GetDispatcher2(this).addEventListener(t, e, s);
                }
                removeEventListener(t, e, s) {
                    C3X._$RequireString$_(t), C3X._$RequireFunction$_(e), GetDispatcher2(this).removeEventListener(t, e, s);
                }
                dispatchEvent(t) {
                    GetDispatcher2(this).dispatchEvent(t);
                }
                destroy() {
                    const t = this.#_$#private$_, e = t._$GetRuntime$_();
                    e._$DestroyInstance$_(t), e._$GetEventSheetManager$_()._$IsInEventEngine$_() || e._$GetLayoutManager$_()._$IsEndingLayout$_() || e._$GetEventSheetManager$_()._$IsFlushingBlocked$_() || e._$FlushPendingInstances$_();
                }
                _$getOtherContainerInstances$_() {
                    const t = this.#_$#private$_._$GetSiblings$_();
                    return t ? t.map(t => t._$GetInterfaceClass$_()) : [];
                }
                *_$otherContainerInstances$_() {
                    const t = this.#_$#private$_;
                    if (t._$IsInContainer$_()) for (const e of t._$siblings$_()) yield e._$GetInterfaceClass$_();
                }
                get uid() {
                    return this.#_$#private$_._$GetUID$_();
                }
                get _$templateName$_() {
                    return this.#_$#private$_._$GetTemplateName$_();
                }
                set timeScale(t) {
                    C3X._$RequireFiniteNumber$_(t), this.#_$#private$_._$SetTimeScale$_(t);
                }
                get timeScale() {
                    return this.#_$#private$_._$GetActiveTimeScale$_();
                }
                _$restoreTimeScale$_() {
                    this.#_$#private$_._$RestoreTimeScale$_();
                }
                get dt() {
                    const t = this.#_$#private$_;
                    return t._$GetRuntime$_()._$GetDt$_(t);
                }
                _$hasTags$_(...t) {
                    C3X._$RequireArray$_(t);
                    const e = new Set(t), s = this.#_$#private$_._$GetTagsSet$_();
                    return e._$isSubsetOf$_(s);
                }
                _$setAllTags$_(t) {
                    C3X._$RequireInstanceOf$_(t, Set), this.#_$#private$_._$SetTagsSet$_(t);
                }
                _$getAllTags$_() {
                    return new Set(this.#_$#private$_._$GetTagsSet$_());
                }
                signal(t) {
                    C3X._$RequireString$_(t);
                    const e = this.#_$#private$_;
                    e._$GetRuntime$_()._$GetEventSheetManager$_()._$InstanceSignal$_(e, t);
                }
                _$waitForSignal$_(t) {
                    C3X._$RequireString$_(t);
                    const e = this.#_$#private$_;
                    return e._$GetRuntime$_()._$GetEventSheetManager$_()._$WaitForInstanceSignal$_(e, t);
                }
            };
        }
        {
            const C33 = self._$C3$_, C3X = self._$C3X$_, internalApiToken = C33._$_GetInternalAPIToken$_();
            self._$ISDKInstanceBase$_ = class extends self._$IInstance$_ {
                #_$#private$_;
                #_$#isTicking$_ = !1;
                #_$#tickFunc$_ = null;
                #_$#isTicking2$_ = !1;
                #_$#tickFunc2$_ = null;
                #_$#domComponentId$_;
                #_$#wrapperComponentId$_;
                constructor(t) {
                    super(), this.#_$#private$_ = C33._$AddonManager$_._$_GetInitObject2$_(internalApiToken), 
                    this.#_$#isTicking$_ = !1, this.#_$#tickFunc$_ = null, this.#_$#isTicking2$_ = !1, 
                    this.#_$#tickFunc2$_ = null, this.#_$#domComponentId$_ = t?.domComponentId, 
                    this.#_$#wrapperComponentId$_ = t?.wrapperComponentId;
                }
                _$_release$_() {
                    this._$_setTicking$_(!1), this._$_setTicking2$_(!1), super._$_release$_();
                }
                _$_getInitProperties$_() {
                    return C33._$AddonManager$_._$_GetInitProperties$_();
                }
                _$_trigger$_(t) {
                    const e = this.#_$#private$_;
                    e._$GetRuntime$_()._$Trigger$_(t, e);
                }
                _$_triggerAsync$_(t) {
                    const e = this.#_$#private$_;
                    return e._$GetRuntime$_()._$TriggerAsync$_(t, e);
                }
                _$_addDOMMessageHandler$_(t, e) {
                    if (C3X._$RequireString$_(t), C3X._$RequireFunction$_(e), !this.#_$#domComponentId$_) throw new Error("no DOM component id set");
                    const s = this.#_$#private$_._$GetRuntime$_();
                    s._$AddDOMComponentMessageHandler$_(this.#_$#domComponentId$_, t, e);
                }
                _$_addDOMMessageHandlers$_(t) {
                    C3X._$RequireArray$_(t);
                    for (const [ e, s ] of t) this._$_addDOMMessageHandler$_(e, s);
                }
                _$_postToDOM$_(t, e) {
                    if (C3X._$RequireString$_(t), !this.#_$#domComponentId$_) throw new Error("no DOM component id set");
                    const s = this.#_$#private$_._$GetRuntime$_();
                    s._$PostComponentMessageToDOM$_(this.#_$#domComponentId$_, t, e);
                }
                _$_postToDOMAsync$_(t, e) {
                    if (C3X._$RequireString$_(t), !this.#_$#domComponentId$_) throw new Error("no DOM component id set");
                    const s = this.#_$#private$_._$GetRuntime$_();
                    return s._$PostComponentMessageToDOMAsync$_(this.#_$#domComponentId$_, t, e);
                }
                _$_postToDOMMaybeSync$_(t, e) {
                    const s = this.#_$#private$_._$GetRuntime$_();
                    if (!s._$IsInWorker$_()) return window.c3_runtimeInterface._OnMessageFromRuntime({
                        type: "event",
                        component: this.#_$#domComponentId$_,
                        handler: t,
                        data: e,
                        responseId: null
                    });
                    this._$_postToDOM$_(t, e);
                }
                _$_setTicking$_(t) {
                    if (this.#_$#isTicking$_ !== (t = !!t)) {
                        this.#_$#isTicking$_ = t;
                        const e = this.#_$#private$_._$GetRuntime$_();
                        t ? (this.#_$#tickFunc$_ || (this.#_$#tickFunc$_ = () => this._$_tick$_()), 
                        e._$Dispatcher$_().addEventListener("tick", this.#_$#tickFunc$_)) : e._$Dispatcher$_().removeEventListener("tick", this.#_$#tickFunc$_);
                    }
                }
                _$_isTicking$_() {
                    return this.#_$#isTicking$_;
                }
                _$_tick$_() {}
                _$_setTicking2$_(t) {
                    if (this.#_$#isTicking2$_ !== (t = !!t)) {
                        this.#_$#isTicking2$_ = t;
                        const e = this.#_$#private$_._$GetRuntime$_();
                        t ? (this.#_$#tickFunc2$_ || (this.#_$#tickFunc2$_ = () => this._$_tick2$_()), 
                        e._$Dispatcher$_().addEventListener("tick2", this.#_$#tickFunc2$_)) : e._$Dispatcher$_().removeEventListener("tick2", this.#_$#tickFunc2$_);
                    }
                }
                _$_isTicking2$_() {
                    return this.#_$#isTicking2$_;
                }
                _$_tick2$_() {}
                _$_getDebuggerProperties$_() {
                    return [];
                }
                _$_saveToJson$_() {
                    return null;
                }
                _$_loadFromJson$_(t) {}
                _$_isWrapperExtensionAvailable$_() {
                    if (!this.#_$#wrapperComponentId$_) throw new Error("no wrapper component id set");
                    const t = this.#_$#private$_._$GetRuntime$_();
                    return t._$HasWrapperComponentId$_(this.#_$#wrapperComponentId$_);
                }
                _$_addWrapperExtensionMessageHandler$_(t, e) {
                    if (C3X._$RequireString$_(t), C3X._$RequireFunction$_(e), !this.#_$#wrapperComponentId$_) throw new Error("no wrapper component id set");
                    const s = this.#_$#private$_._$GetRuntime$_();
                    s._$AddWrapperExtensionMessageHandler$_(this.#_$#wrapperComponentId$_, t, e);
                }
                _$_addWrapperMessageHandlers$_(t) {
                    C3X._$RequireArray$_(t);
                    for (const [ e, s ] of t) this._$_addWrapperExtensionMessageHandler$_(e, s);
                }
                _$_sendWrapperExtensionMessage$_(t, e) {
                    if (!this.#_$#wrapperComponentId$_) throw new Error("no wrapper component id set");
                    this.runtime._$sdk$_._$sendWrapperExtensionMessage$_(this.#_$#wrapperComponentId$_, t, e);
                }
                _$_sendWrapperExtensionMessageAsync$_(t, e) {
                    if (this.#_$#wrapperComponentId$_) return this.runtime._$sdk$_._$sendWrapperExtensionMessageAsync$_(this.#_$#wrapperComponentId$_, t, e);
                    throw new Error("no wrapper component id set");
                }
            };
        }
        {
            let MakeIWorldInstanceClass2 = function(t) {
                return class r extends t {
                    #_$#privateInst$_;
                    #_$#privateWi$_;
                    constructor(t) {
                        super(t);
                        const e = C33._$AddonManager$_._$_GetInitObject2$_(internalApiToken), s = e._$GetWorldInfo$_(), i = (this.#_$#privateInst$_ = e, 
                        this.#_$#privateWi$_ = s, map.set(this, e), []), r = s._$GetInstanceEffectList$_();
                        if (r) {
                            const h = s._$GetObjectClass$_()._$GetEffectList$_()._$GetAllEffectTypes$_().length;
                            for (let t = 0; t < h; ++t) i.push(new self._$IEffectInstance$_(r, t));
                        }
                        const n = {
                            effects: {
                                value: i,
                                writable: !1
                            }
                        };
                        Object.defineProperties(this, n);
                    }
                    get layout() {
                        return this.#_$#privateWi$_._$GetLayout$_()._$GetILayout$_();
                    }
                    get _$layer$_() {
                        return this.#_$#privateWi$_._$GetLayer$_()._$GetILayer$_();
                    }
                    get x() {
                        return this.#_$#privateWi$_._$GetX$_();
                    }
                    set x(t) {
                        t = +t;
                        const e = this.#_$#privateWi$_;
                        isNaN(t) || e._$GetX$_() === t || (e._$SetX$_(t), e._$SetBboxChanged$_());
                    }
                    get y() {
                        return this.#_$#privateWi$_._$GetY$_();
                    }
                    set y(t) {
                        t = +t;
                        const e = this.#_$#privateWi$_;
                        isNaN(t) || e._$GetY$_() === t || (e._$SetY$_(t), e._$SetBboxChanged$_());
                    }
                    setPosition(t, e) {
                        t = +t, e = +e;
                        const s = this.#_$#privateWi$_;
                        isNaN(t) || isNaN(e) || s._$GetX$_() === t && s._$GetY$_() === e || (s._$SetXY$_(t, e), 
                        s._$SetBboxChanged$_());
                    }
                    _$getPosition$_() {
                        const t = this.#_$#privateWi$_;
                        return [ t._$GetX$_(), t._$GetY$_() ];
                    }
                    _$offsetPosition$_(t, e) {
                        if (t = +t, e = +e, !(isNaN(t) || isNaN(e) || 0 === t && 0 === e)) {
                            const s = this.#_$#privateWi$_;
                            s._$OffsetXY$_(t, e), s._$SetBboxChanged$_();
                        }
                    }
                    get _$zElevation$_() {
                        return this.#_$#privateWi$_._$GetZElevation$_();
                    }
                    set _$zElevation$_(t) {
                        t = +t;
                        const e = this.#_$#privateInst$_, s = this.#_$#privateWi$_;
                        isNaN(t) || s._$GetZElevation$_() === t || (s._$SetZElevation$_(t), 
                        e._$GetRuntime$_()._$UpdateRender$_());
                    }
                    get _$totalZElevation$_() {
                        return this.#_$#privateWi$_._$GetTotalZElevation$_();
                    }
                    get width() {
                        return this.#_$#privateWi$_._$GetWidth$_();
                    }
                    set width(t) {
                        t = +t;
                        const e = this.#_$#privateWi$_;
                        isNaN(t) || e._$GetWidth$_() === t || (e._$SetWidth$_(t), 
                        e._$SetBboxChanged$_());
                    }
                    get height() {
                        return this.#_$#privateWi$_._$GetHeight$_();
                    }
                    set height(t) {
                        t = +t;
                        const e = this.#_$#privateWi$_;
                        isNaN(t) || e._$GetHeight$_() === t || (e._$SetHeight$_(t), 
                        e._$SetBboxChanged$_());
                    }
                    _$setSize$_(t, e) {
                        t = +t, e = +e;
                        const s = this.#_$#privateWi$_;
                        isNaN(t) || isNaN(e) || s._$GetWidth$_() === t && s._$GetHeight$_() === e || (s._$SetSize$_(t, e), 
                        s._$SetBboxChanged$_());
                    }
                    getSize() {
                        const t = this.#_$#privateWi$_;
                        return [ t._$GetWidth$_(), t._$GetHeight$_() ];
                    }
                    get angle() {
                        return this.#_$#privateWi$_.GetAngle();
                    }
                    set angle(t) {
                        t = C33._$clampAngle$_(+t);
                        const e = this.#_$#privateWi$_;
                        isNaN(t) || e.GetAngle() === t || (e._$SetAngle$_(t), e._$SetBboxChanged$_());
                    }
                    get _$angleDegrees$_() {
                        return C33._$toDegrees$_(this.angle);
                    }
                    set _$angleDegrees$_(t) {
                        this.angle = C33._$toRadians$_(t);
                    }
                    _$getBoundingBox$_() {
                        return this.#_$#privateWi$_._$GetBoundingBox$_()._$toDOMRect$_();
                    }
                    _$getBoundingQuad$_() {
                        return this.#_$#privateWi$_._$GetBoundingQuad$_()._$toDOMQuad$_();
                    }
                    _$isOnScreen$_() {
                        return this.#_$#privateWi$_._$IsInViewport2$_();
                    }
                    get isVisible() {
                        return this.#_$#privateWi$_._$IsVisible$_();
                    }
                    set isVisible(t) {
                        t = !!t;
                        const e = this.#_$#privateInst$_, s = this.#_$#privateWi$_;
                        s._$IsVisible$_() !== t && (s._$SetVisible$_(t), e._$GetRuntime$_()._$UpdateRender$_());
                    }
                    get opacity() {
                        return this.#_$#privateWi$_._$GetOpacity$_();
                    }
                    set opacity(t) {
                        t = C33._$clamp$_(+t, 0, 1);
                        const e = this.#_$#privateInst$_, s = this.#_$#privateWi$_;
                        isNaN(t) || s._$GetOpacity$_() === t || (s._$SetOpacity$_(t), 
                        e._$GetRuntime$_()._$UpdateRender$_());
                    }
                    set _$colorRgb$_(t) {
                        if (C3X._$RequireArray$_(t), t.length < 3) throw new Error("expected 3 elements");
                        tempColor._$setRgb$_(t[0], t[1], t[2]);
                        const e = this.#_$#privateInst$_, s = this.#_$#privateWi$_;
                        s._$GetUnpremultipliedColor$_()._$equalsIgnoringAlpha$_(tempColor) || (s._$SetUnpremultipliedColor$_(tempColor), 
                        e._$GetRuntime$_()._$UpdateRender$_());
                    }
                    get _$colorRgb$_() {
                        const t = this.#_$#privateWi$_._$GetUnpremultipliedColor$_();
                        return [ t._$getR$_(), t._$getG$_(), t._$getB$_() ];
                    }
                    set _$blendMode$_(t) {
                        C3X._$RequireString$_(t);
                        const e = BLEND_MODE_TO_INDEX.get(t);
                        if ("number" != typeof e) throw new Error("invalid blend mode");
                        const s = this.#_$#privateInst$_, i = this.#_$#privateWi$_;
                        i._$SetBlendMode$_(e), s._$GetRuntime$_()._$UpdateRender$_();
                    }
                    get _$blendMode$_() {
                        return INDEX_TO_BLEND_MODE.get(this.#_$#privateWi$_._$GetBlendMode$_());
                    }
                    _$moveToTop$_() {
                        this.#_$#privateWi$_._$ZOrderMoveToTop$_();
                    }
                    _$moveToBottom$_() {
                        this.#_$#privateWi$_._$ZOrderMoveToBottom$_();
                    }
                    _$moveToLayer$_(t) {
                        C3X._$RequireInstanceOf$_(t, ILayer);
                        const e = this.#_$#privateInst$_, s = e._$GetRuntime$_()._$_UnwrapScriptInterface$_(t);
                        if (!s) throw new Error("invalid layer");
                        e._$GetWorldInfo$_()._$ZOrderMoveToLayer$_(s);
                    }
                    _$moveAdjacentToInstance$_(t, e) {
                        C3X._$RequireInstanceOf$_(t, r), this.#_$#privateWi$_._$ZOrderMoveAdjacentToInstance$_(map.get(t), e);
                    }
                    get zIndex() {
                        return this.#_$#privateWi$_._$GetZIndex$_();
                    }
                    get _$isCollisionEnabled$_() {
                        return this.#_$#privateWi$_._$IsCollisionEnabled$_();
                    }
                    set _$isCollisionEnabled$_(t) {
                        this.#_$#privateWi$_._$SetCollisionEnabled$_(!!t);
                    }
                    _$containsPoint$_(t, e) {
                        return C3X._$RequireNumber$_(t), C3X._$RequireNumber$_(e), 
                        this.#_$#privateWi$_._$ContainsPoint$_(+t, +e);
                    }
                    _$testOverlap$_(t) {
                        C3X._$RequireInstanceOf$_(t, r);
                        const e = this.#_$#privateInst$_, s = map.get(t);
                        return e._$GetRuntime$_()._$GetCollisionEngine$_()._$TestOverlap$_(e, s);
                    }
                    _$testOverlapSolid$_() {
                        const t = this.#_$#privateInst$_, e = t._$GetRuntime$_()._$GetCollisionEngine$_()._$TestOverlapSolid$_(t);
                        return e ? e._$GetInterfaceClass$_() : null;
                    }
                    getParent() {
                        const t = this.#_$#privateInst$_._$GetParent$_();
                        return t ? t._$GetInterfaceClass$_() : null;
                    }
                    _$getTopParent$_() {
                        const t = this.#_$#privateInst$_._$GetTopParent$_();
                        return t ? t._$GetInterfaceClass$_() : null;
                    }
                    *_$parents$_() {
                        for (const t of this.#_$#privateInst$_._$parents$_()) yield t._$GetInterfaceClass$_();
                    }
                    _$getChildCount$_() {
                        return this.#_$#privateInst$_._$GetChildCount$_();
                    }
                    _$getChildAt$_(t) {
                        const e = this.#_$#privateInst$_._$GetChildAt$_(t);
                        return e ? e._$GetInterfaceClass$_() : null;
                    }
                    *children() {
                        for (const t of this.#_$#privateInst$_.children()) yield t._$GetInterfaceClass$_();
                    }
                    *_$allChildren$_() {
                        for (const t of this.#_$#privateInst$_._$allChildren$_()) yield t._$GetInterfaceClass$_();
                    }
                    _$addChild$_(t, e) {
                        C3X._$RequireInstanceOf$_(t, r), C3X._$RequireOptionalObject$_(e), 
                        e = e || {};
                        const s = this.#_$#privateInst$_, i = map.get(t);
                        s._$AddChild$_(i, e);
                    }
                    removeChild(t) {
                        C3X._$RequireInstanceOf$_(t, r);
                        const e = this.#_$#privateInst$_, s = map.get(t);
                        e._$RemoveChild$_(s);
                    }
                    _$removeFromParent$_() {
                        const t = this.#_$#privateInst$_;
                        if (t._$HasParent$_()) {
                            const e = t._$GetParent$_();
                            e._$RemoveChild$_(t);
                        }
                    }
                    _$getHierarchyOpts$_() {
                        const t = this.#_$#privateWi$_;
                        return {
                            _$transformX$_: t._$GetTransformWithParentX$_(),
                            _$transformY$_: t._$GetTransformWithParentY$_(),
                            _$transformWidth$_: t._$GetTransformWithParentWidth$_(),
                            _$transformHeight$_: t._$GetTransformWithParentHeight$_(),
                            _$transformAngle$_: t._$GetTransformWithParentAngle$_(),
                            _$transformZElevation$_: t._$GetTransformWithParentZElevation$_(),
                            _$transformOpacity$_: t._$GetTransformWithParentOpacity$_(),
                            _$transformVisibility$_: t._$GetTransformWithParentVisibility$_(),
                            _$destroyWithParent$_: t._$GetDestroyWithParent$_()
                        };
                    }
                    _$createMesh$_(t, e) {
                        C3X._$RequireFiniteNumber$_(t), C3X._$RequireFiniteNumber$_(e), 
                        this.#_$#privateWi$_._$CreateMesh$_(t, e);
                    }
                    _$releaseMesh$_() {
                        const t = this.#_$#privateWi$_;
                        t._$ReleaseMesh$_(), t._$SetBboxChanged$_();
                    }
                    _$setMeshPoint$_(t, e, s) {
                        C3X._$RequireFiniteNumber$_(t), C3X._$RequireFiniteNumber$_(e), 
                        C3X._$RequireObject$_(s);
                        const i = this.#_$#privateWi$_;
                        i._$SetMeshPoint$_(t, e, s) && i._$SetBboxChanged$_();
                    }
                    _$getMeshPoint$_(t, e) {
                        let s = NaN, i = NaN, r = NaN, n = NaN, h = NaN, o = this.#_$#privateWi$_;
                        if (o._$HasMesh$_()) {
                            const a = o._$GetSourceMesh$_(), l = a._$GetMeshPointAt$_(t, e);
                            null !== l && (s = l._$GetX$_(), i = l._$GetY$_(), r = l._$GetZElevation$_(), 
                            n = l._$GetU$_(), h = l._$GetV$_());
                        }
                        return {
                            x: s,
                            y: i,
                            _$zElevation$_: r,
                            u: n,
                            v: h
                        };
                    }
                    _$getMeshSize$_() {
                        const t = this.#_$#privateWi$_;
                        if (!t._$HasMesh$_()) return [ 0, 0 ];
                        const e = t._$GetSourceMesh$_();
                        return [ e._$GetHSize$_(), e._$GetVSize$_() ];
                    }
                };
            };
            MakeIWorldInstanceClass = MakeIWorldInstanceClass2;
            const C33 = self._$C3$_, C3X = self._$C3X$_, IInstance = self._$IInstance$_, ILayer = self._$ILayer$_, map = new WeakMap(), internalApiToken = C33._$_GetInternalAPIToken$_(), BLEND_MODE_TO_INDEX = new Map([ [ "normal", 0 ], [ "additive", 1 ], [ "copy", 3 ], [ "destination-over", 4 ], [ "source-in", 5 ], [ "destination-in", 6 ], [ "source-out", 7 ], [ "destination-out", 8 ], [ "source-atop", 9 ], [ "destination-atop", 10 ] ]), INDEX_TO_BLEND_MODE = new Map([ ...BLEND_MODE_TO_INDEX.entries() ].map(t => [ t[1], t[0] ])), tempColor = C33._$New$_(C33._$Color$_);
            self._$IWorldInstance$_ = MakeIWorldInstanceClass2(self._$IInstance$_), 
            self._$IWorldInstanceSDKBase$_ = MakeIWorldInstanceClass2(self._$ISDKInstanceBase$_);
        }
        {
            const C33 = self._$C3$_, C3X = self._$C3X$_;
            self._$IDOMInstance$_ = class extends self._$IWorldInstance$_ {
                #_$#private$_;
                constructor() {
                    super(), this.#_$#private$_ = self._$IInstance$_._$_GetInitInst$_();
                }
                _$getElement$_() {
                    return this.#_$#private$_._$GetSdkInstance$_()._$_GetElementInDOMMode$_();
                }
                focus() {
                    this.#_$#private$_._$GetSdkInstance$_()._$FocusElement$_();
                }
                blur() {
                    this.#_$#private$_._$GetSdkInstance$_()._$BlurElement$_();
                }
                _$setCssStyle$_(t, e) {
                    C3X._$RequireString$_(t), this.#_$#private$_._$GetSdkInstance$_()._$SetElementCSSStyle$_(t, e);
                }
            };
        }
        {
            let GetDispatcher2 = function(t) {
                let e = dispatchers.get(t);
                return e || (e = C33._$New$_(C33.Event._$Dispatcher$_), dispatchers.set(t, e)), 
                e;
            };
            GetDispatcher = GetDispatcher2;
            const C33 = self._$C3$_, C3X = self._$C3X$_, dispatchers = new WeakMap(), internalApiToken = C33._$_GetInternalAPIToken$_();
            self._$IBehaviorInstance$_ = class {
                #_$#private$_;
                constructor() {
                    const t = C33._$AddonManager$_._$_GetInitObject2$_(internalApiToken), e = {
                        runtime: {
                            value: (this.#_$#private$_ = t)._$GetRuntime$_()._$GetIRuntime$_(),
                            writable: !1
                        },
                        behavior: {
                            value: t._$GetBehavior$_()._$GetIBehavior$_(),
                            writable: !1
                        },
                        _$behaviorType$_: {
                            value: t._$GetBehaviorType$_()._$GetIBehaviorType$_(),
                            writable: !1
                        }
                    };
                    Object.defineProperties(this, e), t._$GetRuntime$_()._$_MapScriptInterface$_(this, t);
                }
                static _$_GetInitInst$_() {
                    return C33._$AddonManager$_._$_GetInitObject$_();
                }
                get instance() {
                    return this.#_$#private$_._$GetObjectInstance$_()._$GetInterfaceClass$_();
                }
                _$_release$_() {
                    const t = dispatchers.get(this);
                    t && (t._$Release$_(), dispatchers.delete(this));
                }
                addEventListener(t, e, s) {
                    C3X._$RequireString$_(t), C3X._$RequireFunction$_(e), GetDispatcher2(this).addEventListener(t, e, s);
                }
                removeEventListener(t, e, s) {
                    C3X._$RequireString$_(t), C3X._$RequireFunction$_(e), GetDispatcher2(this).removeEventListener(t, e, s);
                }
                dispatchEvent(t) {
                    GetDispatcher2(this).dispatchEvent(t);
                }
            };
        }
        {
            const C33 = self._$C3$_, C3X = self._$C3X$_, internalApiToken = C33._$_GetInternalAPIToken$_();
            self._$IBehaviorType$_ = class {
                constructor() {
                    const t = C33._$AddonManager$_._$_GetInitObject2$_(internalApiToken), e = {
                        runtime: {
                            value: t._$GetRuntime$_()._$GetIRuntime$_(),
                            writable: !1
                        },
                        behavior: {
                            value: t._$GetBehavior$_()._$GetIBehavior$_(),
                            writable: !1
                        },
                        name: {
                            value: t._$GetName$_(),
                            writable: !1
                        }
                    };
                    Object.defineProperties(this, e);
                }
            };
        }
        {
            const C33 = self._$C3$_, C3X = self._$C3X$_, internalApiToken = C33._$_GetInternalAPIToken$_();
            self._$IBehavior$_ = class {
                #_$#private$_;
                constructor() {
                    const t = C33._$AddonManager$_._$_GetInitObject2$_(internalApiToken), e = {
                        runtime: {
                            value: (this.#_$#private$_ = t)._$GetRuntime$_()._$GetIRuntime$_(),
                            writable: !1
                        }
                    };
                    Object.defineProperties(this, e);
                }
                _$getAllInstances$_() {
                    return this.#_$#private$_._$GetInstances$_().map(t => t._$GetInterfaceClass$_());
                }
                static _$getByConstructor$_(t) {
                    if (!t) return null;
                    const e = C33._$AddonManager$_._$GetBehaviorByConstructorFunction$_(t);
                    return e ? e._$GetIBehavior$_() : null;
                }
            };
        }
        {
            const C33 = self._$C3$_, C3X = self._$C3X$_, tempColor = C33._$New$_(C33._$Color$_);
            self._$IEffectInstance$_ = class {
                #_$#private$_;
                constructor(t, e) {
                    this.#_$#private$_ = t;
                    const s = {
                        index: {
                            value: e,
                            writable: !1
                        }
                    };
                    Object.defineProperties(this, s);
                }
                get name() {
                    const t = this.#_$#private$_._$GetAllEffectTypes$_();
                    return t[this.index]._$GetName$_();
                }
                get isActive() {
                    return this.#_$#private$_._$IsEffectIndexActive$_(this.index);
                }
                set isActive(t) {
                    t = !!t;
                    const e = this.#_$#private$_;
                    e._$IsEffectIndexActive$_(this.index) !== t && (e._$SetEffectIndexActive$_(this.index, t), 
                    e._$UpdateActiveEffects$_(), e._$GetRuntime$_()._$UpdateRender$_());
                }
                setParameter(t, e) {
                    C3X._$RequireFiniteNumber$_(t), t = Math.floor(+t);
                    const s = this.#_$#private$_, i = s._$GetEffectParameter$_(this.index, t);
                    if (null === i) throw new RangeError("invalid index");
                    if (i instanceof C33._$Color$_) {
                        if (!Array.isArray(e) || e.length < 3) throw new TypeError("expected array with 3 elements");
                        tempColor._$setRgb$_(e[0], e[1], e[2]), e = tempColor;
                    } else if ("number" != typeof e) throw new TypeError("expected number");
                    const r = s._$SetEffectParameter$_(this.index, t, e);
                    r && s._$IsEffectIndexActive$_(this.index) && s._$GetRuntime$_()._$UpdateRender$_();
                }
                getParameter(t) {
                    C3X._$RequireFiniteNumber$_(t), t = Math.floor(+t);
                    const e = this.#_$#private$_, s = e._$GetEffectParameter$_(this.index, t);
                    if (null === s) throw new RangeError("invalid index");
                    return s instanceof C33._$Color$_ ? [ s._$getR$_(), s._$getG$_(), s._$getB$_() ] : s;
                }
            };
        }
        {
            const C33 = self._$C3$_, C3X = self._$C3X$_;
            self._$IAnimation$_ = class {
                #_$#private$_;
                constructor(t) {
                    this.#_$#private$_ = t, Object.defineProperties(this, {
                        name: {
                            value: t._$GetName$_(),
                            writable: !1
                        }
                    });
                }
                get speed() {
                    return this.#_$#private$_._$GetSpeed$_();
                }
                get isLooping() {
                    return this.#_$#private$_._$IsLooping$_();
                }
                get repeatCount() {
                    return this.#_$#private$_._$GetRepeatCount$_();
                }
                get _$repeatTo$_() {
                    return this.#_$#private$_._$GetRepeatTo$_();
                }
                get _$isPingPong$_() {
                    return this.#_$#private$_._$IsPingPong$_();
                }
                get frameCount() {
                    return this.#_$#private$_._$GetFrameCount$_();
                }
                _$getFrames$_() {
                    return this.#_$#private$_._$GetFrames$_().map(t => t._$GetIAnimationFrame$_());
                }
                *frames() {
                    for (const t of this.#_$#private$_._$GetFrames$_()) yield t._$GetIAnimationFrame$_();
                }
            };
        }
        {
            const C33 = self._$C3$_, C3X = self._$C3X$_;
            self._$IImageInfo$_ = class {
                #_$#private$_;
                constructor(t) {
                    this.#_$#private$_ = t;
                }
                static _$_Unwrap$_(t) {
                    return t.#_$#private$_;
                }
                get width() {
                    return this.#_$#private$_._$GetWidth$_();
                }
                get height() {
                    return this.#_$#private$_._$GetHeight$_();
                }
                getSize() {
                    const t = this.#_$#private$_;
                    return [ t._$GetWidth$_(), t._$GetHeight$_() ];
                }
                _$getTexture$_(t) {
                    return t._$getTextureForImageInfo$_(this);
                }
                _$getTexRect$_() {
                    return this.#_$#private$_._$GetTexRect$_()._$toDOMRect$_();
                }
            };
        }
        {
            const C33 = self._$C3$_, C3X = self._$C3X$_;
            self._$IAnimationFrame$_ = class extends self._$IImageInfo$_ {
                #_$#private$_;
                constructor(t) {
                    super(t._$GetImageInfo$_()), this.#_$#private$_ = t, Object.defineProperties(this, {
                        duration: {
                            value: t._$GetDuration$_(),
                            writable: !1
                        },
                        _$originX$_: {
                            value: t._$GetOriginX$_(),
                            writable: !1
                        },
                        _$originY$_: {
                            value: t._$GetOriginY$_(),
                            writable: !1
                        }
                    });
                }
                _$getOrigin$_() {
                    const t = this.#_$#private$_;
                    return [ t._$GetOriginX$_(), t._$GetOriginY$_() ];
                }
                _$getImagePointCount$_() {
                    return this.#_$#private$_._$GetImagePointCount$_();
                }
                _$getImagePointX$_(t) {
                    return this._$getImagePoint$_(t)[0];
                }
                _$getImagePointY$_(t) {
                    return this._$getImagePoint$_(t)[1];
                }
                _$getImagePoint$_(t) {
                    let e = this.#_$#private$_, s = null;
                    if ("number" == typeof t) s = e._$GetImagePointByIndex$_(Math.floor(t)); else {
                        if ("string" != typeof t) throw new TypeError("expected string or number");
                        s = e._$GetImagePointByName$_(t);
                    }
                    return s ? [ s._$GetX$_(), s._$GetY$_() ] : this._$getOrigin$_();
                }
                _$getPolyPointCount$_() {
                    const t = this.#_$#private$_._$GetCollisionPoly$_();
                    return t ? t._$pointCount$_() : 0;
                }
                _$getPolyPointX$_(t) {
                    return this._$getPolyPoint$_(t)[0];
                }
                _$getPolyPointY$_(t) {
                    return this._$getPolyPoint$_(t)[1];
                }
                _$getPolyPoint$_(t) {
                    C3X._$RequireFiniteNumber$_(t), t = Math.floor(t);
                    const e = this.#_$#private$_._$GetCollisionPoly$_();
                    if (!e || t < 0 || t >= e._$pointCount$_()) return [ 0, 0 ];
                    const s = e._$pointsArr$_(), i = s[2 * t], r = s[2 * t + 1];
                    return [ i, r ];
                }
                get tag() {
                    return this.#_$#private$_._$GetTag$_();
                }
            };
        }
        {
            let GetTimelineState2 = function(t) {
                const e = map.get(t);
                if (e._$IsReleased$_()) throw new Error("timeline/tween was released and is no longer valid");
                return e;
            };
            GetTimelineState = GetTimelineState2;
            const C33 = self._$C3$_, C3X = self._$C3X$_, map = new WeakMap();
            self._$ITimelineStateBase$_ = class {
                constructor(t) {
                    map.set(this, t), t._$GetRuntime$_()._$_MapScriptInterface$_(this, t);
                }
                pause() {
                    GetTimelineState2(this)._$Stop$_();
                }
                resume() {
                    GetTimelineState2(this)._$Resume$_();
                }
                stop() {
                    GetTimelineState2(this)._$Reset$_();
                }
                _$hasTags$_(t) {
                    return GetTimelineState2(this)._$HasTags$_(t);
                }
                set time(t) {
                    C3X._$RequireFiniteNumber$_(t), GetTimelineState2(this)._$SetTime$_(t);
                }
                get time() {
                    return GetTimelineState2(this)._$GetTime$_();
                }
                set totalTime(t) {
                    C3X._$RequireFiniteNumber$_(t), GetTimelineState2(this)._$SetTotalTime$_(t);
                }
                get totalTime() {
                    return GetTimelineState2(this)._$GetTotalTime$_();
                }
                set isLooping(t) {
                    GetTimelineState2(this)._$SetLoop$_(!!t);
                }
                get isLooping() {
                    return GetTimelineState2(this)._$GetLoop$_();
                }
                set _$isPingPong$_(t) {
                    GetTimelineState2(this)._$SetPingPong$_(!!t);
                }
                get _$isPingPong$_() {
                    return GetTimelineState2(this)._$GetPingPong$_();
                }
                set playbackRate(t) {
                    C3X._$RequireFiniteNumber$_(t), GetTimelineState2(this)._$SetPlaybackRate$_(t);
                }
                get playbackRate() {
                    return GetTimelineState2(this)._$GetPlaybackRate$_();
                }
                get progress() {
                    const t = GetTimelineState2(this);
                    return t._$GetTime$_() / t._$GetTotalTime$_();
                }
                get tags() {
                    return GetTimelineState2(this)._$GetTags$_();
                }
                get finished() {
                    return GetTimelineState2(this)._$GetPlayPromise$_();
                }
                get isPlaying() {
                    return GetTimelineState2(this).IsPlaying();
                }
                get _$isPaused$_() {
                    return GetTimelineState2(this)._$IsPaused$_();
                }
                get _$isReleased$_() {
                    return map.get(this)._$IsReleased$_();
                }
            };
        }
        {
            let GetTimelineState2 = function(t) {
                const e = map.get(t);
                if (e._$IsReleased$_()) throw new Error("timeline was released and is no longer valid");
                return e;
            }, C33 = (GetTimelineState = GetTimelineState2, self._$C3$_), C3X = self._$C3X$_, map = new WeakMap(), easeToIndexFunc = null;
            self._$ITimelineState$_ = class extends self._$ITimelineStateBase$_ {
                constructor(t) {
                    super(t), map.set(this, t);
                    const e = {
                        name: {
                            value: t._$GetName$_(),
                            writable: !1
                        }
                    };
                    Object.defineProperties(this, e);
                }
            };
        }
        {
            let GetTweenState2 = function(t) {
                const e = map.get(t);
                if (e._$IsReleased$_()) throw new Error("tween was released and is no longer valid");
                return e;
            }, C33 = (GetTweenState = GetTweenState2, self._$C3$_), C3X = self._$C3X$_, map = new WeakMap(), behInstMap = new WeakMap(), easeToIndexFunc = null;
            self._$ITweenState$_ = class extends self._$ITimelineStateBase$_ {
                constructor(t, e, s) {
                    super(t), easeToIndexFunc = easeToIndexFunc || s._$easeToIndexFunc$_, 
                    map.set(this, t), e && behInstMap.set(this, e);
                }
                stop() {
                    const t = GetTweenState2(this), e = behInstMap.get(this);
                    e._$ReleaseTween$_(t);
                }
                _$setEase$_(t) {
                    C3X._$RequireString$_(t);
                    const e = self._$Ease$_._$GetEaseFromIndex$_(easeToIndexFunc(t));
                    GetTweenState2(this)._$SetEase$_(e);
                }
                get instance() {
                    const t = GetTweenState2(this)._$GetInstance$_();
                    return t ? t._$GetInterfaceClass$_() : null;
                }
                get _$isDestroyOnComplete$_() {
                    return GetTweenState2(this)._$GetDestroyInstanceOnComplete$_();
                }
                set _$isDestroyOnComplete$_(t) {
                    GetTweenState2(this)._$SetDestroyInstanceOnComplete$_(!!t);
                }
                get value() {
                    const t = GetTweenState2(this);
                    if ("value" !== t._$GetId$_()) throw new Error("not a value tween");
                    return t._$GetPropertyTrack$_("value")._$GetSourceAdapterValue$_();
                }
            };
        }
        {
            const C33 = self._$C3$_, C3X = self._$C3X$_;
            self._$ISDKPluginBase$_ = class extends self._$IPlugin$_ {
                constructor() {
                    super();
                }
            };
        }
        {
            const C33 = self._$C3$_, C3X = self._$C3X$_, internalApiToken = C33._$_GetInternalAPIToken$_();
            self._$ISDKDOMPluginBase$_ = class extends self._$ISDKPluginBase$_ {
                #_$#private$_;
                #_$#domComponentId$_;
                #_$#nextElementId$_ = 0;
                #_$#instMap$_ = new Map();
                constructor(t) {
                    if (super(), this.#_$#private$_ = C33._$AddonManager$_._$_GetInitObject2$_(internalApiToken), 
                    !t?.domComponentId) throw new Error("no DOM component ID specified");
                    this.#_$#domComponentId$_ = t.domComponentId, this._$_addElementMessageHandler$_("elem-focused", t => t._$_onElemFocused$_()), 
                    this._$_addElementMessageHandler$_("elem-blurred", t => {
                        t && t._$_onElemBlurred$_();
                    });
                }
                _$_addElement$_(t) {
                    const e = this.#_$#nextElementId$_++;
                    return this.#_$#instMap$_.set(e, t), e;
                }
                _$_removeElement$_(t) {
                    this.#_$#instMap$_.delete(t);
                }
                _$_addElementMessageHandler$_(t, s) {
                    const e = this.#_$#private$_._$GetRuntime$_();
                    e._$AddDOMComponentMessageHandler$_(this.#_$#domComponentId$_, t, t => {
                        const e = this.#_$#instMap$_.get(t.elementId);
                        s(e, t);
                    });
                }
                _$_addElementMessageHandlers$_(t) {
                    C3X._$RequireArray$_(t);
                    for (const [ e, s ] of t) this._$_addElementMessageHandlers$_(e, s);
                }
            };
        }
        {
            const C33 = self._$C3$_, C3X = self._$C3X$_, map = new WeakMap(), internalApiToken = C33._$_GetInternalAPIToken$_();
            self._$ISDKObjectTypeBase$_ = class extends self._$IObjectClass$_ {
                #_$#private$_;
                constructor() {
                    super(), this.#_$#private$_ = C33._$AddonManager$_._$_GetInitObject2$_(internalApiToken);
                }
                _$_onCreate$_() {}
                _$getImageInfo$_() {
                    return this.#_$#private$_._$GetImageInfo$_()._$GetIImageInfo$_();
                }
                _$_loadTextures$_(t) {}
                _$_releaseTextures$_(t) {}
                _$_onDynamicTextureLoadComplete$_() {}
                _$_preloadTexturesWithInstances$_(t) {}
            };
        }
        {
            const C33 = self._$C3$_, C3X = self._$C3X$_, map = new WeakMap(), internalApiToken = C33._$_GetInternalAPIToken$_();
            self._$ISDKWorldInstanceBase$_ = class extends self._$IWorldInstanceSDKBase$_ {
                #_$#private$_;
                #_$#renderercontextlost_handler$_ = null;
                #_$#renderercontextrestored_handler$_ = null;
                constructor(t) {
                    super(t), this.#_$#private$_ = C33._$AddonManager$_._$_GetInitObject2$_(internalApiToken);
                }
                _$_release$_() {
                    if (super._$_release$_(), this.#_$#renderercontextlost_handler$_) {
                        const t = this.#_$#private$_._$GetRuntime$_()._$Dispatcher$_();
                        t.removeEventListener("renderercontextlost", this.#_$#renderercontextlost_handler$_), 
                        t.removeEventListener("renderercontextrestored", this.#_$#renderercontextrestored_handler$_), 
                        this.#_$#renderercontextlost_handler$_ = null, this.#_$#renderercontextrestored_handler$_ = null;
                    }
                }
                _$_handleRendererContextLoss$_() {
                    if (!this.#_$#renderercontextlost_handler$_) {
                        this.#_$#renderercontextlost_handler$_ = () => this._$_onRendererContextLost$_(), 
                        this.#_$#renderercontextrestored_handler$_ = () => this._$_onRendererContextRestored$_();
                        const t = this.#_$#private$_._$GetRuntime$_()._$Dispatcher$_();
                        t.addEventListener("renderercontextlost", this.#_$#renderercontextlost_handler$_), 
                        t.addEventListener("renderercontextrestored", this.#_$#renderercontextrestored_handler$_);
                    }
                }
                _$_onRendererContextLost$_() {}
                _$_onRendererContextRestored$_() {}
                _$_draw$_(t) {}
            };
        }
        {
            const C33 = self._$C3$_, C3X = self._$C3X$_, tempRect = C33._$New$_(C33.Rect), map = new WeakMap(), internalApiToken = C33._$_GetInternalAPIToken$_();
            self._$ISDKDOMInstanceBase$_ = class extends self._$ISDKWorldInstanceBase$_ {
                #_$#elementId$_ = -1;
                #_$#isElementShowing$_ = !0;
                #_$#elemHasFocus$_ = !1;
                #_$#autoFontSize$_ = !1;
                #_$#autoFontSizeOffset$_ = -.2;
                #_$#lastRect$_ = C33._$New$_(C33.Rect, 0, 0, -1, -1);
                #_$#lastWindowWidth$_ = 0;
                #_$#lastWindowHeight$_ = 0;
                #_$#lastHTMLIndex$_ = -1;
                #_$#lastHTMLZIndex$_ = -1;
                #_$#isPendingUpdateState$_ = !1;
                constructor(t) {
                    if (!t?.domComponentId) throw new Error("no DOM component ID specified");
                    super(t);
                    const e = C33._$AddonManager$_._$_GetInitObject2$_(internalApiToken), s = (map.set(this, e), 
                    this.#_$#elementId$_ = this._$plugin$_._$_addElement$_(this), 
                    e._$GetRuntime$_()._$GetCanvasManager$_());
                    this.#_$#lastWindowWidth$_ = s._$GetLastWidth$_(), this.#_$#lastWindowHeight$_ = s._$GetLastHeight$_(), 
                    this._$_setTicking$_(!0);
                }
                _$_release$_() {
                    super._$_release$_(), this._$plugin$_._$_removeElement$_(this.#_$#elementId$_), 
                    this._$_postToDOMElement$_("destroy"), this.#_$#elementId$_ = -1, 
                    map.delete(this);
                }
                _$_getElementInDOMMode$_() {
                    const t = map.get(this)._$GetRuntime$_();
                    if (t._$IsInWorker$_()) throw new Error("not valid in worker mode");
                    return this._$_postToDOMElementMaybeSync$_("get-element");
                }
                _$_postToDOMElement$_(t, e) {
                    (e = e || {}).elementId = this.#_$#elementId$_, this._$_postToDOM$_(t, e);
                }
                _$_postToDOMElementMaybeSync$_(t, e) {
                    return (e = e || {}).elementId = this.#_$#elementId$_, this._$_postToDOMMaybeSync$_(t, e);
                }
                _$_postToDOMElementAsync$_(t, e) {
                    return (e = e || {}).elementId = this.#_$#elementId$_, this._$_postToDOMAsync$_(t, e);
                }
                _$_createElement$_(t) {
                    t = t || {};
                    const e = map.get(this)._$GetWorldInfo$_();
                    t.elementId = this.#_$#elementId$_, t.isVisible = e._$IsVisible$_(), 
                    t.htmlIndex = e._$GetLayer$_()._$GetHTMLIndex$_(), t.htmlZIndex = e._$GetHTMLZIndex$_(), 
                    Object.assign(t, this._$_getElementState$_()), this.#_$#isElementShowing$_ = !!t.isVisible, 
                    this._$_postToDOMMaybeSync$_("create", t), this._$_updatePosition$_(!0);
                }
                _$setElementVisible$_(t) {
                    this.#_$#isElementShowing$_ !== (t = !!t) && (this.#_$#isElementShowing$_ = t, 
                    this._$_postToDOMElement$_("set-visible", {
                        isVisible: t
                    }));
                }
                _$_tick$_() {
                    this._$_updatePosition$_(!1);
                }
                _$_shouldPreserveElement$_() {
                    const t = map.get(this)._$GetRuntime$_(), e = t._$GetCanvasManager$_()._$GetFullscreenMode$_();
                    return "Android" === C33._$Platform$_._$OS$_ && ("scale-inner" === e || "scale-outer" === e || "crop" === e);
                }
                _$_updatePosition$_(u) {
                    const c = map.get(this);
                    if (!c._$IsDestroyed$_()) {
                        let t = c._$GetWorldInfo$_(), e = t._$GetLayer$_(), s = t._$GetBoundingBox$_(), [ i, r ] = e._$LayerToCanvasCss$_(s._$getLeft$_(), s._$getTop$_()), [ n, h ] = e._$LayerToCanvasCss$_(s._$getRight$_(), s._$getBottom$_()), o = c._$GetRuntime$_()._$GetCanvasManager$_(), a = o._$GetCssWidth$_(), l = o._$GetCssHeight$_();
                        if (t._$IsVisible$_() && e._$IsVisible$_()) if (!this._$_shouldPreserveElement$_() && (n <= 0 || h <= 0 || a <= i || l <= r)) this._$setElementVisible$_(!1); else {
                            tempRect.set(i, r, n, h);
                            const f = o._$GetLastWidth$_(), d = o._$GetLastHeight$_(), p = e._$GetHTMLIndex$_(), m = t._$GetHTMLZIndex$_();
                            if (!u && tempRect.equals(this.#_$#lastRect$_) && this.#_$#lastWindowWidth$_ === f && this.#_$#lastWindowHeight$_ === d && this.#_$#lastHTMLIndex$_ === p && this.#_$#lastHTMLZIndex$_ === m) this._$setElementVisible$_(!0); else {
                                this.#_$#lastRect$_._$copy$_(tempRect), this.#_$#lastWindowWidth$_ = f, 
                                this.#_$#lastWindowHeight$_ = d, this.#_$#lastHTMLIndex$_ = p, 
                                this.#_$#lastHTMLZIndex$_ = m, this._$setElementVisible$_(!0);
                                let t = null;
                                this.#_$#autoFontSize$_ && (t = e._$GetDisplayScale$_() + this.#_$#autoFontSizeOffset$_), 
                                this._$_postToDOMElement$_("update-position", {
                                    left: Math.round(this.#_$#lastRect$_._$getLeft$_()),
                                    top: Math.round(this.#_$#lastRect$_._$getTop$_()),
                                    width: Math.round(this.#_$#lastRect$_.width()),
                                    height: Math.round(this.#_$#lastRect$_.height()),
                                    htmlIndex: p,
                                    htmlZIndex: m,
                                    fontSize: t
                                });
                            }
                        } else this._$setElementVisible$_(!1);
                    }
                }
                _$focusElement$_() {
                    this._$_postToDOMElementMaybeSync$_("focus", {
                        focus: !0
                    });
                }
                _$blurElement$_() {
                    this._$_postToDOMElementMaybeSync$_("focus", {
                        focus: !1
                    });
                }
                _$_onElemFocused$_() {
                    this.#_$#elemHasFocus$_ = !0;
                }
                _$_onElemBlurred$_() {
                    this.#_$#elemHasFocus$_ = !1;
                }
                _$isElementFocused$_() {
                    return this.#_$#elemHasFocus$_;
                }
                _$setElementCSSStyle$_(t, e) {
                    this.postToDOMElement("set-css-style", {
                        prop: C33._$CSSToCamelCase$_(t),
                        val: e
                    });
                }
                _$setElementAttribute$_(t, e) {
                    this.postToDOMElement("set-attribute", {
                        name: t,
                        val: e
                    });
                }
                _$removeElementAttribute$_(t) {
                    this.postToDOMElement("remove-attribute", {
                        name: t
                    });
                }
                _$_updateElementState$_() {
                    this.#_$#isPendingUpdateState$_ || (this.#_$#isPendingUpdateState$_ = !0, 
                    Promise.resolve().then(() => {
                        this.#_$#isPendingUpdateState$_ = !1, this._$_postToDOMElement$_("update-state", this._$_getElementState$_());
                    }));
                }
                _$_getElementState$_() {}
                _$_getElementId$_() {
                    return this.#_$#elementId$_;
                }
            };
        }
        {
            const C33 = self._$C3$_, C3X = self._$C3X$_;
            self._$ISDKBehaviorBase$_ = class extends self._$IBehavior$_ {
                constructor() {
                    super();
                }
            };
        }
        {
            const C33 = self._$C3$_, C3X = self._$C3X$_;
            self._$ISDKBehaviorTypeBase$_ = class extends globalThis._$IBehaviorType$_ {
                constructor() {
                    super();
                }
                _$_onCreate$_() {}
            };
        }
        {
            const C33 = self._$C3$_, C3X = self._$C3X$_, map = new WeakMap(), internalApiToken = C33._$_GetInternalAPIToken$_();
            self._$ISDKBehaviorInstanceBase$_ = class extends self._$IBehaviorInstance$_ {
                #_$#isTicking$_ = !1;
                #_$#isTicking2$_ = !1;
                #_$#isPostTicking$_ = !1;
                constructor() {
                    super(), map.set(this, C33._$AddonManager$_._$_GetInitObject2$_(internalApiToken));
                }
                _$_release$_() {
                    super._$_release$_(), this._$_setTicking$_(!1), this._$_setTicking2$_(!1), 
                    this._$_setPostTicking$_(!1), map.delete(this);
                }
                _$_getInitProperties$_() {
                    return C33._$AddonManager$_._$_GetInitProperties$_();
                }
                _$_postCreate$_() {}
                _$_trigger$_(t) {
                    const e = map.get(this);
                    e._$GetRuntime$_()._$Trigger$_(t, e._$GetObjectInstance$_(), e._$GetBehaviorType$_());
                }
                _$_triggerAsync$_(t) {
                    const e = map.get(this);
                    return e._$GetRuntime$_()._$TriggerAsync$_(t, e._$GetObjectInstance$_(), e._$GetBehaviorType$_());
                }
                _$_setTicking$_(t) {
                    if (this.#_$#isTicking$_ !== (t = !!t)) {
                        this.#_$#isTicking$_ = t;
                        const e = map.get(this)._$GetRuntime$_();
                        t ? e._$_AddBehInstToTick$_(this) : e._$_RemoveBehInstToTick$_(this);
                    }
                }
                _$_isTicking$_() {
                    return this.#_$#isTicking$_;
                }
                _$_tick$_() {}
                _$_setTicking2$_(t) {
                    if (this.#_$#isTicking2$_ !== (t = !!t)) {
                        this.#_$#isTicking2$_ = t;
                        const e = map.get(this)._$GetRuntime$_();
                        t ? e._$_AddBehInstToTick2$_(this) : e._$_RemoveBehInstToTick2$_(this);
                    }
                }
                _$_isTicking2$_() {
                    return this.#_$#isTicking2$_;
                }
                _$_tick2$_() {}
                _$_setPostTicking$_(t) {
                    if (this.#_$#isPostTicking$_ !== (t = !!t)) {
                        this.#_$#isPostTicking$_ = t;
                        const e = map.get(this)._$GetRuntime$_();
                        t ? e._$_AddBehInstToPostTick$_(this) : e._$_RemoveBehInstToPostTick$_(this);
                    }
                }
                _$_isPostTicking$_() {
                    return this.#_$#isPostTicking$_;
                }
                _$_postTick$_() {}
                _$_getDebuggerProperties$_() {
                    return [];
                }
                _$_saveToJson$_() {
                    return null;
                }
                _$_loadFromJson$_(t) {}
            };
        }
        {
            let C33 = self._$C3$_, C3X = self._$C3X$_, runtime = null;
            self._$ISDKUtils$_ = class {
                constructor(t) {
                    runtime = t;
                }
                _$addLoadPromise$_(t) {
                    runtime._$AddLoadPromise$_(t);
                }
                _$sendWrapperExtensionMessage$_(t, e, s) {
                    C3X._$RequireString$_(t), C3X._$RequireString$_(e), C3X._$RequireOptionalArray$_(s), 
                    runtime._$SendWrapperExtensionMessage$_(t, e, s);
                }
                _$sendWrapperExtensionMessageAsync$_(t, e, s) {
                    return C3X._$RequireString$_(t), C3X._$RequireString$_(e), C3X._$RequireOptionalArray$_(s), 
                    runtime._$SendWrapperExtensionMessageAsync$_(t, e, s);
                }
                _$createLoopingConditionContext$_(t) {
                    return C3X._$RequireOptionalString$_(t), new self._$ILoopingConditionContext$_(runtime, t);
                }
                set _$isAutoSuspendEnabled$_(t) {
                    runtime._$_SetAutoSuspendEnabled$_(!!t);
                }
                get _$isAutoSuspendEnabled$_() {
                    return runtime._$_IsAutoSuspendEnabled$_();
                }
                _$setSuspended$_(t) {
                    runtime._$SetSuspended$_(!!t);
                }
                _$getObjectClassBySid$_(t) {
                    C3X._$RequireNumber$_(t);
                    const e = runtime._$GetObjectClassBySID$_(t);
                    return e ? e._$GetIObjectClass$_() : null;
                }
            };
        }
        {
            const C33 = self._$C3$_, C3X = self._$C3X$_;
            self._$ILoopingConditionContext$_ = class {
                #_$#runtime$_;
                #_$#currentEvent$_;
                #_$#solModifiers$_;
                #_$#oldFrame$_;
                #_$#newFrame$_;
                #_$#loop$_;
                constructor(t, e) {
                    const s = (this.#_$#runtime$_ = t)._$GetEventSheetManager$_(), i = t._$GetCurrentEvent$_(), r = (this.#_$#currentEvent$_ = i, 
                    this.#_$#solModifiers$_ = i._$GetSolModifiers$_(), t._$GetEventStack$_()), n = (this.#_$#oldFrame$_ = r._$GetCurrentStackFrame$_(), 
                    this.#_$#newFrame$_ = r._$Push$_(i), s._$GetLoopStack$_()), h = n._$Push$_();
                    this.#_$#loop$_ = h, e && h._$SetName$_(e), t._$SetDebuggingEnabled$_(!1);
                }
                _$retrigger$_() {
                    const t = this.#_$#runtime$_._$GetEventSheetManager$_(), e = this.#_$#solModifiers$_, s = this.#_$#loop$_;
                    t._$PushCopySol$_(e), this.#_$#currentEvent$_._$Retrigger$_(this.#_$#oldFrame$_, this.#_$#newFrame$_), 
                    t._$PopSol$_(e), s._$SetIndex$_(s._$GetIndex$_() + 1);
                }
                get _$isStopped$_() {
                    return this.#_$#loop$_._$IsStopped$_();
                }
                release() {
                    const t = this.#_$#runtime$_, e = t._$GetEventStack$_(), s = t._$GetEventSheetManager$_()._$GetLoopStack$_();
                    t._$SetDebuggingEnabled$_(!0), s._$Pop$_(), e._$Pop$_();
                }
            };
        }
        {
            let C33 = self._$C3$_, C3X = self._$C3X$_, renderer = null, runtime = null;
            self._$IRenderer$_ = class {
                constructor(t, e) {
                    runtime = t, renderer = e;
                }
                _$setAlphaBlendMode$_() {
                    renderer._$SetAlphaBlend$_();
                }
                _$setBlendMode$_(t) {
                    renderer._$SetNamedBlendMode$_(t);
                }
                _$setColorFillMode$_() {
                    renderer._$SetColorFillMode$_();
                }
                _$setTextureFillMode$_() {
                    renderer._$SetTextureFillMode$_();
                }
                _$setSmoothLineFillMode$_() {
                    renderer._$SetSmoothLineFillMode$_();
                }
                setColor(t) {
                    renderer._$SetColorRgba$_(t[0], t[1], t[2], t[3]);
                }
                _$setColorRgba$_(t, e, s, i) {
                    renderer._$SetColorRgba$_(t, e, s, i);
                }
                _$resetColor$_() {
                    renderer._$ResetColor$_();
                }
                _$setOpacity$_(t) {
                    renderer._$SetOpacity$_(t);
                }
                _$setCurrentZ$_(t) {
                    renderer._$SetCurrentZ$_(t);
                }
                _$getCurrentZ$_() {
                    renderer._$GetCurrentZ$_();
                }
                rect(t) {
                    renderer._$Rect2$_(t.left, t.top, t.right, t.bottom);
                }
                _$rect2$_(t, e, s, i) {
                    renderer._$Rect2$_(t, e, s, i);
                }
                _$quad$_(t) {
                    renderer._$Quad$_(C33._$Quad$_._$fromDOMQuad$_(t));
                }
                _$quad2$_(t, e, s, i, r, n, h, o) {
                    renderer._$Quad2$_(t, e, s, i, r, n, h, o);
                }
                _$quad3$_(t, e) {
                    renderer._$Quad3$_(C33._$Quad$_._$fromDOMQuad$_(t), C33.Rect._$fromDOMRect$_(e));
                }
                _$quad4$_(t, e) {
                    renderer._$Quad4$_(C33._$Quad$_._$fromDOMQuad$_(t), C33._$Quad$_._$fromDOMQuad$_(e));
                }
                _$quad3D$_(t, e, s, i, r, n, h, o, a, l, u, c, f) {
                    renderer._$Quad3D$_(t, e, s, i, r, n, h, o, a, l, u, c, C33.Rect._$fromDOMRect$_(f));
                }
                _$quad3D2$_(t, e, s, i, r, n, h, o, a, l, u, c, f) {
                    renderer._$Quad3D2$_(t, e, s, i, r, n, h, o, a, l, u, c, C33._$Quad$_._$fromDOMQuad$_(f));
                }
                _$drawMesh$_(t, e, s) {
                    renderer._$DrawMesh$_(t, e, s);
                }
                _$convexPoly$_(t) {
                    renderer._$ConvexPoly$_(t);
                }
                line(t, e, s, i) {
                    renderer._$Line$_(t, e, s, i);
                }
                _$texturedLine$_(t, e, s, i, r, n) {
                    renderer._$TexturedLine$_(t, e, s, i, r, n);
                }
                _$lineRect$_(t, e, s, i) {
                    renderer._$LineRect$_(t, e, s, i);
                }
                _$lineRect2$_(t) {
                    renderer._$LineRect2$_(C33.Rect._$fromDOMRect$_(t));
                }
                _$lineQuad$_(t) {
                    renderer._$LineQuad$_(C33._$Quad$_._$fromDOMQuad$_(t));
                }
                _$pushLineWidth$_(t) {
                    renderer._$PushLineWidth$_(t);
                }
                _$popLineWidth$_() {
                    renderer._$PopLineWidth$_();
                }
                _$pushLineCap$_(t) {
                    renderer._$PushLineCap$_(t);
                }
                _$popLineCap$_() {
                    renderer._$PopLineCap$_();
                }
                _$setTexture$_(t) {
                    C3X._$RequireOptionalInstanceOf$_(t, self._$ITexture$_);
                    const e = t ? runtime._$_UnwrapScriptInterface$_(t) : null;
                    renderer._$SetTexture$_(e);
                }
                _$loadTextureForImageInfo$_(t, e) {
                    const s = self._$IImageInfo$_._$_Unwrap$_(t);
                    if (s) return s._$LoadStaticTexture$_(renderer, {
                        _$wrapX$_: e?._$wrapX$_ ?? "clamp-to-edge",
                        _$wrapY$_: e?._$wrapY$_ ?? "clamp-to-edge",
                        _$sampling$_: e?._$sampling$_ ?? "trilinear",
                        _$mipMap$_: e?._$mipMap$_ ?? !0
                    });
                    throw new Error("invalid IImageInfo");
                }
                _$releaseTextureForImageInfo$_(t) {
                    const e = self._$IImageInfo$_._$_Unwrap$_(t);
                    if (!e) throw new Error("invalid IImageInfo");
                    e._$ReleaseTexture$_();
                }
                _$getTextureForImageInfo$_(t) {
                    const e = self._$IImageInfo$_._$_Unwrap$_(t);
                    if (!e) throw new Error("invalid IImageInfo");
                    const s = e._$GetTexture$_();
                    return self._$ITexture$_._$GetInterface$_(runtime, s);
                }
                _$createDynamicTexture$_(t, e, s) {
                    C3X._$RequireFiniteNumber$_(t), C3X._$RequireFiniteNumber$_(e);
                    const i = renderer._$CreateDynamicTexture$_(t, e, {
                        _$wrapX$_: s?._$wrapX$_ ?? "clamp-to-edge",
                        _$wrapY$_: s?._$wrapY$_ ?? "clamp-to-edge",
                        _$sampling$_: s?._$sampling$_ ?? "trilinear",
                        _$mipMap$_: s?._$mipMap$_ ?? !0
                    });
                    return self._$ITexture$_._$GetInterface$_(runtime, i);
                }
                _$updateTexture$_(t, e, s) {
                    C3X._$RequireInstanceOf$_(e, self._$ITexture$_);
                    const i = runtime._$_UnwrapScriptInterface$_(e);
                    renderer._$UpdateTexture$_(t, i, {
                        premultiplyAlpha: s?.premultiplyAlpha ?? !0
                    });
                }
                deleteTexture(t) {
                    C3X._$RequireInstanceOf$_(t, self._$ITexture$_);
                    const e = runtime._$_UnwrapScriptInterface$_(t);
                    renderer._$DeleteTexture$_(e);
                }
                _$createRendererText$_() {
                    const t = renderer._$CreateRendererText$_();
                    return new self._$IRendererText$_(runtime, t);
                }
                _$setDeviceTransform$_() {
                    runtime._$GetCanvasManager$_()._$SetDeviceTransform$_(renderer);
                }
                _$setLayerTransform$_(t) {
                    C3X._$RequireInstanceOf$_(t, globalThis._$ILayer$_);
                    const e = runtime._$_UnwrapScriptInterface$_(t);
                    e._$_SetTransform$_(renderer);
                }
            };
        }
        {
            const C33 = self._$C3$_, C3X = self._$C3X$_, map = new WeakMap(), reverseMap = new WeakMap();
            self._$ITexture$_ = class {
                constructor(t, e) {
                    map.set(this, {
                        runtime: t,
                        texture: e
                    }), reverseMap.set(e, this), t._$_MapScriptInterface$_(this, e), 
                    Object.defineProperties(this, {
                        width: {
                            value: e._$GetWidth$_(),
                            writable: !1
                        },
                        height: {
                            value: e._$GetHeight$_(),
                            writable: !1
                        }
                    });
                }
                static _$GetInterface$_(t, e) {
                    if (!e) return null;
                    const s = reverseMap.get(e);
                    return s || new self._$ITexture$_(t, e);
                }
            };
        }
        {
            let getActual2 = function(t) {
                return map.get(t)._$rendererText$_;
            };
            getActual = getActual2;
            const C33 = self._$C3$_, C3X = self._$C3X$_, map = new WeakMap();
            self._$IRendererText$_ = class {
                constructor(t, e) {
                    map.set(this, {
                        runtime: t,
                        _$rendererText$_: e
                    }), t._$_MapScriptInterface$_(this, e);
                }
                release() {
                    getActual2(this)._$Release$_();
                }
                set _$fontFace$_(t) {
                    C3X._$RequireString$_(t), getActual2(this)._$SetFontName$_(t);
                }
                get _$fontFace$_() {
                    return getActual2(this)._$GetFontName$_();
                }
                set _$sizePt$_(t) {
                    C3X._$RequireFiniteNumber$_(t), getActual2(this)._$SetFontSize$_(t);
                }
                get _$sizePt$_() {
                    return getActual2(this)._$GetFontSize$_();
                }
                set lineHeight(t) {
                    C3X._$RequireFiniteNumber$_(t), getActual2(this)._$SetLineHeight$_(t);
                }
                get lineHeight() {
                    return getActual2(this)._$GetLineHeight$_();
                }
                set _$isBold$_(t) {
                    getActual2(this)._$SetBold$_(t);
                }
                get _$isBold$_() {
                    return getActual2(this)._$IsBold$_();
                }
                set _$isItalic$_(t) {
                    getActual2(this)._$SetItalic$_(t);
                }
                get _$isItalic$_() {
                    return getActual2(this)._$IsItalic$_();
                }
                setColor(t) {
                    C3X._$RequireArray$_(t), this._$setColorRgb$_(t[0], t[1], t[2]);
                }
                _$setColorRgb$_(t, e, s) {
                    getActual2(this)._$SetColorRgb$_(t, e, s);
                }
                _$setCssColor$_(t) {
                    C3X._$RequireString$_(t), getActual2(this)._$SetColor$_(t);
                }
                set _$horizontalAlign$_(t) {
                    getActual2(this)._$SetHorizontalAlignment$_(t);
                }
                get _$horizontalAlign$_() {
                    return getActual2(this)._$GetHorizontalAlignment$_();
                }
                set verticalAlign(t) {
                    getActual2(this)._$SetVerticalAlignment$_(t);
                }
                get verticalAlign() {
                    return getActual2(this)._$GetVerticalAlignment$_();
                }
                set _$wordWrapMode$_(t) {
                    getActual2(this)._$SetWordWrapMode$_(t);
                }
                get _$wordWrapMode$_() {
                    return getActual2(this)._$GetWordWrapMode$_();
                }
                set _$textDirection$_(t) {
                    getActual2(this)._$SetTextDirection$_(t);
                }
                get _$textDirection$_() {
                    return getActual2(this)._$GetTextDirection$_();
                }
                set text(t) {
                    C3X._$RequireString$_(t), getActual2(this)._$SetText$_(t);
                }
                get text() {
                    return getActual2(this)._$GetText$_();
                }
                _$setSize$_(t, e, s) {
                    C3X._$RequireFiniteNumber$_(t), C3X._$RequireFiniteNumber$_(e), 
                    C3X._$RequireFiniteNumber$_(s), getActual2(this)._$SetSize$_(t, e, s);
                }
                _$getTexture$_() {
                    const {
                        runtime: t,
                        _$rendererText$_: e
                    } = map.get(this), s = e._$GetTexture$_();
                    return self._$ITexture$_._$GetInterface$_(t, s);
                }
                _$getTexRect$_() {
                    return getActual2(this)._$GetTexRect$_()._$toDOMRect$_();
                }
                _$setTextureUpdateCallback$_(t) {
                    C3X._$RequireFunction$_(t), getActual2(this)._$ontextureupdate$_ = t;
                }
                _$releaseTexture$_() {
                    getActual2(this)._$ReleaseTexture$_();
                }
                get _$textWidth$_() {
                    return getActual2(this)._$GetTextWidth$_();
                }
                get _$textHeight$_() {
                    return getActual2(this)._$GetTextHeight$_();
                }
            };
        }
        {
            let GetTypeFromFileExtension2 = function(t) {
                if (!t) return "";
                const e = t.split(".");
                if (e.length < 2) return "";
                const s = e.at(-1).toLowerCase();
                return EXT_TO_TYPE.get(s) || "";
            }, AddScript2 = function(i) {
                return new Promise((t, e) => {
                    const s = document.createElement("script");
                    s.onload = t, s.onerror = e, s.async = !1, s.type = "module", 
                    s.src = i, document.head.appendChild(s);
                });
            };
            GetTypeFromFileExtension = GetTypeFromFileExtension2, AddScript = AddScript2;
            const C33 = self._$C3$_, VALID_LOAD_POLICIES = new Set([ "local", "remote" ]), EXT_TO_TYPE = new Map([ [ "mp4", "video/mp4" ], [ "webm", "video/webm" ], [ "m4a", "audio/mp4" ], [ "mp3", "audio/mpeg" ], [ "js", "application/javascript" ], [ "wasm", "application/wasm" ], [ "svg", "image/svg+xml" ], [ "html", "text/html" ] ]);
            C33._$AssetManager$_ = class extends C33._$DefendedBase$_ {
                constructor(t, e) {
                    super();
                    const s = e.exportType, i = (this._$_runtime$_ = t, this._$_fileStructure$_ = "folders", 
                    this._$_cordovaBlobUrlCache$_ = new Map(), this._$_isCordova$_ = "cordova" === s, 
                    this._$_isiOSCordova$_ = !!e.isiOSCordova, this._$_isFileProtocol$_ = !!e.isFileProtocol, 
                    this._$_swClientId$_ = e.swClientId, this._$_supportedAudioFormats$_ = e.supportedAudioFormats || {}, 
                    this._$_audioFiles$_ = new Map(), this._$_preloadSounds$_ = !1, 
                    this._$_scriptSubfolder$_ = e.scriptFolder, this._$_mediaSubfolder$_ = "", 
                    this._$_fontsSubfolder$_ = "", this._$_iconsSubfolder$_ = "", 
                    this._$_fileMap$_ = e.fileMap || new Map(), this._$_fileMapBlobUrls$_ = new Map(), 
                    "html5" === s || "scirra-arcade" === s || "instant-games" === s);
                    this._$_defaultLoadPolicy$_ = i ? "remote" : "local", this._$_assetsByUrl$_ = new Map(), 
                    this._$_webFonts$_ = [], this._$_loadPromises$_ = [], this._$_hasFinishedInitialLoad$_ = !1, 
                    this._$_totalAssetSizeToLoad$_ = 0, this._$_assetSizeLoaded$_ = 0, 
                    this._$_lastLoadProgress$_ = 0, this._$_hasHadErrorLoading$_ = !1, 
                    this._$_loadingRateLimiter$_ = C33._$New$_(C33._$RateLimiter$_, () => this._$_FireLoadingProgressEvent$_(), 50), 
                    this._$_localPromiseThrottle$_ = C33._$New$_(C33._$PromiseThrottle$_, Math.max(C33.hardwareConcurrency, 8)), 
                    this._$_remotePromiseThrottle$_ = C33._$New$_(C33._$PromiseThrottle$_, 20), 
                    this._$_iAssetManager$_ = new self._$IAssetManager$_(this);
                }
                _$Release$_() {
                    for (const t of this._$_assetsByUrl$_.values()) t._$Release$_();
                    this._$_assetsByUrl$_.clear(), C33._$clearArray$_(this._$_loadPromises$_), 
                    this._$_runtime$_ = null;
                }
                _$GetRuntime$_() {
                    return this._$_runtime$_;
                }
                _$_SetFileStructure$_(t) {
                    this._$_fileStructure$_ = t;
                }
                _$GetFileStructure$_() {
                    return this._$_fileStructure$_;
                }
                _$GetScriptSubfolder$_() {
                    return this._$_scriptSubfolder$_;
                }
                _$_SetMediaSubfolder$_(t) {
                    this._$_mediaSubfolder$_ = t;
                }
                _$GetMediaSubfolder$_() {
                    return this._$_mediaSubfolder$_;
                }
                _$_SetFontsSubfolder$_(t) {
                    this._$_fontsSubfolder$_ = t;
                }
                _$GetFontsSubfolder$_() {
                    return this._$_fontsSubfolder$_;
                }
                _$_SetIconsSubfolder$_(t) {
                    this._$_iconsSubfolder$_ = t;
                }
                _$GetIconsSubfolder$_() {
                    return this._$_iconsSubfolder$_;
                }
                _$IsFileProtocol$_() {
                    return this._$_isFileProtocol$_;
                }
                _$FetchBlob$_(t, e) {
                    return e = e || this._$_defaultLoadPolicy$_, C33._$IsRelativeURL$_(t) ? ("flat" === this._$_fileStructure$_ && (t = t.toLowerCase()), 
                    this._$_isCordova$_ && this._$_isFileProtocol$_ ? this._$CordovaFetchLocalFileAsBlob$_(t) : "playable-ad-single-file" === this._$_runtime$_._$GetExportType$_() ? self.c3_runtimeInterface._PlayableAdFetchBlob(t) : ("local" === e ? this._$_localPromiseThrottle$_ : this._$_remotePromiseThrottle$_)._$Add$_(() => C33._$FetchBlob$_(t))) : C33._$FetchBlob$_(t);
                }
                _$FetchArrayBuffer$_(t) {
                    return C33._$IsRelativeURL$_(t) ? ("flat" === this._$_fileStructure$_ && (t = t.toLowerCase()), 
                    this._$_isCordova$_ && this._$_isFileProtocol$_ ? this._$CordovaFetchLocalFileAsArrayBuffer$_(t) : "playable-ad-single-file" === this._$_runtime$_._$GetExportType$_() ? C33._$BlobToArrayBuffer$_(self.c3_runtimeInterface._PlayableAdFetchBlob(t)) : ("local" === this._$_defaultLoadPolicy$_ ? this._$_localPromiseThrottle$_ : this._$_remotePromiseThrottle$_)._$Add$_(() => C33._$FetchArrayBuffer$_(t))) : C33._$FetchArrayBuffer$_(t);
                }
                _$FetchText$_(t) {
                    return C33._$IsRelativeURL$_(t) ? ("flat" === this._$_fileStructure$_ && (t = t.toLowerCase()), 
                    this._$_isCordova$_ && this._$_isFileProtocol$_ ? this._$CordovaFetchLocalFileAsText$_(t) : "playable-ad-single-file" === this._$_runtime$_._$GetExportType$_() ? C33._$BlobToString$_(self.c3_runtimeInterface._PlayableAdFetchBlob(t)) : ("local" === this._$_defaultLoadPolicy$_ ? this._$_localPromiseThrottle$_ : this._$_remotePromiseThrottle$_)._$Add$_(() => C33._$FetchText$_(t))) : C33._$FetchText$_(t);
                }
                async _$FetchJson$_(t) {
                    const e = await this._$FetchText$_(t);
                    return JSON.parse(e);
                }
                _$_CordovaFetchLocalFileAs$_(t, e) {
                    return "flat" === this._$_fileStructure$_ && (t = t.toLowerCase()), 
                    this._$_runtime$_._$PostComponentMessageToDOMAsync$_("runtime", "cordova-fetch-local-file", {
                        filename: t,
                        as: e
                    });
                }
                _$CordovaFetchLocalFileAsText$_(t) {
                    return this._$_CordovaFetchLocalFileAs$_(t, "text");
                }
                async _$CordovaFetchLocalFileAsBlob$_(t) {
                    const e = await this._$_CordovaFetchLocalFileAs$_(t, "buffer"), s = GetTypeFromFileExtension2(t);
                    return new Blob([ e ], {
                        type: s
                    });
                }
                async _$CordovaFetchLocalFileAsBlobURL$_(t) {
                    "flat" === this._$_fileStructure$_ && (t = t.toLowerCase());
                    let e = this._$_cordovaBlobUrlCache$_.get(t);
                    if (!e) {
                        const s = await this._$CordovaFetchLocalFileAsBlob$_(t);
                        e = URL.createObjectURL(s), this._$_cordovaBlobUrlCache$_.set(t, e);
                    }
                    return e;
                }
                _$CordovaFetchLocalFileAsArrayBuffer$_(t) {
                    return this._$_CordovaFetchLocalFileAs$_(t, "buffer");
                }
                _$GetMediaFileUrl$_(t) {
                    "flat" === this._$_fileStructure$_ && (t = t.toLowerCase());
                    let e = this._$_mediaSubfolder$_ + t;
                    return "Gecko" === C33._$Platform$_._$BrowserEngine$_ && "preview" === this._$_runtime$_._$GetExportType$_() ? this._$_GetLocalBlobURLFromFileMap$_(e) : e;
                }
                _$GetProjectFileUrl$_(t) {
                    return C33._$IsAbsoluteURL$_(t) ? Promise.resolve(t) : this._$_isCordova$_ && this._$_isFileProtocol$_ ? this._$CordovaFetchLocalFileAsBlobURL$_(t) : "playable-ad-single-file" === this._$_runtime$_._$GetExportType$_() ? URL.createObjectURL(self.c3_runtimeInterface._PlayableAdFetchBlob(t)) : ("flat" === this._$_fileStructure$_ && (t = t.toLowerCase()), 
                    Promise.resolve(t));
                }
                _$GetProjectFileIframeUrl$_(e) {
                    if (C33._$IsAbsoluteURL$_(e) || "preview" !== this._$_runtime$_._$GetExportType$_() || !this._$_swClientId$_ || !e) return e;
                    try {
                        const t = new URL(e, location.href);
                        return t.searchParams.set("__c3_client_id", this._$_swClientId$_), 
                        t.toString();
                    } catch (t) {
                        return console.warn("Invalid iframe URL: " + e), e;
                    }
                }
                _$LoadProjectFileUrl$_(t) {
                    return this._$GetProjectFileUrl$_(t);
                }
                _$LoadImage$_(t) {
                    if (t._$loadPolicy$_ && !VALID_LOAD_POLICIES.has(t._$loadPolicy$_)) throw new Error("invalid load policy");
                    let e = this._$_assetsByUrl$_.get(t.url);
                    return e || (e = C33._$New$_(C33._$ImageAsset$_, this, {
                        url: t.url,
                        size: t.size || 0,
                        _$loadPolicy$_: t._$loadPolicy$_ || this._$_defaultLoadPolicy$_
                    }), this._$_assetsByUrl$_.set(e._$GetURL$_(), e), this._$_hasFinishedInitialLoad$_) || (this._$_totalAssetSizeToLoad$_ += e._$GetSize$_(), 
                    this._$_loadPromises$_.push(e._$Load$_().then(() => this._$_AddLoadedSize$_(e._$GetSize$_())))), 
                    e;
                }
                _$_ReleaseAsset$_(t) {
                    this._$_assetsByUrl$_.delete(t._$GetURL$_());
                }
                async _$WaitForAllToLoad$_() {
                    try {
                        await Promise.all(this._$_loadPromises$_), this._$_lastLoadProgress$_ = 1;
                    } catch (t) {
                        console.error("Error loading: ", t), this._$_hasHadErrorLoading$_ = !0, 
                        this._$_FireLoadingProgressEvent$_();
                    }
                }
                _$SetInitialLoadFinished$_() {
                    this._$_hasFinishedInitialLoad$_ = !0;
                }
                _$HasHadErrorLoading$_() {
                    return this._$_hasHadErrorLoading$_;
                }
                _$_AddLoadedSize$_(t) {
                    this._$_assetSizeLoaded$_ += t, this._$_loadingRateLimiter$_._$Call$_();
                }
                _$_FireLoadingProgressEvent$_() {
                    const t = C33._$New$_(C33.Event, "loadingprogress");
                    this._$_lastLoadProgress$_ = C33._$clamp$_(this._$_assetSizeLoaded$_ / this._$_totalAssetSizeToLoad$_, 0, 1), 
                    t.progress = this._$_lastLoadProgress$_, this._$_runtime$_._$Dispatcher$_().dispatchEvent(t);
                }
                _$GetLoadProgress$_() {
                    return this._$_lastLoadProgress$_;
                }
                _$GetImageLoadProgress$_() {
                    return this._$_runtime$_._$GetSystemPlugin$_()._$GetImageLoadingProgress$_();
                }
                _$_SetWebFonts$_(t) {
                    C33._$shallowAssignArray$_(this._$_webFonts$_, t), this._$_webFonts$_.length && this._$_loadPromises$_.push(this._$_LoadWebFonts$_());
                }
                async _$_LoadWebFonts$_() {
                    const t = [], e = [];
                    for (const [ s, i, r ] of this._$_webFonts$_) this._$_totalAssetSizeToLoad$_ += r, 
                    t.push(this._$_LoadWebFont$_(s, i, e).then(() => this._$_AddLoadedSize$_(r)));
                    await Promise.all(t), this._$_runtime$_._$IsInWorker$_() && 0 < e.length && await this._$_runtime$_._$PostComponentMessageToDOMAsync$_("runtime", "load-webfonts", {
                        webfonts: e
                    });
                }
                async _$_LoadWebFont$_(e, s, i) {
                    try {
                        let t = await this._$GetProjectFileUrl$_(s);
                        "Gecko" === C33._$Platform$_._$BrowserEngine$_ && (e = `'${e}'`), 
                        ("Gecko" === C33._$Platform$_._$BrowserEngine$_ && "preview" === this._$_runtime$_._$GetExportType$_() || "playable-ad-single-file" === this._$_runtime$_._$GetExportType$_()) && (t = this._$_GetLocalBlobURLFromFileMap$_(t));
                        const r = new FontFace(e, `url('${t}')`);
                        (this._$_runtime$_._$IsInWorker$_() ? self : document).fonts.add(r), 
                        await r.load(), this._$_runtime$_._$IsInWorker$_() && i.push({
                            name: e,
                            url: t
                        });
                    } catch (t) {
                        console.warn(`[C3 runtime] Failed to load web font '${e}': `, t);
                    }
                }
                _$IsAudioFormatSupported$_(t) {
                    return !!this._$_supportedAudioFormats$_[t];
                }
                _$_SetAudioFiles$_(t, e) {
                    this._$_preloadSounds$_ = !!e;
                    for (const [ s, i, r ] of t) this._$_audioFiles$_.set(s, {
                        fileName: s,
                        _$formats$_: i.map(t => ({
                            type: t[0],
                            _$fileExtension$_: t[1],
                            _$fullName$_: s + t[1],
                            fileSize: t[2]
                        })),
                        isMusic: r
                    });
                }
                _$GetPreferredAudioFile$_(t) {
                    "flat" === this._$_fileStructure$_ && (t = t.toLowerCase());
                    const e = this._$_audioFiles$_.get(t);
                    if (!e) return null;
                    let s = null;
                    for (const i of e._$formats$_) if (s || "audio/webm; codecs=opus" !== i.type || (s = i), 
                    this._$IsAudioFormatSupported$_(i.type)) return i;
                    return s;
                }
                _$GetProjectAudioFileUrl$_(t) {
                    const e = this._$GetPreferredAudioFile$_(t);
                    return e ? {
                        url: this._$GetMediaFileUrl$_(e._$fullName$_),
                        type: e.type
                    } : null;
                }
                _$GetAudioToPreload$_() {
                    if (this._$_preloadSounds$_) {
                        const t = [];
                        for (const e of this._$_audioFiles$_.values()) if (!e.isMusic) {
                            const s = this._$GetPreferredAudioFile$_(e.fileName);
                            s && t.push({
                                originalUrl: e.fileName,
                                url: this._$GetMediaFileUrl$_(s._$fullName$_),
                                type: s.type,
                                fileSize: s.fileSize
                            });
                        }
                        return t;
                    }
                    return [];
                }
                _$_GetLocalBlobFromFileMap$_(t) {
                    return "preview" === this._$_runtime$_._$GetExportType$_() && (t = new URL(t, location.href).toString()), 
                    this._$_fileMap$_.get(t) || null;
                }
                _$_GetLocalBlobURLFromFileMap$_(t) {
                    let e = this._$_fileMapBlobUrls$_.get(t);
                    if (!e) {
                        const s = this._$_GetLocalBlobFromFileMap$_(t);
                        if (!s) return t;
                        e = URL.createObjectURL(s), this._$_fileMapBlobUrls$_.set(t, e);
                    }
                    return e;
                }
                _$GetIAssetManager$_() {
                    return this._$_iAssetManager$_;
                }
                async _$LoadScripts$_(...t) {
                    const e = await Promise.all(t.map(t => this._$GetProjectFileUrl$_(t)));
                    if (this._$_runtime$_._$IsInWorker$_()) if (1 === t.length) {
                        const s = t[0];
                        await import((C33._$IsRelativeURL$_(s) ? "./" : "") + s);
                    } else {
                        const i = t.map(t => `import "${C33._$IsRelativeURL$_(t) ? "./" : ""}${t}";`).join("\n"), r = URL.createObjectURL(new Blob([ i ], {
                            type: "application/javascript"
                        }));
                        await import(r);
                    } else await Promise.all(e.map(t => AddScript2(t)));
                }
                async _$CompileWebAssembly$_(t) {
                    if (WebAssembly.compileStreaming) {
                        const e = await this._$GetProjectFileUrl$_(t);
                        return WebAssembly.compileStreaming(fetch(e));
                    }
                    {
                        const s = await C33._$FetchArrayBuffer$_(t);
                        return WebAssembly.compile(s);
                    }
                }
                async _$LoadStyleSheet$_(t) {
                    const e = await this._$GetProjectFileUrl$_(t);
                    return this._$_runtime$_._$PostComponentMessageToDOMAsync$_("runtime", "add-stylesheet", {
                        url: e
                    });
                }
            };
        }
        {
            const C33 = self._$C3$_;
            C33._$Asset$_ = class extends C33._$DefendedBase$_ {
                constructor(t, e) {
                    super(), this._$_assetManager$_ = t, this._$_runtime$_ = t._$GetRuntime$_(), 
                    this._$_url$_ = e.url || "", this._$_size$_ = e.size, this._$_loadPolicy$_ = e._$loadPolicy$_, 
                    this._$_blob$_ = e.blob || null, this._$_isLoaded$_ = !!this._$_blob$_, 
                    this._$_loadPromise$_ = null;
                }
                _$Release$_() {
                    this._$_loadPromise$_ = null, this._$_assetManager$_ = null, 
                    this._$_runtime$_ = null, this._$_blob$_ = null;
                }
                _$GetURL$_() {
                    return this._$_url$_;
                }
                _$GetSize$_() {
                    return this._$_size$_;
                }
                _$Load$_() {
                    return "local" === this._$_loadPolicy$_ || this._$_blob$_ ? (this._$_isLoaded$_ = !0, 
                    Promise.resolve()) : (this._$_loadPromise$_ || (this._$_loadPromise$_ = this._$_assetManager$_._$FetchBlob$_(this._$_url$_, this._$_loadPolicy$_).then(t => (this._$_isLoaded$_ = !0, 
                    this._$_loadPromise$_ = null, this._$_blob$_ = t)).catch(t => {
                        console.error("Error loading resource: ", t), this._$_loadPromise$_ = null;
                    })), this._$_loadPromise$_);
                }
                _$IsLoaded$_() {
                    return this._$_isLoaded$_;
                }
                _$GetBlob$_() {
                    return this._$_blob$_ ? Promise.resolve(this._$_blob$_) : this._$_loadPromise$_ || this._$_assetManager$_._$FetchBlob$_(this._$_url$_, this._$_loadPolicy$_);
                }
            };
        }
        {
            const C33 = self._$C3$_, promiseThrottle = new C33._$PromiseThrottle$_(), allImageAssets = new Set();
            C33._$ImageAsset$_ = class extends C33._$Asset$_ {
                constructor(t, e) {
                    super(t, e), this._$_texturePromise$_ = null, this._$_webglTexture$_ = null, 
                    this._$_refCount$_ = 0, this._$_imageWidth$_ = -1, this._$_imageHeight$_ = -1, 
                    allImageAssets.add(this);
                }
                _$Release$_() {
                    if (0 !== this._$_refCount$_) throw new Error("released image asset which still has texture references");
                    this._$_assetManager$_._$_ReleaseAsset$_(this), this._$_texturePromise$_ = null, 
                    allImageAssets.delete(this), super._$Release$_();
                }
                static _$OnRendererContextLost$_() {
                    for (const t of allImageAssets) t._$_texturePromise$_ = null, 
                    t._$_webglTexture$_ = null, t._$_refCount$_ = 0;
                }
                _$LoadStaticTexture$_(t, e) {
                    return e = e || {}, this._$_refCount$_++, this._$_webglTexture$_ ? Promise.resolve(this._$_webglTexture$_) : (this._$_texturePromise$_ || (e._$anisotropy$_ = this._$_runtime$_._$GetCanvasManager$_()._$GetTextureAnisotropy$_(), 
                    this._$_texturePromise$_ = this._$_DoLoadStaticTexture$_(t, e)), 
                    this._$_texturePromise$_);
                }
                async _$_DoLoadStaticTexture$_(e, s) {
                    try {
                        const i = await this._$GetBlob$_();
                        return 0 === this._$_refCount$_ ? this._$_texturePromise$_ = null : await promiseThrottle._$Add$_(async () => {
                            const t = await e._$CreateStaticTextureAsync$_(i, s);
                            return this._$_texturePromise$_ = null, 0 === this._$_refCount$_ ? (e._$DeleteTexture$_(t), 
                            null) : (this._$_webglTexture$_ = t, this._$_imageWidth$_ = t._$GetWidth$_(), 
                            this._$_imageHeight$_ = t._$GetHeight$_(), this._$_webglTexture$_);
                        });
                    } catch (t) {
                        throw console.error("Failed to load texture: ", t), t;
                    }
                }
                _$ReleaseTexture$_() {
                    if (this._$_refCount$_ <= 0) throw new Error("texture released too many times");
                    if (this._$_refCount$_--, 0 === this._$_refCount$_ && this._$_webglTexture$_) {
                        const t = this._$_webglTexture$_._$GetRenderer$_();
                        t._$DeleteTexture$_(this._$_webglTexture$_), this._$_webglTexture$_ = null;
                    }
                }
                _$GetRefCount$_() {
                    return this._$_refCount$_;
                }
                _$GetTexture$_() {
                    return this._$_webglTexture$_;
                }
                _$GetWidth$_() {
                    return this._$_imageWidth$_;
                }
                _$GetHeight$_() {
                    return this._$_imageHeight$_;
                }
                async _$LoadToDrawable$_() {
                    const t = await this._$GetBlob$_();
                    return C33._$Supports$_.ImageBitmap ? createImageBitmap(t) : C33._$BlobToImage$_(t);
                }
            };
        }
        {
            let SortByInstLastCachedZIndex2 = function(t, e) {
                return t._$GetWorldInfo$_()._$_GetLastCachedZIndex$_() - e._$GetWorldInfo$_()._$_GetLastCachedZIndex$_();
            };
            SortByInstLastCachedZIndex = SortByInstLastCachedZIndex2;
            const C33 = self._$C3$_, assert = self.assert;
            C33._$RenderCell$_ = class extends C33._$DefendedBase$_ {
                constructor(t, e, s) {
                    super(), this._$_grid$_ = t, this._$_x$_ = e, this._$_y$_ = s, 
                    this._$_instances$_ = [], this._$_isSorted$_ = !0, this._$_pendingRemoval$_ = new Set(), 
                    this._$_isAnyPendingRemoval$_ = !1;
                }
                _$Release$_() {
                    C33._$clearArray$_(this._$_instances$_), this._$_pendingRemoval$_.clear(), 
                    this._$_grid$_ = null;
                }
                _$Reset$_() {
                    C33._$clearArray$_(this._$_instances$_), this._$_isSorted$_ = !0, 
                    this._$_pendingRemoval$_.clear(), this._$_isAnyPendingRemoval$_ = !1;
                }
                _$SetChanged$_() {
                    this._$_isSorted$_ = !1;
                }
                _$IsEmpty$_() {
                    if (this._$_instances$_.length) {
                        if (this._$_instances$_.length > this._$_pendingRemoval$_.size) return !1;
                        this._$_FlushPending$_();
                    }
                    return !0;
                }
                _$Insert$_(t) {
                    this._$_pendingRemoval$_.has(t) ? (this._$_pendingRemoval$_.delete(t), 
                    0 === this._$_pendingRemoval$_.size && (this._$_isAnyPendingRemoval$_ = !1)) : (this._$_instances$_.push(t), 
                    this._$_isSorted$_ = 1 === this._$_instances$_.length);
                }
                _$Remove$_(t) {
                    this._$_pendingRemoval$_.add(t), this._$_isAnyPendingRemoval$_ = !0, 
                    50 <= this._$_pendingRemoval$_.size && this._$_FlushPending$_();
                }
                _$_FlushPending$_() {
                    this._$_isAnyPendingRemoval$_ && (this._$_instances$_.length === this._$_pendingRemoval$_.size ? this._$Reset$_() : (C33._$arrayRemoveAllInSet$_(this._$_instances$_, this._$_pendingRemoval$_), 
                    this._$_pendingRemoval$_.clear(), this._$_isAnyPendingRemoval$_ = !1));
                }
                _$_EnsureSorted$_() {
                    this._$_isSorted$_ || (this._$_instances$_.sort(SortByInstLastCachedZIndex2), 
                    this._$_isSorted$_ = !0);
                }
                _$Dump$_(t) {
                    this._$_FlushPending$_(), this._$_EnsureSorted$_(), this._$_instances$_.length && t.push(this._$_instances$_);
                }
            };
        }
        {
            const C33 = self._$C3$_;
            C33._$RenderGrid$_ = class extends C33._$DefendedBase$_ {
                constructor(t, e) {
                    super(), this._$_cellWidth$_ = t, this._$_cellHeight$_ = e, 
                    this._$_cells$_ = C33._$New$_(C33._$PairMap$_);
                }
                _$Release$_() {
                    this._$_cells$_._$Release$_(), this._$_cells$_ = null;
                }
                _$GetCell$_(t, e, s) {
                    let i = this._$_cells$_._$Get$_(t, e);
                    return i || (s ? (i = C33._$New$_(C33._$RenderCell$_, this, t, e), 
                    this._$_cells$_.Set(t, e, i), i) : null);
                }
                _$XToCell$_(t) {
                    return Math.floor(t / this._$_cellWidth$_);
                }
                _$YToCell$_(t) {
                    return Math.floor(t / this._$_cellHeight$_);
                }
                _$Update$_(i, r, n) {
                    if (r) for (let s = r._$getLeft$_(), t = r._$getRight$_(); s <= t; ++s) for (let t = r._$getTop$_(), e = r._$getBottom$_(); t <= e; ++t) if (!n || !n._$containsPoint$_(s, t)) {
                        const h = this._$GetCell$_(s, t, !1);
                        h && (h._$Remove$_(i), h._$IsEmpty$_()) && this._$_cells$_._$Delete$_(s, t);
                    }
                    if (n) for (let s = n._$getLeft$_(), t = n._$getRight$_(); s <= t; ++s) for (let t = n._$getTop$_(), e = n._$getBottom$_(); t <= e; ++t) r && r._$containsPoint$_(s, t) || this._$GetCell$_(s, t, !0)._$Insert$_(i);
                }
                _$QueryRange$_(t, e) {
                    let s = this._$XToCell$_(t._$getLeft$_()), i = this._$YToCell$_(t._$getTop$_()), r = this._$XToCell$_(t._$getRight$_()), n = this._$YToCell$_(t._$getBottom$_());
                    for (;s <= r; ++s) for (let t = i; t <= n; ++t) {
                        const h = this._$GetCell$_(s, t, !1);
                        h && h._$Dump$_(e);
                    }
                }
                _$MarkRangeChanged$_(t) {
                    let e = t._$getLeft$_(), s = t._$getTop$_(), i = t._$getRight$_(), r = t._$getBottom$_();
                    for (;e <= i; ++e) for (let t = s; t <= r; ++t) {
                        const n = this._$GetCell$_(e, t, !1);
                        n && n._$SetChanged$_();
                    }
                }
            };
        }
        {
            let SortByInstLastCachedZIndex2 = function(t, e) {
                return t._$GetWorldInfo$_()._$_GetLastCachedZIndex$_() - e._$GetWorldInfo$_()._$_GetLastCachedZIndex$_();
            }, SortByInstZElevation2 = function(t, e) {
                return t._$GetWorldInfo$_()._$GetZElevation$_() - e._$GetWorldInfo$_()._$GetZElevation$_();
            };
            SortByInstLastCachedZIndex = SortByInstLastCachedZIndex2, SortByInstZElevation = SortByInstZElevation2;
            const C33 = self._$C3$_, assert = self.assert, tmpRect = new C33.Rect(), tmpQuad = new C33._$Quad$_(), renderCellArr = [], tmpDestRect = new C33.Rect(), tmpSrcRect = new C33.Rect(), glMatrix = self._$glMatrix$_, vec32 = glMatrix._$vec3$_, vec42 = glMatrix._$vec4$_, mat42 = glMatrix._$mat4$_, tempMat4 = mat42.create(), tempVec3 = vec32.create(), tempVec4 = vec42.create(), camVector = vec32.create(), lookVector = vec32.create(), upVector = vec32.create(), tempVec2 = C33._$New$_(C33._$Vector2$_), tempRect = C33._$New$_(C33.Rect), tempInstanceList1 = [], tempInstanceList2 = [], tempInstancesByCameraDist = [], DEFAULT_LAYER_OPTIONS = {
                name: "",
                sid: -1,
                _$isDynamic$_: !1,
                isVisible: !0,
                isInteractive: !0,
                _$isHTMLElementsLayer$_: !1,
                backgroundColor: [ 1, 1, 1, 1 ],
                _$isTransparent$_: !0,
                _$parallax$_: [ 1, 1 ],
                opacity: 1,
                _$isForceOwnTexture$_: !1,
                _$renderAs3d$_: !1,
                _$useCameraDistanceDrawOrder$_: !1,
                _$useRenderCells$_: !1,
                scaleRate: 1,
                _$blendMode$_: 0,
                _$zElevation$_: 0,
                _$initialInstancesData$_: [],
                _$effectListData$_: [],
                _$subLayersData$_: []
            };
            C33._$Layer$_ = class extends C33._$DefendedBase$_ {
                constructor(t, e, s) {
                    super(), s = Object.assign({}, DEFAULT_LAYER_OPTIONS, s), this._$_layout$_ = t, 
                    this._$_runtime$_ = t._$GetRuntime$_(), this._$_parentLayer$_ = e, 
                    this._$_name$_ = s.name, this._$_index$_ = -1, this._$_isHTMLElementsLayer$_ = !!s._$isHTMLElementsLayer$_, 
                    this._$_htmlIndex$_ = -1, this._$_sid$_ = s.sid, this._$_isDynamic$_ = !!s._$isDynamic$_, 
                    this._$_isVisible$_ = !!s.isVisible, this._$_isInteractive$_ = !!s.isInteractive, 
                    this._$_backgroundColor$_ = C33._$New$_(C33._$Color$_), this._$_backgroundColor$_._$setFromJSON$_(s.backgroundColor), 
                    this._$_isTransparent$_ = !!s._$isTransparent$_, this._$_parallaxX$_ = s._$parallax$_[0], 
                    this._$_parallaxY$_ = s._$parallax$_[1], this._$_color$_ = C33._$New$_(C33._$Color$_, 1, 1, 1, s.opacity), 
                    this._$_premultipliedColor$_ = C33._$New$_(C33._$Color$_), this._$_isForceOwnTexture$_ = !!s._$isForceOwnTexture$_, 
                    this._$_renderAs3d$_ = !!s._$renderAs3d$_, this._$_useCameraDistanceDrawOrder$_ = !!s._$useCameraDistanceDrawOrder$_, 
                    this._$_useRenderCells$_ = !!s._$useRenderCells$_, this._$_scaleRate$_ = s.scaleRate, 
                    this._$_blendMode$_ = s._$blendMode$_, this._$_curRenderTarget$_ = null, 
                    this._$_scale$_ = 1, this._$_zElevation$_ = s._$zElevation$_, 
                    this._$_angle$_ = 0, this._$_scrollX$_ = 0, this._$_scrollY$_ = 0, 
                    this._$_hasOwnScrollPosition$_ = !1, this._$_viewport$_ = C33._$New$_(C33.Rect), 
                    this._$_viewportZ0$_ = C33._$New$_(C33.Rect), this._$_viewport3D$_ = C33._$New$_(C33.Rect), 
                    this._$_isViewportChanged$_ = !0, this._$_projectionMatrix$_ = mat42.create(), 
                    this._$_isProjectionMatrixChanged$_ = !0, this._$_modelViewMatrix$_ = mat42.create(), 
                    this._$_isMVMatrixChanged$_ = !0, this._$_viewFrustum$_ = C33._$New$_(C33._$Gfx$_._$ViewFrustum$_), 
                    this._$_isViewFrustumChanged$_ = !0, this._$_startupInitialInstances$_ = [], 
                    this._$_initialInstancesData$_ = s._$initialInstancesData$_, 
                    this._$_initialInstances$_ = [], this._$_createdGlobalUids$_ = [], 
                    this._$_initialUIDsToInstanceData$_ = new Map(), this._$_instances$_ = [], 
                    this._$_zIndicesUpToDate$_ = !1, this._$_htmlZIndicesUpToDate$_ = !1, 
                    this._$_anyInstanceZElevated$_ = !1;
                    const r = this._$_runtime$_._$GetCanvasManager$_();
                    this._$_effectList$_ = C33._$New$_(C33._$EffectList$_, this, s._$effectListData$_), 
                    this._$_effectChain$_ = C33._$New$_(C33._$Gfx$_._$EffectChain$_, r._$GetEffectChainManager$_(), {
                        _$drawContent$_: (t, e) => {
                            const s = e._$GetContentObject$_(), i = s._$GetRenderTarget$_();
                            t._$SetColor$_(s._$GetPremultipliedColor$_()), t._$DrawRenderTarget$_(i), 
                            t._$InvalidateRenderTarget$_(i), r._$ReleaseAdditionalRenderTarget$_(i);
                        },
                        _$getShaderParameters$_: t => this._$GetEffectList$_()._$_GetEffectChainShaderParametersForIndex$_(t)
                    }), this._$_needsRebuildEffectChainSteps$_ = !0, this._$_wasDefaultColor$_ = !0, 
                    this._$_renderGrid$_ = null, this._$_lastRenderList$_ = [], 
                    this._$_isRenderListUpToDate$_ = !1, this._$_lastRenderCells$_ = C33._$New$_(C33.Rect, 0, 0, -1, -1), 
                    this._$_curRenderCells$_ = C33._$New$_(C33.Rect, 0, 0, -1, -1), 
                    this._$_iLayer$_ = new self._$ILayer$_(this), this._$_UpdatePremultipliedColor$_(), 
                    this._$UsesRenderCells$_() && (this._$_renderGrid$_ = C33._$New$_(C33._$RenderGrid$_, this._$_runtime$_._$GetOriginalViewportWidth$_(), this._$_runtime$_._$GetOriginalViewportHeight$_())), 
                    this._$_subLayers$_ = s._$subLayersData$_.map(t => C33._$Layer$_._$CreateFromExportData$_(this._$_layout$_, this, t));
                }
                _$_InitInitialInstances$_() {
                    for (const t of this._$_initialInstancesData$_) {
                        const e = this._$_runtime$_._$GetObjectClassByIndex$_(t[1]);
                        this._$_layout$_._$_AddInitialObjectClass$_(e), e._$GetDefaultInstanceData$_() || (e._$SetDefaultInstanceData$_(t), 
                        e._$_SetDefaultLayerIndex$_(this._$_index$_)), this._$_initialInstances$_.push(t), 
                        this._$_initialUIDsToInstanceData$_.set(t[2], t);
                    }
                    C33._$shallowAssignArray$_(this._$_startupInitialInstances$_, this._$_initialInstances$_), 
                    this._$_initialInstancesData$_ = null;
                }
                static _$CreateFromExportData$_(t, e, s) {
                    return C33._$New$_(C33._$Layer$_, t, e, {
                        name: s[0],
                        sid: s[2],
                        isVisible: s[3],
                        isInteractive: s[13],
                        _$isHTMLElementsLayer$_: s[19],
                        backgroundColor: s[4].map(t => t / 255),
                        _$isTransparent$_: s[5],
                        _$parallax$_: [ s[6], s[7] ],
                        opacity: s[8],
                        _$isForceOwnTexture$_: s[9],
                        _$renderAs3d$_: s[17],
                        _$useCameraDistanceDrawOrder$_: s[18],
                        _$useRenderCells$_: s[10],
                        scaleRate: s[11],
                        _$blendMode$_: s[12],
                        _$zElevation$_: s[16],
                        _$initialInstancesData$_: s[14],
                        _$effectListData$_: s[15],
                        _$subLayersData$_: s[20]
                    });
                }
                _$Release$_() {
                    for (const t of this._$_subLayers$_) t._$Release$_();
                    C33._$clearArray$_(this._$_subLayers$_);
                    for (const e of this._$_instances$_) this._$_runtime$_._$DestroyInstance$_(e);
                    C33._$clearArray$_(this._$_instances$_), this._$_effectList$_._$Release$_(), 
                    this._$_effectList$_ = null, this._$_effectChain$_._$Release$_(), 
                    this._$_effectChain$_ = null, this._$_iLayer$_ = null, this._$_parentLayer$_ = null, 
                    this._$_layout$_ = null, this._$_runtime$_ = null;
                }
                _$GetInitialInstanceData$_(t) {
                    return this._$_initialUIDsToInstanceData$_.get(t);
                }
                _$CreateInitialInstances$_(r) {
                    let n = this._$_layout$_._$IsFirstVisit$_(), h = 0, o = this._$_initialInstances$_;
                    for (let i = 0, t = o.length; i < t; ++i) {
                        let t = o[i], e = this._$_runtime$_._$GetObjectClassByIndex$_(t[1]), s = !0;
                        if (!e._$HasPersistBehavior$_() || n) {
                            const a = this._$_runtime$_._$CreateInstanceFromData$_(t, this, !0);
                            r.push(a), e._$IsGlobal$_() && (s = !1, this._$_createdGlobalUids$_.push(a._$GetUID$_()));
                        }
                        s && (o[h] = o[i], ++h);
                    }
                    C33._$truncateArray$_(o, h), this._$_runtime$_._$FlushPendingInstances$_(), 
                    this._$SetZIndicesChanged$_();
                }
                _$_AddInstance$_(t, e) {
                    if (!t._$GetPlugin$_()._$IsWorldType$_()) throw new Error("instance is not of world type");
                    const s = t._$GetWorldInfo$_();
                    if (s._$GetLayer$_() !== this) throw new Error("instance added to wrong layer");
                    this._$_instances$_.push(t), 0 !== s._$GetZElevation$_() && (this._$_anyInstanceZElevated$_ = !0), 
                    e && this._$UsesRenderCells$_() && t._$GetWorldInfo$_()._$SetBboxChanged$_(), 
                    this._$SetZIndicesChanged$_(t);
                }
                _$_MaybeAddInstance$_(t) {
                    this._$_instances$_.includes(t) || (this._$_instances$_.push(t), 
                    0 !== t._$GetWorldInfo$_()._$GetZElevation$_() && (this._$_anyInstanceZElevated$_ = !0), 
                    this._$SetZIndicesChanged$_(t));
                }
                _$_PrependInstance$_(t, e) {
                    const s = t._$GetWorldInfo$_();
                    if (s._$GetLayer$_() !== this) throw new Error("instance added to wrong layer");
                    this._$_instances$_.unshift(t), 0 !== s._$GetZElevation$_() && (this._$_anyInstanceZElevated$_ = !0), 
                    this._$SetZIndicesChanged$_(t), e && this._$UsesRenderCells$_() && t._$GetWorldInfo$_()._$SetBboxChanged$_();
                }
                _$_RemoveInstance$_(t, e) {
                    const s = this._$_instances$_.indexOf(t);
                    s < 0 || (e && this._$UsesRenderCells$_() && t._$GetWorldInfo$_()._$_RemoveFromRenderCells$_(), 
                    this._$_instances$_.splice(s, 1), this._$SetZIndicesChanged$_(t), 
                    this._$_MaybeResetAnyInstanceZElevatedFlag$_());
                }
                _$_SetAnyInstanceZElevated$_() {
                    this._$_anyInstanceZElevated$_ = !0;
                }
                _$_MaybeResetAnyInstanceZElevatedFlag$_() {
                    0 === this._$_instances$_.length && (this._$_anyInstanceZElevated$_ = !1);
                }
                _$_SortInstancesByLastCachedZIndex$_(t) {
                    if (t) {
                        const e = new Set();
                        for (const s of this._$_instances$_) {
                            const i = s._$GetWorldInfo$_()._$_GetLastCachedZIndex$_();
                            0 <= i && e.add(i);
                        }
                        let t = -1;
                        for (const r of this._$_instances$_) {
                            const n = r._$GetWorldInfo$_();
                            if (!(0 <= n._$_GetLastCachedZIndex$_())) {
                                for (++t; e.has(t); ) ++t;
                                n._$_SetZIndex$_(t);
                            }
                        }
                    }
                    this._$_instances$_.sort(SortByInstLastCachedZIndex2);
                }
                _$_Start$_() {}
                _$_End$_() {
                    for (const t of this._$_instances$_) t._$GetObjectClass$_()._$IsGlobal$_() || this._$_runtime$_._$DestroyInstance$_(t);
                    this._$_runtime$_._$FlushPendingInstances$_(), C33._$clearArray$_(this._$_instances$_), 
                    this._$_anyInstanceZElevated$_ = !1, this._$SetZIndicesChanged$_();
                }
                _$RecreateInitialObjects$_(e, t, s, i, r, n) {
                    const h = this._$_runtime$_._$GetEventSheetManager$_(), o = this._$_runtime$_._$GetAllObjectClasses$_(), a = e._$IsFamily$_(), l = [];
                    for (const u of this._$_initialInstances$_) {
                        const c = u[0], f = c[0], d = c[1];
                        if (t._$containsPoint$_(f, d)) {
                            const p = o[u[1]];
                            if (p !== e) {
                                if (!a) continue;
                                if (!e._$FamilyHasMember$_(p)) continue;
                            }
                            let t = r;
                            if (!t) {
                                const g = this._$_runtime$_._$GetCurrentLayout$_();
                                t = this._$GetLayout$_() === g ? this : (t = g._$GetLayerByName$_(this._$GetName$_())) || g._$GetLayerByIndex$_(this._$GetIndex$_());
                            }
                            const m = this._$_runtime$_._$CreateInstanceFromData$_(u, t, !1, void 0, void 0, !1, n), C = (t._$SortAndAddInstancesByZIndex$_(m), 
                            m._$GetWorldInfo$_());
                            C._$OffsetXY$_(s, i), C._$SetBboxChanged$_(), h._$BlockFlushingInstances$_(!0), 
                            m._$_TriggerOnCreatedOnSelfAndRelated$_(), h._$BlockFlushingInstances$_(!1), 
                            l.push(m);
                        }
                    }
                    return l;
                }
                _$GetInstanceCount$_() {
                    return this._$_instances$_.length;
                }
                _$GetLayout$_() {
                    return this._$_layout$_;
                }
                _$GetName$_() {
                    return this._$_name$_;
                }
                _$_SetIndex$_(t) {
                    this._$_index$_ = t;
                }
                _$GetIndex$_() {
                    return this._$_index$_;
                }
                _$_SetHTMLIndex$_(t) {
                    this._$_htmlIndex$_ = t;
                }
                _$GetHTMLIndex$_() {
                    return this._$_htmlIndex$_;
                }
                _$IsHTMLElementsLayer$_() {
                    return this._$_isHTMLElementsLayer$_;
                }
                _$SetIsHTMLElementsLayer$_(t) {
                    this._$_isHTMLElementsLayer$_ !== (t = !!t) && (this._$_isHTMLElementsLayer$_ = t, 
                    this._$_layout$_._$_ReindexAndUpdateAllLayers$_(), this._$_runtime$_._$UpdateRender$_());
                }
                _$_GetSiblingIndex$_() {
                    let t = this._$GetParentLayer$_();
                    return (t ? t._$GetSubLayers$_() : this._$GetLayout$_()._$_GetRootLayers$_()).indexOf(this);
                }
                _$GetSID$_() {
                    return this._$_sid$_;
                }
                _$GetRuntime$_() {
                    return this._$_runtime$_;
                }
                _$IsDynamic$_() {
                    return this._$_isDynamic$_;
                }
                _$HasAnyDynamicParentLayer$_() {
                    for (const t of this._$parentLayers$_()) if (t._$IsDynamic$_()) return !0;
                    return !1;
                }
                _$GetDevicePixelRatio$_() {
                    return this._$_runtime$_._$GetDevicePixelRatio$_();
                }
                _$GetEffectList$_() {
                    return this._$_effectList$_;
                }
                _$GetEffectChain$_() {
                    return this._$_MaybeRebuildEffectChainSteps$_(), this._$_effectChain$_;
                }
                _$_MaybeRebuildEffectChainSteps$_() {
                    const t = this._$HasDefaultColor$_();
                    if (this._$_needsRebuildEffectChainSteps$_ || t !== this._$_wasDefaultColor$_ || this._$_effectChain$_._$NeedsRebuild$_()) {
                        const e = this._$GetEffectList$_()._$GetActiveEffectTypes$_();
                        this._$_effectChain$_._$BuildSteps$_(e.map(t => t._$GetShaderProgram$_()), {
                            _$indexMap$_: e.map(t => t._$GetIndex$_()),
                            _$forcePreDraw$_: !t,
                            _$useFullSurface$_: !0
                        }), this._$_needsRebuildEffectChainSteps$_ = !1, this._$_wasDefaultColor$_ = t;
                    }
                }
                _$UpdateActiveEffects$_() {
                    this._$GetEffectList$_()._$UpdateActiveEffects$_(), this._$_needsRebuildEffectChainSteps$_ = !0;
                }
                _$UsesRenderCells$_() {
                    return this._$_useRenderCells$_ && !this._$_useCameraDistanceDrawOrder$_;
                }
                _$GetRenderGrid$_() {
                    return this._$_renderGrid$_;
                }
                _$SetRenderListStale$_() {
                    this._$_isRenderListUpToDate$_ = !1;
                }
                _$IsVisible$_() {
                    for (const t of this._$selfAndParentLayers$_()) if (!t._$_IsVisibleFlagSet$_()) return !1;
                    return !0;
                }
                _$_IsVisibleFlagSet$_() {
                    return this._$_isVisible$_;
                }
                _$SetVisible$_(t) {
                    this._$_isVisible$_ !== (t = !!t) && (this._$_isVisible$_ = t, 
                    this._$_runtime$_._$UpdateRender$_());
                }
                _$SetInteractive$_(t) {
                    this._$_isInteractive$_ = !!t;
                }
                _$IsInteractive$_() {
                    return this._$_isInteractive$_;
                }
                _$IsSelfAndParentsInteractive$_() {
                    for (const t of this._$selfAndParentLayers$_()) if (!t._$IsInteractive$_()) return !1;
                    return !0;
                }
                _$SetOwnScrollPositionEnabled$_(t) {
                    if (this._$_hasOwnScrollPosition$_ !== (t = !!t)) {
                        if (this._$_hasOwnScrollPosition$_ = t) {
                            const e = this._$GetLayout$_();
                            this._$_scrollX$_ = e._$GetScrollX$_(), this._$_scrollY$_ = e._$GetScrollY$_();
                        }
                        this._$_SetMVMatrixChanged$_(), this._$_runtime$_._$UpdateRender$_();
                    }
                }
                _$IsOwnScrollPositionEnabled$_() {
                    return this._$_hasOwnScrollPosition$_;
                }
                _$SetScrollX$_(t) {
                    const e = this._$GetLayout$_(), s = e._$GetScrollLeftBound$_(), i = e._$GetScrollRightBound$_();
                    this._$_scrollX$_ !== (t = (t = i < t ? i : t) < s ? s : t) && (this._$_scrollX$_ = t, 
                    this._$IsOwnScrollPositionEnabled$_()) && (this._$_SetMVMatrixChanged$_(), 
                    this._$_runtime$_._$UpdateRender$_());
                }
                _$SetScrollY$_(t) {
                    const e = this._$GetLayout$_(), s = e._$GetScrollTopBound$_(), i = e._$GetScrollBottomBound$_();
                    this._$_scrollY$_ !== (t = (t = i < t ? i : t) < s ? s : t) && (this._$_scrollY$_ = t, 
                    this._$IsOwnScrollPositionEnabled$_()) && (this._$_SetMVMatrixChanged$_(), 
                    this._$_runtime$_._$UpdateRender$_());
                }
                _$GetScrollX$_() {
                    return this._$IsOwnScrollPositionEnabled$_() ? this._$_scrollX$_ : this._$GetLayout$_()._$GetScrollX$_();
                }
                _$GetScrollY$_() {
                    return this._$IsOwnScrollPositionEnabled$_() ? this._$_scrollY$_ : this._$GetLayout$_()._$GetScrollY$_();
                }
                _$GetViewport$_() {
                    return this._$_MaybeUpdateViewport$_(), this._$_viewport$_;
                }
                _$_GetViewportZ0$_() {
                    return this._$_MaybeUpdateViewport$_(), this._$_viewportZ0$_;
                }
                _$GetViewport3D$_() {
                    return this._$_MaybeUpdateViewport$_(), this._$_viewport3D$_;
                }
                _$_GetVanishingPoint$_() {
                    const t = this._$GetLayout$_();
                    return [ t._$GetVanishingPointX$_(), t._$GetVanishingPointY$_() ];
                }
                _$GetDefaultCameraZ$_(t) {
                    return this._$_runtime$_._$GetDefaultCameraZ$_(t);
                }
                _$GetViewportForZ$_(c, i) {
                    const r = this._$_GetViewportZ0$_();
                    if (0 === c) i._$copy$_(r); else {
                        let o = r._$midX$_(), a = r._$midY$_(), t = this._$Get2DScaleFactorToZ$_(c), e = r.width() / t, s = r.height() / t, [ l, u ] = this._$_GetVanishingPoint$_();
                        if (.5 !== l || .5 !== u) {
                            let t = this._$Get2DCameraZ$_(), e = this._$_runtime$_, s = this._$GetDefaultCameraZ$_() / t, i = (l - .5) * e._$GetViewportWidth$_() / s, r = (u - .5) * e._$GetViewportHeight$_() / s, n = this.GetAngle(), h = (0 !== n && (tempVec2.set(i, r), 
                            tempVec2.rotate(n), i = tempVec2._$getX$_(), r = tempVec2._$getY$_()), 
                            C33._$unlerp$_(t, 0, c));
                            o += C33._$lerp$_(i, 0, h), a += C33._$lerp$_(r, 0, h);
                        }
                        i.set(o - e / 2, a - s / 2, o + e / 2, a + s / 2);
                    }
                }
                _$GetOpacity$_() {
                    return this._$_color$_._$getA$_();
                }
                _$SetOpacity$_(t) {
                    t = C33._$clamp$_(t, 0, 1), this._$_color$_._$getA$_() !== t && (this._$_color$_._$setA$_(t), 
                    this._$_UpdatePremultipliedColor$_(), this._$_runtime$_._$UpdateRender$_());
                }
                _$_UpdatePremultipliedColor$_() {
                    this._$_premultipliedColor$_._$copy$_(this._$_color$_), this._$_premultipliedColor$_._$premultiply$_();
                }
                _$GetPremultipliedColor$_() {
                    return this._$_premultipliedColor$_;
                }
                _$HasDefaultColor$_() {
                    return this._$_color$_._$equalsRgba$_(1, 1, 1, 1);
                }
                _$GetScaleRate$_() {
                    return this._$_scaleRate$_;
                }
                _$SetScaleRate$_(t) {
                    this._$_scaleRate$_ !== t && (this._$_scaleRate$_ = t, this._$_SetMVMatrixChanged$_(), 
                    this._$_runtime$_._$UpdateRender$_());
                }
                _$GetParallaxX$_() {
                    return this._$_parallaxX$_;
                }
                _$GetParallaxY$_() {
                    return this._$_parallaxY$_;
                }
                _$SetParallax$_(t, e) {
                    this._$_parallaxX$_ === t && this._$_parallaxY$_ === e || (this._$_parallaxX$_ = t, 
                    this._$_parallaxY$_ = e, this._$_SetMVMatrixChanged$_(), this._$_runtime$_._$UpdateRender$_());
                }
                _$SetParallaxX$_(t) {
                    this._$SetParallax$_(t, this._$GetParallaxY$_());
                }
                _$SetParallaxY$_(t) {
                    this._$SetParallax$_(this._$GetParallaxX$_(), t);
                }
                _$SetZElevation$_(t) {
                    this._$_zElevation$_ !== t && (this._$_zElevation$_ = t, this._$_runtime$_._$UpdateRender$_());
                }
                _$GetZElevation$_() {
                    return this._$_zElevation$_;
                }
                _$SetAngle$_(t) {
                    t = C33._$clampAngle$_(t), this._$_angle$_ !== t && (this._$_angle$_ = t, 
                    this._$_SetMVMatrixChanged$_(), this._$_runtime$_._$UpdateRender$_());
                }
                GetAngle() {
                    return C33._$clampAngle$_(this._$_layout$_.GetAngle() + this._$_angle$_);
                }
                _$GetOwnAngle$_() {
                    return this._$_angle$_;
                }
                _$HasInstances$_() {
                    return 0 < this._$_instances$_.length;
                }
                _$_GetInstances$_() {
                    return this._$_instances$_;
                }
                _$_GetInstancesInDrawOrder$_() {
                    return this._$RendersIn3DMode$_() && this._$_useCameraDistanceDrawOrder$_ ? (C33._$shallowAssignArray$_(tempInstancesByCameraDist, this._$_GetInstances$_()), 
                    tempInstancesByCameraDist.sort((t, e) => this._$_SortInstancesByCameraDistance$_(t, e)), 
                    tempInstancesByCameraDist) : this._$_GetInstances$_();
                }
                _$_AppendAllInstancesIncludingSubLayersInDrawOrder$_(t) {
                    C33._$appendArray$_(t, this._$_GetInstancesInDrawOrder$_());
                    for (const e of this._$_subLayers$_) e._$IsVisible$_() && 0 < e._$GetOpacity$_() && e._$_AppendAllInstancesIncludingSubLayersInDrawOrder$_(t);
                }
                _$_SortInstancesByCameraDistance$_(t, e) {
                    const s = this._$GetLayout$_()._$Get3DCameraPosition$_(), i = s[0], r = s[1], n = s[2], h = t._$GetWorldInfo$_(), o = e._$GetWorldInfo$_(), a = h._$GetX$_() - i, l = h._$GetY$_() - r, u = h._$GetZElevation$_() - n, c = o._$GetX$_() - i, f = o._$GetY$_() - r, d = o._$GetZElevation$_() - n;
                    return c * c + f * f + d * d - (a * a + l * l + u * u);
                }
                _$GetBackgroundColor$_() {
                    return this._$_backgroundColor$_;
                }
                _$IsTransparent$_() {
                    return this._$_isTransparent$_;
                }
                _$SetTransparent$_(t) {
                    this._$_isTransparent$_ !== (t = !!t) && (this._$_isTransparent$_ = t, 
                    this._$_runtime$_._$UpdateRender$_());
                }
                _$IsForceOwnTexture$_() {
                    return this._$_isForceOwnTexture$_;
                }
                _$SetForceOwnTexture$_(t) {
                    this._$_isForceOwnTexture$_ !== (t = !!t) && (this._$_isForceOwnTexture$_ = t, 
                    this._$_runtime$_._$UpdateRender$_());
                }
                _$RendersIn2DMode$_() {
                    return !this._$GetRuntime$_()._$Uses3DFeatures$_() || !this._$_renderAs3d$_;
                }
                _$RendersIn3DMode$_() {
                    return !this._$RendersIn2DMode$_();
                }
                _$Has3DCamera$_() {
                    return this._$RendersIn3DMode$_() && this._$GetLayout$_()._$Is3DCameraEnabled$_();
                }
                _$SelfAndAllSubLayersHave3DCamera$_() {
                    if (!this._$Has3DCamera$_()) return !1;
                    for (const t of this._$_subLayers$_) if (!t._$SelfAndAllSubLayersHave3DCamera$_()) return !1;
                    return !0;
                }
                _$SetBlendMode$_(t) {
                    this._$_blendMode$_ !== t && (this._$_blendMode$_ = t, this._$_runtime$_._$UpdateRender$_());
                }
                _$GetBlendMode$_() {
                    return this._$_blendMode$_;
                }
                _$IsRootLayer$_() {
                    return !this._$_parentLayer$_;
                }
                _$GetParentLayer$_() {
                    return this._$_parentLayer$_;
                }
                _$_SetParentLayer$_(t) {
                    this._$_parentLayer$_ = t;
                }
                _$GetSubLayers$_() {
                    return this._$_subLayers$_;
                }
                _$HasAnySubLayers$_() {
                    return 0 < this._$_subLayers$_.length;
                }
                _$_AddSubLayer$_(t, e = !0) {
                    e ? this._$_subLayers$_.push(t) : this._$_subLayers$_.unshift(t);
                }
                _$_InsertSubLayer$_(t, e, s) {
                    let i = this._$_subLayers$_.indexOf(e);
                    if (-1 === i) throw new Error("cannot find layer to insert by");
                    s && ++i, this._$_subLayers$_.splice(i, 0, t);
                }
                _$_RemoveSubLayer$_(t) {
                    const e = this._$_subLayers$_.indexOf(t);
                    if (-1 === e) throw new Error("cannot find layer to remove");
                    this._$_subLayers$_.splice(e, 1);
                }
                _$HasAnyVisibleSubLayer$_() {
                    for (const t of this._$_subLayers$_) if (t._$ShouldDraw$_()) return !0;
                    return !1;
                }
                *_$selfAndAllSubLayers$_() {
                    for (const t of this._$_subLayers$_) yield* t._$selfAndAllSubLayers$_();
                    yield this;
                }
                *_$parentLayers$_() {
                    let t = this._$GetParentLayer$_();
                    for (;t; ) yield t, t = t._$GetParentLayer$_();
                }
                *_$selfAndParentLayers$_() {
                    yield this, yield* this._$parentLayers$_();
                }
                _$HasParentLayer$_(t) {
                    for (const e of this._$parentLayers$_()) if (e === t) return !0;
                    return !1;
                }
                _$IsTransformCompatibleWith$_(t) {
                    return this === t || this._$_parallaxX$_ === t._$_parallaxX$_ && this._$_parallaxY$_ === t._$_parallaxY$_ && this._$_scale$_ === t._$_scale$_ && this._$_scaleRate$_ === t._$_scaleRate$_ && this._$_angle$_ === t._$_angle$_ && this._$GetScrollX$_() === t._$GetScrollX$_() && this._$GetScrollY$_() === t._$GetScrollY$_();
                }
                _$SaveTransform$_() {
                    return {
                        parallaxX: this._$GetParallaxX$_(),
                        parallaxY: this._$GetParallaxY$_(),
                        scale: this._$GetOwnScale$_(),
                        scaleRate: this._$GetScaleRate$_(),
                        angle: this._$GetOwnAngle$_(),
                        hasOwnScroll: this._$IsOwnScrollPositionEnabled$_(),
                        scrollX: this._$GetScrollX$_(),
                        scrollY: this._$GetScrollY$_()
                    };
                }
                _$RestoreTransform$_(t) {
                    this._$SetParallax$_(t.parallaxX, t.parallaxY), this._$SetOwnScale$_(t.scale), 
                    this._$SetScaleRate$_(t.scaleRate), this._$SetAngle$_(t.angle), 
                    this._$SetOwnScrollPositionEnabled$_(t.hasOwnScroll), this._$SetScrollX$_(t.scrollX), 
                    this._$SetScrollY$_(t.scrollY), this._$_MaybeUpdateViewport$_();
                }
                _$_RemoveAllInstancesInSet$_(t) {
                    if (0 !== t.size) {
                        const e = C33._$arrayRemoveAllInSet$_(this._$_instances$_, t);
                        0 < e && (this._$_MaybeResetAnyInstanceZElevatedFlag$_(), 
                        this._$SetZIndicesChanged$_());
                    }
                }
                _$SetZIndicesChanged$_(t) {
                    this._$_zIndicesUpToDate$_ = !1, this._$_isRenderListUpToDate$_ = !1, 
                    t && !t._$GetObjectClass$_()._$GetPlugin$_()._$IsHTMLElementType$_() || (this._$_htmlZIndicesUpToDate$_ = !1);
                }
                _$_UpdateZIndices$_() {
                    if (!this._$_zIndicesUpToDate$_) {
                        if (this._$_instances$_.sort(SortByInstZElevation2), this._$UsesRenderCells$_()) for (let t = 0, e = this._$_instances$_.length; t < e; ++t) {
                            const s = this._$_instances$_[t]._$GetWorldInfo$_();
                            s._$_SetZIndex$_(t), this._$_renderGrid$_._$MarkRangeChanged$_(s._$GetRenderCellRange$_());
                        } else for (let t = 0, e = this._$_instances$_.length; t < e; ++t) this._$_instances$_[t]._$GetWorldInfo$_()._$_SetZIndex$_(t);
                        this._$_zIndicesUpToDate$_ = !0;
                    }
                }
                _$_UpdateHTMLZIndices$_() {
                    if (!this._$_htmlZIndicesUpToDate$_) {
                        let t = this._$_layout$_._$GetRootLayersForHTMLLayer$_(this._$GetHTMLIndex$_()), e = t.map(t => [ ...t._$selfAndAllSubLayers$_() ]).flat(), s = 0;
                        for (const i of e) {
                            for (const r of i._$_GetInstances$_()) r._$GetObjectClass$_()._$GetPlugin$_()._$IsHTMLElementType$_() && r._$GetWorldInfo$_()._$_SetHTMLZIndex$_(s++);
                            i._$_SetHTMLZIndicesUpToDate$_();
                        }
                    }
                }
                _$_SetHTMLZIndicesUpToDate$_() {
                    this._$_htmlZIndicesUpToDate$_ = !0;
                }
                _$_GetHTMLLayerDOMState$_() {
                    return {
                        isVisible: this._$IsVisible$_(),
                        opacity: this._$GetOpacity$_(),
                        isInteractive: this._$IsInteractive$_()
                    };
                }
                _$MoveInstanceAdjacent$_(t, e, s) {
                    const i = t._$GetWorldInfo$_(), r = e._$GetWorldInfo$_();
                    if (i._$GetLayer$_() !== this || r._$GetLayer$_() !== this) throw new Error("can't arrange Z order unless both objects on this layer");
                    let n = i._$GetZIndex$_(), h = r._$GetZIndex$_();
                    return n !== h + (s ? 1 : -1) && (C33._$arrayRemove$_(this._$_instances$_, n), 
                    n < h && h--, s && h++, h === this._$_instances$_.length ? this._$_instances$_.push(t) : this._$_instances$_.splice(h, 0, t), 
                    this._$SetZIndicesChanged$_(t), !0);
                }
                _$_MergeSortedZArrays$_(t, e) {
                    let s = [], i = 0, r = 0, n = t.length, h = e.length;
                    for (;i < n && r < h; ) {
                        const o = t[i], a = e[r];
                        o._$GetWorldInfo$_()._$_GetLastCachedZIndex$_() < a._$GetWorldInfo$_()._$_GetLastCachedZIndex$_() ? (s.push(o), 
                        ++i) : (s.push(a), ++r);
                    }
                    for (;i < n; ++i) s.push(t[i]);
                    for (;r < h; ++r) s.push(e[r]);
                    return s;
                }
                _$_MergeAllSortedZArrays_pass$_(e) {
                    const s = [], i = e.length;
                    for (let t = 0; t < i - 1; t += 2) {
                        const r = e[t], n = e[t + 1];
                        s.push(this._$_MergeSortedZArrays$_(r, n));
                    }
                    return i % 2 == 1 && s.push(e[i - 1]), s;
                }
                _$_MergeAllSortedZArrays$_(t) {
                    for (;1 < t.length; ) t = this._$_MergeAllSortedZArrays_pass$_(t);
                    return t[0];
                }
                _$_GetRenderCellInstancesToDraw$_() {
                    return this._$_UpdateZIndices$_(), C33._$clearArray$_(renderCellArr), 
                    this._$_renderGrid$_._$QueryRange$_(this._$GetViewport$_(), renderCellArr), 
                    renderCellArr.length ? 1 === renderCellArr.length ? renderCellArr[0] : this._$_MergeAllSortedZArrays$_(renderCellArr) : [];
                }
                _$ShouldDraw$_() {
                    return this._$IsVisible$_() && 0 < this._$GetOpacity$_() && this._$_DrawsAnyContentInSelfOrSubLayers$_();
                }
                _$_DrawsAnyContentInSelfOrSubLayers$_() {
                    if (this._$HasInstances$_() || !this._$IsTransparent$_()) return !0;
                    for (const t of this._$_subLayers$_) if (t._$_DrawsAnyContentInSelfOrSubLayers$_()) return !0;
                    return !1;
                }
                _$UsesOwnTexture$_() {
                    return this._$IsForceOwnTexture$_() || !this._$HasDefaultColor$_() || 0 !== this._$GetBlendMode$_() || this._$_effectList$_._$HasAnyActiveEffect$_();
                }
                _$SelfOrAnySubLayerUsesOwnTexture$_() {
                    if (this._$UsesOwnTexture$_()) return !0;
                    for (const t of this._$_subLayers$_) if (t._$SelfOrAnySubLayerUsesOwnTexture$_()) return !0;
                    return !1;
                }
                _$GetRenderTarget$_() {
                    return this._$_curRenderTarget$_;
                }
                _$Get2DScaleFactorToZ$_(t) {
                    if (this._$_layout$_._$IsOrthographicProjection$_()) return 1;
                    {
                        const e = this._$Get3DCameraZ$_();
                        return e / (e - t);
                    }
                }
                _$GetResolutionScaleFactorToZ$_(t) {
                    const e = this._$_runtime$_._$GetRenderScale$_();
                    if (this._$_layout$_._$IsOrthographicProjection$_()) return e;
                    {
                        const s = this._$Get3DCameraZ$_(), i = this._$GetDefaultCameraZ$_();
                        return i / Math.abs(s - t) * e;
                    }
                }
                _$_SetMVMatrixChanged$_() {
                    this._$_isMVMatrixChanged$_ = !0, this._$_isViewFrustumChanged$_ = !0, 
                    this._$_isViewportChanged$_ = !0;
                }
                _$_GetModelViewMatrix$_(t) {
                    return this._$_isMVMatrixChanged$_ && (this._$_CalculateModelViewMatrix$_(t, this._$_modelViewMatrix$_, 0, 0, null), 
                    this._$_isMVMatrixChanged$_ = !1), this._$_modelViewMatrix$_;
                }
                _$Get2DCameraZ$_(t) {
                    return this._$GetDefaultCameraZ$_(t) / this._$GetNormalScale$_();
                }
                _$Get3DCameraZ$_() {
                    return this._$Has3DCamera$_() ? this._$GetLayout$_()._$Get3DCameraPosition$_()[2] : this._$Get2DCameraZ$_();
                }
                _$GetCameraPosition$_() {
                    if (this._$Has3DCamera$_()) {
                        const t = this._$GetLayout$_()._$Get3DCameraPosition$_();
                        return [ t[0], t[1], t[2] ];
                    }
                    return this._$_Get2DCameraPosition$_();
                }
                _$_Get2DCameraPosition$_(t = 0, e = 0, r = 0) {
                    let n = this._$_runtime$_, s = this._$GetLayout$_(), i = n._$GetParallaxXOrigin$_(), h = n._$GetParallaxYOrigin$_(), o = (this._$GetScrollX$_() - i) * this._$_parallaxX$_ + i, a = (this._$GetScrollY$_() - h) * this._$_parallaxY$_ + h, l = (n._$IsPixelRoundingEnabled$_() && (o = Math.round(o), 
                    a = Math.round(a)), o + t), u = a + e, c = s._$IsOrthographicProjection$_() ? this._$GetDefaultCameraZ$_(r) : this._$Get2DCameraZ$_(r), [ f, d ] = this._$_GetVanishingPoint$_();
                    if (.5 !== f || .5 !== d) {
                        let t = this._$GetDefaultCameraZ$_(r) / c, e = (f - .5) * n._$GetViewportWidth$_() / t, s = (d - .5) * n._$GetViewportHeight$_() / t, i = this.GetAngle();
                        0 !== i && (tempVec2.set(e, s), tempVec2.rotate(i), e = tempVec2._$getX$_(), 
                        s = tempVec2._$getY$_()), l += e, u += s;
                    }
                    return [ l, u, c ];
                }
                _$_CalculateModelViewMatrix$_(t, e, s, i, r) {
                    const n = this._$_runtime$_, h = this._$GetLayout$_();
                    if (this._$Has3DCamera$_()) {
                        vec32._$copy$_(camVector, h._$Get3DCameraPosition$_()), 
                        vec32._$copy$_(lookVector, h._$Get3DCameraLookAt$_()), vec32._$copy$_(upVector, h._$Get3DCameraUpVector$_());
                        const o = n._$GetParallaxXOrigin$_(), a = n._$GetParallaxYOrigin$_(), l = lookVector[0] - camVector[0], u = lookVector[1] - camVector[1], c = lookVector[2] - camVector[2];
                        camVector[0] = (camVector[0] - o) * this._$_parallaxX$_ + o, 
                        camVector[1] = (camVector[1] - a) * this._$_parallaxY$_ + a, 
                        camVector[2] *= Math.max(this._$_parallaxX$_, this._$_parallaxY$_), 
                        lookVector[0] = camVector[0] + l, lookVector[1] = camVector[1] + u, 
                        lookVector[2] = camVector[2] + c;
                    } else {
                        const [ f, d, p ] = this._$_Get2DCameraPosition$_(s, i, r), m = (vec32.set(camVector, f, d, p), 
                        vec32.set(lookVector, f, d, p - 100), this.GetAngle());
                        0 === m ? vec32.set(upVector, 0, 1, 0) : vec32.set(upVector, Math.sin(m), Math.cos(m), 0);
                    }
                    t._$CalculateLookAtModelView$_(e, camVector, lookVector, upVector, r || n._$GetViewportHeight$_());
                }
                _$_SetProjectionMatrixChanged$_() {
                    this._$_isProjectionMatrixChanged$_ = !0, this._$_isViewFrustumChanged$_ = !0, 
                    this._$_isViewportChanged$_ = !0;
                }
                _$_GetProjectionMatrix$_(t) {
                    return this._$_isProjectionMatrixChanged$_ && (this._$_CalculateProjectionMatrix$_(t), 
                    this._$_isProjectionMatrixChanged$_ = !1), this._$_projectionMatrix$_;
                }
                _$_CalculateProjectionMatrix$_(t) {
                    const e = this._$_runtime$_._$GetCanvasManager$_(), [ s, i ] = this._$_GetVanishingPoint$_();
                    if (this._$_layout$_._$IsOrthographicProjection$_()) t._$CalculateOrthographicMatrix$_(this._$_projectionMatrix$_, e._$GetDrawWidth$_(), e._$GetDrawHeight$_()); else if (.5 === s && .5 === i) mat42._$copy$_(this._$_projectionMatrix$_, e._$GetDefaultProjectionMatrix$_()); else {
                        const r = e._$GetDrawWidth$_(), n = e._$GetDrawHeight$_();
                        t._$CalculatePerspectiveMatrix$_(this._$_projectionMatrix$_, r / n, s, i);
                    }
                }
                _$_SetTransform$_(t, e = !0, s = 0, i = 0, r = 0) {
                    e && t._$SetProjectionMatrix$_(this._$_GetProjectionMatrix$_(t));
                    let n;
                    n = 0 === s && 0 === i && 0 === r ? this._$_GetModelViewMatrix$_(t) : (this._$_CalculateModelViewMatrix$_(t, tempMat4, s, i, r), 
                    tempMat4), t._$SetModelViewMatrix$_(n);
                }
                _$PrepareForDraw$_(t) {
                    this._$_SetTransform$_(t), t._$SetBaseZ$_(this._$GetZElevation$_());
                }
                _$_MaybeStartWebGLProfiling$_(t) {
                    let e = null;
                    if (t._$IsWebGL$_() && this._$_runtime$_._$IsGPUProfiling$_()) {
                        const s = this._$_runtime$_._$GetCanvasManager$_()._$GetLayerTimingsBuffer$_(this);
                        s && (e = s._$AddTimeElapsedQuery$_(), t._$StartQuery$_(e));
                    }
                    return e;
                }
                _$_MaybeStartWebGPUProfiling$_(t) {
                    if (t._$IsWebGPU$_() && this._$_runtime$_._$IsGPUProfiling$_()) {
                        const e = 2 * (this._$GetIndex$_() + 1);
                        t._$StartMeasuringRenderPassTime$_(e, 1 + e);
                    }
                }
                _$Draw$_(t, e, s) {
                    let i = this._$_runtime$_._$GetCanvasManager$_(), r = this._$UsesOwnTexture$_(), n = null, h = this._$_MaybeStartWebGLProfiling$_(t);
                    if (this._$_MaybeStartWebGPUProfiling$_(t), r) {
                        const o = {
                            _$sampling$_: this._$_runtime$_._$GetSampling$_(),
                            _$isSampled$_: !0,
                            _$canReadPixels$_: !!t._$IsWebGPU$_() && this._$_runtime$_._$UsesAnyBackgroundBlending$_()
                        };
                        "low" === i._$GetCurrentFullscreenScalingQuality$_() && (o.width = i._$GetDrawWidth$_(), 
                        o.height = i._$GetDrawHeight$_()), n = this._$_runtime$_._$GetAdditionalRenderTarget$_(o), 
                        this._$_curRenderTarget$_ = n, t._$SetRenderTarget$_(n), 
                        this._$IsTransparent$_() && t._$ClearRgba$_(0, 0, 0, 0);
                    } else this._$_curRenderTarget$_ = e, t._$SetRenderTarget$_(e);
                    if (this._$IsTransparent$_() || t._$Clear$_(this._$_backgroundColor$_), 
                    this._$_layout$_._$_DrawLayerList$_(t, this._$_curRenderTarget$_, this._$_subLayers$_, r && this._$IsTransparent$_()), 
                    this._$_MaybeStartWebGPUProfiling$_(t), this._$_SetTransform$_(t), 
                    t._$SetBaseZ$_(this._$GetZElevation$_()), t._$SetDepthEnabled$_(this._$RendersIn3DMode$_()), 
                    this._$GetNormalScale$_() > Number.EPSILON) {
                        this._$_UpdateZIndices$_();
                        const a = this._$UsesRenderCells$_() && 0 === this._$GetZElevation$_() && !this._$_anyInstanceZElevated$_;
                        this._$Has3DCamera$_() ? this._$_DrawInstances_3DCamera$_(t) : a ? this._$_DrawInstances_RenderCells$_(t) : this._$_DrawInstances$_(t, this._$_GetInstancesInDrawOrder$_());
                    }
                    t._$SetBaseZ$_(0), t._$SetCurrentZ$_(0), r && (t._$SetDepthEnabled$_(!1), 
                    this._$_DrawLayerOwnTextureToRenderTarget$_(t, n, e, s)), h && t._$EndQuery$_(h), 
                    this._$_curRenderTarget$_ = null;
                }
                _$_DrawInstances$_(s, i) {
                    let r = this._$GetViewport$_(), n = this._$_curRenderTarget$_, h = this._$GetLayout$_()._$IsOrthographicProjection$_(), o = this._$GetLayout$_()._$HasVanishingPointOutsideViewport$_(), a = null;
                    for (let t = 0, e = i.length; t < e; ++t) {
                        const l = i[t];
                        if (l !== a) {
                            const u = (a = l)._$GetWorldInfo$_();
                            u._$IsVisible$_() && u._$IsInViewport$_(r, o, h) && this._$_DrawInstanceMaybeWithEffects$_(l, u, s, n);
                        }
                    }
                }
                _$_DrawInstances_3DCamera$_(i) {
                    const r = this._$_curRenderTarget$_, n = this._$_GetViewFrustum$_(), h = tempInstanceList1, o = tempInstanceList2, a = this._$_GetInstancesInDrawOrder$_();
                    for (let e = 0, s = a.length; e < s; ) {
                        const l = a[e], u = l._$GetWorldInfo$_();
                        if (u._$IsVisible$_() && u._$IsInViewport3D$_(n)) {
                            (!l._$RendersToOwnZPlane$_() || 0 < u._$GetDepth$_()) && o.push(l);
                            const c = l._$GetWorldInfo$_()._$GetTotalZElevation$_();
                            h.push(l);
                            let t = e + 1;
                            for (;t < s; ++t) {
                                const f = a[t], d = f._$GetWorldInfo$_();
                                if (d._$IsVisible$_() && d._$IsInViewport3D$_(n)) {
                                    if (d._$GetTotalZElevation$_() !== c) break;
                                    (f._$RendersToOwnZPlane$_() ? (0 < d._$GetDepth$_() && o.push(f), 
                                    h) : o).push(f);
                                }
                            }
                            if (1 !== h.length || h[0]._$MustMitigateZFighting$_()) {
                                this._$_DrawCoplanarInstances_3DCamera$_(i, h);
                                for (let t = 0, e = o.length; t < e; ++t) {
                                    const p = o[t], m = p._$GetWorldInfo$_();
                                    m._$_SetDrawNonBackFacesOnly$_(!0), this._$_DrawInstanceMaybeWithEffects$_(p, m, i, r), 
                                    m._$_SetDrawNonBackFacesOnly$_(!1);
                                }
                            } else {
                                this._$_DrawInstanceMaybeWithEffects$_(l, u, i, r);
                                for (let t = 0, e = o.length; t < e; ++t) {
                                    const C = o[t];
                                    if (C !== l) {
                                        const g = C._$GetWorldInfo$_(), S = g._$GetLayer$_();
                                        S._$_DrawInstanceMaybeWithEffects$_(C, g, i, r);
                                    }
                                }
                            }
                            e = t, C33._$clearArray$_(h), C33._$clearArray$_(o);
                        } else ++e;
                    }
                }
                _$_DrawCoplanarInstances_3DCamera$_(s, i) {
                    const r = this._$_curRenderTarget$_;
                    s._$CoplanarStartStencilPass$_();
                    for (let t = 0, e = i.length; t < e; ++t) {
                        const n = i[t], h = n._$GetWorldInfo$_();
                        h._$_SetDrawBackFaceOnly$_(!0), this._$_DrawInstance$_(n, h, s);
                    }
                    s._$CoplanarStartColorPass$_();
                    for (let t = 0, e = i.length; t < e; ++t) {
                        const o = i[t], a = o._$GetWorldInfo$_();
                        this._$_DrawInstanceMaybeWithEffects$_(o, a, s, r), a._$_SetDrawBackFaceOnly$_(!1);
                    }
                    s._$CoplanarRestoreStandardRendering$_();
                }
                _$_DrawInstances_RenderCells$_(t) {
                    let e = this._$_renderGrid$_, s = this._$_curRenderCells$_, i = this._$_lastRenderCells$_, r = this._$GetViewport$_(), n;
                    s.set(e._$XToCell$_(r._$getLeft$_()), e._$YToCell$_(r._$getTop$_()), e._$XToCell$_(r._$getRight$_()), e._$YToCell$_(r._$getBottom$_())), 
                    this._$_isRenderListUpToDate$_ && s.equals(i) ? n = this._$_lastRenderList$_ : (n = this._$_GetRenderCellInstancesToDraw$_(), 
                    this._$_isRenderListUpToDate$_ = !0, i._$copy$_(s)), this._$_DrawInstances$_(t, n), 
                    n !== this._$_lastRenderList$_ && C33._$shallowAssignArray$_(this._$_lastRenderList$_, n);
                }
                _$_DrawInstanceMaybeWithEffects$_(t, e, s, i) {
                    e._$HasAnyActiveEffect$_() ? this._$_DrawInstanceWithEffectsAndRestore$_(t, e, s, i) : this._$_DrawInstance$_(t, e, s);
                }
                _$_DrawInstance$_(t, e, s) {
                    const i = e._$GetRendererStateGroup$_();
                    s._$GetCurrentStateGroup$_() !== i && i._$Apply$_(), t._$Draw$_(s);
                }
                _$_DrawInstanceWithEffectsAndRestore$_(t, e, s, i) {
                    this._$_DrawInstanceWithEffects$_(t, e, s, i, null) && this._$_SetTransform$_(s);
                }
                _$_DrawInstanceWithEffects$_(t, e, s, i, r) {
                    const n = e._$GetInstanceEffectList$_()._$GetEffectChain$_();
                    return n._$Render$_(s, i, {
                        _$contentObject$_: t,
                        _$blendMode$_: e._$GetBlendMode$_(),
                        devicePixelRatio: this._$_runtime$_._$GetEffectDevicePixelRatioParam$_(),
                        time: t._$GetInstanceGameTime$_(),
                        _$layerScale$_: this._$_runtime$_._$GetEffectLayerScaleParam$_() * this._$GetNormalScale$_(),
                        _$layerAngle$_: this.GetAngle(),
                        _$layoutRect$_: e._$GetBoundingBox$_(),
                        _$drawSurfaceRect$_: n._$CanSkipCalculatingDrawSurfaceRect$_() ? null : this._$_InstanceBoxToDrawSurface$_(e),
                        _$drawContentHook$_: r && r._$drawContentHook$_,
                        _$compositOffX$_: r && r._$compositOffX$_,
                        _$compositOffY$_: r && r._$compositOffY$_,
                        _$updateOwnProjection$_: r && r._$updateOwnProjection$_
                    }), s._$SetBaseZ$_(this._$GetZElevation$_()), n._$DidChangeTransform$_();
                }
                _$_DrawLayerOwnTextureToRenderTarget$_(t, e, s, i) {
                    const r = this._$_effectList$_._$GetActiveEffectTypes$_(), n = this._$_runtime$_;
                    0 === r.length ? (t._$SetRenderTarget$_(s), t._$SetTextureFillMode$_(), 
                    i && 0 === this._$_blendMode$_ && this._$HasDefaultColor$_() ? t._$CopyRenderTarget$_(e) : (t._$SetBlendMode$_(this._$_blendMode$_), 
                    t._$SetColor$_(this._$_premultipliedColor$_), t._$DrawRenderTarget$_(e)), 
                    t._$InvalidateRenderTarget$_(e), n._$ReleaseAdditionalRenderTarget$_(e)) : this._$GetEffectChain$_()._$Render$_(t, s, {
                        _$contentObject$_: this,
                        _$blendMode$_: this._$GetBlendMode$_(),
                        devicePixelRatio: n._$GetEffectDevicePixelRatioParam$_(),
                        _$layerScale$_: n._$GetEffectLayerScaleParam$_() * this._$GetNormalScale$_(),
                        _$layerAngle$_: this.GetAngle(),
                        _$layoutRect$_: this._$GetViewport$_(),
                        _$drawSurfaceRect$_: null,
                        _$invalidateRenderTargets$_: !0
                    });
                }
                _$GetOwnScale$_() {
                    return this._$_scale$_;
                }
                _$SetOwnScale$_(t) {
                    this._$_scale$_ !== t && (this._$_scale$_ = t, this._$_layout$_._$BoundScrolling$_(), 
                    this._$_SetMVMatrixChanged$_(), this._$_runtime$_._$UpdateRender$_());
                }
                _$GetRenderScale$_() {
                    return this._$GetNormalScale$_() * this._$_runtime$_._$GetRenderScale$_();
                }
                _$GetDisplayScale$_() {
                    return this._$GetNormalScale$_() * this._$_runtime$_._$GetDisplayScale$_();
                }
                _$GetNormalScale$_() {
                    return (this._$_scale$_ * this._$_layout$_._$GetScale$_() - 1) * this._$_scaleRate$_ + 1;
                }
                _$_MaybeUpdateViewport$_() {
                    if (this._$_isViewportChanged$_) {
                        this._$_isViewportChanged$_ = !1;
                        let t = this._$_runtime$_._$GetParallaxXOrigin$_(), e = this._$_runtime$_._$GetParallaxYOrigin$_(), s = (this._$GetScrollX$_() - t) * this._$_parallaxX$_ + t, i = (this._$GetScrollY$_() - e) * this._$_parallaxY$_ + e, r = this._$GetNormalScale$_(), n = this._$_runtime$_._$GetViewportWidth$_() / r, h = this._$_runtime$_._$GetViewportHeight$_() / r, o = s - n / 2, a = i - h / 2;
                        this._$_runtime$_._$IsPixelRoundingEnabled$_() && (o = Math.round(o), 
                        a = Math.round(a));
                        const l = this._$_viewportZ0$_, u = (l.set(o, a, o + n, a + h), 
                        this.GetAngle()), c = (0 !== u && (tmpRect._$copy$_(l), 
                        tmpRect.offset(-l._$midX$_(), -l._$midY$_()), tmpQuad._$setFromRotatedRect$_(tmpRect, u), 
                        tmpQuad._$getBoundingBox$_(tmpRect), tmpRect.offset(l._$midX$_(), l._$midY$_()), 
                        l._$copy$_(tmpRect)), this._$_zElevation$_);
                        this._$GetViewportForZ$_(c, this._$_viewport$_), this._$Has3DCamera$_() ? this._$CalculateViewport3D$_(c, this._$_viewport3D$_) : this._$_viewport3D$_._$copy$_(this._$_viewport$_);
                    }
                }
                _$CalculateViewport3D$_(t, e) {
                    let s = this._$_runtime$_._$GetCanvasManager$_(), i = s._$GetCssWidth$_(), r = s._$GetCssHeight$_(), [ n, h ] = this._$CanvasCssToLayer$_(0, 0, t), [ o, a ] = this._$CanvasCssToLayer$_(i, 0, t), [ l, u ] = this._$CanvasCssToLayer$_(i, r, t), [ c, f ] = this._$CanvasCssToLayer$_(0, r, t), d = Math.min(n, o, l, c), p = Math.min(h, a, u, f), m = Math.max(n, o, l, c), C = Math.max(h, a, u, f);
                    isFinite(d) || (d = -1 / 0), isFinite(p) || (p = -1 / 0), isFinite(m) || (m = 1 / 0), 
                    isFinite(C) || (C = 1 / 0), e.set(d, p, m, C);
                }
                _$CanvasCssToLayer$_(t, e, s = 0) {
                    return this._$_CanvasToLayer$_(t, e, s, this._$GetDisplayScale$_());
                }
                _$DrawSurfaceToLayer$_(t, e, s = 0) {
                    return this._$_CanvasToLayer$_(t, e, s, this._$GetRenderScale$_() * this._$GetDevicePixelRatio$_());
                }
                _$_CanvasToLayer$_(t, e, s, i) {
                    const r = this._$_runtime$_, n = r._$GetRenderer$_(), h = this._$GetNormalScale$_(), o = r._$GetViewportWidth$_() / h, a = r._$GetViewportHeight$_() / h, l = tempVec4, u = (vec42.set(l, 0, 0, o, a), 
                    t /= i, e = l[3] - e / i, this._$_GetProjectionMatrix$_(n)), c = this._$_GetModelViewMatrix$_(n), f = tempVec3, d = C33._$Gfx$_._$UnprojectScreenToWorldZ$_(t, e, s, c, u, l, f);
                    return d ? [ f[0], f[1] ] : [ NaN, NaN ];
                }
                _$CanvasCssToLayer_DefaultTransform$_(t, e) {
                    const s = this._$_scale$_, i = this._$_scaleRate$_, r = this._$_parallaxX$_, n = this._$_parallaxY$_, h = this._$_angle$_, o = (this._$_scale$_ = 1, 
                    this._$_scaleRate$_ = 1, this._$_parallaxX$_ = 1, this._$_parallaxY$_ = 1, 
                    this._$_angle$_ = 0, this._$_SetMVMatrixChanged$_(), this._$CanvasCssToLayer$_(t, e));
                    return this._$_scale$_ = s, this._$_scaleRate$_ = i, this._$_parallaxX$_ = r, 
                    this._$_parallaxY$_ = n, this._$_angle$_ = h, this._$_SetMVMatrixChanged$_(), 
                    o;
                }
                _$LayerToCanvasCss$_(t, e, s = 0) {
                    return this._$_LayerToCanvas$_(t, e, s, this._$GetDisplayScale$_());
                }
                _$LayerToDrawSurface$_(t, e, s = 0) {
                    return this._$_LayerToCanvas$_(t, e, s, this._$GetRenderScale$_() * this._$GetDevicePixelRatio$_());
                }
                _$_LayerToCanvas$_(t, e, s, i) {
                    const r = this._$_runtime$_, n = r._$GetRenderer$_(), h = this._$GetNormalScale$_(), o = r._$GetViewportWidth$_() / h, a = r._$GetViewportHeight$_() / h, l = tempVec4, u = (vec42.set(l, 0, 0, o, a), 
                    this._$_GetProjectionMatrix$_(n)), c = this._$_GetModelViewMatrix$_(n), f = tempVec3, d = C33._$Gfx$_._$Project$_(t, e, s, c, u, l, f);
                    return d ? [ f[0] * i, (l[3] - f[1]) * i ] : [ NaN, NaN ];
                }
                _$_GetLayerToDrawSurfaceScale$_(t, e) {
                    return t *= this._$GetRenderScale$_() * this._$GetDevicePixelRatio$_(), 
                    0 !== e && (t *= this._$Get2DScaleFactorToZ$_(e)), t;
                }
                _$_InstanceBoxToDrawSurface$_(t) {
                    const e = t._$GetBoundingBox$_(), s = t._$GetTotalZElevation$_(), i = t._$GetDepth$_(), l = s + i, u = e._$getLeft$_(), c = e._$getTop$_(), f = e._$getRight$_(), d = e._$getBottom$_();
                    if (this._$Has3DCamera$_()) {
                        if (this._$_IsPointBehindNearPlane$_(u, c, s) || this._$_IsPointBehindNearPlane$_(f, c, s) || this._$_IsPointBehindNearPlane$_(f, d, s) || this._$_IsPointBehindNearPlane$_(u, d, s)) return null;
                        if (0 < i && (this._$_IsPointBehindNearPlane$_(u, c, l) || this._$_IsPointBehindNearPlane$_(f, c, l) || this._$_IsPointBehindNearPlane$_(f, d, l) || this._$_IsPointBehindNearPlane$_(u, d, l))) return null;
                    } else if (l >= this._$Get2DCameraZ$_()) return null;
                    let [ p, m ] = this._$LayerToDrawSurface$_(u, c, s), [ C, g ] = this._$LayerToDrawSurface$_(f, d, s);
                    if (0 !== this.GetAngle() || 0 < i || this._$Has3DCamera$_()) {
                        const [ S, _ ] = this._$LayerToDrawSurface$_(f, c, s), [ T, y ] = this._$LayerToDrawSurface$_(u, d, s);
                        if (0 < i) {
                            let [ t, e ] = this._$LayerToDrawSurface$_(u, c, l), [ s, i ] = this._$LayerToDrawSurface$_(f, c, l), [ r, n ] = this._$LayerToDrawSurface$_(f, d, l), [ h, o ] = this._$LayerToDrawSurface$_(u, d, l), a = Math.min(p, C, S, T, t, s, r, h);
                            C = Math.max(p, C, S, T, t, s, r, h), p = a, a = Math.min(m, g, _, y, e, i, n, o), 
                            g = Math.max(m, g, _, y, e, i, n, o), m = a;
                        } else {
                            let t = Math.min(p, C, S, T);
                            C = Math.max(p, C, S, T), p = t, t = Math.min(m, g, _, y), 
                            g = Math.max(m, g, _, y), m = t;
                        }
                    }
                    return tmpRect.set(p, m, C, g), tmpRect;
                }
                _$_GetViewFrustum$_() {
                    return this._$_isViewFrustumChanged$_ && (this._$_UpdateViewFrustum$_(), 
                    this._$_isViewFrustumChanged$_ = !1), this._$_viewFrustum$_;
                }
                _$_UpdateViewFrustum$_() {
                    const t = this._$_runtime$_._$GetRenderer$_(), e = this._$_GetProjectionMatrix$_(t), s = this._$_GetModelViewMatrix$_(t);
                    this._$_viewFrustum$_._$CalculatePlanes$_(s, e);
                }
                _$_IsPointBehindNearPlane$_(t, e, s) {
                    return this._$_GetViewFrustum$_()._$IsBehindNearPlane$_(t, e, s);
                }
                _$_SaveToJson$_() {
                    const t = {
                        d: this._$IsDynamic$_(),
                        s: this._$GetOwnScale$_(),
                        a: this._$GetOwnAngle$_(),
                        v: this._$_IsVisibleFlagSet$_(),
                        i: this._$IsInteractive$_(),
                        html: this._$IsHTMLElementsLayer$_(),
                        bc: this._$_backgroundColor$_.toJSON(),
                        t: this._$IsTransparent$_(),
                        sx: this._$_scrollX$_,
                        sy: this._$_scrollY$_,
                        hosp: this._$_hasOwnScrollPosition$_,
                        px: this._$GetParallaxX$_(),
                        py: this._$GetParallaxY$_(),
                        c: this._$_color$_.toJSON(),
                        sr: this._$GetScaleRate$_(),
                        fx: this._$_effectList$_._$SaveToJson$_(),
                        cg: this._$_createdGlobalUids$_
                    };
                    return t;
                }
                _$_LoadFromJson$_(t) {
                    this._$_isDynamic$_ = !!t.d, this._$_scale$_ = t.s, this._$_angle$_ = t.a, 
                    this._$_isVisible$_ = !!t.v, this._$_isInteractive$_ = !t.hasOwnProperty("i") || t.i, 
                    this._$_isHTMLElementsLayer$_ = !!t.html, this._$_backgroundColor$_._$setFromJSON$_(t.bc), 
                    this._$_isTransparent$_ = !!t.t, t.hasOwnProperty("sx") && (this._$_scrollX$_ = t.sx), 
                    t.hasOwnProperty("sy") && (this._$_scrollY$_ = t.sy), t.hasOwnProperty("hosp") && (this._$_hasOwnScrollPosition$_ = !!t.hosp), 
                    this._$_parallaxX$_ = t.px, this._$_parallaxY$_ = t.py, this._$_color$_._$setFromJSON$_(t.c), 
                    this._$_UpdatePremultipliedColor$_(), this._$_scaleRate$_ = t.sr, 
                    C33._$shallowAssignArray$_(this._$_createdGlobalUids$_, t.cg), 
                    C33._$shallowAssignArray$_(this._$_initialInstances$_, this._$_startupInitialInstances$_);
                    let s = new Set(this._$_createdGlobalUids$_), i = 0;
                    for (let t = 0, e = this._$_initialInstances$_.length; t < e; ++t) s.has(this._$_initialInstances$_[t][2]) || (this._$_initialInstances$_[i] = this._$_initialInstances$_[t], 
                    ++i);
                    C33._$truncateArray$_(this._$_initialInstances$_, i), this._$_effectList$_._$LoadFromJson$_(t.fx), 
                    this._$_needsRebuildEffectChainSteps$_ = !0;
                }
                _$_LoadFromJsonAfterInstances$_() {
                    this._$_SortInstancesByLastCachedZIndex$_(!1), this._$SetZIndicesChanged$_(), 
                    this._$_SetMVMatrixChanged$_(), this._$_SetProjectionMatrixChanged$_();
                }
                _$GetILayer$_() {
                    return this._$_iLayer$_;
                }
                _$SortAndAddInstancesByZIndex$_(t, e = !1) {
                    if (this._$_instances$_.includes(t)) e && this._$_instances$_.sort((t, e) => {
                        const s = t._$GetWorldInfo$_()._$GetSceneGraphZIndex$_(), i = e._$GetWorldInfo$_()._$GetSceneGraphZIndex$_();
                        return s - i;
                    }); else if (t._$HasChildren$_()) {
                        const s = [ ...t._$allChildren$_() ];
                        s.push(t), s.sort((t, e) => {
                            const s = t._$GetWorldInfo$_()._$GetSceneGraphZIndex$_(), i = e._$GetWorldInfo$_()._$GetSceneGraphZIndex$_();
                            return s - i;
                        });
                        for (const i of s) if (i._$IsInContainer$_()) for (const r of i._$siblings$_()) if (!s.includes(r)) {
                            const n = [ ...r._$allChildren$_() ];
                            n.push(r), n.sort((t, e) => {
                                const s = t._$GetWorldInfo$_()._$GetSceneGraphZIndex$_(), i = e._$GetWorldInfo$_()._$GetSceneGraphZIndex$_();
                                return s - i;
                            }), n && n.length && s.splice(s.length, 0, ...n);
                        }
                        for (const h of s) h._$GetPlugin$_()._$IsWorldType$_() && this._$_AddInstance$_(h, !0);
                    } else if (t._$GetPlugin$_()._$IsWorldType$_() && this._$_AddInstance$_(t, !0), 
                    t._$IsInContainer$_()) for (const o of t._$siblings$_()) {
                        const a = [ ...o._$allChildren$_() ];
                        if (a.push(o), a.sort((t, e) => {
                            const s = t._$GetWorldInfo$_()._$GetSceneGraphZIndex$_(), i = e._$GetWorldInfo$_()._$GetSceneGraphZIndex$_();
                            return s - i;
                        }), a && a.length) for (const l of a) l._$GetPlugin$_()._$IsWorldType$_() && this._$_AddInstance$_(l, !0);
                    }
                }
            };
        }
        {
            let vec3EqualsXYZ2 = function(t, e, s, i) {
                return t[0] === Math.fround(e) && t[1] === Math.fround(s) && t[2] === Math.fround(i);
            }, MaybePrepareLayerDraw2 = function(t, e) {
                lastLayerPreparedForDrawing !== t && (t._$PrepareForDraw$_(e), lastLayerPreparedForDrawing = t);
            }, C33 = (vec3EqualsXYZ = vec3EqualsXYZ2, MaybePrepareLayerDraw = MaybePrepareLayerDraw2, 
            self._$C3$_), C3Debugger = self.C3Debugger, assert = self.assert, tempDestRect = C33._$New$_(C33.Rect), tempSrcRect = C33._$New$_(C33.Rect), tempLayoutRect = C33._$New$_(C33.Rect), tempColor = C33._$New$_(C33._$Color$_), glMatrix = self._$glMatrix$_, vec32 = glMatrix._$vec3$_, tempRender3dList = [], tempInstanceList1 = [], tempInstanceList2 = [], tempInstanceList3 = [], lastLayerPreparedForDrawing = null;
            C33._$Layout$_ = class extends C33._$DefendedBase$_ {
                constructor(t, e, s) {
                    super(), this._$_layoutManager$_ = t, this._$_runtime$_ = t._$GetRuntime$_(), 
                    this._$_name$_ = s[0], this._$_originalWidth$_ = s[1], this._$_originalHeight$_ = s[2], 
                    this._$_width$_ = s[1], this._$_height$_ = s[2], this._$_isUnboundedScrolling$_ = !!s[3], 
                    this._$_isOrthographicProjection$_ = !!s[4], this._$_vanishingPointX$_ = s[5], 
                    this._$_vanishingPointY$_ = s[6], this._$_eventSheetName$_ = s[7], 
                    this._$_eventSheet$_ = null, this._$_sid$_ = s[8], this._$_index$_ = e, 
                    this._$_scrollX$_ = 0, this._$_scrollY$_ = 0, this._$_scale$_ = 1, 
                    this._$_angle$_ = 0, this._$_initialObjectClasses$_ = new Set(), 
                    this._$_textureLoadedTypes$_ = new Set(), this._$_textureLoadPendingPromises$_ = new Set(), 
                    this._$_createdInstances$_ = [], this._$_createdPersistedInstances$_ = [], 
                    this._$_createdPersistedInstancesToDataMap$_ = new Map(), this._$_createdPersistedIndexToInstanceMap$_ = new Map(), 
                    this._$_initialNonWorld$_ = [], this._$_is3dCameraEnabled$_ = !1, 
                    this._$_cam3dposition$_ = vec32.create(), this._$_cam3dlook$_ = vec32.create(), 
                    this._$_cam3dup$_ = vec32.create(), this._$_rootLayers$_ = [], 
                    this._$_allLayersFlat$_ = [], this._$_layersByName$_ = new Map(), 
                    this._$_layersBySid$_ = new Map(), this._$_pendingSetHTMLLayerCount$_ = -1;
                    const r = this._$_runtime$_._$GetCanvasManager$_();
                    this._$_effectList$_ = C33._$New$_(C33._$EffectList$_, this, s[11]), 
                    this._$_effectChain$_ = C33._$New$_(C33._$Gfx$_._$EffectChain$_, r._$GetEffectChainManager$_(), {
                        _$drawContent$_: (t, e) => {
                            const s = e._$GetContentObject$_(), i = s._$GetRenderTarget$_();
                            t._$ResetColor$_(), t._$DrawRenderTarget$_(i), t._$InvalidateRenderTarget$_(i), 
                            r._$ReleaseAdditionalRenderTarget$_(i);
                        },
                        _$getShaderParameters$_: t => this._$GetEffectList$_()._$_GetEffectChainShaderParametersForIndex$_(t)
                    }), this._$_needsRebuildEffectChainSteps$_ = !0, this._$_wasFullScreenQualityLow$_ = !1, 
                    this._$_curRenderTarget$_ = null, this._$_persistData$_ = {}, 
                    this._$_persistedIntances$_ = new Map(), this._$_isFirstVisit$_ = !0, 
                    this._$_iLayout$_ = new self._$ILayout$_(this), this._$_userScriptDispatcher$_ = C33._$New$_(C33.Event._$Dispatcher$_);
                    for (const i of s[9]) this._$_rootLayers$_.push(C33._$Layer$_._$CreateFromExportData$_(this, null, i));
                    this._$_ReindexLayers$_();
                    for (const n of this._$allLayers$_()) n._$_InitInitialInstances$_();
                    for (const h of s[10]) {
                        const o = this._$_runtime$_._$GetObjectClassByIndex$_(h[1]);
                        if (!o) throw new Error("missing nonworld object class");
                        o._$GetDefaultInstanceData$_() || o._$SetDefaultInstanceData$_(h), 
                        this._$_initialNonWorld$_.push(h), this._$_AddInitialObjectClass$_(o);
                    }
                }
                _$Release$_() {
                    for (const t of this._$_allLayersFlat$_) t._$Release$_();
                    C33._$clearArray$_(this._$_allLayersFlat$_), this._$_textureLoadPendingPromises$_.clear(), 
                    this._$_eventSheet$_ = null, this._$_layoutManager$_ = null, 
                    this._$_runtime$_ = null;
                }
                _$GetRuntime$_() {
                    return this._$_runtime$_;
                }
                _$GetName$_() {
                    return this._$_name$_;
                }
                _$GetSID$_() {
                    return this._$_sid$_;
                }
                _$GetIndex$_() {
                    return this._$_index$_;
                }
                _$GetEffectList$_() {
                    return this._$_effectList$_;
                }
                _$GetEffectChain$_() {
                    return this._$_MaybeRebuildEffectChainSteps$_(), this._$_effectChain$_;
                }
                _$_MaybeRebuildEffectChainSteps$_() {
                    const t = "low" === this._$_runtime$_._$GetCanvasManager$_()._$GetCurrentFullscreenScalingQuality$_();
                    if (this._$_needsRebuildEffectChainSteps$_ || this._$_wasFullScreenQualityLow$_ !== t || this._$_effectChain$_._$NeedsRebuild$_()) {
                        const e = this._$GetEffectList$_()._$GetActiveEffectTypes$_();
                        this._$_effectChain$_._$BuildSteps$_(e.map(t => t._$GetShaderProgram$_()), {
                            _$indexMap$_: e.map(t => t._$GetIndex$_()),
                            _$forcePostDraw$_: t,
                            _$useFullSurface$_: !0
                        }), this._$_needsRebuildEffectChainSteps$_ = !1, this._$_wasFullScreenQualityLow$_ = t;
                    }
                }
                _$UpdateActiveEffects$_() {
                    this._$GetEffectList$_()._$UpdateActiveEffects$_(), this._$_needsRebuildEffectChainSteps$_ = !0;
                }
                _$GetMinLayerScale$_() {
                    let s = this._$_allLayersFlat$_[0]._$GetNormalScale$_();
                    for (let t = 1, e = this._$_allLayersFlat$_.length; t < e; ++t) {
                        const i = this._$_allLayersFlat$_[t];
                        0 === i._$GetParallaxX$_() && 0 === i._$GetParallaxY$_() || (s = Math.min(s, i._$GetNormalScale$_()));
                    }
                    return s;
                }
                _$_GetScrollBoundMarginHorizontal$_() {
                    return .5 * this._$_runtime$_._$GetViewportWidth$_() / this._$GetMinLayerScale$_();
                }
                _$_GetScrollBoundMarginVertical$_() {
                    return .5 * this._$_runtime$_._$GetViewportHeight$_() / this._$GetMinLayerScale$_();
                }
                _$GetScrollLeftBound$_() {
                    return this._$IsUnboundedScrolling$_() ? -1 / 0 : this._$_GetScrollBoundMarginHorizontal$_();
                }
                _$GetScrollRightBound$_() {
                    return this._$IsUnboundedScrolling$_() ? 1 / 0 : this._$GetWidth$_() - this._$_GetScrollBoundMarginHorizontal$_();
                }
                _$GetScrollTopBound$_() {
                    return this._$IsUnboundedScrolling$_() ? -1 / 0 : this._$_GetScrollBoundMarginVertical$_();
                }
                _$GetScrollBottomBound$_() {
                    return this._$IsUnboundedScrolling$_() ? 1 / 0 : this._$GetHeight$_() - this._$_GetScrollBoundMarginVertical$_();
                }
                _$SetScrollX$_(t) {
                    const e = this._$GetScrollLeftBound$_(), s = this._$GetScrollRightBound$_();
                    this._$_scrollX$_ !== (t = (t = s < t ? s : t) < e ? e : t) && (this._$_scrollX$_ = t, 
                    this._$_SetAllLayersMVChanged$_(), this._$_runtime$_._$UpdateRender$_());
                }
                _$GetScrollX$_() {
                    return this._$_scrollX$_;
                }
                _$SetScrollY$_(t) {
                    const e = this._$GetScrollTopBound$_(), s = this._$GetScrollBottomBound$_();
                    this._$_scrollY$_ !== (t = (t = s < t ? s : t) < e ? e : t) && (this._$_scrollY$_ = t, 
                    this._$_SetAllLayersMVChanged$_(), this._$_runtime$_._$UpdateRender$_());
                }
                _$GetScrollY$_() {
                    return this._$_scrollY$_;
                }
                _$IsUnboundedScrolling$_() {
                    return this._$_isUnboundedScrolling$_;
                }
                _$BoundScrolling$_() {
                    this._$SetScrollX$_(this._$GetScrollX$_()), this._$SetScrollY$_(this._$GetScrollY$_());
                    for (const t of this._$_allLayersFlat$_) t._$IsOwnScrollPositionEnabled$_() && (t._$SetScrollX$_(t._$GetScrollX$_()), 
                    t._$SetScrollY$_(t._$GetScrollY$_()));
                }
                _$SetVanishingPointXY$_(t, e) {
                    this._$_vanishingPointX$_ === t && this._$_vanishingPointY$_ === e || (this._$_vanishingPointX$_ = t, 
                    this._$_vanishingPointY$_ = e, this._$IsPerspectiveProjection$_() && (this._$_SetAllLayersProjectionChanged$_(), 
                    this._$_SetAllLayersMVChanged$_(), this._$_runtime$_._$UpdateRender$_()));
                }
                _$GetVanishingPointX$_() {
                    return this._$IsOrthographicProjection$_() ? .5 : this._$_vanishingPointX$_;
                }
                _$GetVanishingPointY$_() {
                    return this._$IsOrthographicProjection$_() ? .5 : this._$_vanishingPointY$_;
                }
                _$HasVanishingPointOutsideViewport$_() {
                    const t = this._$GetVanishingPointX$_(), e = this._$GetVanishingPointY$_();
                    return t < 0 || 1 < t || e < 0 || 1 < e;
                }
                _$SetPerspectiveProjection$_() {
                    this._$_isOrthographicProjection$_ && (this._$_isOrthographicProjection$_ = !1, 
                    this._$_SetAllLayersProjectionChanged$_(), this._$_SetAllLayersMVChanged$_(), 
                    this._$_runtime$_._$UpdateRender$_());
                }
                _$SetOrthographicProjection$_() {
                    this._$_isOrthographicProjection$_ || (this._$_isOrthographicProjection$_ = !0, 
                    this._$_SetAllLayersProjectionChanged$_(), this._$_SetAllLayersMVChanged$_(), 
                    this._$_runtime$_._$UpdateRender$_());
                }
                _$IsOrthographicProjection$_() {
                    return this._$_isOrthographicProjection$_;
                }
                _$IsPerspectiveProjection$_() {
                    return !this._$IsOrthographicProjection$_();
                }
                _$Set3DCameraEnabled$_(t) {
                    this._$_is3dCameraEnabled$_ !== (t = !!t) && (this._$_is3dCameraEnabled$_ = t, 
                    this._$_SetAllLayersMVChanged$_(), this._$_runtime$_._$UpdateRender$_());
                }
                _$Is3DCameraEnabled$_() {
                    return this._$_is3dCameraEnabled$_;
                }
                _$Set3DCameraOrientation$_(t, e, s, i, r, n, h, o, a) {
                    vec3EqualsXYZ2(this._$_cam3dposition$_, t, e, s) && vec3EqualsXYZ2(this._$_cam3dlook$_, i, r, n) && vec3EqualsXYZ2(this._$_cam3dup$_, h, o, a) || (vec32.set(this._$_cam3dposition$_, t, e, s), 
                    vec32.set(this._$_cam3dlook$_, i, r, n), vec32.set(this._$_cam3dup$_, h, o, a), 
                    this._$Set3DCameraChanged$_());
                }
                _$Set3DCameraChanged$_() {
                    this._$_SetAllLayersMVChanged$_(), this._$_runtime$_._$UpdateRender$_();
                }
                _$Get3DCameraPosition$_() {
                    return this._$_cam3dposition$_;
                }
                _$Get3DCameraLookAt$_() {
                    return this._$_cam3dlook$_;
                }
                _$Get3DCameraUpVector$_() {
                    return this._$_cam3dup$_;
                }
                _$GetScale$_() {
                    return this._$_scale$_;
                }
                _$SetScale$_(t) {
                    this._$_scale$_ !== t && (this._$_scale$_ = t, this._$_SetAllLayersMVChanged$_(), 
                    this._$BoundScrolling$_(), this._$_runtime$_._$UpdateRender$_());
                }
                _$SetAngle$_(t) {
                    t = C33._$clampAngle$_(t), this._$_angle$_ !== t && (this._$_angle$_ = t, 
                    this._$_SetAllLayersMVChanged$_(), this._$_runtime$_._$UpdateRender$_());
                }
                GetAngle() {
                    return this._$_angle$_;
                }
                _$GetWidth$_() {
                    return this._$_width$_;
                }
                _$SetWidth$_(t) {
                    !isFinite(t) || t < 1 || (this._$_width$_ = t);
                }
                _$GetHeight$_() {
                    return this._$_height$_;
                }
                _$SetHeight$_(t) {
                    !isFinite(t) || t < 1 || (this._$_height$_ = t);
                }
                _$GetEventSheet$_() {
                    return this._$_eventSheet$_;
                }
                _$_GetRootLayers$_() {
                    return this._$_rootLayers$_;
                }
                *_$allLayers$_() {
                    for (const t of this._$_rootLayers$_) yield* t._$selfAndAllSubLayers$_();
                }
                _$GetLayers$_() {
                    return this._$_allLayersFlat$_;
                }
                _$GetLayerCount$_() {
                    return this._$_allLayersFlat$_.length;
                }
                _$GetLayer$_(t) {
                    return "number" == typeof t ? this._$GetLayerByIndex$_(t) : this._$GetLayerByName$_(t.toString());
                }
                _$GetLayerByIndex$_(t) {
                    return t = C33._$clamp$_(Math.floor(t), 0, this._$_allLayersFlat$_.length - 1), 
                    this._$_allLayersFlat$_[t];
                }
                _$GetLayerByName$_(t) {
                    return this._$_layersByName$_.get(t.toLowerCase()) || null;
                }
                _$HasLayerByName$_(t) {
                    return !!this._$GetLayerByName$_(t);
                }
                _$GetLayerBySID$_(t) {
                    return this._$_layersBySid$_.get(t) || null;
                }
                _$_SetAllLayersProjectionChanged$_() {
                    for (const t of this._$_allLayersFlat$_) t._$_SetProjectionMatrixChanged$_();
                }
                _$_SetAllLayersMVChanged$_() {
                    for (const t of this._$_allLayersFlat$_) t._$_SetMVMatrixChanged$_();
                }
                _$AddLayer$_(t, e, s) {
                    if (this._$HasLayerByName$_(t)) throw new Error(`layer name '${t}' already in use`);
                    if (!e && s < 2) throw new Error("invalid insert position");
                    const i = 2 <= s ? e : e._$GetParentLayer$_(), r = C33._$New$_(C33._$Layer$_, this, i, {
                        name: t,
                        sid: Math.floor(1e15 * Math.random()),
                        _$isDynamic$_: !0
                    });
                    this._$_InsertLayer$_(r, e, s), this._$GetRuntime$_()._$UpdateRender$_(), 
                    this._$_ReindexAndUpdateAllLayers$_();
                }
                _$MoveLayer$_(t, e, s) {
                    if (!e && s < 2) throw new Error("invalid insert position");
                    t === e && s < 2 || (this._$_RemoveLayer$_(t), this._$_InsertLayer$_(t, e, s), 
                    this._$GetRuntime$_()._$UpdateRender$_(), this._$_ReindexAndUpdateAllLayers$_());
                }
                _$RemoveLayer$_(t) {
                    if (this._$_RemoveLayer$_(t)) {
                        const e = this._$_runtime$_._$GetEventSheetManager$_();
                        e._$BlockFlushingInstances$_(!0), t._$Release$_(), e._$BlockFlushingInstances$_(!1), 
                        this._$GetRuntime$_()._$UpdateRender$_(), this._$_ReindexAndUpdateAllLayers$_();
                    }
                }
                _$RemoveAllDynamicLayers$_() {
                    const t = new Set();
                    for (const e of this._$allLayers$_()) e._$IsDynamic$_() && !e._$HasAnyDynamicParentLayer$_() && t.add(e);
                    if (0 !== t.size) {
                        const s = this._$_runtime$_._$GetEventSheetManager$_();
                        s._$BlockFlushingInstances$_(!0);
                        for (const i of t) this._$_RemoveLayer$_(i), i._$Release$_();
                        s._$BlockFlushingInstances$_(!1), this._$GetRuntime$_()._$UpdateRender$_(), 
                        this._$_ReindexAndUpdateAllLayers$_();
                    }
                }
                _$_InsertLayer$_(e, s, i) {
                    if (2 <= i) if (s) {
                        if (s === e || s._$HasParentLayer$_(e)) throw new Error(`cannot move layer '${e._$GetName$_()}' to sub-layer of itself`);
                        s._$_AddSubLayer$_(e, 2 === i), e._$_SetParentLayer$_(s);
                    } else 2 === i ? this._$_rootLayers$_.push(e) : this._$_rootLayers$_.unshift(e), 
                    e._$_SetParentLayer$_(null); else {
                        const t = s._$GetParentLayer$_();
                        if (t) {
                            if (s._$HasParentLayer$_(e)) throw new Error(`cannot move layer '${e._$GetName$_()}' to sub-layer of itself`);
                            t._$_InsertSubLayer$_(e, s, 0 === i), e._$_SetParentLayer$_(t);
                        } else {
                            let t = this._$_rootLayers$_.indexOf(s);
                            if (-1 === t) throw new Error("cannot find layer to insert by");
                            0 === i && ++t, this._$_rootLayers$_.splice(t, 0, e), 
                            e._$_SetParentLayer$_(null);
                        }
                    }
                }
                _$_RemoveLayer$_(t) {
                    const e = t._$GetParentLayer$_();
                    if (e) return e._$_RemoveSubLayer$_(t), !0;
                    if (1 < this._$_rootLayers$_.length) {
                        const s = this._$_rootLayers$_.indexOf(t);
                        if (-1 === s) throw new Error("cannot find layer to remove");
                        return this._$_rootLayers$_.splice(s, 1), !0;
                    }
                    return !1;
                }
                _$_ReindexLayers$_() {
                    this._$_allLayersFlat$_ = [ ...this._$allLayers$_() ], this._$_layersByName$_.clear(), 
                    this._$_layersBySid$_.clear();
                    for (let t = 0, e = this._$_allLayersFlat$_.length; t < e; ++t) {
                        const s = this._$_allLayersFlat$_[t];
                        s._$_SetIndex$_(t), this._$_layersByName$_.set(s._$GetName$_().toLowerCase(), s), 
                        this._$_layersBySid$_.set(s._$GetSID$_(), s);
                    }
                }
                _$_ReindexHTMLLayers$_() {
                    let t = 0;
                    for (const e of this._$_rootLayers$_) {
                        for (const s of e._$selfAndAllSubLayers$_()) s._$_SetHTMLIndex$_(t);
                        e._$IsHTMLElementsLayer$_() && t++;
                    }
                }
                _$GetHTMLLayerCount$_() {
                    return this._$_rootLayers$_.at(-1)._$GetHTMLIndex$_() + 1;
                }
                async _$_ReindexAndUpdateAllLayers$_() {
                    this._$_ReindexLayers$_(), this._$_ReindexHTMLLayers$_(), this._$_pendingSetHTMLLayerCount$_ = this._$GetHTMLLayerCount$_();
                }
                _$_GetPendingSetHTMLLayerCount$_() {
                    return this._$_pendingSetHTMLLayerCount$_;
                }
                _$_ResetPendingHTMLLayerCount$_() {
                    this._$_pendingSetHTMLLayerCount$_ = -1;
                }
                _$GetRootLayersForHTMLLayer$_(t) {
                    const e = [];
                    for (const s of this._$_rootLayers$_) {
                        const i = s._$GetHTMLIndex$_();
                        if (i === t) e.push(s); else if (t < i) break;
                    }
                    return e;
                }
                _$SaveTransform$_() {
                    return {
                        scrollX: this._$GetScrollX$_(),
                        scrollY: this._$GetScrollY$_(),
                        scale: this._$GetScale$_(),
                        angle: this.GetAngle(),
                        vpX: this._$GetVanishingPointX$_(),
                        vpY: this._$GetVanishingPointY$_()
                    };
                }
                _$RestoreTransform$_(t) {
                    this._$SetScrollX$_(t.scrollX), this._$SetScrollY$_(t.scrollY), 
                    this._$SetScale$_(t.scale), this._$SetAngle$_(t.angle), this._$SetVanishingPointXY$_(t.vpX, t.vpY);
                }
                _$GetLayoutBackgroundColor$_() {
                    let t = this._$_rootLayers$_.filter(t => t._$ShouldDraw$_())[0];
                    for (;t; ) {
                        if (!t._$IsTransparent$_()) return tempColor._$copyRgb$_(t._$GetBackgroundColor$_()), 
                        tempColor._$setA$_(1), tempColor;
                        if (t._$UsesOwnTexture$_()) return tempColor._$setRgba$_(0, 0, 0, 0), 
                        tempColor;
                        t = t._$GetSubLayers$_().filter(t => t._$ShouldDraw$_())[0];
                    }
                    return tempColor._$setRgba$_(0, 0, 0, 0), tempColor;
                }
                _$IsFirstVisit$_() {
                    return this._$_isFirstVisit$_;
                }
                _$_GetInitialObjectClasses$_() {
                    return [ ...this._$_initialObjectClasses$_ ];
                }
                _$_AddInitialObjectClass$_(t) {
                    if (t._$IsInContainer$_()) for (const e of t._$GetContainer$_()._$GetObjectTypes$_()) this._$_initialObjectClasses$_.add(e); else this._$_initialObjectClasses$_.add(t);
                }
                _$_GetTextureLoadedObjectTypes$_() {
                    return [ ...this._$_textureLoadedTypes$_ ];
                }
                _$_Load$_(t, e) {
                    if (t === this || !e) return Promise.resolve();
                    t && (C33._$CopySet$_(this._$_textureLoadedTypes$_, t._$_textureLoadedTypes$_), 
                    t._$_textureLoadedTypes$_.clear());
                    const s = [];
                    for (const i of this._$_initialObjectClasses$_) this._$_textureLoadedTypes$_.has(i) || (s.push(i._$LoadTextures$_(e)), 
                    this._$_textureLoadedTypes$_.add(i));
                    return Promise.all(s);
                }
                async _$MaybeLoadTexturesFor$_(t) {
                    if (t._$IsFamily$_()) throw new Error("cannot load textures for family");
                    const e = this._$_runtime$_._$GetRenderer$_();
                    if (e && !e._$IsContextLost$_() && !this._$_textureLoadedTypes$_.has(t)) {
                        this._$_textureLoadedTypes$_.add(t);
                        const s = t._$LoadTextures$_(e);
                        this._$_AddPendingTextureLoadPromise$_(s), await s, t._$OnDynamicTextureLoadComplete$_(), 
                        this._$_runtime$_._$UpdateRender$_();
                    }
                }
                _$_AddPendingTextureLoadPromise$_(t) {
                    this._$_textureLoadPendingPromises$_.add(t), t.then(() => this._$_textureLoadPendingPromises$_.delete(t)).catch(() => this._$_textureLoadPendingPromises$_.delete(t));
                }
                _$WaitForPendingTextureLoadsToComplete$_() {
                    return Promise.all([ ...this._$_textureLoadPendingPromises$_ ]);
                }
                _$MaybeUnloadTexturesFor$_(t) {
                    if (t._$IsFamily$_() || 0 < t._$GetInstanceCount$_()) throw new Error("cannot unload textures");
                    const e = this._$_runtime$_._$GetRenderer$_();
                    e && this._$_textureLoadedTypes$_.has(t) && (this._$_textureLoadedTypes$_.delete(t), 
                    t._$ReleaseTextures$_(e));
                }
                _$_Unload$_(t, e) {
                    if (t !== this && e) for (const s of this._$_textureLoadedTypes$_) s._$IsGlobal$_() || t._$_initialObjectClasses$_.has(s) || (s._$ReleaseTextures$_(), 
                    this._$_textureLoadedTypes$_.delete(s));
                }
                _$_OnRendererContextLost$_() {
                    this._$_textureLoadedTypes$_.clear();
                }
                async _$_StartRunning$_(t) {
                    const e = this._$_runtime$_, s = this._$_layoutManager$_, i = e._$GetEventSheetManager$_(), r = (this._$_eventSheetName$_ && (this._$_eventSheet$_ = i._$GetEventSheetByName$_(this._$_eventSheetName$_), 
                    this._$_eventSheet$_._$_UpdateDeepIncludes$_()), s._$_SetMainRunningLayout$_(this), 
                    this._$_width$_ = this._$_originalWidth$_, this._$_height$_ = this._$_originalHeight$_, 
                    this._$_scrollX$_ = e._$GetOriginalViewportWidth$_() / 2, this._$_scrollY$_ = e._$GetOriginalViewportHeight$_() / 2, 
                    this._$BoundScrolling$_(), this._$_SetAllLayersProjectionChanged$_(), 
                    this._$_SetAllLayersMVChanged$_(), this._$_ReindexHTMLLayers$_(), 
                    await this._$_runtime$_._$GetCanvasManager$_()._$SetHTMLLayerCount$_(this._$GetHTMLLayerCount$_(), !0), 
                    this._$_MoveGlobalObjectsToThisLayout$_(t), this._$_runtime$_._$SetUsingCreatePromises$_(!0), 
                    this._$_CreateInitialInstances$_(), this._$_isFirstVisit$_ || this._$_CreatePersistedInstances$_(), 
                    this._$_CreateAndLinkContainerInstances$_(this._$_createdInstances$_), 
                    this._$_CreateAndLinkContainerInstances$_(this._$_createdPersistedInstances$_), 
                    this._$_CreateInitialNonWorldInstances$_(), s._$ClearPendingChangeLayout$_(), 
                    e._$FlushPendingInstances$_(), this._$_runtime$_._$SetUsingCreatePromises$_(!1), 
                    this._$_runtime$_._$GetCreatePromises$_());
                    if (await Promise.all(r), C33._$clearArray$_(r), !e._$IsLoadingState$_()) {
                        for (const n of this._$_createdInstances$_) n._$SetupInitialSceneGraphConnections$_();
                        for (const h of this._$_createdPersistedInstances$_) h._$SetupPersistedSceneGraphConnections$_(this._$_createdPersistedInstancesToDataMap$_, this._$_createdPersistedIndexToInstanceMap$_);
                        for (const [ o, a ] of Object.entries(this._$_persistData$_)) {
                            const l = this._$_runtime$_._$GetObjectClassBySID$_(parseInt(o, 10));
                            l && !l._$IsFamily$_() && l._$HasPersistBehavior$_() && C33._$clearArray$_(a);
                        }
                        for (const u of this._$_createdInstances$_) u._$_TriggerOnCreated$_();
                        for (const c of this._$_createdPersistedInstances$_) c._$_TriggerOnCreated$_();
                        for (const f of this._$_createdInstances$_) f._$HasParent$_() || f._$_OnHierarchyReady$_();
                        for (const d of this._$_createdPersistedInstances$_) d._$HasParent$_() || d._$_OnHierarchyReady$_();
                    }
                    C33._$clearArray$_(this._$_createdInstances$_), C33._$clearArray$_(this._$_createdPersistedInstances$_), 
                    this._$_createdPersistedInstancesToDataMap$_.clear(), this._$_createdPersistedIndexToInstanceMap$_.clear(), 
                    await Promise.all([ ...this._$_initialObjectClasses$_ ].map(t => t._$PreloadTexturesWithInstances$_(this._$_runtime$_._$GetRenderer$_()))), 
                    t && (e._$Dispatcher$_().dispatchEvent(new C33.Event("beforefirstlayoutstart")), 
                    await e._$DispatchUserScriptEventAsyncWait$_(new C33.Event("beforeprojectstart"))), 
                    await this._$DispatchRuntimeUserScriptEventAsyncWait$_(new C33.Event("beforeanylayoutstart")), 
                    e._$Dispatcher$_().dispatchEvent(new C33.Event("beforelayoutstart")), 
                    await this._$DispatchUserScriptEventAsyncWait$_(new C33.Event("beforelayoutstart")), 
                    e._$IsLoadingState$_() || await e._$TriggerAsync$_(C33._$Plugins$_._$System$_._$Cnds$_._$OnLayoutStart$_, null, null), 
                    e._$Dispatcher$_().dispatchEvent(new C33.Event("afterlayoutstart")), 
                    await this._$DispatchUserScriptEventAsyncWait$_(new C33.Event("afterlayoutstart")), 
                    await this._$DispatchRuntimeUserScriptEventAsyncWait$_(new C33.Event("afteranylayoutstart")), 
                    t && (e._$Dispatcher$_().dispatchEvent(new C33.Event("afterfirstlayoutstart")), 
                    await e._$DispatchUserScriptEventAsyncWait$_(new C33.Event("afterprojectstart"))), 
                    i._$_RunQueuedTriggers$_(s), await this._$WaitForPendingTextureLoadsToComplete$_(), 
                    this._$_isFirstVisit$_ = !1;
                }
                _$_MoveGlobalObjectsToThisLayout$_(t) {
                    for (const e of this._$_runtime$_._$GetAllObjectClasses$_()) if (!e._$IsFamily$_() && e._$IsWorldType$_()) for (const s of e._$GetInstances$_()) {
                        const i = s._$GetWorldInfo$_(), r = i._$GetLayer$_(), n = C33._$clamp$_(r._$GetIndex$_(), 0, this._$_allLayersFlat$_.length - 1), h = this._$_allLayersFlat$_[n];
                        i._$_SetLayer$_(h, !0), h._$_MaybeAddInstance$_(s);
                    }
                    if (!t) for (const o of this._$_allLayersFlat$_) o._$_SortInstancesByLastCachedZIndex$_(!1);
                }
                _$_CreateInitialInstances$_() {
                    for (const t of this._$_allLayersFlat$_) t._$CreateInitialInstances$_(this._$_createdInstances$_), 
                    t._$_Start$_();
                }
                _$_CreatePersistedInstances$_() {
                    let e = !1;
                    for (const [ t, s ] of Object.entries(this._$_persistData$_)) {
                        const i = this._$_runtime$_._$GetObjectClassBySID$_(parseInt(t, 10));
                        if (i && !i._$IsFamily$_() && i._$HasPersistBehavior$_()) for (const r of s) {
                            let t = null;
                            if (!i._$IsWorldType$_() || (t = r.hasOwnProperty("instJson") ? this._$GetLayerBySID$_(r.instJson.w.l) : this._$GetLayerBySID$_(r.w.l))) {
                                const n = this._$_runtime$_._$CreateInstanceFromData$_(i, t, !1, 0, 0, !0);
                                r.hasOwnProperty("instJson") ? n._$LoadFromJson$_(r.instJson) : n._$LoadFromJson$_(r), 
                                e = !0, this._$_createdPersistedInstances$_.push(n), 
                                r.hasOwnProperty("instJson") && (this._$_createdPersistedInstancesToDataMap$_.set(n, r), 
                                this._$_createdPersistedIndexToInstanceMap$_.set(r.index, n));
                            }
                        }
                    }
                    for (const h of this._$_allLayersFlat$_) h._$_SortInstancesByLastCachedZIndex$_(!0), 
                    h._$SetZIndicesChanged$_();
                    e && (this._$_runtime$_._$FlushPendingInstances$_(), this._$_runtime$_._$_RefreshUidMap$_());
                }
                _$_CreateAndLinkContainerInstances$_(e) {
                    for (const s of e) if (s._$IsInContainer$_()) {
                        const i = s._$GetWorldInfo$_(), t = s._$GetIID$_();
                        for (const r of s._$GetObjectClass$_()._$GetContainer$_()._$objectTypes$_()) if (r !== s._$GetObjectClass$_()) {
                            const n = r._$GetInstances$_();
                            if (n.length > t) s._$_AddSibling$_(n[t]); else {
                                let t;
                                t = i ? this._$_runtime$_._$CreateInstanceFromData$_(r, i._$GetLayer$_(), !0, i._$GetX$_(), i._$GetY$_(), !0) : this._$_runtime$_._$CreateInstanceFromData$_(r, null, !0, 0, 0, !0), 
                                this._$_runtime$_._$FlushPendingInstances$_(), r._$_UpdateIIDs$_(), 
                                s._$_AddSibling$_(t), e.push(t);
                            }
                        }
                    }
                }
                _$_CreateInitialNonWorldInstances$_() {
                    for (const t of this._$_initialNonWorld$_) {
                        const e = this._$_runtime$_._$GetObjectClassByIndex$_(t[1]);
                        e._$IsInContainer$_() || this._$_runtime$_._$CreateInstanceFromData$_(t, null, !0);
                    }
                }
                _$_CreateGlobalNonWorlds$_() {
                    let s = [], i = this._$_initialNonWorld$_, r = 0;
                    for (let t = 0, e = i.length; t < e; ++t) {
                        const n = i[t], h = this._$_runtime$_._$GetObjectClassByIndex$_(n[1]);
                        h._$IsGlobal$_() ? h._$IsInContainer$_() && h._$GetContainer$_()._$HasAnyWorldType$_() || s.push(this._$_runtime$_._$CreateInstanceFromData$_(n, null, !0)) : (i[r] = n, 
                        ++r);
                    }
                    C33._$truncateArray$_(i, r), this._$_runtime$_._$FlushPendingInstances$_(), 
                    this._$_CreateAndLinkContainerInstances$_(s);
                }
                _$RecreateInitialObjects$_(t, e, s, i, r, n, h) {
                    if (s) return s._$RecreateInitialObjects$_(t, e, r, n, i, h);
                    {
                        const o = [];
                        for (const a of this._$_allLayersFlat$_) o.push(a._$RecreateInitialObjects$_(t, e, r, n, i, h));
                        return o.flat();
                    }
                }
                async _$_StopRunning$_() {
                    const t = this._$_layoutManager$_;
                    this._$_runtime$_._$IsLoadingState$_() || (await this._$DispatchRuntimeUserScriptEventAsyncWait$_(new C33.Event("beforeanylayoutend")), 
                    await this._$DispatchUserScriptEventAsyncWait$_(new C33.Event("beforelayoutend")), 
                    await this._$_runtime$_._$TriggerAsync$_(C33._$Plugins$_._$System$_._$Cnds$_._$OnLayoutEnd$_, null, null), 
                    await this._$DispatchUserScriptEventAsyncWait$_(new C33.Event("afterlayoutend")), 
                    await this._$DispatchRuntimeUserScriptEventAsyncWait$_(new C33.Event("afteranylayoutend"))), 
                    t._$SetIsEndingLayout$_(!0), this._$_runtime$_._$GetEventSheetManager$_()._$ClearAllScheduledWaits$_(), 
                    this._$_isFirstVisit$_ || this._$_SavePersistData$_();
                    for (const e of this._$_allLayersFlat$_) e._$_End$_();
                    for (const s of this._$_runtime$_._$GetAllObjectClasses$_()) if (!(s._$IsGlobal$_() || s._$IsWorldType$_() || s._$GetPlugin$_()._$IsSingleGlobal$_() || s._$IsFamily$_())) {
                        for (const i of s._$GetInstances$_()) this._$_runtime$_._$DestroyInstance$_(i);
                        this._$_runtime$_._$FlushPendingInstances$_();
                    }
                    t._$SetIsEndingLayout$_(!1), t._$GetMainRunningLayout$_() === this && t._$_SetMainRunningLayout$_(null);
                }
                _$_SaveInstanceToPersist$_(t, e) {
                    const s = t._$GetObjectClass$_()._$GetSID$_().toString(), i = (this._$_persistData$_.hasOwnProperty(s) || (this._$_persistData$_[s] = []), 
                    this._$_persistData$_[s]), r = {
                        index: e,
                        instJson: t._$SaveToJson$_(),
                        sceneGraphJson: {
                            children: []
                        }
                    };
                    i.push(r), this._$_persistedIntances$_.set(t, r);
                }
                _$_SaveSceneGraphInfoToPersist$_(t) {
                    const e = this._$_persistedIntances$_.get(t);
                    for (const s of t._$GetChildren$_()) {
                        const i = this._$_persistedIntances$_.get(s);
                        i && e.sceneGraphJson.children.push({
                            index: i.index,
                            flags: C33._$SceneGraphInfo$_._$_GetFlagsNumber$_(s._$GetWorldInfo$_())
                        });
                    }
                }
                _$_SavePersistData$_() {
                    this._$_persistedIntances$_.clear();
                    let t = 0;
                    for (const e of this._$_allLayersFlat$_) {
                        e._$_UpdateZIndices$_();
                        for (const s of e._$_GetInstances$_()) {
                            const i = s._$GetObjectClass$_();
                            !i._$IsGlobal$_() && i._$HasPersistBehavior$_() && (this._$_SaveInstanceToPersist$_(s, t), 
                            t++);
                        }
                    }
                    for (const r of this._$_allLayersFlat$_) for (const n of r._$_GetInstances$_()) {
                        const h = n._$GetObjectClass$_();
                        !h._$IsGlobal$_() && h._$HasPersistBehavior$_() && this._$_SaveSceneGraphInfoToPersist$_(n);
                    }
                    this._$_persistedIntances$_.clear();
                }
                _$ResetPersistData$_() {
                    this._$_persistData$_ = {}, this._$_isFirstVisit$_ = !0;
                }
                _$GetRenderTarget$_() {
                    return this._$_curRenderTarget$_;
                }
                _$UsesOwnTexture$_() {
                    const t = this._$_runtime$_, e = t._$GetRenderer$_()._$IsWebGL$_();
                    return "low" === t._$GetCanvasManager$_()._$GetCurrentFullscreenScalingQuality$_() || e && t._$UsesAnyBackgroundBlending$_() || this._$_effectList$_._$HasAnyActiveEffect$_() || e && t._$Uses3DFeatures$_();
                }
                _$_MaybeStartDrawToOwnTexture$_(t) {
                    const e = this._$_runtime$_._$GetCanvasManager$_();
                    if (this._$UsesOwnTexture$_()) {
                        t._$SetRenderTarget$_(null), t._$ClearRgba$_(0, 0, 0, 0);
                        const s = {
                            _$sampling$_: this._$_runtime$_._$GetSampling$_(),
                            _$isSampled$_: t._$IsWebGPU$_() || this._$_runtime$_._$UsesAnyBackgroundBlending$_() || this._$_effectList$_._$HasAnyActiveEffect$_(),
                            _$canReadPixels$_: !!t._$IsWebGPU$_() && this._$_runtime$_._$UsesAnyBackgroundBlending$_()
                        };
                        "low" === e._$GetCurrentFullscreenScalingQuality$_() && (s.width = e._$GetDrawWidth$_(), 
                        s.height = e._$GetDrawHeight$_()), this._$_curRenderTarget$_ = this._$_runtime$_._$GetAdditionalRenderTarget$_(s);
                    } else this._$_curRenderTarget$_ = null;
                }
                _$_MaybeCopyOwnTextureToBackbuffer$_(t) {
                    this._$_runtime$_._$_NeedsHTMLLayerCompositing$_(t) && (t._$SetDepthEnabled$_(!1), 
                    t._$SetRenderTarget$_(null), t._$SetTextureFillMode$_(), t._$CopyRenderTarget$_(this._$_curRenderTarget$_));
                }
                _$_MaybeEndDrawToOwnTexture$_(t) {
                    this._$UsesOwnTexture$_() && (t._$SetDepthEnabled$_(!1), this._$_DrawLayoutOwnTextureToRenderTarget$_(t, this._$_curRenderTarget$_));
                }
                _$DrawMain$_(t) {
                    t._$SetRenderTarget$_(this._$_curRenderTarget$_), t._$Clear$_(this._$GetLayoutBackgroundColor$_()), 
                    this._$_runtime$_._$Uses3DFeatures$_() && t._$ClearDepth$_();
                    const e = this._$GetRootLayersForHTMLLayer$_(0);
                    this._$_DrawLayerList$_(t, this._$_curRenderTarget$_, e, !0), 
                    t._$IsWebGPU$_() && t._$StartMeasuringRenderPassTime$_(0, 1), 
                    this._$_MaybeEndDrawToOwnTexture$_(t), this._$_curRenderTarget$_ = null;
                }
                _$DrawForHTMLLayerIndex$_(t, e) {
                    let s = null;
                    this._$_runtime$_._$_NeedsHTMLLayerCompositing$_(t) && (s = this._$_curRenderTarget$_), 
                    t._$SetRenderTarget$_(s), t._$ClearRgba$_(0, 0, 0, 0), this._$_runtime$_._$Uses3DFeatures$_() && t._$ClearDepth$_();
                    const i = this._$GetRootLayersForHTMLLayer$_(e);
                    this._$_DrawLayerList$_(t, s, i, !0), this._$_MaybeCopyOwnTextureToBackbuffer$_(t), 
                    t._$EndBatch$_(), this._$_runtime$_._$GetCanvasManager$_()._$BlitMainCanvasToHTMLLayerCanvas$_(e);
                }
                _$_DrawLayerList$_(t, i, e, r) {
                    const n = e.filter(t => t._$ShouldDraw$_());
                    for (let e = 0, s = n.length; e < s; ) {
                        const h = n[e];
                        if (h._$SelfAndAllSubLayersHave3DCamera$_() && !h._$SelfOrAnySubLayerUsesOwnTexture$_()) {
                            tempRender3dList.push(h);
                            for (let t = e + 1; t < s; ++t) {
                                const o = n[t];
                                if (!o._$SelfAndAllSubLayersHave3DCamera$_() || o._$SelfOrAnySubLayerUsesOwnTexture$_()) break;
                                tempRender3dList.push(n[t]);
                            }
                            if (2 <= tempRender3dList.length || 1 === tempRender3dList.length && tempRender3dList[0]._$HasAnyVisibleSubLayer$_()) {
                                this._$_Draw3DLayers$_(t, i, tempRender3dList), 
                                e += tempRender3dList.length, C33._$clearArray$_(tempRender3dList);
                                continue;
                            }
                            C33._$clearArray$_(tempRender3dList);
                        }
                        h._$Draw$_(t, i, r && 0 === e), ++e;
                    }
                }
                _$_DrawLayoutOwnTextureToRenderTarget$_(t, e) {
                    const s = this._$_effectList$_._$GetActiveEffectTypes$_(), i = this._$_runtime$_;
                    0 === s.length ? (t._$SetRenderTarget$_(null), t._$SetTextureFillMode$_(), 
                    t._$CopyRenderTarget$_(e), t._$InvalidateRenderTarget$_(e), 
                    i._$ReleaseAdditionalRenderTarget$_(e)) : (tempLayoutRect.set(0, 0, i._$GetViewportWidth$_(), i._$GetViewportHeight$_()), 
                    this._$GetEffectChain$_()._$Render$_(t, null, {
                        _$contentObject$_: this,
                        _$blendMode$_: 3,
                        devicePixelRatio: this._$_runtime$_._$GetEffectDevicePixelRatioParam$_(),
                        _$layerScale$_: this._$_runtime$_._$GetEffectLayerScaleParam$_() * this._$GetScale$_(),
                        _$layerAngle$_: this.GetAngle(),
                        _$layoutRect$_: tempLayoutRect,
                        _$drawSurfaceRect$_: null,
                        _$invalidateRenderTargets$_: !0
                    }));
                }
                _$_Draw3DLayers$_(i, r, t) {
                    t[0]._$IsTransparent$_() || (tempColor._$copyRgb$_(t[0]._$GetBackgroundColor$_()), 
                    tempColor._$setA$_(1), i._$Clear$_(tempColor)), this._$_runtime$_._$GetCanvasManager$_(), 
                    i._$SetDepthEnabled$_(!0);
                    const n = tempInstanceList1, h = tempInstanceList2, o = tempInstanceList3;
                    for (const a of t) a._$_UpdateZIndices$_(), a._$_AppendAllInstancesIncludingSubLayersInDrawOrder$_(n);
                    const e = t[0], s = e._$_MaybeStartWebGLProfiling$_(i);
                    e._$_MaybeStartWebGPUProfiling$_(i);
                    for (let e = 0, s = n.length; e < s; ) {
                        const l = n[e], u = l._$GetWorldInfo$_(), c = u._$GetLayer$_();
                        if (u._$IsVisible$_() && u._$IsInViewport3D$_(c._$_GetViewFrustum$_())) {
                            (!l._$RendersToOwnZPlane$_() || 0 < u._$GetDepth$_()) && o.push(l);
                            const f = l._$GetWorldInfo$_()._$GetTotalZElevation$_();
                            h.push(l);
                            let t = e + 1;
                            for (;t < s; ++t) {
                                const d = n[t], p = d._$GetWorldInfo$_();
                                if (p._$IsVisible$_() && p._$IsInViewport3D$_(p._$GetLayer$_()._$_GetViewFrustum$_())) {
                                    if (p._$GetTotalZElevation$_() !== f) break;
                                    (d._$RendersToOwnZPlane$_() ? (0 < p._$GetDepth$_() && o.push(d), 
                                    h) : o).push(d);
                                }
                            }
                            if (1 !== h.length || h[0]._$MustMitigateZFighting$_()) {
                                this._$_Draw3DLayersCoplanarInstances$_(i, r, h);
                                for (let t = 0, e = o.length; t < e; ++t) {
                                    const m = o[t], C = m._$GetWorldInfo$_(), g = C._$GetLayer$_();
                                    C._$_SetDrawNonBackFacesOnly$_(!0), MaybePrepareLayerDraw2(g, i), 
                                    g._$_DrawInstanceMaybeWithEffects$_(m, C, i, r), 
                                    C._$_SetDrawNonBackFacesOnly$_(!1);
                                }
                            } else {
                                MaybePrepareLayerDraw2(c, i), c._$_DrawInstanceMaybeWithEffects$_(l, u, i, r);
                                for (let t = 0, e = o.length; t < e; ++t) {
                                    const S = o[t];
                                    if (S !== l) {
                                        const _ = S._$GetWorldInfo$_(), T = _._$GetLayer$_();
                                        MaybePrepareLayerDraw2(T, i), T._$_DrawInstanceMaybeWithEffects$_(S, _, i, r);
                                    }
                                }
                            }
                            e = t, C33._$clearArray$_(h), C33._$clearArray$_(o);
                        } else ++e;
                    }
                    s && i._$EndQuery$_(s), C33._$clearArray$_(n), lastLayerPreparedForDrawing = null;
                }
                _$_Draw3DLayersCoplanarInstances$_(s, i, r) {
                    s._$CoplanarStartStencilPass$_();
                    for (let t = 0, e = r.length; t < e; ++t) {
                        const n = r[t], h = n._$GetWorldInfo$_(), o = h._$GetLayer$_();
                        h._$_SetDrawBackFaceOnly$_(!0), MaybePrepareLayerDraw2(o, s), 
                        o._$_DrawInstance$_(n, h, s);
                    }
                    s._$CoplanarStartColorPass$_();
                    for (let t = 0, e = r.length; t < e; ++t) {
                        const a = r[t], l = a._$GetWorldInfo$_(), u = l._$GetLayer$_();
                        MaybePrepareLayerDraw2(u, s), u._$_DrawInstanceMaybeWithEffects$_(a, l, s, i), 
                        l._$_SetDrawBackFaceOnly$_(!1);
                    }
                    s._$CoplanarRestoreStandardRendering$_();
                }
                _$_SaveToJson$_() {
                    const t = {
                        sx: this._$GetScrollX$_(),
                        sy: this._$GetScrollY$_(),
                        s: this._$GetScale$_(),
                        a: this.GetAngle(),
                        w: this._$GetWidth$_(),
                        h: this._$GetHeight$_(),
                        ortho: this._$IsOrthographicProjection$_(),
                        vpX: this._$GetVanishingPointX$_(),
                        vpY: this._$GetVanishingPointY$_(),
                        fv: this._$_isFirstVisit$_,
                        persist: this._$_persistData$_,
                        fx: this._$_effectList$_._$SaveToJson$_(),
                        layers: {},
                        dynamicLayers: []
                    };
                    for (const e of this._$_allLayersFlat$_) if (e._$IsDynamic$_()) {
                        const s = e._$GetParentLayer$_();
                        t.dynamicLayers.push({
                            sid: e._$GetSID$_(),
                            name: e._$GetName$_(),
                            parentSid: s ? s._$GetSID$_() : null,
                            siblingIndex: e._$_GetSiblingIndex$_(),
                            data: e._$_SaveToJson$_()
                        });
                    } else t.layers[e._$GetSID$_().toString()] = e._$_SaveToJson$_();
                    return t;
                }
                _$_LoadFromJson$_(t) {
                    this._$_scrollX$_ = t.sx, this._$_scrollY$_ = t.sy, this._$_scale$_ = t.s, 
                    this._$_angle$_ = t.a, this._$_width$_ = t.w, this._$_height$_ = t.h, 
                    this._$_isOrthographicProjection$_ = !!t.ortho, t.hasOwnProperty("vpX") && (this._$_vanishingPointX$_ = t.vpX), 
                    t.hasOwnProperty("vpY") && (this._$_vanishingPointY$_ = t.vpY), 
                    this._$_isFirstVisit$_ = !!t.fv, this._$_persistData$_ = t.persist, 
                    this._$_effectList$_._$LoadFromJson$_(t.fx), this._$_needsRebuildEffectChainSteps$_ = !0;
                    for (const [ e, s ] of Object.entries(t.layers)) {
                        const i = parseInt(e, 10), r = this._$GetLayerBySID$_(i);
                        r && r._$_LoadFromJson$_(s);
                    }
                    if (t.hasOwnProperty("dynamicLayers")) {
                        this._$RemoveAllDynamicLayers$_(), this._$_runtime$_._$FlushPendingInstances$_();
                        const n = new Map(), h = t.dynamicLayers;
                        for (let t = h.length - 1; 0 <= t; --t) {
                            const o = h[t], a = o.sid, l = o.name, u = o.parentSid, c = o.siblingIndex, f = o.data;
                            if (this._$_ReindexLayers$_(), !this._$HasLayerByName$_(l) && !this._$GetLayerBySID$_(a)) {
                                let t, e;
                                if (null === u) t = null, e = this._$_rootLayers$_; else {
                                    if (!(t = this._$GetLayerBySID$_(u))) continue;
                                    e = t._$GetSubLayers$_();
                                }
                                const d = C33._$New$_(C33._$Layer$_, this, t, {
                                    name: l,
                                    sid: a,
                                    _$isDynamic$_: !0
                                });
                                e.push(d);
                                let s = n.get(e);
                                s || (s = [], n.set(e, s)), s.push({
                                    _$layer$_: d,
                                    siblingIndex: c
                                }), d._$_LoadFromJson$_(f);
                            }
                        }
                        for (const [ p, m ] of n) {
                            m.sort((t, e) => t.siblingIndex - e.siblingIndex);
                            for (const C of m) {
                                let t = C._$layer$_, e = C.siblingIndex, s = p.indexOf(t);
                                p.splice(s, 1), p.splice(e, 0, t);
                            }
                        }
                    }
                    this._$_ReindexAndUpdateAllLayers$_(), this._$_SetAllLayersProjectionChanged$_(), 
                    this._$_SetAllLayersMVChanged$_();
                }
                _$GetILayout$_() {
                    return this._$_iLayout$_;
                }
                _$UserScriptDispatcher$_() {
                    return this._$_userScriptDispatcher$_;
                }
                _$DispatchUserScriptEvent$_(t) {
                    t.layout = this._$GetILayout$_();
                    const e = this._$_runtime$_, s = e._$IsDebug$_() && !e._$GetEventSheetManager$_()._$IsInEventEngine$_();
                    s && C3Debugger.StartMeasuringScriptTime(), this._$_userScriptDispatcher$_.dispatchEvent(t), 
                    s && C3Debugger.AddScriptTime();
                }
                _$DispatchUserScriptEventAsyncWait$_(t) {
                    return t.layout = this._$GetILayout$_(), this._$_userScriptDispatcher$_._$dispatchEventAndWaitAsync$_(t);
                }
                _$DispatchRuntimeUserScriptEventAsyncWait$_(t) {
                    return t.layout = this._$GetILayout$_(), this._$_runtime$_._$DispatchUserScriptEventAsyncWait$_(t);
                }
                _$_LogLayerTree$_() {
                    this._$_LogLayerList$_(this._$_rootLayers$_);
                }
                _$_LogLayerList$_(t, e = 0) {
                    const s = t.slice(0);
                    s.reverse();
                    for (const i of s) console.log("\t".repeat(e) + "- " + i._$GetName$_()), 
                    this._$_LogLayerList$_(i._$GetSubLayers$_(), e + 1);
                }
            };
        }
        {
            const C33 = self._$C3$_;
            C33._$LayoutManager$_ = class extends C33._$DefendedBase$_ {
                #_$#runtime$_;
                #_$#allLayouts$_ = [];
                #_$#layoutsByName$_ = new Map();
                #_$#layoutsBySid$_ = new Map();
                #_$#mainRunningLayout$_ = null;
                #_$#runningSubLayouts$_ = [];
                #_$#firstLayout$_ = null;
                #_$#isEndingLayout$_ = 0;
                #_$#pendingChangeLayout$_ = null;
                constructor(t) {
                    super(), this.#_$#runtime$_ = t;
                }
                _$Release$_() {
                    this.#_$#runtime$_ = null, this.#_$#mainRunningLayout$_ = null, 
                    this.#_$#firstLayout$_ = null, this.#_$#pendingChangeLayout$_ = null, 
                    C33._$clearArray$_(this.#_$#allLayouts$_), this.#_$#layoutsByName$_.clear(), 
                    this.#_$#layoutsBySid$_.clear(), C33._$clearArray$_(this.#_$#runningSubLayouts$_);
                }
                _$Create$_(t) {
                    const e = C33._$New$_(C33._$Layout$_, this, this.#_$#allLayouts$_.length, t);
                    this.#_$#allLayouts$_.push(e), this.#_$#layoutsByName$_.set(e._$GetName$_().toLowerCase(), e), 
                    this.#_$#layoutsBySid$_.set(e._$GetSID$_(), e);
                }
                _$GetRuntime$_() {
                    return this.#_$#runtime$_;
                }
                _$SetFirstLayout$_(t) {
                    this.#_$#firstLayout$_ = t;
                }
                _$GetFirstLayout$_() {
                    if (this.#_$#firstLayout$_) return this.#_$#firstLayout$_;
                    if (this.#_$#allLayouts$_.length) return this.#_$#allLayouts$_[0];
                    throw new Error("no first layout");
                }
                _$GetLayoutByName$_(t) {
                    return this.#_$#layoutsByName$_.get(t.toLowerCase()) || null;
                }
                _$GetLayoutBySID$_(t) {
                    return this.#_$#layoutsBySid$_.get(t) || null;
                }
                _$GetLayoutByIndex$_(t) {
                    return t = C33._$clamp$_(Math.floor(t), 0, this.#_$#allLayouts$_.length - 1), 
                    this.#_$#allLayouts$_[t];
                }
                _$GetLayout$_(t) {
                    return "number" == typeof t ? this._$GetLayoutByIndex$_(t) : this._$GetLayoutByName$_(t.toString());
                }
                _$GetAllLayouts$_() {
                    return this.#_$#allLayouts$_;
                }
                _$_SetMainRunningLayout$_(t) {
                    this.#_$#mainRunningLayout$_ = t;
                }
                _$GetMainRunningLayout$_() {
                    return this.#_$#mainRunningLayout$_;
                }
                _$_AddRunningSubLayout$_(t) {
                    if (this.#_$#runningSubLayouts$_.includes(t)) throw new Error("layout already running");
                    this.#_$#runningSubLayouts$_.push(t);
                }
                _$_RemoveRunningSubLayout$_(t) {
                    const e = this.#_$#runningSubLayouts$_.indexOf(t);
                    if (-1 === e) throw new Error("layout not running");
                    this.#_$#runningSubLayouts$_.splice(e, 1);
                }
                *_$runningLayouts$_() {
                    this.#_$#mainRunningLayout$_ && (yield this.#_$#mainRunningLayout$_), 
                    this.#_$#runningSubLayouts$_.length && (yield* this.#_$#runningSubLayouts$_);
                }
                _$IsLayoutRunning$_(t) {
                    return this.#_$#mainRunningLayout$_ === t || this.#_$#runningSubLayouts$_.includes(t);
                }
                _$SetIsEndingLayout$_(t) {
                    if (t) this.#_$#isEndingLayout$_++; else {
                        if (this.#_$#isEndingLayout$_ <= 0) throw new Error("already unset");
                        this.#_$#isEndingLayout$_--;
                    }
                }
                _$IsEndingLayout$_() {
                    return 0 < this.#_$#isEndingLayout$_;
                }
                _$ChangeMainLayout$_(t) {
                    this.#_$#pendingChangeLayout$_ = t;
                }
                _$ClearPendingChangeLayout$_() {
                    this.#_$#pendingChangeLayout$_ = null;
                }
                _$IsPendingChangeMainLayout$_() {
                    return !!this.#_$#pendingChangeLayout$_;
                }
                _$GetPendingChangeMainLayout$_() {
                    return this.#_$#pendingChangeLayout$_;
                }
                _$SetAllLayerProjectionChanged$_() {
                    const t = this._$GetMainRunningLayout$_();
                    t && t._$_SetAllLayersProjectionChanged$_();
                }
                _$SetAllLayerMVChanged$_() {
                    const t = this._$GetMainRunningLayout$_();
                    t && t._$_SetAllLayersMVChanged$_();
                }
            };
        }
        {
            const C33 = self._$C3$_, NAMES_REGEXP = new RegExp("<(.+?)>", "g");
            C33._$TimelineManager$_ = class extends C33._$DefendedBase$_ {
                constructor(t) {
                    super(), this._$_runtime$_ = t, this._$_timelineDataManager$_ = C33._$New$_(C33._$TimelineDataManager$_), 
                    this._$_pluginInstance$_ = null, this._$_timelines$_ = [], this._$_timelinesByName$_ = new Map(), 
                    this._$_objectClassToTimelineMap$_ = new Map(), this._$_timelinesCreatedByTemplate$_ = new Map(), 
                    this._$_scheduledTimelines$_ = [], this._$_playingTimelines$_ = [], 
                    this._$_markedForRemovalTimelines$_ = [], this._$_hasRuntimeListeners$_ = !1, 
                    this._$_changingLayout$_ = !1, this._$_isTickingTimelines$_ = !1, 
                    this._$_tickFunc$_ = () => this._$_OnTick$_(), this._$_tick2Func$_ = () => this._$_OnTick2$_(), 
                    this._$_beforeLayoutChange$_ = () => this._$_OnBeforeChangeLayout$_(), 
                    this._$_layoutChange$_ = () => this._$_OnAfterChangeLayout$_(), 
                    this._$_instanceDestroy$_ = t => this._$_OnInstanceDestroy$_(t.instance), 
                    this._$_beforeLoad$_ = t => this._$_OnBeforeLoad$_(), this._$_afterLoad$_ = t => this._$_OnAfterLoad$_(), 
                    this._$_afterLayoutStart$_ = t => this._$_OnAfterLayoutStart$_(), 
                    this._$_destroyedWhileLoadingState$_ = [], this._$_renderChange$_ = 0;
                }
                _$Release$_() {
                    this._$RemoveRuntimeListeners$_(), this._$_tickFunc$_ = null, 
                    this._$_tick2Func$_ = null, this._$_beforeLayoutChange$_ = null, 
                    this._$_layoutChange$_ = null, this._$_instanceDestroy$_ = null, 
                    this._$_afterLoad$_ = null;
                    for (const t of this._$_timelines$_) t._$Stop$_(), t._$Release$_();
                    C33._$clearArray$_(this._$_timelines$_), this._$_timelines$_ = null, 
                    this._$_timelineDataManager$_._$Release$_(), this._$_timelineDataManager$_ = null, 
                    C33._$clearArray$_(this._$_scheduledTimelines$_), this._$_scheduledTimelines$_ = null, 
                    C33._$clearArray$_(this._$_playingTimelines$_), this._$_playingTimelines$_ = null, 
                    C33._$clearArray$_(this._$_markedForRemovalTimelines$_), this._$_markedForRemovalTimelines$_ = null, 
                    this._$_timelinesByName$_.clear(), this._$_timelinesByName$_ = null, 
                    this._$_objectClassToTimelineMap$_.clear(), this._$_objectClassToTimelineMap$_ = null, 
                    this._$_timelinesCreatedByTemplate$_.clear(), this._$_timelinesCreatedByTemplate$_ = null, 
                    C33._$clearArray$_(this._$_destroyedWhileLoadingState$_), this._$_destroyedWhileLoadingState$_ = null, 
                    this._$_runtime$_ = null;
                }
                _$AddRuntimeListeners$_() {
                    const t = this._$_runtime$_._$Dispatcher$_();
                    t.addEventListener("pretick", this._$_tickFunc$_), t.addEventListener("tick2", this._$_tick2Func$_), 
                    t.addEventListener("beforelayoutchange", this._$_beforeLayoutChange$_), 
                    t.addEventListener("layoutchange", this._$_layoutChange$_), 
                    t.addEventListener("instancedestroy", this._$_instanceDestroy$_), 
                    t.addEventListener("beforeload", this._$_beforeLoad$_), t.addEventListener("afterload", this._$_afterLoad$_), 
                    t.addEventListener("afterlayoutstart", this._$_afterLayoutStart$_);
                }
                _$RemoveRuntimeListeners$_() {
                    const t = this._$_runtime$_._$Dispatcher$_();
                    t.removeEventListener("pretick", this._$_tickFunc$_), t.removeEventListener("tick2", this._$_tick2Func$_), 
                    t.removeEventListener("beforelayoutchange", this._$_beforeLayoutChange$_), 
                    t.removeEventListener("layoutchange", this._$_layoutChange$_), 
                    t.removeEventListener("instancedestroy", this._$_instanceDestroy$_), 
                    t.removeEventListener("beforeload", this._$_beforeLoad$_), t.removeEventListener("afterload", this._$_afterLoad$_), 
                    t.removeEventListener("afterlayoutstart", this._$_afterLayoutStart$_);
                }
                _$Create$_(t) {
                    this._$_timelineDataManager$_._$Add$_(t);
                    const e = C33._$TimelineState$_._$CreateInitial$_(t, this);
                    this._$Add$_(e), this._$SetTimelineObjectClassesToMap$_(e), 
                    this._$_timelinesCreatedByTemplate$_.set(e._$GetName$_(), 0);
                }
                _$CreateFromTemplate$_(t) {
                    const e = this._$GetTimelineDataManager$_(), s = t._$GetTemplateName$_(), i = e._$Get$_(s), r = C33._$TimelineState$_._$CreateFromTemplate$_(s + ":" + this._$_timelinesCreatedByTemplate$_.get(s), i, this);
                    return this._$_IncreaseTemplateTimelinesCount$_(s), this._$Add$_(r), 
                    r;
                }
                _$_IncreaseTemplateTimelinesCount$_(t) {
                    this._$_timelinesCreatedByTemplate$_.set(t, this._$_timelinesCreatedByTemplate$_.get(t) + 1);
                }
                _$_SetCreatedTemplateTimelinesCount$_() {
                    for (const t of this._$_timelines$_) if (!t._$IsTemplate$_()) {
                        const e = t._$GetTemplateName$_();
                        this._$_IncreaseTemplateTimelinesCount$_(e);
                    }
                }
                _$_ClearCreatedTemplateTimelinesCount$_() {
                    for (const t of this._$_timelinesCreatedByTemplate$_.keys()) this._$_timelinesCreatedByTemplate$_.set(t, 0);
                }
                _$Add$_(t) {
                    this._$_timelines$_.push(t), this._$_timelinesByName$_.set(t._$GetName$_().toLowerCase(), t);
                }
                _$Remove$_(t) {
                    t._$Removed$_(), t._$IsTemplate$_() || (C33._$arrayFindRemove$_(this._$_timelines$_, t), 
                    C33._$arrayFindRemove$_(this._$_scheduledTimelines$_, t), C33._$arrayFindRemove$_(this._$_playingTimelines$_, t), 
                    C33._$arrayFindRemove$_(this._$_markedForRemovalTimelines$_, t), 
                    this._$_timelinesByName$_.delete(t._$GetName$_().toLowerCase()), 
                    this._$RemoveTimelineFromObjectClassMap$_(t), t._$IsReleased$_()) || t._$Release$_();
                }
                _$Trigger$_(t) {
                    this._$_runtime$_._$Trigger$_(t, this._$_pluginInstance$_, null);
                }
                _$GetRuntime$_() {
                    return this._$_runtime$_;
                }
                _$GetTimelineDataManager$_() {
                    return this._$_timelineDataManager$_;
                }
                _$SetPluginInstance$_(t) {
                    this._$_pluginInstance$_ = t;
                }
                _$GetPluginInstance$_() {
                    return this._$_pluginInstance$_;
                }
                *_$GetTimelines$_() {
                    for (const t of this._$_timelines$_) yield t;
                }
                *_$GetPlayingTimelines$_() {
                    for (const t of this._$_playingTimelines$_) yield t;
                }
                _$SetTimelineObjectClassToMap$_(t, e) {
                    this._$_objectClassToTimelineMap$_.has(t) || this._$_objectClassToTimelineMap$_.set(t, new Set()), 
                    this._$_objectClassToTimelineMap$_.get(t).add(e);
                }
                _$SetTimelineObjectClassesToMap$_(t) {
                    for (const e of t._$GetObjectClasses$_()) this._$SetTimelineObjectClassToMap$_(e, t);
                }
                _$RemoveTimelineFromObjectClassMap$_(t) {
                    for (const [ e, s ] of this._$_objectClassToTimelineMap$_.entries()) s.has(t) && (s.delete(t), 
                    0 === s.size) && this._$_objectClassToTimelineMap$_.delete(e);
                }
                _$GetTimelinesForObjectClass$_(t) {
                    if (this._$_objectClassToTimelineMap$_.has(t)) return this._$_objectClassToTimelineMap$_.get(t);
                }
                _$GetTimelineOfTemplateForInstances$_(t, e) {
                    if (e) for (const s of this._$_timelines$_) {
                        const i = e.every(t => s._$HasTrackInstance$_(t.instance, t.trackId));
                        if (i && s._$GetName$_().includes(t._$GetName$_())) return s;
                    }
                }
                _$GetTimelineByName$_(t) {
                    return this._$_timelinesByName$_.get(t.toLowerCase()) || null;
                }
                _$GetScheduledOrPlayingTimelineByName$_(t) {
                    for (const e of this._$_scheduledTimelines$_) if (e._$GetName$_() === t) return e;
                    for (const s of this._$_playingTimelines$_) if (s._$GetName$_() === t) return s;
                    return null;
                }
                *_$GetTimelinesByName$_(s) {
                    if (NAMES_REGEXP.test(s)) {
                        NAMES_REGEXP.lastIndex = 0;
                        let t, e = new Set();
                        do {
                            if (t = NAMES_REGEXP.exec(s)) {
                                const i = t[1].split(",");
                                for (const r of i) e.add(r);
                            }
                        } while (t);
                        for (const n of e.values()) {
                            const h = this._$GetTimelineByName$_(n);
                            h && (yield h);
                        }
                        e.clear();
                    } else {
                        const t = this._$GetTimelineByName$_(s);
                        t && (yield t);
                    }
                }
                *_$GetTimelinesByTags$_(t) {
                    for (const e of this._$_timelines$_) e._$HasTags$_(t) && (yield e);
                }
                _$AddScheduledTimeline$_(t) {
                    this._$_scheduledTimelines$_.includes(t) || this._$_scheduledTimelines$_.push(t), 
                    this._$_MaybeEnableRuntimeListeners$_();
                }
                _$RemovePlayingTimeline$_(t) {
                    C33._$arrayFindRemove$_(this._$_playingTimelines$_, t), this._$_MaybeDisableRuntimeListeners$_();
                }
                _$ScheduleTimeline$_(t) {
                    this._$_playingTimelines$_.includes(t) ? (t._$SetPlaying$_(!0), 
                    t._$SetScheduled$_(!1), t._$SetMarkedForRemoval$_(!1)) : (t._$SetPlaying$_(!1), 
                    t._$SetScheduled$_(!0), t._$SetMarkedForRemoval$_(!1), this._$_scheduledTimelines$_.includes(t) || this._$_scheduledTimelines$_.push(t)), 
                    this._$_MaybeEnableRuntimeListeners$_();
                }
                _$DeScheduleTimeline$_(t) {
                    t._$SetPlaying$_(!1), t._$SetScheduled$_(!1), t._$ResolvePlayPromise$_(), 
                    C33._$arrayFindRemove$_(this._$_scheduledTimelines$_, t), this._$_MaybeDisableRuntimeListeners$_();
                }
                _$CompleteTimeline$_(t) {
                    t._$SetPlaying$_(!1), t._$SetScheduled$_(!1), this._$_playingTimelines$_.includes(t) && (t._$SetMarkedForRemoval$_(!0), 
                    this._$_markedForRemovalTimelines$_.push(t), C33._$arrayFindRemove$_(this._$_playingTimelines$_, t)), 
                    this._$_scheduledTimelines$_.includes(t) && t._$SetMarkedForRemoval$_(!0);
                }
                _$CompleteTimelineBeforeChangeOfLayout$_(t) {
                    t._$SetPlaying$_(!1), t._$SetScheduled$_(!1), t._$SetMarkedForRemoval$_(!1), 
                    t._$SetPlaybackRate$_(1), C33._$arrayFindRemove$_(this._$_playingTimelines$_, t);
                }
                _$CompleteTimelineAndResolve$_(t) {
                    this._$CompleteTimeline$_(t), t._$ResolvePlayPromise$_();
                }
                _$_OnTick$_() {
                    if (!this._$GetRuntime$_()._$IsLoadingState$_() && this._$_hasRuntimeListeners$_ && !this._$_changingLayout$_) {
                        for (this._$_isTickingTimelines$_ = !0; this._$_scheduledTimelines$_.length; ) {
                            const t = this._$_scheduledTimelines$_.pop();
                            (t._$IsMarkedForRemoval$_() ? (t._$SetInitialStateForce$_(), 
                            this._$_markedForRemovalTimelines$_) : (t._$SetInitialState$_(), 
                            this._$_playingTimelines$_)).push(t), 0 !== t._$GetRenderChange$_() && (this._$_renderChange$_ = 1);
                        }
                        const e = this._$_runtime$_._$_GetDtFast$_(), s = this._$_runtime$_._$GetDt1$_(), i = this._$_runtime$_._$GetTimeScale$_();
                        for (let t = this._$_playingTimelines$_.length - 1; 0 <= t; t--) {
                            const r = this._$_playingTimelines$_[t];
                            r && r._$Tick$_(e, i, s);
                        }
                        this._$_isTickingTimelines$_ = !1, 0 !== this._$_renderChange$_ && this._$GetRuntime$_()._$UpdateRender$_();
                    }
                }
                _$_OnTick2$_() {
                    if (!this._$GetRuntime$_()._$IsLoadingState$_() && this._$_hasRuntimeListeners$_ && !this._$_changingLayout$_) {
                        let s;
                        for (let t = 0, e = this._$_markedForRemovalTimelines$_.length; t < e; t++) {
                            const i = this._$_markedForRemovalTimelines$_[t];
                            s = s || new Set(), i._$Removed$_(), this._$_MaybeExecuteTimelineFinishTriggers$_(i), 
                            s.add(i);
                        }
                        if (s) {
                            C33._$arrayRemoveAllInSet$_(this._$_markedForRemovalTimelines$_, s);
                            for (let t = this._$_renderChange$_ = 0, e = this._$_playingTimelines$_.length; t < e; t++) if (0 !== this._$_playingTimelines$_[t]._$GetRenderChange$_()) {
                                this._$_renderChange$_ = 1;
                                break;
                            }
                        }
                        this._$_MaybeDisableRuntimeListeners$_();
                    }
                }
                _$_MaybeExecuteTimelineFinishTriggers$_(t) {
                    t._$IsReleased$_() || t._$HasValidTracks$_() && t._$IsComplete$_() && t._$InitialStateSet$_() && t._$FinishTriggers$_();
                }
                _$_MaybeEnableRuntimeListeners$_() {
                    this._$_hasRuntimeListeners$_ || (this._$_hasRuntimeListeners$_ = !0);
                }
                _$_MaybeDisableRuntimeListeners$_() {
                    this._$_markedForRemovalTimelines$_.length || this._$_playingTimelines$_.length || this._$_scheduledTimelines$_.length || this._$_isTickingTimelines$_ || (this._$_hasRuntimeListeners$_ = !1);
                }
                _$_OnBeforeChangeLayout$_() {
                    for (this._$_changingLayout$_ = !0; this._$_scheduledTimelines$_.length; ) this._$DeScheduleTimeline$_(this._$_scheduledTimelines$_.pop());
                    const t = new Set();
                    for (const e of this._$_playingTimelines$_) {
                        const s = e._$_OnBeforeChangeLayout$_();
                        s && (e._$Removed$_(), t.add(e));
                    }
                    C33._$arrayRemoveAllInSet$_(this._$_playingTimelines$_, t), 
                    t.clear();
                    for (const i of this._$_markedForRemovalTimelines$_) {
                        const r = i._$_OnBeforeChangeLayout$_();
                        r && (i._$Removed$_(), t.add(i));
                    }
                    C33._$arrayRemoveAllInSet$_(this._$_markedForRemovalTimelines$_, t), 
                    this._$_MaybeDisableRuntimeListeners$_();
                    for (const n of this._$_timelines$_) n._$CleanCaches$_();
                }
                _$_OnAfterChangeLayout$_() {
                    this._$_changingLayout$_ = !1;
                }
                _$_OnInstanceDestroy$_(t) {
                    const e = t._$GetObjectClass$_(), s = this._$GetTimelinesForObjectClass$_(e);
                    if (s) if (this._$_runtime$_._$IsLoadingState$_()) this._$_destroyedWhileLoadingState$_.push(t); else for (const i of s) i._$IsTemplate$_() || (i._$IsReleased$_() ? this._$Remove$_(i) : i._$HasValidTracks$_() || (this._$_MaybeExecuteTimelineFinishTriggers$_(i), 
                    this._$Remove$_(i)));
                }
                _$_OnBeforeLoad$_() {
                    for (const t of this._$_scheduledTimelines$_.map(t => t)) this._$_MaybeExecuteTimelineFinishTriggers$_(t), 
                    this._$Remove$_(t);
                    for (const e of this._$_playingTimelines$_.map(t => t)) this._$_MaybeExecuteTimelineFinishTriggers$_(e), 
                    this._$Remove$_(e);
                }
                _$_OnAfterLoad$_() {
                    for (const t of this._$_destroyedWhileLoadingState$_) this._$_OnInstanceDestroy$_(t);
                    C33._$clearArray$_(this._$_destroyedWhileLoadingState$_);
                    for (const e of this._$_timelines$_) e._$_OnAfterLoad$_();
                }
                _$_OnAfterLayoutStart$_() {
                    const t = this._$_runtime$_._$GetLayoutManager$_(), e = t._$GetMainRunningLayout$_();
                    if (e) for (const s of this._$_timelines$_) {
                        const i = s._$GetStartOnLayout$_();
                        i && e._$GetName$_() === i && this._$ScheduleTimeline$_(s);
                    }
                }
                _$_SaveToJson$_() {
                    return {
                        timelinesJson: this._$_SaveTimelinesToJson$_(),
                        scheduledTimelinesJson: this._$_SaveScheduledTimelinesToJson$_(),
                        playingTimelinesJson: this._$_SavePlayingTimelinesToJson$_(),
                        markedForRemovalTimelinesJson: this._$_SaveMarkedForRemovalTimelinesToJson$_(),
                        hasRuntimeListeners: this._$_hasRuntimeListeners$_,
                        changingLayout: this._$_changingLayout$_,
                        isTickingTimelines: this._$_isTickingTimelines$_
                    };
                }
                _$_LoadFromJson$_(t) {
                    t && (this._$_ClearCreatedTemplateTimelinesCount$_(), this._$_LoadTimelinesFromJson$_(t.timelinesJson), 
                    this._$_LoadScheduledTimelinesFromJson$_(t.scheduledTimelinesJson), 
                    this._$_LoadPlayingTimelinesFromJson$_(t.playingTimelinesJson), 
                    this._$_LoadMarkedForRemovalTimelinesFromJson$_(t.markedForRemovalTimelinesJson), 
                    this._$_hasRuntimeListeners$_ = !t.hasRuntimeListeners, this._$_changingLayout$_ = !!t.changingLayout, 
                    this._$_isTickingTimelines$_ = !!t.isTickingTimelines, this._$_SetCreatedTemplateTimelinesCount$_(), 
                    this._$_MaybeEnableRuntimeListeners$_(), this._$_MaybeDisableRuntimeListeners$_());
                }
                _$_SaveTimelinesToJson$_() {
                    return this._$_timelines$_.map(t => t._$_SaveToJson$_());
                }
                _$_LoadTimelinesFromJson$_(t) {
                    for (const e of t) {
                        let t = this._$GetTimelineByName$_(e.name);
                        if (t) t._$_LoadFromJson$_(e); else {
                            const s = this._$_GetTemplateNameFromJson$_(e);
                            if (!s) continue;
                            const i = this._$GetTimelineByName$_(s);
                            (t = this._$CreateFromTemplate$_(i))._$_LoadFromJson$_(e);
                        }
                        t._$HasTracks$_() || this._$Remove$_(t);
                    }
                }
                _$_GetTemplateNameFromJson$_(t) {
                    const e = t.name, s = e.split(":");
                    return s && 2 === s.length ? s[0] : null;
                }
                _$_SaveScheduledTimelinesToJson$_() {
                    return this._$_SaveTimelines$_(this._$_scheduledTimelines$_);
                }
                _$_LoadScheduledTimelinesFromJson$_(t) {
                    this._$_LoadTimelines$_(t, this._$_scheduledTimelines$_);
                }
                _$_SavePlayingTimelinesToJson$_() {
                    return this._$_SaveTimelines$_(this._$_playingTimelines$_);
                }
                _$_LoadPlayingTimelinesFromJson$_(t) {
                    this._$_LoadTimelines$_(t, this._$_playingTimelines$_);
                }
                _$_SaveMarkedForRemovalTimelinesToJson$_() {
                    return this._$_SaveTimelines$_(this._$_markedForRemovalTimelines$_);
                }
                _$_LoadMarkedForRemovalTimelinesFromJson$_(t) {
                    this._$_LoadTimelines$_(t, this._$_markedForRemovalTimelines$_);
                }
                _$_IsTimelineInJson$_(t, e) {
                    if (e) for (const s of e) if (s === t._$GetName$_()) return !0;
                    return !1;
                }
                _$_SaveTimelines$_(t) {
                    return t.map(t => t._$GetName$_());
                }
                _$_LoadTimelines$_(t, e) {
                    const s = new Set();
                    for (const i of e) this._$_IsTimelineInJson$_(i, t) || s.add(i);
                    if (C33._$arrayRemoveAllInSet$_(e, s), t) for (const r of t) {
                        const n = this._$GetTimelineByName$_(r);
                        if (n) {
                            const h = e.find((e => t => t._$GetName$_() === e)(r));
                            h || e.push(n);
                        }
                    }
                }
            };
        }
        {
            const C33 = self._$C3$_, STEPS = 100, LENGTH_STEP_SIZE = .01, BEZIER_STEP_SIZE = 25, REFINE_ITERATIONS = 20, LOOKUP_STEPS_FROM_LAST = 5, TANGENT_RESULT = [ 0, 0 ], MAP_RESULT = [ 0, 0 ], SHORT_PROJECTION_RESULT = [ 0, 0 ], PROJECTION_RESULT = [ 0, 0, 0, 0, 0 ], REFINE_LUT = new Array(4), REFINE_LUT_OBJECTS = [ {
                x: 0,
                y: 0,
                t: 0,
                _$distance$_: 0
            }, {
                x: 0,
                y: 0,
                t: 0,
                _$distance$_: 0
            }, {
                x: 0,
                y: 0,
                t: 0,
                _$distance$_: 0
            } ], REFINE_RESULT = {
                x: 0,
                y: 0,
                t: 0,
                _$distance$_: 0
            };
            C33._$TimelineInfo$_ = class {
                constructor(t, e) {
                    this._$_initialized$_ = !1, this._$_timeline$_ = t, this._$_segments$_ = [];
                    let s = null;
                    if (s = e ? this._$_timeline$_._$GetTrackById$_(e) : C33.first(this._$_timeline$_._$GetTracks$_())) {
                        const i = s._$GetPropertyTrack$_("offsetX"), r = s._$GetPropertyTrack$_("offsetY");
                        if (i && r) {
                            this._$_xTrack$_ = i, this._$_yTrack$_ = r;
                            const n = i._$GetPropertyKeyframeDataItemArrayIncludingDisabled$_(), h = r._$GetPropertyKeyframeDataItemArrayIncludingDisabled$_();
                            for (let t = 1, e = Math.min(n.length, h.length); t < e; ++t) {
                                const o = n[t], a = (o._$GetNext$_(), o._$GetPrevious$_()), l = h[t], u = (l._$GetNext$_(), 
                                l._$GetPrevious$_());
                                a && "cubic-bezier" === a._$GetPathMode$_() && u && "cubic-bezier" === u._$GetPathMode$_() ? this._$_segments$_.push(C33._$New$_(C33._$TimelineCubicBezierSegmentInfo$_, a, u, o, l, this._$_segments$_.length)) : (a && "line" === a._$GetPathMode$_() && u && u._$GetPathMode$_(), 
                                this._$_segments$_.push(C33._$New$_(C33._$TimelineLineSegmentInfo$_, o, l, this._$_segments$_.length)));
                            }
                            this._$_initialized$_ = !0;
                        }
                    }
                }
                _$Release$_() {
                    for (const t of this._$_segments$_) t._$Release$_();
                    C33._$clearArray$_(this._$_segments$_), this._$_segments$_ = null, 
                    this._$_timeline$_ = null, this._$_xTrack$_ = null, this._$_yTrack$_ = null;
                }
                _$WasInitialized$_() {
                    return this._$_initialized$_;
                }
                _$segments$_() {
                    return this._$_segments$_;
                }
                _$SetOrigin$_(t) {
                    const e = "relative" === this._$_xTrack$_._$GetResultMode$_() ? t._$GetX$_() : 0, s = "relative" === this._$_yTrack$_._$GetResultMode$_() ? t._$GetY$_() : 0;
                    for (const i of this._$_segments$_) i._$SetOrigin$_(e, s);
                }
                _$Project$_(e, s, t) {
                    let i = NaN, r = this._$_segments$_.length;
                    for (let t = 0; t < r; t++) {
                        const n = this._$_segments$_[t];
                        if ("cubic-bezier" === n._$GetType$_()) {
                            const h = n._$Project$_(e, s);
                            (isNaN(i) || h[3] < i) && (i = h[3], SHORT_PROJECTION_RESULT[0] = h[2], 
                            SHORT_PROJECTION_RESULT[1] = n._$GetIndex$_());
                        }
                    }
                    return SHORT_PROJECTION_RESULT;
                }
                _$ProjectWithOptions$_(e, s, t) {
                    const i = t.tRange;
                    C33._$IsFiniteNumber$_(i[0]) || (i[0] = 0), C33._$IsFiniteNumber$_(i[1]) || (i[1] = 1);
                    let r = NaN, n = this._$_segments$_.length;
                    for (let t = 0; t < n; t++) {
                        const h = this._$_segments$_[t];
                        if ("cubic-bezier" === h._$GetType$_()) {
                            const o = h._$ProjectWithRange$_(e, s, i);
                            (isNaN(r) || o[3] < r) && (r = o[3], SHORT_PROJECTION_RESULT[0] = o[2], 
                            SHORT_PROJECTION_RESULT[1] = h._$GetIndex$_());
                        }
                    }
                    return SHORT_PROJECTION_RESULT;
                }
                _$Tangent$_(t, e) {
                    return this._$_segments$_[e]._$Tangent$_(t);
                }
                _$TangentAngle$_(t, e) {
                    return this._$_segments$_[e]._$TangentAngle$_(t);
                }
            }, C33._$TimelineCubicBezierSegmentInfo$_ = class {
                constructor(t, e, s, i, r) {
                    this._$_index$_ = r;
                    const n = t._$GetAddOn$_("cubic-bezier"), h = s._$GetAddOn$_("cubic-bezier"), o = e._$GetAddOn$_("cubic-bezier"), a = i._$GetAddOn$_("cubic-bezier");
                    this._$_aX$_ = t._$GetValueWithResultMode$_(), this._$_aY$_ = e._$GetValueWithResultMode$_(), 
                    this._$_bX$_ = t._$GetValueWithResultMode$_() + n._$GetStartAnchor$_(), 
                    this._$_bY$_ = e._$GetValueWithResultMode$_() + o._$GetStartAnchor$_(), 
                    this._$_cX$_ = s._$GetValueWithResultMode$_() + h._$GetEndAnchor$_(), 
                    this._$_cY$_ = i._$GetValueWithResultMode$_() + a._$GetEndAnchor$_(), 
                    this._$_dX$_ = s._$GetValueWithResultMode$_(), this._$_dY$_ = i._$GetValueWithResultMode$_(), 
                    this._$_aXO$_ = 0, this._$_aYO$_ = 0, this._$_bXO$_ = 0, this._$_bYO$_ = 0, 
                    this._$_cXO$_ = 0, this._$_cYO$_ = 0, this._$_dXO$_ = 0, this._$_dYO$_ = 0, 
                    this._$_d0x$_ = 0, this._$_d0y$_ = 0, this._$_d1x$_ = 0, this._$_d1y$_ = 0, 
                    this._$_d2x$_ = 0, this._$_d2y$_ = 0, this._$_x1Factor$_ = 0, 
                    this._$_x2Factor$_ = 0, this._$_x3Factor$_ = 0, this._$_y1Factor$_ = 0, 
                    this._$_y2Factor$_ = 0, this._$_y3Factor$_ = 0, this._$_lutIndex$_ = NaN, 
                    this._$_initialized$_ = !1, this._$_len$_ = STEPS, this._$_arcLengths$_ = new Array(this._$_len$_ + 1), 
                    this._$_arcLengths$_[0] = 0, this._$_length$_ = 0, this._$_lut$_ = [], 
                    this._$_lutObjects$_ = [];
                    for (let t = 0; t < STEPS; t++) this._$_lutObjects$_.push({
                        x: 0,
                        y: 0,
                        t: 0,
                        _$distance$_: 0
                    });
                    this._$_CalculateLength$_();
                }
                _$Release$_() {
                    C33._$clearArray$_(this._$_arcLengths$_), this._$_arcLengths$_ = null, 
                    C33._$clearArray$_(this._$_lut$_), this._$_lut$_ = null, C33._$clearArray$_(this._$_lutObjects$_), 
                    this._$_lutObjects$_ = null;
                }
                _$GetType$_() {
                    return "cubic-bezier";
                }
                _$GetIndex$_() {
                    return this._$_index$_;
                }
                _$GetStepCount$_() {
                    return Math.floor(this._$_length$_ / BEZIER_STEP_SIZE);
                }
                _$GetStepIncrement$_() {
                    return 1 / this._$GetStepCount$_();
                }
                _$SetOrigin$_(t, e) {
                    this._$_originX$_ = t, this._$_originY$_ = e, this._$_arcLengths$_ = new Array(this._$_len$_ + 1), 
                    this._$_arcLengths$_[0] = 0, this._$_CalculateLength$_(), this._$_aXO$_ = this._$_aX$_ + this._$_originX$_, 
                    this._$_aYO$_ = this._$_aY$_ + this._$_originY$_, this._$_bXO$_ = this._$_bX$_ + this._$_originX$_, 
                    this._$_bYO$_ = this._$_bY$_ + this._$_originY$_, this._$_cXO$_ = this._$_cX$_ + this._$_originX$_, 
                    this._$_cYO$_ = this._$_cY$_ + this._$_originY$_, this._$_dXO$_ = this._$_dX$_ + this._$_originX$_, 
                    this._$_dYO$_ = this._$_dY$_ + this._$_originY$_, this._$_d0x$_ = 3 * (this._$_bXO$_ - this._$_aXO$_), 
                    this._$_d0y$_ = 3 * (this._$_bYO$_ - this._$_aYO$_), this._$_d1x$_ = 3 * (this._$_cXO$_ - this._$_bXO$_), 
                    this._$_d1y$_ = 3 * (this._$_cYO$_ - this._$_bYO$_), this._$_d2x$_ = 3 * (this._$_dXO$_ - this._$_cXO$_), 
                    this._$_d2y$_ = 3 * (this._$_dYO$_ - this._$_cYO$_), this._$_x1Factor$_ = 3 * (this._$_bXO$_ - this._$_aXO$_), 
                    this._$_x2Factor$_ = 3 * (this._$_aXO$_ + this._$_cXO$_ - 2 * this._$_bXO$_), 
                    this._$_x3Factor$_ = this._$_dXO$_ - this._$_aXO$_ + 3 * (this._$_bXO$_ - this._$_cXO$_), 
                    this._$_y1Factor$_ = 3 * (this._$_bYO$_ - this._$_aYO$_), this._$_y2Factor$_ = 3 * (this._$_aYO$_ + this._$_cYO$_ - 2 * this._$_bYO$_), 
                    this._$_y3Factor$_ = this._$_dYO$_ - this._$_aYO$_ + 3 * (this._$_bYO$_ - this._$_cYO$_);
                }
                Map(t) {
                    if (!this._$_initialized$_) return NaN;
                    const e = this._$_Map$_(t);
                    return MAP_RESULT[0] = this._$_X$_(e), MAP_RESULT[1] = this._$_Y$_(e), 
                    MAP_RESULT;
                }
                _$Project$_(t, e) {
                    const s = this._$_GenerateLUT$_(STEPS), i = this._$_FindClosestFromLUT$_(t, e, s), r = this._$_RefineProjection$_(t, e, s, i);
                    return PROJECTION_RESULT[0] = r.x, PROJECTION_RESULT[1] = r.y, 
                    PROJECTION_RESULT[2] = r.t, PROJECTION_RESULT[3] = r._$distance$_, 
                    PROJECTION_RESULT;
                }
                _$ProjectWithRange$_(t, e, s) {
                    const i = this._$_GenerateLUT$_(STEPS), r = this._$_FindClosestFromLUTWithRange$_(t, e, i, s), n = this._$_RefineProjection$_(t, e, i, r);
                    return PROJECTION_RESULT[0] = n.x, PROJECTION_RESULT[1] = n.y, 
                    PROJECTION_RESULT[2] = n.t, PROJECTION_RESULT[3] = n._$distance$_, 
                    PROJECTION_RESULT;
                }
                _$Tangent$_(t) {
                    const e = 1 - t, s = e * e, i = 2 * e * t, r = t * t, n = s * this._$_d0x$_ + i * this._$_d1x$_ + r * this._$_d2x$_, h = s * this._$_d0y$_ + i * this._$_d1y$_ + r * this._$_d2y$_, o = C33._$hypot2DFast$_(n, h);
                    return TANGENT_RESULT[0] = n / o, TANGENT_RESULT[1] = h / o, 
                    TANGENT_RESULT;
                }
                _$TangentAngle$_(t) {
                    const e = 1 - t, s = e * e, i = 2 * e * t, r = t * t, n = s * this._$_d0x$_ + i * this._$_d1x$_ + r * this._$_d2x$_, h = s * this._$_d0y$_ + i * this._$_d1y$_ + r * this._$_d2y$_;
                    return Math.atan2(h, n);
                }
                _$_Map$_(r) {
                    if (this._$_initialized$_) {
                        let t = r * this._$_arcLengths$_[this._$_len$_], e = 0, s = this._$_len$_, i = 0;
                        for (;e < s; ) i = e + ((s - e) / 2 | 0), this._$_arcLengths$_[i] < t ? e = i + 1 : s = i;
                        this._$_arcLengths$_[i] > t && i--;
                        const n = this._$_arcLengths$_[i];
                        return n === t ? i / this._$_len$_ : (i + (t - n) / (this._$_arcLengths$_[i + 1] - n)) / this._$_len$_;
                    }
                }
                _$_X$_(t) {
                    return this._$_initialized$_ ? self._$Ease$_._$GetRuntimeEase$_("cubicbezier")(t, this._$_aX$_ + this._$_originX$_, this._$_bX$_ + this._$_originX$_, this._$_cX$_ + this._$_originX$_, this._$_dX$_ + this._$_originX$_) : NaN;
                }
                _$_Y$_(t) {
                    return this._$_initialized$_ ? self._$Ease$_._$GetRuntimeEase$_("cubicbezier")(t, this._$_aY$_ + this._$_originY$_, this._$_bY$_ + this._$_originY$_, this._$_cY$_ + this._$_originY$_, this._$_dY$_ + this._$_originY$_) : NaN;
                }
                _$_GenerateLUT$_(e) {
                    if (e = e || STEPS, !(this._$_lut$_.length >= e)) {
                        this._$_lut$_ = new Array(e), e++;
                        for (let t = 0; t < e - 1; t++) {
                            const s = t / (e - 1), i = s ** 2, r = s ** 3, n = this._$_x1Factor$_ * s, h = this._$_x2Factor$_ * i, o = this._$_x3Factor$_ * r, a = this._$_y1Factor$_ * s, l = this._$_y2Factor$_ * i, u = this._$_y3Factor$_ * r, c = this._$_aXO$_ + n + h + o, f = this._$_aYO$_ + a + l + u;
                            this._$_lutObjects$_[t].x = c, this._$_lutObjects$_[t].y = f, 
                            this._$_lutObjects$_[t].t = s, this._$_lutObjects$_[t]._$distance$_ = 0, 
                            this._$_lut$_[t] = this._$_lutObjects$_[t];
                        }
                    }
                    return this._$_lut$_;
                }
                _$_FindClosestFromLUT$_(e, s, i, t = 0, r = Number.MAX_SAFE_INTEGER) {
                    let n = 0;
                    if (isNaN(this._$_lutIndex$_)) for (let t = 0; t < STEPS; t++) {
                        const h = i[t], o = h.x - e, a = h.y - s;
                        h._$distance$_ = o * o + a * a, h._$distance$_ < r && (r = h._$distance$_, 
                        n = t);
                    } else {
                        for (let t = this._$_lutIndex$_; t < this._$_lutIndex$_ + LOOKUP_STEPS_FROM_LAST && !(t >= i.length); t++) {
                            const l = i[t], u = l.x - e, c = l.y - s;
                            l._$distance$_ = u * u + c * c, l._$distance$_ < r && (r = l._$distance$_, 
                            n = t);
                        }
                        for (let t = this._$_lutIndex$_; t > this._$_lutIndex$_ - LOOKUP_STEPS_FROM_LAST && !(t < 0); t--) {
                            const f = i[t], d = f.x - e, p = f.y - s;
                            f._$distance$_ = d * d + p * p, f._$distance$_ < r && (r = f._$distance$_, 
                            n = t);
                        }
                    }
                    return this._$_lutIndex$_ = n;
                }
                _$_FindClosestFromLUTWithRange$_(e, s, i, r, n = Number.MAX_SAFE_INTEGER) {
                    let h = 0;
                    if (isNaN(this._$_lutIndex$_)) for (let t = 0; t < STEPS; t++) {
                        const o = i[t], a = o.x - e, l = o.y - s;
                        o._$distance$_ = a * a + l * l, o.t >= r[0] && o.t <= r[1] && o._$distance$_ < n && (n = o._$distance$_, 
                        h = t);
                    } else {
                        for (let t = this._$_lutIndex$_; t < this._$_lutIndex$_ + LOOKUP_STEPS_FROM_LAST && !(t >= i.length); t++) {
                            const u = i[t], c = u.x - e, f = u.y - s;
                            u._$distance$_ = c * c + f * f, u.t >= r[0] && u.t <= r[1] && u._$distance$_ < n && (n = u._$distance$_, 
                            h = t);
                        }
                        for (let t = this._$_lutIndex$_; t > this._$_lutIndex$_ - LOOKUP_STEPS_FROM_LAST && !(t < 0); t--) {
                            const d = i[t], p = d.x - e, m = d.y - s;
                            d._$distance$_ = p * p + m * m, d.t >= r[0] && d.t <= r[1] && d._$distance$_ < n && (n = d._$distance$_, 
                            h = t);
                        }
                    }
                    return this._$_lutIndex$_ = h;
                }
                _$_RefineProjection$_(h, o, a, l) {
                    let u = a[l], t = 1, c = Number.MAX_SAFE_INTEGER;
                    t: do {
                        let t = a.length, e = 0 === l ? 0 : l - 1, s = l === t - 1 ? t - 1 : l + 1, i = a[e].t, r = a[s].t, n = (r - i) / 4;
                        if (n < .001) break;
                        REFINE_LUT[0] = a[e];
                        for (let t = 1; t <= 2; t++) {
                            const f = i + t * n, d = f ** 2, p = f ** 3, m = this._$_x1Factor$_ * f, C = this._$_x2Factor$_ * d, g = this._$_x3Factor$_ * p, S = this._$_y1Factor$_ * f, _ = this._$_y2Factor$_ * d, T = this._$_y3Factor$_ * p, y = this._$_aXO$_ + m + C + g, E = this._$_aYO$_ + S + _ + T, A = y - h, I = E - o, M = A * A + I * I;
                            if (M < c) {
                                c = M, l = t, REFINE_RESULT.x = y, REFINE_RESULT.y = E, 
                                REFINE_RESULT.t = f, REFINE_RESULT._$distance$_ = M, 
                                u = REFINE_RESULT;
                                break t;
                            }
                            const w = REFINE_LUT_OBJECTS[t - 1];
                            w.x = y, w.y = E, w.t = f, w._$distance$_ = M, REFINE_LUT[t] = w;
                        }
                        REFINE_LUT[3] = a[s], a = REFINE_LUT;
                    } while (t++ < REFINE_ITERATIONS);
                    return u;
                }
                _$_CalculateLength$_() {
                    this._$_initialized$_ = !0;
                    let e = this._$_X$_(0), s = this._$_Y$_(0), i = 0;
                    for (let t = 1; t <= this._$_len$_; t++) {
                        const r = this._$_X$_(t * LENGTH_STEP_SIZE), n = this._$_Y$_(t * LENGTH_STEP_SIZE), h = e - r, o = s - n;
                        i += C33._$hypot2DFast$_(h, o), this._$_arcLengths$_[t] = i, 
                        e = r, s = n;
                    }
                    this._$_length$_ = i;
                }
            }, C33._$TimelineLineSegmentInfo$_ = class {
                constructor(t, e, s) {
                    this._$_index$_ = s, this._$_targetX$_ = t._$GetValueWithResultMode$_(), 
                    this._$_targetY$_ = e._$GetValueWithResultMode$_(), this._$_originX$_ = 0, 
                    this._$_originY$_ = 0;
                }
                _$Release$_() {}
                _$GetType$_() {
                    return "line";
                }
                _$GetIndex$_() {
                    return this._$_index$_;
                }
                _$SetOrigin$_(t, e) {
                    this._$_originX$_ = t, this._$_originY$_ = e;
                }
                _$GetX$_() {
                    return this._$_targetX$_ + this._$_originX$_;
                }
                _$GetY$_() {
                    return this._$_targetY$_ + this._$_originY$_;
                }
            };
        }
        {
            const C33 = self._$C3$_, PING_PONG_BEGIN = 0, PING_PONG_END = 1;
            C33._$TimelineState$_ = class extends C33._$DefendedBase$_ {
                constructor(t, e, s) {
                    super(), this._$_runtime$_ = s._$GetRuntime$_(), this._$_timelineManager$_ = s, 
                    this._$_timelineDataItem$_ = e, this._$_name$_ = t, this._$_tracks$_ = [], 
                    this._$_tracksLength$_ = 0, this._$_beforeAndAfterTracks$_ = null, 
                    this._$_beforeAndAfterTracksLength$_ = 0, this._$CreateTrackStates$_(), 
                    this._$_playPromise$_ = null, this._$_playResolve$_ = null, 
                    this._$_playheadTime$_ = 0, this._$_overshoot$_ = 0, this._$_playbackRate$_ = 1, 
                    this._$_pingPongState$_ = PING_PONG_BEGIN, this._$_currentRepeatCount$_ = 1, 
                    this._$_isPlaying$_ = !1, this._$_isScheduled$_ = !1, this._$_initialStateSet$_ = !1, 
                    this._$_complete$_ = !0, this._$_released$_ = !1, this._$_markedForRemoval$_ = !1, 
                    this._$_completedTick$_ = -1, this._$_implicitPause$_ = !1, 
                    this._$_isTemplate$_ = !1, this._$_finishedTriggers$_ = !1, 
                    this._$_firstTick$_ = !1, this._$_lastDelta$_ = NaN, this._$_tags$_ = [ "" ], 
                    this._$_stringTags$_ = "", this._$_tagsChanged$_ = !1, this._$_renderChange$_ = 0, 
                    this._$_hasNestedContent$_ = 0, this._$_iTimelineState$_ = null;
                }
                static _$CreateInitial$_(t, e) {
                    const s = e._$GetTimelineDataManager$_(), i = s._$GetNameId$_(), r = s._$Get$_(t[i]), n = C33._$New$_(C33._$TimelineState$_, t[i], r, e);
                    return n._$SetIsTemplate$_(!0), n;
                }
                static _$CreateFromTemplate$_(t, e, s) {
                    return C33._$New$_(C33._$TimelineState$_, t, e, s);
                }
                _$Release$_() {
                    if (!this._$IsReleased$_()) {
                        const t = this._$_runtime$_._$Dispatcher$_();
                        this._$_timelineManager$_._$DeScheduleTimeline$_(this), 
                        this._$_timelineManager$_._$CompleteTimelineAndResolve$_(this);
                        for (const e of this._$_tracks$_) e._$Release$_();
                        C33._$clearArray$_(this._$_tracks$_), this._$_tracks$_ = null, 
                        this._$_runtime$_ = null, this._$_timelineManager$_ = null, 
                        this._$_timelineDataItem$_ = null, this._$_released$_ = !0, 
                        this._$_playPromise$_ = null, this._$_playResolve$_ = null, 
                        this._$FireReleaseEvent$_(t);
                    }
                }
                _$FireReleaseEvent$_(t) {
                    const e = C33._$New$_(C33.Event, "timelinestatereleased");
                    e._$timelineState$_ = this, t.dispatchEvent(e);
                }
                _$GetType$_() {
                    return 0;
                }
                _$CreateTrackStates$_() {
                    for (const t of this._$_timelineDataItem$_._$GetTrackData$_()._$trackDataItems$_()) this._$_tracksLength$_ = this._$_tracks$_.push(C33._$TrackState$_._$Create$_(this, t));
                }
                _$GetTimelineManager$_() {
                    return this._$_timelineManager$_;
                }
                _$GetRuntime$_() {
                    return this._$_runtime$_;
                }
                _$GetTracks$_() {
                    return this._$_tracks$_;
                }
                _$GetSimilarPropertyTracks$_(i, r, n, h) {
                    if (this._$_hasNestedContent$_) {
                        let s;
                        for (let e = 0; e < this._$_tracks$_.length; e++) {
                            let t = this._$_tracks$_[e];
                            if (i === t._$GetInstance$_()) {
                                const o = t._$GetPropertyTrack$_(n);
                                o && r.constructor === o._$GetSourceAdapter$_().constructor && o._$GetResultMode$_() === h._$GetResultMode$_() && (s = s || []).push(o);
                            }
                        }
                        return s;
                    }
                }
                _$HasTracks$_() {
                    return !!this._$_tracks$_.length;
                }
                _$GetTrackById$_(t) {
                    for (const e of this._$_tracks$_) if (C33._$equalsNoCase$_(e._$GetId$_(), t)) return e;
                    return null;
                }
                _$GetTrackByName$_(t) {
                    for (const e of this._$_tracks$_) if (!e._$IsInstanceTrack$_() && C33._$equalsNoCase$_(e._$GetName$_(), t)) return e;
                    return null;
                }
                _$SetName$_(t) {
                    this._$_name$_ = t;
                }
                _$GetName$_() {
                    return this._$_name$_;
                }
                _$GetTimelineDataItem$_() {
                    return this._$_timelineDataItem$_;
                }
                _$GetTemplateName$_() {
                    return this._$_timelineDataItem$_._$GetName$_();
                }
                _$GetTotalTime$_() {
                    return this._$_timelineDataItem$_._$GetTotalTime$_();
                }
                _$SetTotalTime$_(t) {
                    this._$_timelineDataItem$_._$SetTotalTime$_(t);
                }
                _$GetStep$_() {
                    return this._$_timelineDataItem$_._$GetStep$_();
                }
                _$SetStep$_(t) {
                    this._$_timelineDataItem$_._$SetStep$_(t);
                }
                _$GetInterpolationMode$_() {
                    return this._$_timelineDataItem$_._$GetInterpolationMode$_();
                }
                _$SetInterpolationMode$_(t) {
                    this._$_timelineDataItem$_._$SetInterpolationMode$_(t);
                }
                _$GetResultMode$_() {
                    return this._$_timelineDataItem$_._$GetResultMode$_();
                }
                _$SetResultMode$_(t) {
                    this._$_timelineDataItem$_._$GetResultMode$_(t);
                }
                _$SetEase$_(t) {
                    for (const e of this._$GetTracks$_()) e._$SetEase$_(t);
                }
                _$GetLoop$_() {
                    return this._$_timelineDataItem$_._$GetLoop$_();
                }
                _$SetLoop$_(t) {
                    return this._$_timelineDataItem$_._$SetLoop$_(t);
                }
                _$GetPingPong$_() {
                    return this._$_timelineDataItem$_._$GetPingPong$_();
                }
                _$SetPingPong$_(t) {
                    return this._$_timelineDataItem$_._$SetPingPong$_(t);
                }
                _$GetRepeatCount$_() {
                    return this._$_timelineDataItem$_._$GetRepeatCount$_();
                }
                _$SetRepeatCount$_(t) {
                    return this._$_timelineDataItem$_._$SetRepeatCount$_(t);
                }
                _$SetPlaybackRate$_(t) {
                    return this._$_playbackRate$_ = t;
                }
                _$GetPlaybackRate$_() {
                    return this._$_playbackRate$_;
                }
                _$GetStartOnLayout$_() {
                    return this._$_timelineDataItem$_._$GetStartOnLayout$_();
                }
                _$GetTransformWithSceneGraph$_() {
                    return this._$_timelineDataItem$_._$GetTransformWithSceneGraph$_();
                }
                _$GetUseSystemTimescale$_() {
                    return this._$_timelineDataItem$_._$GetUseSystemTimescale$_();
                }
                _$GetPingPongState$_() {
                    return this._$_pingPongState$_;
                }
                _$IsForwardPlayBack$_() {
                    return !this.IsPlaying() || 0 < this._$_playbackRate$_;
                }
                _$GetPlayPromise$_() {
                    return this._$_playPromise$_ || (this._$_playPromise$_ = new Promise(t => {
                        this._$_playResolve$_ = t;
                    })), this._$_playPromise$_;
                }
                _$ResolvePlayPromise$_() {
                    this._$_playPromise$_ && (this._$_playResolve$_(), this._$_playPromise$_ = null, 
                    this._$_playResolve$_ = null);
                }
                _$SetTags$_(t) {
                    this._$_tags$_ = C33._$TimelineState$_._$_GetTagArray$_(t), 
                    this._$_tagsChanged$_ = !0;
                }
                _$GetTags$_() {
                    return this._$_tags$_;
                }
                _$GetStringTags$_() {
                    return this._$_tagsChanged$_ && (this._$_stringTags$_ = this._$_tags$_.join(" ")), 
                    this._$_tagsChanged$_ = !1, this._$_stringTags$_;
                }
                _$HasTags$_(t) {
                    if (!this._$_tags$_) return !1;
                    if (!this._$_tags$_.length) return !1;
                    const e = C33._$TimelineState$_._$_GetTagArray$_(t);
                    return !!e && !!e.length && e.every(C33._$TimelineState$_._$_HasTag$_, this);
                }
                _$OnStarted$_() {
                    C33._$Plugins$_._$Timeline$_ && this.constructor === C33._$TimelineState$_ && (C33._$Plugins$_._$Timeline$_._$Cnds$_._$PushTriggerTimeline$_(this), 
                    this._$_timelineManager$_._$Trigger$_(C33._$Plugins$_._$Timeline$_._$Cnds$_._$OnTimelineStarted$_), 
                    this._$_timelineManager$_._$Trigger$_(C33._$Plugins$_._$Timeline$_._$Cnds$_._$OnTimelineStartedByName$_), 
                    this._$_timelineManager$_._$Trigger$_(C33._$Plugins$_._$Timeline$_._$Cnds$_._$OnTimelineStartedByTags$_), 
                    this._$_timelineManager$_._$Trigger$_(C33._$Plugins$_._$Timeline$_._$Cnds$_._$OnAnyTimelineStarted$_), 
                    C33._$Plugins$_._$Timeline$_._$Cnds$_._$PopTriggerTimeline$_());
                }
                _$OnCompleted$_() {
                    this._$_completedTick$_ = this._$_runtime$_._$GetTickCount$_();
                }
                _$FinishTriggers$_() {
                    this._$_finishedTriggers$_ || (this._$_finishedTriggers$_ = !0, 
                    C33._$Plugins$_._$Timeline$_ && this.constructor === C33._$TimelineState$_ && (C33._$Plugins$_._$Timeline$_._$Cnds$_._$PushTriggerTimeline$_(this), 
                    this._$_timelineManager$_._$Trigger$_(C33._$Plugins$_._$Timeline$_._$Cnds$_._$OnTimelineFinished$_), 
                    this._$_timelineManager$_._$Trigger$_(C33._$Plugins$_._$Timeline$_._$Cnds$_._$OnTimelineFinishedByName$_), 
                    this._$_timelineManager$_._$Trigger$_(C33._$Plugins$_._$Timeline$_._$Cnds$_._$OnTimelineFinishedByTags$_), 
                    this._$_timelineManager$_._$Trigger$_(C33._$Plugins$_._$Timeline$_._$Cnds$_._$OnAnyTimelineFinished$_), 
                    C33._$Plugins$_._$Timeline$_._$Cnds$_._$PopTriggerTimeline$_()));
                }
                _$SetPlaying$_(t) {
                    this._$_isPlaying$_ = t;
                }
                _$IsCompletedTick$_() {
                    return this._$_completedTick$_ === this._$_runtime$_._$GetTickCount$_();
                }
                IsPlaying(t = !1) {
                    return !!this._$IsCompletedTick$_() || !(!this._$IsScheduled$_() || t) || this._$_isPlaying$_;
                }
                _$_IsPlaying$_() {
                    return this.IsPlaying(!0);
                }
                _$IsPaused$_() {
                    return this._$_IsPaused$_();
                }
                _$_IsPaused$_() {
                    return !(this._$IsReleased$_() || this._$IsScheduled$_() || this._$_IsPlaying$_() || this._$IsComplete$_());
                }
                _$SetScheduled$_(t) {
                    this._$_isScheduled$_ = t;
                }
                _$IsScheduled$_() {
                    return this._$_isScheduled$_;
                }
                _$SetComplete$_(t) {
                    this._$_complete$_ = t;
                    const e = this._$GetTime$_();
                    (e <= 0 || e >= this._$GetTotalTime$_()) && (this._$_complete$_ = !0);
                }
                _$IsComplete$_() {
                    return this._$_complete$_;
                }
                _$IsReleased$_() {
                    return this._$_released$_;
                }
                _$SetMarkedForRemoval$_(t) {
                    this._$_markedForRemoval$_ = t;
                }
                _$IsMarkedForRemoval$_() {
                    return this._$_markedForRemoval$_;
                }
                _$SetImplicitPause$_(t) {
                    this._$_implicitPause$_ = t;
                }
                _$IsImplicitPause$_() {
                    return this._$_implicitPause$_;
                }
                _$SetIsTemplate$_(t) {
                    this._$_isTemplate$_ = !!t;
                }
                _$IsTemplate$_() {
                    return this._$_isTemplate$_;
                }
                _$InitialStateSet$_() {
                    return this._$_initialStateSet$_;
                }
                _$GetTime$_() {
                    return this._$_playheadTime$_;
                }
                _$SetTime$_(t) {
                    const e = this._$GetTime$_();
                    this._$_SetTime$_(t), this._$SetComplete$_(!1), this._$IsComplete$_() || this._$SetImplicitPause$_(!0), 
                    !this._$_IsPlaying$_() && !this._$IsScheduled$_() && this._$_initialStateSet$_ || (this._$_IsPlaying$_() || this._$IsScheduled$_() || this._$_initialStateSet$_ ? this._$_IsPlaying$_() ? this._$Stop$_() : this._$IsScheduled$_() && (this._$_timelineManager$_._$DeScheduleTimeline$_(this), 
                    this._$SetInitialStateFromSetTime$_()) : this._$SetInitialStateFromSetTime$_()), 
                    this._$_SetUpdateStateBefore$_(), this._$_Interpolate$_(this._$GetTime$_(), !1, !0, !0, e), 
                    this._$_SetUpdateStateAfter$_(), this._$_renderChange$_ && this._$GetRuntime$_()._$UpdateRender$_(), 
                    this._$_OnSetTime$_();
                }
                _$_SetTime$_(t) {
                    (t = C33._$IsFiniteNumber$_(t) ? t : this._$GetTotalTime$_()) < 0 ? this._$_playheadTime$_ = 0 : t >= this._$GetTotalTime$_() ? this._$_playheadTime$_ = this._$GetTotalTime$_() : this._$_playheadTime$_ = t;
                }
                _$_SetTimeAndReset$_(t) {
                    (t = C33._$IsFiniteNumber$_(t) ? t : this._$GetTotalTime$_()) < 0 ? this._$_playheadTime$_ = 0 : t >= this._$GetTotalTime$_() ? this._$_playheadTime$_ = this._$GetTotalTime$_() : this._$_playheadTime$_ = t;
                    for (const e of this._$_tracks$_) e._$SetResetState$_();
                }
                _$_OnSetTime$_() {
                    C33._$Plugins$_._$Timeline$_ && this.constructor === C33._$TimelineState$_ && (C33._$Plugins$_._$Timeline$_._$Cnds$_._$PushTriggerTimeline$_(this), 
                    this._$_timelineManager$_._$Trigger$_(C33._$Plugins$_._$Timeline$_._$Cnds$_._$OnTimeSet$_), 
                    this._$_timelineManager$_._$Trigger$_(C33._$Plugins$_._$Timeline$_._$Cnds$_._$OnTimeSetByName$_), 
                    this._$_timelineManager$_._$Trigger$_(C33._$Plugins$_._$Timeline$_._$Cnds$_._$OnTimeSetByTags$_), 
                    C33._$Plugins$_._$Timeline$_._$Cnds$_._$PopTriggerTimeline$_());
                }
                _$_CanResume$_() {
                    if (!this._$GetLoop$_()) if (this._$GetPingPong$_() && this._$_pingPongState$_ === PING_PONG_END) {
                        if (this._$IsForwardPlayBack$_()) {
                            if (this._$GetTime$_() >= this._$GetTotalTime$_()) return !1;
                        } else if (this._$GetTime$_() <= 0) return !1;
                    } else if (!this._$GetLoop$_() && !this._$GetPingPong$_()) if (this._$IsForwardPlayBack$_()) {
                        if (this._$GetTime$_() >= this._$GetTotalTime$_()) return !1;
                    } else if (this._$GetTime$_() <= 0) return !1;
                    return !0;
                }
                _$Resume$_() {
                    this._$IsReleased$_() || this._$_CanResume$_() && this.Play(!0);
                }
                Play(t = !1) {
                    return !this._$IsReleased$_() && !this._$IsScheduled$_() && (this._$_IsPlaying$_() && this._$IsCompletedTick$_() ? this._$_SchedulePlayingTimeline$_() : !this._$_IsPlaying$_() && !!(this._$IsComplete$_() || t || this._$IsImplicitPause$_()) && this._$_ScheduleStoppedTimeline$_());
                }
                _$_SchedulePlayingTimeline$_() {
                    return this._$SetImplicitPause$_(!1), this._$_timelineManager$_._$RemovePlayingTimeline$_(this), 
                    this._$_timelineManager$_._$ScheduleTimeline$_(this), this._$GetPlayPromise$_(), 
                    !0;
                }
                _$_ScheduleStoppedTimeline$_() {
                    return this._$SetImplicitPause$_(!1), this._$_timelineManager$_._$ScheduleTimeline$_(this), 
                    this._$GetPlayPromise$_(), !0;
                }
                _$Stop$_(t = !1) {
                    this._$IsReleased$_() || (this._$SetComplete$_(t), this._$_timelineManager$_._$CompleteTimeline$_(this), 
                    this._$IsComplete$_() && this._$ResolvePlayPromise$_());
                }
                _$Reset$_(t = !0, e = !1) {
                    if (!this._$IsReleased$_()) {
                        if (!this._$_IsPlaying$_() && this._$IsScheduled$_()) return this._$_timelineManager$_._$DeScheduleTimeline$_(this);
                        if (!this._$IsComplete$_()) {
                            this._$Stop$_(!0), this._$IsForwardPlayBack$_() ? this._$_SetTime$_(0) : this._$_SetTime$_(this._$GetTotalTime$_());
                            const s = this._$GetTime$_();
                            this._$_SetUpdateStateBefore$_(), e ? this._$_InterpolateBeforeChangeLayout$_(s) : this._$_Interpolate$_(s, !1, !1, !0), 
                            t && this._$_OnSetTime$_(), this._$_SetUpdateStateAfter$_(), 
                            this._$_renderChange$_ && t && this._$GetRuntime$_()._$UpdateRender$_();
                        }
                    }
                }
                _$ResetBeforeChangeLayout$_() {
                    this._$Reset$_(!1, !0);
                }
                _$_InterpolateBeforeChangeLayout$_(t) {
                    this._$_Interpolate$_(t, !1, !1, !0, NaN, !1, !0);
                }
                _$_OnBeforeChangeLayout$_() {
                    if (!this._$IsReleased$_()) {
                        if (!this._$GetRuntime$_()._$IsLoadingState$_() && this._$HasValidGlobalTracks$_()) return !1;
                        this._$_timelineManager$_._$CompleteTimelineBeforeChangeOfLayout$_(this), 
                        this._$GetRuntime$_()._$IsLoadingState$_() || this._$ResetBeforeChangeLayout$_();
                    }
                    return !0;
                }
                _$SetInitialStateFromSetTime$_() {
                    this._$SetInitialState$_(!0);
                }
                _$SetInitialStateForce$_() {
                    this._$SetInitialState$_(!1, !0), this._$SetPlaying$_(!1), this._$SetScheduled$_(!1);
                }
                _$SetInitialState$_(t = !1, e = !1) {
                    if (!this._$IsMarkedForRemoval$_() || e) {
                        if (t) {
                            this._$_finishedTriggers$_ = !1, this._$_initialStateSet$_ = !0, 
                            this._$_firstTick$_ = !0, this._$_SetUpdateStateBefore$_();
                            for (const s of this._$_tracks$_) s._$SetInitialState$_();
                        } else if (this._$SetPlaying$_(!0), this._$SetScheduled$_(!1), 
                        this._$OnStarted$_(), this._$IsComplete$_()) {
                            this._$_completedTick$_ = -1, this._$_pingPongState$_ !== PING_PONG_BEGIN && (this._$_playbackRate$_ = Math.abs(this._$_playbackRate$_)), 
                            this._$_pingPongState$_ = PING_PONG_BEGIN, this._$_currentRepeatCount$_ = 1, 
                            this._$_complete$_ = !1, this._$_finishedTriggers$_ = !1, 
                            this._$_initialStateSet$_ = !0, this._$_firstTick$_ = !0, 
                            this._$IsForwardPlayBack$_() ? this._$_SetTime$_(0) : this._$_SetTime$_(this._$GetTotalTime$_()), 
                            this._$_SetUpdateStateBefore$_();
                            for (const i of this._$_tracks$_) i._$SetInitialState$_();
                        } else {
                            this._$_firstTick$_ = !0, this._$_finishedTriggers$_ = !1, 
                            this._$_SetUpdateStateBefore$_();
                            for (const r of this._$_tracks$_) r._$SetResumeState$_();
                        }
                        this._$_SetUpdateStateAfter$_();
                    }
                }
                _$GetRenderChange$_() {
                    return this._$_renderChange$_;
                }
                _$_SetUpdateStateBefore$_() {
                    this._$_hasNestedContent$_ = 0;
                    for (const t of this._$_tracks$_) t._$IsNested$_() && (this._$_hasNestedContent$_ = 1);
                }
                _$_SetUpdateStateAfter$_() {
                    this._$_renderChange$_ = 0;
                    for (const t of this._$_tracks$_) t._$_SetUpdateState$_(), 0 === this._$_renderChange$_ && 1 === t._$GetRenderChange$_() && (this._$_renderChange$_ = 1), 
                    this._$_beforeAndAfterTracks$_ || 1 !== t._$GetNeedsBeforeAndAfter$_() || (this._$_beforeAndAfterTracks$_ || (this._$_beforeAndAfterTracks$_ = []), 
                    this._$_beforeAndAfterTracksLength$_ = this._$_beforeAndAfterTracks$_.push(t));
                }
                _$Tick$_(t, e, s) {
                    if (this._$GetUseSystemTimescale$_()) {
                        if (0 === t && 0 === this._$_lastDelta$_) return;
                        this._$_lastDelta$_ = t, t = s;
                    } else {
                        if (0 === s && 0 === this._$_lastDelta$_) return;
                        t = this._$_lastDelta$_ = s, e = 1;
                    }
                    const i = this._$_playheadTime$_ + this._$_overshoot$_, r = t * e * this._$_playbackRate$_, n = i + r, h = this._$_timelineDataItem$_._$_totalTime$_;
                    n < 0 ? (this._$_playheadTime$_ = 0, this._$_overshoot$_ = -n) : h <= n ? (this._$_playheadTime$_ = h, 
                    this._$_overshoot$_ = this._$_playheadTime$_ - n) : (this._$_playheadTime$_ = n, 
                    this._$_overshoot$_ = 0);
                    let o = !1, a = !1, l = this._$GetLoop$_(), u = this._$GetPingPong$_();
                    l || u ? l && !u ? 0 < this._$_playbackRate$_ ? this._$_playheadTime$_ >= h && (this._$_SetTimeAndReset$_(0), 
                    a = !0) : this._$_playheadTime$_ <= 0 && (this._$_SetTimeAndReset$_(h), 
                    a = !0) : !l && u ? 0 < this._$_playbackRate$_ ? this._$_playheadTime$_ >= h && (this._$_SetTime$_(h), 
                    this._$SetPlaybackRate$_(-1 * this._$GetPlaybackRate$_()), a = !0, 
                    this._$_pingPongState$_ === PING_PONG_END ? this._$_currentRepeatCount$_ < this._$GetRepeatCount$_() ? (this._$_currentRepeatCount$_++, 
                    this._$_pingPongState$_ = PING_PONG_BEGIN) : o = !0 : this._$_pingPongState$_ === PING_PONG_BEGIN && (this._$_pingPongState$_ = PING_PONG_END)) : this._$_playheadTime$_ <= 0 && (this._$_SetTime$_(0), 
                    this._$SetPlaybackRate$_(-1 * this._$GetPlaybackRate$_()), a = !0, 
                    this._$_pingPongState$_ === PING_PONG_END ? this._$_currentRepeatCount$_ < this._$GetRepeatCount$_() ? (this._$_currentRepeatCount$_++, 
                    this._$_pingPongState$_ = PING_PONG_BEGIN) : o = !0 : this._$_pingPongState$_ === PING_PONG_BEGIN && (this._$_pingPongState$_ = PING_PONG_END)) : l && u && (0 < this._$_playbackRate$_ ? this._$_playheadTime$_ >= h && (this._$_SetTime$_(h), 
                    this._$SetPlaybackRate$_(-1 * this._$GetPlaybackRate$_()), a = !0, 
                    this._$_pingPongState$_++, C33.wrap(this._$_pingPongState$_, 0, 2)) : this._$_playheadTime$_ <= 0 && (this._$_SetTime$_(0), 
                    this._$SetPlaybackRate$_(-1 * this._$GetPlaybackRate$_()), a = !0, 
                    this._$_pingPongState$_++, C33.wrap(this._$_pingPongState$_, 0, 2))) : 0 < this._$_playbackRate$_ ? this._$_playheadTime$_ >= h && (this._$_currentRepeatCount$_ < this._$GetRepeatCount$_() ? (this._$_currentRepeatCount$_++, 
                    this._$_SetTimeAndReset$_(0), a = !0) : (this._$_SetTime$_(h), 
                    o = !0)) : this._$_playheadTime$_ <= 0 && (this._$_currentRepeatCount$_ < this._$GetRepeatCount$_() ? (this._$_currentRepeatCount$_++, 
                    this._$_SetTimeAndReset$_(h), a = !0) : (this._$_SetTime$_(0), 
                    o = !0));
                    let c, f = this._$_tracksLength$_;
                    if (o) {
                        for (c = 0; c < f; c++) this._$_tracks$_[c]._$SetEndState$_();
                        this._$Stop$_(!0), this._$OnCompleted$_();
                    } else {
                        const d = this._$_beforeAndAfterTracksLength$_;
                        for (c = 0; c < d; c++) this._$_beforeAndAfterTracks$_[c]._$BeforeInterpolate$_();
                        if (1 === this._$_hasNestedContent$_) for (c = 0; c < f; c++) {
                            const p = this._$_tracks$_[c], m = p._$GetStartOffset$_(), C = this._$_playheadTime$_ - m, g = i - m;
                            C < 0 && 0 < g ? (this._$_playheadTime$_ = m < 0 ? 0 : h <= m ? h : m, 
                            p._$Interpolate$_(m, !0, !1, a, this._$_firstTick$_, !1)) : p._$Interpolate$_(this._$_playheadTime$_, !0, !1, a, this._$_firstTick$_, !1);
                        } else for (c = 0; c < f; c++) this._$_tracks$_[c]._$Interpolate$_(this._$_playheadTime$_, !0, !1, a, this._$_firstTick$_, !1);
                        for (c = 0; c < d; c++) this._$_beforeAndAfterTracks$_[c]._$AfterInterpolate$_();
                        this._$_firstTick$_ && (this._$_firstTick$_ = !1);
                    }
                }
                _$_Interpolate$_(e, s = !1, i = !1, r = !1, n = NaN, t = !1, h = !1) {
                    for (const o of this._$_tracks$_) o._$BeforeInterpolate$_();
                    for (const a of this._$_tracks$_) {
                        let t = e;
                        if ("number" == typeof n && !isNaN(n)) {
                            const l = this._$GetTime$_(), u = l - a._$GetStartOffset$_(), c = n - a._$GetStartOffset$_();
                            u < 0 && 0 < c && (t = a._$GetStartOffset$_(), this._$_SetTime$_(t));
                        }
                        a._$Interpolate$_(t, s, i, r, this._$_firstTick$_, h);
                    }
                    for (const f of this._$_tracks$_) f._$AfterInterpolate$_();
                    this._$_firstTick$_ && t && (this._$_firstTick$_ = !1);
                }
                _$AddTrack$_() {
                    const t = this._$_timelineDataItem$_._$GetTrackData$_()._$AddEmptyTrackDataItem$_(), e = C33._$TrackState$_._$Create$_(this, t);
                    return this._$_tracksLength$_ = this._$_tracks$_.push(e), e;
                }
                _$Removed$_() {
                    if (!this._$IsReleased$_()) for (const t of this._$_tracks$_) t._$TimelineRemoved$_();
                }
                _$CleanCaches$_() {
                    for (const t of this._$_tracks$_) t._$CleanCaches$_();
                }
                _$ClearTrackInstances$_() {
                    for (const t of this._$_tracks$_) t._$ClearInstance$_();
                }
                _$SetTrackInstance$_(t, e, s) {
                    if (e) {
                        if ("number" == typeof s && 0 <= s) {
                            const i = this._$_tracks$_[s];
                            return i ? (i._$SetInstance$_(e), void this._$_timelineManager$_._$SetTimelineObjectClassToMap$_(e._$GetObjectClass$_(), this)) : void 0;
                        }
                        for (const r of this._$_tracks$_) if (r._$IsInstanceTrack$_()) if (t) {
                            if (r._$GetId$_() === t) {
                                r._$SetInstance$_(e), this._$_timelineManager$_._$SetTimelineObjectClassToMap$_(e._$GetObjectClass$_(), this);
                                break;
                            }
                        } else if (!r._$HasInstance$_()) {
                            r._$SetInstance$_(e), this._$_timelineManager$_._$SetTimelineObjectClassToMap$_(e._$GetObjectClass$_(), this);
                            break;
                        }
                    }
                }
                _$HasTrackInstance$_(t, e) {
                    for (const s of this._$_tracks$_) if (s._$IsInstanceTrack$_()) if (e) {
                        if (e === s._$GetId$_() && t === s._$GetInstance$_()) return !0;
                    } else if (t === s._$GetInstance$_()) return !0;
                    return !1;
                }
                _$HasValidTracks$_() {
                    return this._$_tracks$_.some(t => !t._$IsInstanceTrack$_() || t._$CanInstanceBeValid$_());
                }
                _$HasValidGlobalTracks$_() {
                    return this._$_tracks$_.some(t => {
                        if (t._$IsInstanceTrack$_()) {
                            if (!t._$CanInstanceBeValid$_()) return !1;
                            const e = t._$GetObjectClass$_();
                            return !!e && e._$IsGlobal$_();
                        }
                        return !1;
                    });
                }
                _$GetPropertyTrack$_(t) {
                    for (const e of this._$GetTracks$_()) for (const s of e._$GetPropertyTracks$_()) if (s._$GetPropertyName$_() === t) return s;
                }
                _$GetTrackFromInstance$_(t) {
                    for (const e of this._$_tracks$_) if (t === e._$GetInstance$_()) return e;
                    return null;
                }
                _$GetKeyframeWithTags$_(t) {
                    let e = t ? t.split(" ") : [], s = new Set(e.map(t => t.toLowerCase().trim()));
                    e = [ ...s.values() ];
                    for (const i of this._$GetTracks$_()) for (const r of i._$GetKeyframeDataItems$_()) {
                        const n = e.every(t => r._$HasTag$_(t));
                        if (n) return r;
                    }
                }
                _$GetObjectClasses$_() {
                    const t = [];
                    for (const e of this._$GetTracks$_()) t.push(e._$GetObjectClass$_());
                    return t.filter(t => t);
                }
                _$_OnAfterLoad$_() {
                    for (const t of this._$GetTracks$_()) t._$_OnAfterLoad$_();
                }
                _$_SaveToJson$_() {
                    return {
                        tracksJson: this._$_SaveTracksToJson$_(),
                        name: this._$_name$_,
                        playheadTime: this._$GetTime$_(),
                        playbackRate: this._$_playbackRate$_,
                        pingPongState: this._$_pingPongState$_,
                        currentRepeatCount: this._$_currentRepeatCount$_,
                        isPlaying: this._$_isPlaying$_,
                        isScheduled: this._$_isScheduled$_,
                        initialStateSet: this._$_initialStateSet$_,
                        finishedTriggers: this._$_finishedTriggers$_,
                        complete: this._$_complete$_,
                        released: this._$_released$_,
                        markedForRemoval: this._$_markedForRemoval$_,
                        completedTick: this._$_completedTick$_,
                        implicitPause: this._$_implicitPause$_,
                        isTemplate: this._$_isTemplate$_,
                        tags: this._$_tags$_.join(" "),
                        stringTags: this._$_stringTags$_,
                        tagsChanged: this._$_tagsChanged$_,
                        firstTick: this._$_firstTick$_
                    };
                }
                _$_LoadFromJson$_(t) {
                    t && (this._$_LoadTracksFromJson$_(t.tracksJson), this._$_name$_ = t.name, 
                    this._$_playheadTime$_ = t.playheadTime, this._$_playbackRate$_ = t.playbackRate, 
                    this._$_pingPongState$_ = t.pingPongState, this._$_currentRepeatCount$_ = t.currentRepeatCount, 
                    this._$_isPlaying$_ = !!t.isPlaying, this._$_isScheduled$_ = !!t.isScheduled, 
                    this._$_initialStateSet$_ = !!t.initialStateSet, this._$_finishedTriggers$_ = !!t.hasOwnProperty("finishedTriggers") && !!t.finishedTriggers, 
                    this._$_complete$_ = !!t.complete, this._$_released$_ = !!t.released, 
                    this._$_markedForRemoval$_ = !!t.markedForRemoval, this._$_completedTick$_ = t.completedTick, 
                    this._$_implicitPause$_ = !!t.implicitPause, this._$_isTemplate$_ = !!t.isTemplate, 
                    this._$_tags$_ = t.tags.split(" "), this._$_stringTags$_ = t.stringTags, 
                    this._$_tagsChanged$_ = !!t.tagsChanged, this._$_firstTick$_ = !!t.firstTick);
                }
                _$_SaveTracksToJson$_() {
                    return this._$_tracks$_.map(t => t._$_SaveToJson$_());
                }
                _$_LoadTracksFromJson$_(t) {
                    this._$ClearTrackInstances$_(), t.forEach((t, e) => {
                        const s = this._$_tracks$_[e];
                        s._$_LoadFromJson$_(t);
                    }), this._$_tracks$_.filter(t => t._$CanInstanceBeValid$_());
                }
                static _$_HasTag$_(t) {
                    const e = this._$GetTags$_();
                    return "" === t ? 1 === e.length && "" === e[0] : e.map(t => t.toLowerCase()).includes(t.toLowerCase());
                }
                static _$_GetTagArray$_(t) {
                    if (C33._$IsArray$_(t)) return t.slice(0);
                    if (C33._$IsString$_(t)) return t.split(" ");
                    throw new Error("invalid tags");
                }
                _$GetITimelineState$_() {
                    return this._$_iTimelineState$_ || (this._$_iTimelineState$_ = C33._$New$_(self._$ITimelineState$_, this)), 
                    this._$_iTimelineState$_;
                }
            };
        }
        {
            const C33 = self._$C3$_, INSTANCE_TRACK = 0, VALUE_TRACK = 1, AUDIO_TRACK = 2;
            C33._$TrackState$_ = class extends C33._$DefendedBase$_ {
                constructor(t, e) {
                    super(), this._$_timeline$_ = t, this._$_trackDataItem$_ = e, 
                    this._$_trackData$_ = e._$GetTrackData$_(), this._$_instanceUid$_ = NaN, 
                    this._$_objectClassIndex$_ = NaN, this._$_instance$_ = null, 
                    this._$_worldInfo$_ = null, this._$_cleared$_ = !1, this._$_isNested$_ = 0 < e._$GetStartOffset$_(), 
                    this._$_initialStateOfNestedSet$_ = !1, this._$_endStateOfNestedSet$_ = !1, 
                    this._$_instanceUidToLoad$_ = NaN, this._$_lastKeyframeDataItem$_ = null, 
                    this._$_keyframeDataItems$_ = this._$_trackDataItem$_._$GetKeyframeData$_()._$GetKeyframeDataItemArray$_(), 
                    this._$_propertyTracks$_ = [], this._$CreatePropertyTrackStates$_(), 
                    this._$_worldInfoChange$_ = 0, this._$_renderChange$_ = 0, this._$_needsBeforeAndAfter$_ = 0;
                }
                static _$Create$_(t, e) {
                    return C33._$New$_(C33._$TrackState$_, t, e);
                }
                _$Release$_() {
                    this._$_keyframeDataItems$_ = null;
                    for (const t of this._$_propertyTracks$_) t._$Release$_();
                    C33._$clearArray$_(this._$_propertyTracks$_), this._$_propertyTracks$_ = null, 
                    this._$_timeline$_ = null, this._$_instance$_ = null, this._$_worldInfo$_ = null, 
                    this._$_trackDataItem$_ = null, this._$_lastKeyframeDataItem$_ = null;
                }
                _$CreatePropertyTrackStates$_() {
                    for (const t of this._$_trackDataItem$_._$GetPropertyTrackData$_()._$propertyTrackDataItems$_()) this._$_propertyTracks$_.push(C33._$PropertyTrackState$_._$Create$_(this, t));
                }
                _$TimelineRemoved$_() {
                    for (const t of this._$_propertyTracks$_) t._$TimelineRemoved$_();
                }
                _$CleanCaches$_() {
                    for (const t of this._$_propertyTracks$_) t._$CleanCaches$_();
                    this._$_instance$_ = null, this._$_worldInfo$_ = null;
                }
                _$GetTimeline$_() {
                    return this._$_timeline$_;
                }
                _$GetRuntime$_() {
                    return this._$_timeline$_._$GetRuntime$_();
                }
                _$GetKeyframeDataItems$_() {
                    return this._$_keyframeDataItems$_ || (this._$_keyframeDataItems$_ = this._$_trackDataItem$_._$GetKeyframeData$_()._$GetKeyframeDataItemArray$_()), 
                    this._$_keyframeDataItems$_;
                }
                _$GetPropertyTracks$_() {
                    return this._$_propertyTracks$_;
                }
                _$GetPropertyTrack$_(e) {
                    for (let t = 0; t < this._$_propertyTracks$_.length; t++) {
                        const s = this._$_propertyTracks$_[t];
                        if (s._$GetPropertyName$_() === e) return s;
                    }
                }
                _$MaybeGetInstance$_() {
                    this._$_instance$_ || this._$GetInstance$_();
                }
                _$IsInstanceValid$_() {
                    return !!this._$_instance$_ && !this._$_instance$_._$IsDestroyed$_();
                }
                _$CanInstanceBeValid$_() {
                    if (!this._$IsInstanceTrack$_()) return !1;
                    const t = this._$GetInstanceUID$_(), e = this._$GetRuntime$_()._$GetInstanceByUID$_(t);
                    return !!e && !e._$IsDestroyed$_();
                }
                _$GetObjectClass$_() {
                    if (this._$IsInstanceTrack$_()) {
                        const t = this._$GetObjectClassIndex$_();
                        if (-1 !== t) return this._$GetRuntime$_()._$GetObjectClassByIndex$_(t);
                    }
                }
                _$GetTrackIndexInTimeline$_() {
                    return this._$_timeline$_._$GetTracks$_().indexOf(this);
                }
                _$ClearInstance$_() {
                    this._$_instance$_ = null, this._$_instanceUid$_ = NaN, this._$_worldInfo$_ = null, 
                    this._$_objectClassIndex$_ = NaN, this._$_cleared$_ = !0;
                }
                _$HasInstance$_() {
                    return !!this._$_instance$_;
                }
                _$GetInstance$_() {
                    if (!this._$_cleared$_) {
                        if (!this._$_instance$_ || !this._$IsInstanceValid$_()) {
                            const t = this._$GetInstanceUID$_();
                            this._$_instance$_ = this._$GetRuntime$_()._$GetInstanceByUID$_(t);
                        }
                        return this._$_instance$_;
                    }
                }
                _$SetInstance$_(t) {
                    if (this._$_cleared$_ = !1, this._$_instance$_ !== t) {
                        this._$CleanCaches$_(), this._$_instance$_ = t, this._$_objectClassIndex$_ = t._$GetObjectClass$_()._$GetIndex$_(), 
                        this._$_instanceUid$_ = t._$GetUID$_(), this._$_worldInfo$_ = t._$GetWorldInfo$_();
                        for (const e of this._$propertyTrackItems$_()) {
                            const s = e._$propertyTrack$_, i = e._$sourceAdapter$_, r = s._$GetSourceAdapterId$_();
                            switch (r) {
                              case "instance-variable":
                                {
                                    i._$GetEditorIndex$_();
                                    const n = t._$GetObjectClass$_(), h = n._$GetInstanceVariableIndexByName$_(e.name), o = n._$GetInstanceVariableName$_(h), a = n._$GetInstanceVariableType$_(h);
                                    o === e.name && a === e.type && i._$UpdateInstanceVariableIndex$_(h);
                                    break;
                                }

                              case "behavior":
                                {
                                    const l = e._$behaviorType$_, u = this._$GetObjectClass$_(), c = t._$GetObjectClass$_(), f = i._$GetBehaviorType$_(c);
                                    if (l && f) {
                                        const d = l._$GetName$_();
                                        u._$GetBehaviorIndexByName$_(d), c._$GetBehaviorIndexByName$_(d), 
                                        i._$GetEditorIndex$_(), i._$UpdateBehaviorTypeSid$_(f._$GetSID$_());
                                    }
                                    break;
                                }
                            }
                        }
                    }
                }
                *_$propertyTrackItems$_() {
                    for (const t of this._$_propertyTracks$_) {
                        const e = t._$GetSourceAdapter$_(), s = this._$GetObjectClass$_(), i = {
                            _$propertyTrack$_: t,
                            _$sourceAdapter$_: e
                        };
                        switch (t._$GetSourceAdapterId$_()) {
                          case "world-instance":
                            i.property = t._$GetPropertyName$_();
                            break;

                          case "instance-variable":
                            {
                                const r = e._$GetEditorIndex$_();
                                i.name = s._$GetInstanceVariableName$_(r), i.type = s._$GetInstanceVariableType$_(r);
                                break;
                            }

                          case "effect":
                            {
                                const n = s._$GetEffectList$_(), h = e._$GetEffectType$_(n);
                                i._$effectType$_ = h;
                                break;
                            }

                          case "behavior":
                            {
                                const o = e._$GetBehaviorType$_(s);
                                i._$behaviorType$_ = o;
                                break;
                            }

                          case "plugin":
                            i._$plugin$_ = s._$GetPlugin$_();
                        }
                        yield i;
                    }
                }
                _$GetWorldInfo$_() {
                    if (!this._$_worldInfo$_ || !this._$IsInstanceValid$_()) {
                        const t = this._$GetInstance$_();
                        t && (this._$_worldInfo$_ = t._$GetWorldInfo$_());
                    }
                    return this._$_worldInfo$_;
                }
                _$GetTrackDataItem$_() {
                    return this._$_trackDataItem$_;
                }
                _$GetInstanceUID$_() {
                    return isNaN(this._$_instanceUid$_) ? this._$_trackDataItem$_._$GetInstanceUID$_() : this._$_instanceUid$_;
                }
                _$SetInstanceUID$_(t) {
                    this._$_trackDataItem$_._$SetInstanceUID$_(t);
                }
                _$GetInterpolationMode$_() {
                    return this._$_trackDataItem$_._$GetInterpolationMode$_();
                }
                _$SetInterpolationMode$_(t) {
                    this._$_trackDataItem$_._$SetInterpolationMode$_(t);
                }
                _$GetResultMode$_() {
                    return this._$_trackDataItem$_._$GetResultMode$_();
                }
                _$GetId$_() {
                    return this._$_trackDataItem$_._$GetId$_();
                }
                _$GetStartOffset$_() {
                    return this._$_trackDataItem$_._$GetStartOffset$_();
                }
                _$GetLocalTotalTime$_() {
                    return this._$_trackDataItem$_._$GetLocalTotalTime$_();
                }
                _$SetLocalTotalTime$_(t) {
                    this._$_trackDataItem$_._$SetLocalTotalTime$_(t);
                }
                _$SetResultMode$_(t) {
                    this._$_trackDataItem$_._$SetResultMode$_(t);
                }
                _$SetEase$_(t) {
                    for (const e of this._$GetKeyframeDataItems$_()) e._$SetEase$_(t);
                    for (const s of this._$GetPropertyTracks$_()) s._$SetEase$_(t);
                }
                _$GetEnable$_() {
                    return this._$_trackDataItem$_._$GetEnable$_();
                }
                _$SetEnable$_(t) {
                    this._$_trackDataItem$_._$SetEnable$_(t);
                }
                _$GetObjectClassIndex$_() {
                    return isNaN(this._$_objectClassIndex$_) ? this._$_trackDataItem$_._$GetObjectClassIndex$_() : this._$_objectClassIndex$_;
                }
                _$SetObjectClassIndex$_(t) {
                    this._$_trackDataItem$_._$SetObjectClassIndex$_(t);
                }
                _$SetOriginalWidth$_(t) {
                    this._$_trackDataItem$_._$SetOriginalWidth$_(t);
                }
                _$GetOriginalWidth$_() {
                    const t = this._$GetInstance$_();
                    if (t) {
                        const e = t._$GetSdkInstance$_();
                        if (e._$IsOriginalSizeKnown$_()) return t._$GetSdkInstance$_()._$GetOriginalWidth$_();
                    }
                    return this._$_trackDataItem$_._$GetOriginalWidth$_();
                }
                _$SetOriginalHeight$_(t) {
                    this._$_trackDataItem$_._$SetOriginalHeight$_(t);
                }
                _$GetOriginalHeight$_() {
                    const t = this._$GetInstance$_();
                    if (t) {
                        const e = t._$GetSdkInstance$_();
                        if (e._$IsOriginalSizeKnown$_()) return t._$GetSdkInstance$_()._$GetOriginalHeight$_();
                    }
                    return this._$_trackDataItem$_._$GetOriginalHeight$_();
                }
                _$GetType$_() {
                    return this._$_trackDataItem$_._$GetType$_();
                }
                _$GetName$_() {
                    return this._$_trackDataItem$_._$GetName$_();
                }
                _$IsInstanceTrack$_() {
                    return this._$GetType$_() === INSTANCE_TRACK;
                }
                _$IsValueTrack$_() {
                    return this._$GetType$_() === VALUE_TRACK;
                }
                _$IsAudioTrack$_() {
                    return this._$GetType$_() === AUDIO_TRACK;
                }
                _$GetWorldInfoChange$_() {
                    return this._$_worldInfoChange$_;
                }
                _$GetRenderChange$_() {
                    return this._$_renderChange$_;
                }
                _$GetNeedsBeforeAndAfter$_() {
                    return this._$_needsBeforeAndAfter$_;
                }
                _$IsNested$_() {
                    return this._$_isNested$_;
                }
                _$SetResetState$_() {
                    for (const t of this._$_propertyTracks$_) t._$SetResetState$_();
                }
                _$SetInitialState$_() {
                    if (this._$MaybeGetInstance$_(), this._$IsInstanceValid$_() || !this._$IsInstanceTrack$_()) {
                        const t = this._$GetTimeline$_(), e = t._$IsForwardPlayBack$_(), s = e ? 0 : this._$GetLocalTotalTime$_();
                        for (const r of this._$_propertyTracks$_) r._$SetInitialState$_(s), 
                        0 === this._$_worldInfoChange$_ && 1 === r._$GetWorldInfoChange$_() && (this._$_worldInfoChange$_ = 1), 
                        0 === this._$_renderChange$_ && 1 === r._$GetRenderChange$_() && (this._$_renderChange$_ = 1);
                        this._$_needsBeforeAndAfter$_ = 0;
                        const i = this._$_propertyTracks$_.some(t => t._$GetNeedsBeforeAndAfter$_());
                        i && (this._$_needsBeforeAndAfter$_ = 1), this._$_lastKeyframeDataItem$_ = this._$_GetLastKeyFrameBeforeTime$_(s), 
                        this._$_initialStateOfNestedSet$_ = !1, this._$_endStateOfNestedSet$_ = !1, 
                        this._$Interpolate$_(s), this._$OnKeyframeReached$_(this._$_GetLastKeyFrameBeforeTime$_(s));
                    }
                }
                _$SetResumeState$_() {
                    if (this._$MaybeGetInstance$_(), this._$IsInstanceValid$_() || !this._$IsInstanceTrack$_()) {
                        this._$_timeline$_._$IsForwardPlayBack$_();
                        const t = this._$_timeline$_._$GetTime$_() - this._$GetStartOffset$_();
                        this._$_lastKeyframeDataItem$_ = this._$_GetLastKeyFrameBeforeTime$_(t);
                        for (const e of this._$_propertyTracks$_) e._$SetResumeState$_(t);
                    }
                }
                _$SetEndState$_() {
                    if (!this._$GetTimeline$_()._$IsComplete$_() && (this._$MaybeGetInstance$_(), 
                    this._$IsInstanceValid$_() || !this._$IsInstanceTrack$_()) && !this._$_isNested$_) {
                        const t = this._$_timeline$_._$GetTime$_(), e = this._$GetStartOffset$_() + this._$GetLocalTotalTime$_();
                        e <= t ? this._$Interpolate$_(this._$GetLocalTotalTime$_(), !0, !1, !0, !1, !1, !0) : t <= 0 && this._$Interpolate$_(0, !0, !1, !0, !1, !1, !0);
                    }
                }
                _$_SetUpdateState$_() {
                    for (let t = 0, e = this._$_propertyTracks$_.length; t < e; t++) {
                        const s = this._$_propertyTracks$_[t];
                        s._$_SetUpdateState$_(), 0 === this._$_worldInfoChange$_ && 1 === s._$GetWorldInfoChange$_() && (this._$_worldInfoChange$_ = 1), 
                        0 === this._$_renderChange$_ && 1 === s._$GetRenderChange$_() && (this._$_renderChange$_ = 1);
                    }
                }
                _$BeforeInterpolate$_() {
                    const e = this._$_propertyTracks$_.length;
                    for (let t = 0; t < e; t++) this._$_propertyTracks$_[t]._$BeforeInterpolate$_();
                }
                _$Interpolate$_(s, t = !1, i = !1, r = !1, e = !1, n = !1, h = !1) {
                    this._$_instance$_ || this._$GetInstance$_();
                    const o = this._$_instance$_ && !this._$_instance$_._$IsDestroyed$_(), a = this._$_trackDataItem$_._$_type$_ === INSTANCE_TRACK;
                    if ((o || !a) && !(n && a && this._$GetObjectClass$_()._$IsGlobal$_() || (s -= this._$GetStartOffset$_()) < 0)) {
                        this._$MaybeSetInitialStateOfNestedTrack$_(s, t), this._$MaybeTriggerKeyframeReachedConditions$_(s, t, e);
                        for (let t = 0, e = this._$_propertyTracks$_.length; t < e; t++) this._$_propertyTracks$_[t]._$Interpolate$_(s, i, r, h);
                        this._$MaybeSetEndStateOfNestedTrack$_(s, t), 0 !== this._$_worldInfoChange$_ && (this._$_worldInfo$_ || (this._$_worldInfo$_ = this._$_instance$_._$GetWorldInfo$_()), 
                        this._$_worldInfo$_) && this._$_worldInfo$_._$SetBboxChanged$_();
                    }
                }
                _$AfterInterpolate$_() {
                    const e = this._$_propertyTracks$_.length;
                    for (let t = 0; t < e; t++) this._$_propertyTracks$_[t]._$AfterInterpolate$_();
                }
                _$MaybeSetInitialStateOfNestedTrack$_(t, e) {
                    if (e && this._$_isNested$_ && !this._$_initialStateOfNestedSet$_) {
                        const s = this._$GetTimeline$_();
                        if (s._$IsForwardPlayBack$_()) {
                            if (t < 0) return;
                        } else if (t > this._$GetLocalTotalTime$_()) return;
                        for (const i of this._$_propertyTracks$_) i._$SetInitialState$_();
                        this._$_initialStateOfNestedSet$_ = !0;
                    }
                }
                _$MaybeSetEndStateOfNestedTrack$_(t, e) {
                    if (e && this._$_isNested$_ && !this._$_endStateOfNestedSet$_) {
                        const s = this._$GetTimeline$_();
                        if (s._$IsForwardPlayBack$_()) {
                            if (t >= this._$GetLocalTotalTime$_()) {
                                for (const i of this._$_propertyTracks$_) i._$Interpolate$_(this._$GetLocalTotalTime$_(), !1, !0);
                                this._$_endStateOfNestedSet$_ = !0;
                            }
                        } else if (t <= 0) {
                            for (const r of this._$_propertyTracks$_) r._$Interpolate$_(0, !1, !0);
                            this._$_endStateOfNestedSet$_ = !0;
                        }
                    }
                }
                _$MaybeTriggerKeyframeReachedConditions$_(t, e, s) {
                    if (!s && e && C33._$Plugins$_._$Timeline$_) {
                        const i = this._$GetTimeline$_(), r = this._$_lastKeyframeDataItem$_._$GetNext$_(), n = this._$_lastKeyframeDataItem$_._$GetTime$_(), h = r ? r._$GetTime$_() : i._$GetTotalTime$_();
                        if (t <= n || h <= t) if (this._$_lastKeyframeDataItem$_ = this._$_trackData$_._$GetFirstKeyFrameDataItemLowerOrEqualThan$_(t, this._$_trackDataItem$_), 
                        i._$IsForwardPlayBack$_()) r && this._$OnKeyframeReached$_(this._$_lastKeyframeDataItem$_); else {
                            const o = this._$_lastKeyframeDataItem$_._$GetNext$_();
                            o && this._$OnKeyframeReached$_(o);
                        }
                    }
                }
                _$_GetLastKeyFrameBeforeTime$_(t) {
                    const e = this._$_trackData$_._$GetKeyFrameDataItemAtTime$_(t, this._$_trackDataItem$_);
                    return e || this._$_trackData$_._$GetFirstKeyFrameDataItemLowerOrEqualThan$_(t, this._$_trackDataItem$_);
                }
                _$OnKeyframeReached$_(t) {
                    if (C33._$Plugins$_._$Timeline$_) {
                        const e = this._$GetTimeline$_(), s = e._$GetTimelineManager$_();
                        C33._$Plugins$_._$Timeline$_._$Cnds$_._$PushTriggerTimeline$_(e), 
                        C33._$Plugins$_._$Timeline$_._$Cnds$_._$PushTriggerKeyframe$_(t), 
                        s._$Trigger$_(C33._$Plugins$_._$Timeline$_._$Cnds$_._$OnAnyKeyframeReached$_), 
                        s._$Trigger$_(C33._$Plugins$_._$Timeline$_._$Cnds$_._$OnKeyframeReached$_), 
                        C33._$Plugins$_._$Timeline$_._$Cnds$_._$PopTriggerTimeline$_(e), 
                        C33._$Plugins$_._$Timeline$_._$Cnds$_._$PopTriggerKeyframe$_(t);
                    }
                }
                _$AddKeyframe$_() {
                    const t = this._$_trackDataItem$_._$GetKeyframeData$_(), e = t._$AddEmptyKeyframeDataItem$_();
                    return e;
                }
                _$AddPropertyTrack$_() {
                    const t = this._$_trackDataItem$_._$GetPropertyTrackData$_(), e = t._$AddEmptyPropertyTrackDataItem$_(), s = C33._$PropertyTrackState$_._$Create$_(this, e);
                    return this._$_propertyTracks$_.push(s), s;
                }
                _$DeleteKeyframes$_(t) {
                    const e = this._$_trackDataItem$_._$GetKeyframeData$_();
                    e._$DeleteKeyframeDataItems$_(t);
                }
                _$DeletePropertyKeyframes$_(t) {
                    for (const e of this._$_propertyTracks$_) e._$DeletePropertyKeyframes$_(t);
                }
                _$SaveState$_() {
                    for (const t of this._$_propertyTracks$_) t._$SaveState$_();
                }
                _$CompareInitialStateWithCurrent$_() {
                    if (this._$MaybeGetInstance$_(), this._$IsInstanceValid$_() || !this._$IsInstanceTrack$_()) for (const t of this._$_propertyTracks$_) t._$CompareInitialStateWithCurrent$_();
                }
                _$CompareSaveStateWithCurrent$_() {
                    if (this._$MaybeGetInstance$_(), this._$IsInstanceValid$_() || !this._$IsInstanceTrack$_()) {
                        let t = !1;
                        for (const e of this._$_propertyTracks$_) {
                            const s = e._$CompareSaveStateWithCurrent$_();
                            !t && s && (t = !0);
                        }
                        if (t) {
                            const i = this._$AddKeyframe$_();
                            i._$SetTime$_(this._$GetTimeline$_()._$GetTime$_()), 
                            i._$SetEase$_("noease"), i._$SetEnable$_(!0), i._$SetTags$_("");
                        }
                    }
                }
                _$_OnAfterLoad$_() {
                    isNaN(this._$_instanceUidToLoad$_) || this._$_LoadInstanceFromJson$_(this._$_instanceUidToLoad$_), 
                    this._$_instanceUidToLoad$_ = NaN;
                }
                _$_SaveToJson$_() {
                    const t = this._$GetInstance$_(), e = t ? t._$GetUID$_() : this._$GetInstanceUID$_();
                    return {
                        propertyTracksJson: this._$_SavePropertyTracksToJson$_(),
                        lastKeyframeDataItemJson: this._$_SaveLastKeyframeDataItemToJson$_(),
                        initialStateOfNestedSet: this._$_initialStateOfNestedSet$_,
                        endStateOfNestedSet: this._$_endStateOfNestedSet$_,
                        instanceUid: e,
                        cleared: this._$_cleared$_
                    };
                }
                _$_LoadFromJson$_(t) {
                    if (t) {
                        this._$_LoadPropertyTracksFromJson$_(t.propertyTracksJson), 
                        this._$_LoadLastKeyframeDataItemFromJson$_(t.lastKeyframeDataItemJson), 
                        this._$_instanceUidToLoad$_ = t.instanceUid, this._$_initialStateOfNestedSet$_ = !1, 
                        t.hasOwnProperty.initialStateOfNestedSet && (this._$_initialStateOfNestedSet$_ = t.initialStateOfNestedSet), 
                        this._$_endStateOfNestedSet$_ = !1, t.hasOwnProperty.endStateOfNestedSet && (this._$_endStateOfNestedSet$_ = t.endStateOfNestedSet), 
                        this._$_cleared$_ = !!t.hasOwnProperty("cleared") && t.cleared;
                        for (const e of this._$_propertyTracks$_) 0 === this._$_worldInfoChange$_ && 1 === e._$GetWorldInfoChange$_() && (this._$_worldInfoChange$_ = 1), 
                        0 === this._$_renderChange$_ && 1 === e._$GetRenderChange$_() && (this._$_renderChange$_ = 1);
                        this._$_needsBeforeAndAfter$_ = 0, this._$_propertyTracks$_.some(t => t._$GetNeedsBeforeAndAfter$_()) && (this._$_needsBeforeAndAfter$_ = 1);
                    }
                }
                _$_SaveLastKeyframeDataItemToJson$_() {
                    const t = this._$_trackDataItem$_._$GetKeyframeData$_();
                    return t._$GetKeyframeDataItemIndex$_(this._$_lastKeyframeDataItem$_);
                }
                _$_SavePropertyTracksToJson$_() {
                    return this._$_propertyTracks$_.map(t => t._$_SaveToJson$_());
                }
                _$_LoadPropertyTracksFromJson$_(t) {
                    t.forEach((t, e) => {
                        const s = this._$_propertyTracks$_[e];
                        s._$_LoadFromJson$_(t);
                    });
                }
                _$_LoadInstanceFromJson$_(t) {
                    if (C33._$IsFiniteNumber$_(t)) {
                        const e = this._$GetRuntime$_()._$GetInstanceByUID$_(t);
                        if (e) {
                            const s = this._$GetTimeline$_();
                            s._$SetTrackInstance$_(this._$_trackDataItem$_._$GetId$_(), e, this._$GetTrackIndexInTimeline$_());
                        }
                    }
                }
                _$_LoadLastKeyframeDataItemFromJson$_(t) {
                    const e = this._$_trackDataItem$_._$GetKeyframeData$_();
                    this._$_lastKeyframeDataItem$_ = e._$GetKeyframeDataItemFromIndex$_(t);
                }
            };
        }
        {
            const C33 = self._$C3$_;
            C33._$PropertyTrackState$_ = class extends C33._$DefendedBase$_ {
                constructor(t, e) {
                    super(), this._$_track$_ = t, this._$_propertyTrackDataItem$_ = e, 
                    this._$_propertyTrackData$_ = e._$GetPropertyTrackData$_(), 
                    this._$_worldInfoChange$_ = 0, this._$_renderChange$_ = 0, this._$_needsBeforeAndAfter$_ = 0, 
                    this._$_sourceAdapter$_ = this._$GetSourceAdapter$_(), this._$_propertyKeyframeDataItems$_ = this._$_propertyTrackDataItem$_._$GetPropertyKeyframeData$_()._$GetPropertyKeyframeDataItemArray$_(), 
                    this._$_lastPropertyKeyframeDataItem$_ = null, this._$_absoluteValueObject$_ = null;
                }
                static _$Create$_(t, e) {
                    return C33._$New$_(C33._$PropertyTrackState$_, t, e);
                }
                _$Release$_() {
                    this._$_track$_ = null, this._$_sourceAdapter$_ && (this._$_sourceAdapter$_._$Release$_(), 
                    this._$_sourceAdapter$_ = null), this._$_propertyKeyframeDataItems$_ = null, 
                    this._$_propertyTrackDataItem$_ = null, this._$_propertyTrackData$_ = null;
                }
                _$GetWorldInfoChange$_() {
                    return this._$_worldInfoChange$_;
                }
                _$GetRenderChange$_() {
                    return this._$_renderChange$_;
                }
                _$GetNeedsBeforeAndAfter$_() {
                    return this._$_needsBeforeAndAfter$_;
                }
                _$HasAbsoluteValueObject$_() {
                    return !!this._$_absoluteValueObject$_;
                }
                _$SetAbsoluteValueObject$_(t) {
                    this._$_absoluteValueObject$_ = t;
                }
                _$GetAbsoluteValueObject$_() {
                    return this._$_absoluteValueObject$_;
                }
                _$GetTrack$_() {
                    return this._$_track$_;
                }
                _$GetPropertyTrackDataItem$_() {
                    return this._$_propertyTrackDataItem$_;
                }
                _$GetPropertyTrackData$_() {
                    return this._$_propertyTrackData$_;
                }
                _$GetTimeline$_() {
                    return this._$_track$_._$GetTimeline$_();
                }
                _$GetRuntime$_() {
                    return this._$_track$_._$GetRuntime$_();
                }
                _$GetInstance$_() {
                    return this._$_track$_._$GetInstance$_();
                }
                _$GetSourceAdapter$_() {
                    if (!this._$_sourceAdapter$_) {
                        let t = this._$_propertyTrackDataItem$_._$GetSourceAdapterId$_(), e;
                        switch (t) {
                          case "behavior":
                            e = new C33._$PropertyTrackState$_._$BehaviorSourceAdapter$_(this);
                            break;

                          case "effect":
                            e = new C33._$PropertyTrackState$_._$EffectSourceAdapter$_(this), 
                            this._$_renderChange$_ = 1;
                            break;

                          case "instance-variable":
                            e = new C33._$PropertyTrackState$_._$InstanceVariableSourceAdapter$_(this);
                            break;

                          case "plugin":
                            e = new C33._$PropertyTrackState$_._$PluginSourceAdapter$_(this), 
                            this._$_renderChange$_ = 1;
                            break;

                          case "world-instance":
                            e = new C33._$PropertyTrackState$_._$PropertySourceAdapter$_(this), 
                            this._$_renderChange$_ = 1, this._$_worldInfoChange$_ = 1;
                            break;

                          case "value":
                            e = new C33._$PropertyTrackState$_._$ValueSourceAdapter$_(this);
                            break;

                          case "audio":
                            e = new C33._$PropertyTrackState$_._$AudioSourceAdapter$_(this);
                        }
                        this._$_sourceAdapter$_ = e;
                    }
                    return this._$_sourceAdapter$_;
                }
                _$GetSourceAdapterId$_() {
                    return this._$_propertyTrackDataItem$_._$GetSourceAdapterId$_();
                }
                _$SetSourceAdapterId$_(t) {
                    this._$_propertyTrackDataItem$_._$SetSourceAdapterId$_(t);
                }
                _$GetSourceAdapterArgs$_() {
                    return this._$_propertyTrackDataItem$_._$GetSourceAdapterArguments$_();
                }
                _$SetSourceAdapterArgs$_(t) {
                    this._$_propertyTrackDataItem$_._$SetSourceAdapterArguments$_(t);
                }
                _$GetSourceAdapterValue$_() {
                    return this._$GetSourceAdapter$_()._$GetValue$_();
                }
                _$GetPropertyName$_() {
                    return this._$_propertyTrackDataItem$_._$GetProperty$_();
                }
                _$SetPropertyName$_(t) {
                    this._$_propertyTrackDataItem$_._$SetProperty$_(t);
                }
                _$GetPropertyType$_() {
                    return this._$_propertyTrackDataItem$_._$GetType$_();
                }
                _$SetPropertyType$_(t) {
                    this._$_propertyTrackDataItem$_.SetType(t);
                }
                _$GetPropertyKeyframeType$_() {
                    return this._$GetPropertyTrackData$_()._$GetFirstPropertyKeyframeDataItem$_(this._$_propertyTrackDataItem$_)._$GetType$_();
                }
                _$GetMin$_() {
                    return this._$_propertyTrackDataItem$_._$GetMin$_();
                }
                _$SetMin$_(t) {
                    this._$_propertyTrackDataItem$_._$SetMin$_(t);
                }
                _$GetMax$_() {
                    return this._$_propertyTrackDataItem$_._$GetMax$_();
                }
                _$SetMax$_(t) {
                    this._$_propertyTrackDataItem$_._$SetMax$_(t);
                }
                _$GetEnable$_() {
                    return this._$_propertyTrackDataItem$_._$GetEnable$_();
                }
                _$SetEnable$_(t) {
                    this._$_propertyTrackDataItem$_._$SetEnable$_(t);
                }
                _$GetInterpolationMode$_() {
                    return this._$_propertyTrackDataItem$_._$GetInterpolationMode$_();
                }
                _$SetInterpolationMode$_(t) {
                    this._$_propertyTrackDataItem$_._$SetInterpolationMode$_(t);
                }
                _$GetResultMode$_() {
                    return this._$_propertyTrackDataItem$_._$GetResultMode$_();
                }
                _$SetResultMode$_(t) {
                    this._$_propertyTrackDataItem$_._$SetResultMode$_(t);
                }
                _$SetEase$_(t) {
                    for (const e of this._$GetPropertyKeyframeDataItems$_()) e._$SetEase$_(t);
                }
                _$CanHavePropertyKeyframes$_() {
                    return this._$_propertyTrackDataItem$_._$CanHavePropertyKeyframes$_();
                }
                _$GetPropertyKeyframeDataItems$_() {
                    return this._$_propertyKeyframeDataItems$_ || (this._$_propertyKeyframeDataItems$_ = this._$_propertyTrackDataItem$_._$GetPropertyKeyframeData$_()._$GetPropertyKeyframeDataItemArray$_()), 
                    this._$_propertyKeyframeDataItems$_;
                }
                _$GetPropertyKeyframeDataItemArrayIncludingDisabled$_() {
                    return this._$_propertyTrackDataItem$_._$GetPropertyKeyframeData$_()._$GetPropertyKeyframeDataItemArrayIncludingDisabled$_();
                }
                _$GetPropertyKeyFrameDataItemAtTime$_(t) {
                    return this._$_propertyTrackData$_._$GetPropertyKeyFrameDataItemAtTime$_(t, this._$_propertyTrackDataItem$_);
                }
                _$GetFirstPropertyKeyFrameDataItemLowerOrEqualThan$_(t) {
                    return this._$_propertyTrackData$_._$GetFirstPropertyKeyFrameDataItemLowerOrEqualThan$_(t, this._$_propertyTrackDataItem$_);
                }
                _$GetPropertyKeyframeDataItemPairForTime$_(t) {
                    let e = this._$_propertyTrackData$_._$GetPropertyKeyFrameDataItemAtTime$_(t, this._$_propertyTrackDataItem$_), s;
                    return s = e ? this._$_propertyTrackData$_._$GetFirstPropertyKeyFrameDataItemHigherThan$_(t, this._$_propertyTrackDataItem$_) : (e = this._$_propertyTrackData$_._$GetFirstPropertyKeyFrameDataItemLowerOrEqualThan$_(t, this._$_propertyTrackDataItem$_), 
                    this._$_propertyTrackData$_._$GetFirstPropertyKeyFrameDataItemHigherOrEqualThan$_(t, this._$_propertyTrackDataItem$_)), 
                    {
                        start: e,
                        end: s
                    };
                }
                *_$GetPropertyKeyframeValues$_() {
                    for (const t of this._$GetPropertyKeyframeDataItems$_()) yield t._$GetValueWithResultMode$_();
                }
                *_$GetPropertyKeyframeTimes$_() {
                    for (const t of this._$GetPropertyKeyframeDataItems$_()) yield t._$GetTime$_();
                }
                _$TimelineRemoved$_() {
                    this._$GetSourceAdapter$_()._$TimelineRemoved$_();
                }
                _$CleanCaches$_() {
                    this._$GetSourceAdapter$_()._$CleanCaches$_();
                }
                _$GetCurrentState$_() {
                    return this._$GetSourceAdapter$_()._$GetCurrentState$_();
                }
                _$SetResetState$_() {
                    this._$GetSourceAdapter$_()._$SetResetState$_();
                }
                _$SetInitialState$_(t) {
                    this._$GetSourceAdapter$_()._$SetInitialState$_(), this._$_lastPropertyKeyframeDataItem$_ = this._$_GetLastPropertyKeyFrameBeforeTime$_(t), 
                    this._$_SetUpdateState$_();
                }
                _$SetResumeState$_(t) {
                    this._$GetSourceAdapter$_()._$SetResumeState$_(), this._$_lastPropertyKeyframeDataItem$_ = this._$_GetLastPropertyKeyFrameBeforeTime$_(t);
                }
                _$_SetUpdateState$_() {
                    const t = this._$GetTrack$_();
                    if (this._$_needsBeforeAndAfter$_ = 0, t._$IsInstanceTrack$_()) {
                        const e = this._$GetTimeline$_(), s = t._$GetInstance$_(), i = this._$GetSourceAdapter$_(), r = this._$GetPropertyName$_(), n = i._$MayNeedBeforeAndAfterInterpolate$_();
                        if (n) {
                            const h = e._$GetSimilarPropertyTracks$_(s, i, r, this);
                            h && h.length && (this._$_needsBeforeAndAfter$_ = 1);
                        } else this._$_needsBeforeAndAfter$_ = 0;
                    }
                }
                _$_GetLastPropertyKeyFrameBeforeTime$_(t) {
                    const e = this._$GetTimeline$_(), s = this._$_propertyTrackData$_._$GetPropertyKeyFrameDataItemAtTime$_(t, this._$_propertyTrackDataItem$_);
                    return s || (e._$IsForwardPlayBack$_() ? this._$_propertyTrackData$_._$GetFirstPropertyKeyFrameDataItemLowerOrEqualThan$_(t, this._$_propertyTrackDataItem$_) : this._$_propertyTrackData$_._$GetFirstPropertyKeyFrameDataItemHigherOrEqualThan$_(t, this._$_propertyTrackDataItem$_));
                }
                _$BeforeInterpolate$_() {
                    this._$_sourceAdapter$_._$BeforeInterpolate$_();
                }
                _$Interpolate$_(t, e = !1, s = !1, i = !1) {
                    let r, n, h = !1;
                    if (e) r = this._$_propertyTrackData$_._$GetFirstPropertyKeyFrameDataItemLowerOrEqualThan$_(t, this._$_propertyTrackDataItem$_); else {
                        if (this._$_lastPropertyKeyframeDataItem$_) {
                            const o = this._$GetTimeline$_(), a = this._$_lastPropertyKeyframeDataItem$_._$GetNext$_(), l = this._$_lastPropertyKeyframeDataItem$_._$GetTime$_(), u = a ? a._$GetTime$_() : o._$GetTotalTime$_();
                            (t <= l || u <= t) && (this._$_lastPropertyKeyframeDataItem$_ = this._$_propertyTrackData$_._$GetFirstPropertyKeyFrameDataItemLowerOrEqualThan$_(t, this._$_propertyTrackDataItem$_), 
                            h = !0);
                        } else this._$_lastPropertyKeyframeDataItem$_ = this._$_propertyTrackData$_._$GetFirstPropertyKeyFrameDataItemLowerOrEqualThan$_(t, this._$_propertyTrackDataItem$_), 
                        h = !0;
                        r = this._$_lastPropertyKeyframeDataItem$_;
                    }
                    r && (n = r._$GetNext$_()), this._$_sourceAdapter$_._$Interpolate$_(t, r, n, e, s, i, h);
                }
                _$GetInterpolatedValue$_(t) {
                    if (this._$_lastPropertyKeyframeDataItem$_) {
                        const i = this._$GetTimeline$_(), r = this._$_lastPropertyKeyframeDataItem$_._$GetNext$_(), n = this._$_lastPropertyKeyframeDataItem$_._$GetTime$_(), h = r ? r._$GetTime$_() : i._$GetTotalTime$_();
                        (t <= n || h <= t) && (this._$_lastPropertyKeyframeDataItem$_ = this._$_propertyTrackData$_._$GetFirstPropertyKeyFrameDataItemLowerOrEqualThan$_(t, this._$_propertyTrackDataItem$_));
                    } else this._$_lastPropertyKeyframeDataItem$_ = this._$_propertyTrackData$_._$GetFirstPropertyKeyFrameDataItemLowerOrEqualThan$_(t, this._$_propertyTrackDataItem$_);
                    const e = this._$_lastPropertyKeyframeDataItem$_, s = e._$GetNext$_();
                    return this._$_sourceAdapter$_._$GetInterpolatedValue$_(t, e, s);
                }
                _$GetInterpolatedValueFast$_(t, e, s) {
                    return this._$_sourceAdapter$_._$GetInterpolatedValue$_(t, e, s);
                }
                _$AfterInterpolate$_() {
                    this._$_sourceAdapter$_._$AfterInterpolate$_();
                }
                static _$GetStartPropertyKeyframeForTime$_(t, e) {
                    const s = e._$GetPropertyTrackDataItem$_(), i = e._$_propertyTrackData$_;
                    return i._$GetFirstPropertyKeyFrameDataItemLowerOrEqualThan$_(t, s);
                }
                static _$GetEndPropertyKeyframeForTime$_(t, e) {
                    const s = e._$GetPropertyTrackDataItem$_(), i = e._$_propertyTrackData$_;
                    return i._$GetFirstPropertyKeyFrameDataItemHigherOrEqualThan$_(t, s);
                }
                _$AddPropertyKeyframe$_() {
                    const t = this._$_propertyTrackDataItem$_._$GetPropertyKeyframeData$_(), e = t._$AddEmptyPropertyKeyframeDataItem$_();
                    return this._$_lastPropertyKeyframeDataItem$_ = null, e;
                }
                _$DeletePropertyKeyframes$_(t) {
                    this._$_lastPropertyKeyframeDataItem$_ = null;
                    const e = this._$_propertyTrackDataItem$_._$GetPropertyKeyframeData$_();
                    e._$DeletePropertyKeyframeDataItems$_(t);
                }
                _$SaveState$_() {
                    this._$GetSourceAdapter$_()._$SaveState$_();
                }
                _$CompareInitialStateWithCurrent$_() {
                    const t = this._$GetSourceAdapter$_()._$CompareInitialStateWithCurrent$_();
                    if (t) {
                        const e = this._$_propertyTrackData$_._$GetFirstPropertyKeyframeDataItem$_(this._$_propertyTrackDataItem$_), s = this._$GetSourceAdapter$_()._$GetCurrentState$_();
                        e._$SetAbsoluteValue$_(s);
                    }
                }
                _$CompareSaveStateWithCurrent$_() {
                    const t = this._$GetSourceAdapter$_()._$CompareSaveStateWithCurrent$_();
                    return t && this._$AddPropertyKeyframeAtCurrentTime$_(), this._$GetSourceAdapter$_()._$ClearSaveState$_(), 
                    t;
                }
                _$AddPropertyKeyframeAtCurrentTime$_() {
                    const t = this._$GetTimeline$_()._$GetTime$_(), e = this._$GetSourceAdapter$_(), s = C33._$PropertyTrackState$_._$GetStartPropertyKeyframeForTime$_(t, this), i = this._$AddPropertyKeyframe$_();
                    i.SetType(s._$GetType$_()), i._$SetTime$_(t), i._$SetEase$_(s._$GetEase$_()), 
                    i._$SetEnable$_(!0), i._$SetValue$_(e._$GetValueAtTime$_()), 
                    i._$SetAbsoluteValue$_(e._$GetCurrentState$_());
                }
                _$_SaveToJson$_() {
                    return {
                        sourceAdapterJson: this._$GetSourceAdapter$_()._$_SaveToJson$_()
                    };
                }
                _$_LoadFromJson$_(t) {
                    t && this._$GetSourceAdapter$_()._$_LoadFromJson$_(t.sourceAdapterJson);
                }
            };
        }
        {
            const C33 = self._$C3$_, NS = C33._$PropertyTrackState$_;
            NS._$PropertySourceAdapter$_ = class {
                constructor(t) {
                    this._$_propertyTrack$_ = t, this._$_propertyAdapter$_ = null, 
                    this._$GetPropertyAdapter$_();
                }
                _$Release$_() {
                    this._$_propertyAdapter$_ && (this._$_propertyAdapter$_._$Release$_(), 
                    this._$_propertyAdapter$_ = null), this._$_propertyTrack$_ = null;
                }
                _$MayNeedBeforeAndAfterInterpolate$_() {
                    return this._$_propertyAdapter$_._$MayNeedBeforeAndAfterInterpolate$_();
                }
                _$GetPropertyTrack$_() {
                    return this._$_propertyTrack$_;
                }
                _$TimelineRemoved$_() {
                    this._$_propertyAdapter$_ && this._$_propertyAdapter$_._$TimelineRemoved$_();
                }
                _$CleanCaches$_() {
                    this._$_propertyAdapter$_ && this._$_propertyAdapter$_._$CleanCaches$_();
                }
                _$GetPropertyAdapter$_() {
                    return this._$_propertyAdapter$_ || (this._$_propertyAdapter$_ = this._$_CreatePropertyAdapter$_()), 
                    this._$_propertyAdapter$_;
                }
                _$GetEditorIndex$_() {}
                _$GetIndex$_() {
                    return this._$GetEditorIndex$_();
                }
                _$GetTarget$_() {}
                _$SetResetState$_() {
                    this._$GetPropertyAdapter$_()._$SetResetState$_();
                }
                _$SetInitialState$_() {
                    this._$GetPropertyAdapter$_()._$SetInitialState$_();
                }
                _$SetResumeState$_() {
                    this._$GetPropertyAdapter$_()._$SetResumeState$_();
                }
                _$BeforeInterpolate$_() {
                    this._$_propertyAdapter$_._$BeforeChangeProperty$_();
                }
                _$Interpolate$_(t, e, s, i, r, n, h) {
                    let o = this._$_propertyTrack$_._$GetPropertyKeyframeType$_(), a;
                    switch (o) {
                      case "numeric":
                        a = NS._$NumericTypeAdapter$_._$Interpolate$_(t, e, s, this._$_propertyTrack$_);
                        break;

                      case "angle":
                        a = NS._$AngleTypeAdapter$_._$Interpolate$_(t, e, s, this._$_propertyTrack$_);
                        break;

                      case "boolean":
                        a = NS._$BooleanTypeAdapter$_._$Interpolate$_(t, e, s, this._$_propertyTrack$_);
                        break;

                      case "color":
                        a = NS._$ColorTypeAdapter$_._$Interpolate$_(t, e, s, this._$_propertyTrack$_);
                        break;

                      case "text":
                        a = NS._$TextTypeAdapter$_._$Interpolate$_(t, e, s, this._$_propertyTrack$_);
                    }
                    this._$_propertyAdapter$_._$ChangeProperty$_(t, a, e, s, i, r, n, h);
                }
                _$GetInterpolatedValue$_(t, e, s) {
                    switch (this._$_propertyTrack$_._$GetPropertyKeyframeType$_()) {
                      case "numeric":
                        return NS._$NumericTypeAdapter$_._$Interpolate$_(t, e, s, this._$_propertyTrack$_);

                      case "angle":
                        return NS._$AngleTypeAdapter$_._$Interpolate$_(t, e, s, this._$_propertyTrack$_);

                      case "boolean":
                        return NS._$BooleanTypeAdapter$_._$Interpolate$_(t, e, s, this._$_propertyTrack$_);

                      case "color":
                        return NS._$ColorTypeAdapter$_._$Interpolate$_(t, e, s, this._$_propertyTrack$_);

                      case "text":
                        return NS._$TextTypeAdapter$_._$Interpolate$_(t, e, s, this._$_propertyTrack$_);
                    }
                }
                _$AfterInterpolate$_() {
                    this._$_propertyAdapter$_._$AfterChangeProperty$_();
                }
                _$SaveState$_() {
                    this._$GetPropertyAdapter$_()._$SetSaveState$_();
                }
                _$ClearSaveState$_() {
                    this._$GetPropertyAdapter$_()._$ClearSaveState$_();
                }
                _$GetCurrentState$_() {
                    return this._$GetPropertyAdapter$_()._$GetCurrentState$_();
                }
                _$CompareInitialStateWithCurrent$_() {
                    return this._$GetPropertyAdapter$_()._$CompareInitialStateWithCurrent$_();
                }
                _$CompareSaveStateWithCurrent$_() {
                    return this._$GetPropertyAdapter$_()._$CompareSaveStateWithCurrent$_();
                }
                _$GetValueAtTime$_() {
                    const t = this._$_propertyTrack$_, e = t._$GetTrack$_(), s = e._$GetTimeline$_()._$GetTime$_(), i = NS._$GetStartPropertyKeyframeForTime$_(s, t), r = i._$GetNext$_(), n = t._$GetPropertyKeyframeType$_();
                    switch (n) {
                      case "numeric":
                        return NS._$NumericTypeAdapter$_._$Interpolate$_(s, i, r, t);

                      case "angle":
                        return NS._$AngleTypeAdapter$_._$Interpolate$_(s, i, r, t);

                      case "boolean":
                        return NS._$BooleanTypeAdapter$_._$Interpolate$_(s, i, r, t);

                      case "color":
                        return NS._$ColorTypeAdapter$_._$Interpolate$_(s, i, r, t);

                      case "text":
                        return NS._$TextTypeAdapter$_._$Interpolate$_(s, i, r, t);
                    }
                }
                _$_CreatePropertyAdapter$_() {
                    const t = this._$_propertyTrack$_, e = t._$CanHavePropertyKeyframes$_() ? t._$GetPropertyKeyframeType$_() : "";
                    switch (e) {
                      case "combo":
                      case "boolean":
                      case "text":
                      case "string":
                        return new NS._$PropertyInterpolationAdapter$_._$NoInterpolationAdapter$_(this);

                      case "numeric":
                      case "number":
                      case "angle":
                        return new ("combo" === this._$_propertyTrack$_._$GetPropertyType$_() ? NS._$PropertyInterpolationAdapter$_._$NoInterpolationAdapter$_ : NS._$PropertyInterpolationAdapter$_._$NumericInterpolationAdapter$_)(this);

                      case "color":
                      case "offsetColor":
                        return new NS._$PropertyInterpolationAdapter$_._$ColorInterpolationAdapter$_(this);

                      default:
                        return new NS._$PropertyInterpolationAdapter$_._$NumericInterpolationAdapter$_(this);
                    }
                }
                _$_SaveToJson$_() {
                    return {
                        propertyAdapterJson: this._$GetPropertyAdapter$_()._$_SaveToJson$_()
                    };
                }
                _$_LoadFromJson$_(t) {
                    t && this._$GetPropertyAdapter$_()._$_LoadFromJson$_(t.propertyAdapterJson);
                }
            };
        }
        {
            const C33 = self._$C3$_, INDEX = 0;
            class InstanceVariableSourceAdapter extends C33._$PropertyTrackState$_._$PropertySourceAdapter$_ {
                constructor(t) {
                    super(t), this._$_updatedIndex$_ = NaN;
                }
                _$GetEditorIndex$_() {
                    return this._$_propertyTrack$_._$GetPropertyTrackDataItem$_()._$GetSourceAdapterArguments$_()[INDEX];
                }
                _$GetIndex$_() {
                    return this._$_updatedIndex$_ || super._$GetIndex$_();
                }
                _$GetTarget$_() {
                    return this._$_propertyTrack$_._$GetTrack$_()._$GetInstance$_();
                }
                _$UpdateInstanceVariableIndex$_(t) {
                    const e = this._$_propertyTrack$_._$GetPropertyTrackDataItem$_()._$GetSourceAdapterArguments$_()[INDEX];
                    e !== t && (this._$_updatedIndex$_ = t);
                }
                _$Interpolate$_(t, e, s, i, r, n, h) {
                    this._$GetPropertyAdapter$_()._$CanChange$_(e._$GetValue$_()) && super._$Interpolate$_(t, e, s, i, r, n, h);
                }
                _$GetInterpolatedValue$_(t, e, s) {
                    if (this._$GetPropertyAdapter$_()._$CanChange$_(e._$GetValue$_())) return super._$GetInterpolatedValue$_(t, e, s);
                }
                _$_SaveToJson$_() {
                    return Object.assign(super._$_SaveToJson$_(), {
                        index: this._$_updatedIndex$_
                    });
                }
                _$_LoadFromJson$_(t) {
                    t && (super._$_LoadFromJson$_(t), this._$_updatedIndex$_ = t.index);
                }
            }
            C33._$PropertyTrackState$_._$InstanceVariableSourceAdapter$_ = InstanceVariableSourceAdapter;
        }
        {
            const C33 = self._$C3$_, SID = 0, INDEX = 1, NAME = 2;
            class BehaviorSourceAdapter extends C33._$PropertyTrackState$_._$PropertySourceAdapter$_ {
                constructor(t) {
                    super(t), this._$_sid$_ = NaN;
                }
                _$GetEditorIndex$_() {
                    const t = this._$_propertyTrack$_._$GetPropertyTrackDataItem$_();
                    return t._$GetSourceAdapterArguments$_()[INDEX];
                }
                _$GetTarget$_() {
                    const t = this._$_propertyTrack$_._$GetPropertyTrackDataItem$_(), e = this._$_propertyTrack$_._$GetTrack$_(), s = this._$_sid$_ || t._$GetSourceAdapterArguments$_()[SID], i = e._$GetInstance$_(), r = i._$GetBehaviorIndexBySID$_(s), n = i._$GetBehaviorInstances$_()[r];
                    return n._$GetSdkInstance$_();
                }
                _$GetBehaviorType$_(t) {
                    const e = this._$_propertyTrack$_._$GetPropertyTrackDataItem$_(), s = e._$GetSourceAdapterArguments$_()[NAME];
                    return t._$GetBehaviorTypeByName$_(s);
                }
                _$UpdateBehaviorTypeSid$_(t) {
                    const e = this._$_propertyTrack$_._$GetPropertyTrackDataItem$_();
                    e._$GetSourceAdapterArguments$_()[SID] !== t && (this._$_sid$_ = t);
                }
                _$Interpolate$_(t, e, s, i, r, n, h) {
                    const o = this._$_propertyTrack$_._$GetTrack$_(), a = o._$GetInstance$_();
                    this._$GetBehaviorType$_(a._$GetObjectClass$_()) && super._$Interpolate$_(t, e, s, i, r, n, h);
                }
                _$GetInterpolatedValue$_(t, e, s) {
                    const i = this._$_propertyTrack$_._$GetTrack$_(), r = i._$GetInstance$_();
                    if (this._$GetBehaviorType$_(r._$GetObjectClass$_())) return super._$GetInterpolatedValue$_(t, e, s);
                }
                _$_SaveToJson$_() {
                    return Object.assign(super._$_SaveToJson$_(), {
                        sid: this._$_sid$_
                    });
                }
                _$_LoadFromJson$_(t) {
                    t && (super._$_LoadFromJson$_(t), this._$_sid$_ = t.sid);
                }
            }
            C33._$PropertyTrackState$_._$BehaviorSourceAdapter$_ = BehaviorSourceAdapter;
        }
        {
            const C33 = self._$C3$_, NAME = 0, INDEX = 1;
            class EffectSourceAdapter extends C33._$PropertyTrackState$_._$PropertySourceAdapter$_ {
                constructor(t) {
                    super(t);
                }
                _$GetEditorIndex$_() {
                    return this._$_propertyTrack$_._$GetPropertyTrackDataItem$_()._$GetSourceAdapterArguments$_()[INDEX];
                }
                _$GetTarget$_() {
                    const t = this._$_propertyTrack$_, e = t._$GetTrack$_(), s = e._$GetWorldInfo$_(), i = s._$GetInstanceEffectList$_(), r = i._$GetEffectList$_(), n = this._$GetEffectType$_(r), h = n._$GetIndex$_();
                    return i._$IsEffectIndexActive$_(h) ? i._$GetEffectParametersForIndex$_(h) : null;
                }
                _$GetEffectType$_(t) {
                    const e = this._$_propertyTrack$_, s = e._$GetPropertyTrackDataItem$_()._$GetSourceAdapterArguments$_()[NAME];
                    return t._$GetEffectTypeByName$_(s);
                }
                _$Interpolate$_(t, e, s, i, r, n, h) {
                    this._$_IsEffectActive$_() && super._$Interpolate$_(t, e, s, i, r, n, h);
                }
                _$GetInterpolatedValue$_(t, e, s) {
                    if (this._$_IsEffectActive$_()) return super._$GetInterpolatedValue$_(t, e, s);
                }
                _$_IsEffectActive$_() {
                    const t = this._$_propertyTrack$_, e = t._$GetTrack$_(), s = e._$GetWorldInfo$_(), i = s._$GetInstanceEffectList$_(), r = i._$GetEffectList$_(), n = this._$GetEffectType$_(r);
                    if (n) {
                        const h = n._$GetIndex$_();
                        return i._$IsEffectIndexActive$_(h);
                    }
                }
            }
            C33._$PropertyTrackState$_._$EffectSourceAdapter$_ = EffectSourceAdapter;
        }
        {
            const C33 = self._$C3$_, INDEX = 0;
            class PluginSourceAdapter extends C33._$PropertyTrackState$_._$PropertySourceAdapter$_ {
                constructor(t) {
                    super(t);
                }
                _$GetEditorIndex$_() {
                    return this._$_propertyTrack$_._$GetPropertyTrackDataItem$_()._$GetSourceAdapterArguments$_()[INDEX];
                }
                _$GetTarget$_() {
                    return this._$_propertyTrack$_._$GetTrack$_()._$GetInstance$_()._$GetSdkInstance$_();
                }
                _$Interpolate$_(t, e, s, i, r, n, h) {
                    const o = this._$_propertyTrack$_._$GetTrack$_(), a = o._$GetObjectClass$_()._$GetPlugin$_(), l = o._$GetInstance$_()._$GetObjectClass$_()._$GetPlugin$_();
                    a === l && super._$Interpolate$_(t, e, s, i, r, n, h);
                }
                _$GetInterpolatedValue$_(t, e, s) {
                    const i = this._$_propertyTrack$_._$GetTrack$_(), r = i._$GetObjectClass$_()._$GetPlugin$_(), n = i._$GetInstance$_()._$GetObjectClass$_()._$GetPlugin$_();
                    if (r === n) return super._$GetInterpolatedValue$_(t, e, s);
                }
                _$GetOptionalCallbacks$_() {
                    const t = this._$_propertyTrack$_._$GetTrack$_(), e = t._$GetObjectClass$_()._$GetPlugin$_();
                    if (C33._$Plugins$_._$Sprite$_ && e instanceof C33._$Plugins$_._$Sprite$_ && ("initial-frame" === this._$_propertyTrack$_._$GetPropertyName$_() || "initial-animation" === this._$_propertyTrack$_._$GetPropertyName$_())) switch (this._$_propertyTrack$_._$GetResultMode$_()) {
                      case "relative":
                      case "absolute":
                        return null;
                    }
                }
            }
            C33._$PropertyTrackState$_._$PluginSourceAdapter$_ = PluginSourceAdapter;
        }
        {
            const C33 = self._$C3$_;
            class ValueSourceAdapter extends C33._$PropertyTrackState$_._$PropertySourceAdapter$_ {
                constructor(t) {
                    super(t), this._$_value$_ = 0, this._$_init$_ = !1;
                }
                _$MayNeedBeforeAndAfterInterpolate$_() {
                    return !1;
                }
                _$SetInitialState$_() {
                    let t = this._$_propertyTrack$_._$GetPropertyTrackData$_(), e = this._$_propertyTrack$_._$GetPropertyTrackDataItem$_();
                    e = t._$GetFirstPropertyKeyframeDataItem$_(e), this._$_value$_ = e._$GetValueWithResultMode$_();
                }
                _$SetResumeState$_() {}
                _$GetValue$_() {
                    return this._$_init$_ || this._$_propertyTrack$_._$Interpolate$_(0), 
                    this._$_value$_;
                }
                _$Interpolate$_(t, e, s, i, r, n, h) {
                    this._$_value$_ = C33._$PropertyTrackState$_._$NumericTypeAdapter$_._$Interpolate$_(t, e, s, this._$_propertyTrack$_), 
                    this._$_init$_ = !0;
                }
                _$SaveState$_() {}
                _$ClearSaveState$_() {}
                _$GetCurrentState$_() {
                    return this._$_value$_;
                }
                _$CompareInitialStateWithCurrent$_() {
                    return !1;
                }
                _$CompareSaveStateWithCurrent$_() {
                    return !1;
                }
                _$_SaveToJson$_() {
                    return {
                        value: this._$_value$_,
                        init: this._$_init$_
                    };
                }
                _$_LoadFromJson$_(t) {
                    t && (this._$_value$_ = t.value, this._$_init$_ = !t.hasOwnProperty("init") || t.init);
                }
            }
            C33._$PropertyTrackState$_._$ValueSourceAdapter$_ = ValueSourceAdapter;
        }
        {
            const C33 = self._$C3$_, PROJECT_FILE = 0, PROJECT_FILE_NAME = 0, PROJECT_FILE_TYPE = 1, START_OFFSET = 1, AUDIO_DURATION = 2, AUDIO_TAG = 3;
            class AudioSourceAdapter extends C33._$PropertyTrackState$_._$PropertySourceAdapter$_ {
                constructor(t) {
                    super(t), this._$_audioPlaybackStarted$_ = !1, this._$_sdkInstance$_ = null, 
                    this._$_actions$_ = null, this._$_expressions$_ = null, this._$_timeline$_ = this._$_propertyTrack$_._$GetTimeline$_(), 
                    this._$_track$_ = this._$_propertyTrack$_._$GetTrack$_(), this._$_sourceAdapterArgs$_ = this._$_propertyTrack$_._$GetSourceAdapterArgs$_(), 
                    this._$_fileArgs$_ = this._$_sourceAdapterArgs$_[PROJECT_FILE], 
                    this._$_startOffsetTime$_ = this._$_sourceAdapterArgs$_[START_OFFSET], 
                    this._$_sourceAdapterArgs$_[AUDIO_TAG] ? this._$_audioTag$_ = this._$_sourceAdapterArgs$_[AUDIO_TAG] : this._$_audioTag$_ = Math.random().toString(36).slice(2), 
                    this._$_pauseTime$_ = NaN, this._$_pauseVolume$_ = NaN, this._$_volume$_ = NaN, 
                    this._$_audioSource$_ = null, this._$_Initialize$_();
                }
                _$Release$_() {
                    super._$Release$_(), this._$_sdkInstance$_ = null, this._$_actions$_ = null, 
                    this._$_expressions$_ = null, this._$_timeline$_ = null, this._$_track$_ = null, 
                    this._$_sourceAdapterArgs$_ = null, this._$_fileArgs$_ = null, 
                    this._$_audioSource$_ = null;
                }
                _$_Initialize$_() {
                    if (self._$C3$_._$Plugins$_.Audio) {
                        const t = this._$_propertyTrack$_._$GetRuntime$_(), e = t._$GetSingleGlobalObjectClassByCtor$_(self._$C3$_._$Plugins$_.Audio);
                        e && (this._$_sdkInstance$_ = e._$GetSingleGlobalInstance$_()._$GetSdkInstance$_()), 
                        this._$_actions$_ = self._$C3$_._$Plugins$_.Audio._$Acts$_, 
                        this._$_expressions$_ = self._$C3$_._$Plugins$_.Audio._$Exps$_;
                    }
                }
                _$_MaybeSetAudioSource$_() {
                    if (!this._$_audioSource$_) {
                        const t = this._$_propertyTrack$_._$GetTrack$_(), e = t._$GetPropertyTrack$_("audioSource");
                        e && (this._$_audioSource$_ = e._$GetSourceAdapter$_());
                    }
                }
                _$_GetPauseVolume$_() {
                    const t = this._$_propertyTrack$_._$GetTrack$_(), e = t._$GetPropertyTrack$_("volume");
                    return (e ? e._$GetSourceAdapter$_() : this)._$_pauseVolume$_;
                }
                _$TimelineRemoved$_() {
                    super._$TimelineRemoved$_(), this._$_audioPlaybackStarted$_ = !1, 
                    this._$_sdkInstance$_ && (this._$_expressions$_ && (this._$_pauseTime$_ = this._$_expressions$_._$PlaybackTime$_.call(this._$_sdkInstance$_, this._$_audioTag$_), 
                    this._$_pauseVolume$_ = this._$_expressions$_._$Volume$_.call(this._$_sdkInstance$_, this._$_audioTag$_)), 
                    this._$_actions$_) && this._$_actions$_._$Stop$_.call(this._$_sdkInstance$_, this._$_audioTag$_);
                }
                _$GetAudioTag$_() {
                    return this._$_audioTag$_;
                }
                _$GetVolume$_() {
                    return this._$_volume$_;
                }
                _$SetVolume$_(t) {
                    this._$_volume$_ = t;
                }
                _$SetInitialState$_() {
                    super._$SetInitialState$_(), this._$_pauseTime$_ = NaN, this._$_audioPlaybackStarted$_ = !1;
                }
                _$SetResumeState$_() {
                    super._$SetResumeState$_();
                    const t = this._$_propertyTrack$_._$GetTimeline$_(), e = t._$GetTime$_();
                    switch (this._$_pauseTime$_ = e - this._$_startOffsetTime$_, 
                    this._$_propertyTrack$_._$GetPropertyName$_()) {
                      case "audioSource":
                        break;

                      case "volume":
                        this._$_pauseVolume$_ = this._$_propertyTrack$_._$GetInterpolatedValue$_(e);
                    }
                    this._$_audioPlaybackStarted$_ = !1;
                }
                _$Interpolate$_(t, e, s, i, r, n, h) {
                    if (this._$_sdkInstance$_) switch (this._$_propertyTrack$_._$GetPropertyName$_()) {
                      case "audioSource":
                        {
                            if (!this._$_timeline$_._$IsForwardPlayBack$_()) return;
                            if (i) return void (this._$_actions$_ && this._$_actions$_._$Stop$_.call(this._$_sdkInstance$_, this._$_audioTag$_));
                            if (t < this._$_startOffsetTime$_) return void (this._$_audioPlaybackStarted$_ = !1);
                            const o = this._$_expressions$_._$PlaybackRate$_.call(this._$_sdkInstance$_, this._$_audioTag$_), a = this._$_timeline$_._$GetPlaybackRate$_();
                            if (a !== o && this._$_actions$_._$SetPlaybackRate$_.call(this._$_sdkInstance$_, this._$_audioTag$_, a), 
                            this._$_audioPlaybackStarted$_) return;
                            if (!this._$_propertyTrack$_._$GetTimeline$_().IsPlaying()) return;
                            if (this._$_audioPlaybackStarted$_ = !0, isNaN(this._$_pauseTime$_)) {
                                const l = self.performance.now(), u = t - this._$_startOffsetTime$_, c = this._$_sdkInstance$_._$GetAudioContextState$_();
                                if ("suspended" === c) return void (this._$_audioPlaybackStarted$_ = !1);
                                const f = self.performance.now(), d = (f - l) / 1e3, p = u + d;
                                if (this._$_actions$_) {
                                    let t = this._$GetVolume$_();
                                    isNaN(t) ? (this._$SetVolume$_(0), t = 0) : this._$SetVolume$_(t), 
                                    this._$_actions$_._$PlayFromTimeline$_.call(this._$_sdkInstance$_, this._$_fileArgs$_, t, this._$_audioTag$_, p);
                                }
                            } else {
                                const m = this._$_pauseTime$_, C = (this._$_pauseTime$_ = NaN, 
                                this._$_GetPauseVolume$_()), g = (this._$_pauseVolume$_ = NaN, 
                                this._$_sdkInstance$_._$GetAudioContextState$_());
                                if ("suspended" === g) return void (this._$_audioPlaybackStarted$_ = !1);
                                this._$_actions$_ && (this._$SetVolume$_(C), this._$_actions$_._$PlayFromTimeline$_.call(this._$_sdkInstance$_, this._$_fileArgs$_, C, this._$_audioTag$_, m));
                            }
                            break;
                        }

                      case "volume":
                        this._$_MaybeSetAudioSource$_(), super._$Interpolate$_(t, e, s, i, r, n, h);
                    }
                }
                _$GetInterpolatedValue$_(t, e, s) {
                    if (this._$_sdkInstance$_) switch (this._$_propertyTrack$_._$GetPropertyName$_()) {
                      case "audioSource":
                        return;

                      case "volume":
                        return this._$_MaybeSetAudioSource$_(), super._$GetInterpolatedValue$_(t, e, s);
                    }
                }
                _$Getter$_(t, e) {
                    return this._$_audioSource$_ ? this._$_audioSource$_._$GetVolume$_() : 0;
                }
                _$Setter$_(t, e, s, i) {
                    this._$_audioSource$_ && this._$_audioSource$_._$SetVolume$_(this._$Getter$_() + e), 
                    this._$_actions$_ && this._$_audioSource$_ && this._$_actions$_._$SetVolume$_.call(this._$_sdkInstance$_, this._$_audioSource$_._$GetAudioTag$_(), this._$_audioSource$_._$GetVolume$_());
                }
                _$AbsoluteSetter$_(t, e, s) {
                    this._$_audioSource$_ && this._$_audioSource$_._$SetVolume$_(e), 
                    this._$_actions$_ && this._$_audioSource$_ && this._$_actions$_._$SetVolume$_.call(this._$_sdkInstance$_, this._$_audioSource$_._$GetAudioTag$_(), this._$_audioSource$_._$GetVolume$_());
                }
                _$DoesRounding$_() {
                    return !0;
                }
                _$_SaveToJson$_() {
                    return {
                        audioPlaybackStarted: this._$_audioPlaybackStarted$_,
                        audioTag: this._$_audioTag$_,
                        pauseTime: this._$_pauseTime$_,
                        pauseVolume: this._$_pauseVolume$_,
                        volume: this._$_volume$_
                    };
                }
                _$_LoadFromJson$_(t) {
                    t && (this._$_audioPlaybackStarted$_ = t.audioPlaybackStarted, 
                    this._$_audioTag$_ = t.audioTag, this._$_pauseTime$_ = t.pauseTime, 
                    this._$_pauseVolume$_ = t.pauseVolume, this._$_volume$_ = t.volume, 
                    this._$_Initialize$_());
                }
            }
            C33._$PropertyTrackState$_._$AudioSourceAdapter$_ = AudioSourceAdapter;
        }
        {
            const C33 = self._$C3$_;
            C33._$PropertyTrackState$_._$PropertyInterpolationAdapter$_ = class {
                constructor(t) {
                    this._$_sourceAdapter$_ = t, this._$_propertyTrack$_ = t._$GetPropertyTrack$_(), 
                    this._$_worldInfo$_ = this._$_propertyTrack$_._$GetTrack$_()._$GetWorldInfo$_(), 
                    this._$_property$_ = this._$_propertyTrack$_._$GetPropertyName$_(), 
                    this._$_firstAbsoluteUpdate$_ = !1, this._$_saveState$_ = null, 
                    this._$_target$_ = null;
                }
                _$Release$_() {
                    this._$_sourceAdapter$_ = null, this._$_propertyTrack$_ = null, 
                    this._$_worldInfo$_ = null, this._$_saveState$_ = null, this._$_target$_ = null;
                }
                _$MayNeedBeforeAndAfterInterpolate$_() {
                    return !1;
                }
                _$TimelineRemoved$_() {}
                _$CleanCaches$_() {
                    this._$_worldInfo$_ = null, this._$_saveState$_ = null, this._$_target$_ = null;
                }
                _$GetSourceAdapter$_() {
                    return this._$_sourceAdapter$_;
                }
                _$GetPropertyTrack$_() {
                    return this._$_propertyTrack$_;
                }
                _$GetWorldInfo$_() {
                    return this._$_worldInfo$_ || (this._$_worldInfo$_ = this._$_propertyTrack$_._$GetTrack$_()._$GetWorldInfo$_()), 
                    this._$_worldInfo$_;
                }
                _$SetFirstAbsoluteUpdate$_(t) {
                    this._$_firstAbsoluteUpdate$_ = !!t;
                }
                _$GetFirstAbsoluteUpdate$_() {
                    return this._$_firstAbsoluteUpdate$_;
                }
                _$SetResetState$_() {}
                _$SetInitialState$_() {}
                _$SetResumeState$_() {}
                _$SetSaveState$_() {
                    this._$_saveState$_ = this._$GetCurrentState$_();
                }
                _$ClearSaveState$_() {
                    this._$_saveState$_ = null;
                }
                _$GetCurrentState$_() {}
                _$CompareInitialStateWithCurrent$_() {}
                _$CompareSaveStateWithCurrent$_() {}
                _$CanChange$_(t) {
                    const e = typeof this._$_Getter$_(), s = typeof t;
                    return e == s;
                }
                _$BeforeChangeProperty$_() {}
                _$ChangeProperty$_(t, e, s, i, r, n, h, o) {}
                _$AfterChangeProperty$_() {}
                _$_FirstKeyframeGetter$_() {
                    const t = this._$_PickTimelinePlaybackMode$_(() => {
                        const t = this._$_propertyTrack$_._$GetPropertyTrackDataItem$_(), e = this._$_propertyTrack$_._$GetPropertyTrackData$_();
                        return e._$GetFirstPropertyKeyframeDataItem$_(t);
                    }, () => {
                        const t = this._$_propertyTrack$_._$GetPropertyTrackDataItem$_(), e = this._$_propertyTrack$_._$GetPropertyTrackData$_();
                        return e._$GetLastPropertyKeyframeDataItem$_(t);
                    });
                    return t._$GetAbsoluteValue$_();
                }
                _$_CurrentKeyframeGetter$_() {
                    const t = this._$_propertyTrack$_._$GetTimeline$_(), i = t._$GetTime$_() - this._$_propertyTrack$_._$GetTrack$_()._$GetStartOffset$_(), e = this._$_PickTimelinePlaybackMode$_(() => {
                        const t = this._$_propertyTrack$_._$GetPropertyTrackDataItem$_(), e = this._$_propertyTrack$_._$GetPropertyTrackData$_();
                        return e._$GetFirstPropertyKeyFrameDataItemLowerOrEqualThan$_(i, t);
                    }, () => {
                        const t = this._$_propertyTrack$_._$GetPropertyTrackDataItem$_(), e = this._$_propertyTrack$_._$GetPropertyTrackData$_(), s = e._$GetFirstPropertyKeyFrameDataItemHigherOrEqualThan$_(i, t);
                        return s || e._$GetLastPropertyKeyframeDataItem$_(t);
                    });
                    return e._$GetAbsoluteValue$_();
                }
                _$_PickTimelinePlaybackMode$_(t, e) {
                    const s = this._$_propertyTrack$_._$GetTimeline$_();
                    return (s._$IsForwardPlayBack$_() ? t : e)();
                }
                _$_PickResultMode$_(t, e) {
                    const s = this._$_propertyTrack$_._$GetResultMode$_();
                    return ("relative" === s ? t : e)();
                }
                _$_PickFirstAbsoluteUpdate$_(t, e) {
                    return (this._$GetFirstAbsoluteUpdate$_() ? (this._$SetFirstAbsoluteUpdate$_(!1), 
                    t) : e)();
                }
                _$_GetAbsoluteInitialValue$_(t) {}
                _$_GetIndex$_() {
                    return this._$_sourceAdapter$_._$GetIndex$_();
                }
                _$_GetTarget$_() {
                    return this._$_target$_ || (this._$_target$_ = this._$_sourceAdapter$_._$GetTarget$_()), 
                    this._$_target$_;
                }
                _$_PickSource$_(t, e, s, i, r, n) {
                    const h = this._$_propertyTrack$_._$GetSourceAdapterId$_();
                    switch (h) {
                      case "behavior":
                        return t();

                      case "effect":
                        return e();

                      case "instance-variable":
                        return s();

                      case "plugin":
                        return i();

                      case "world-instance":
                        return r();

                      case "audio":
                        return n();
                    }
                }
                _$_SaveToJson$_() {
                    return {
                        firstAbsoluteUpdate: this._$_firstAbsoluteUpdate$_,
                        saveState: this._$_saveState$_
                    };
                }
                _$_LoadFromJson$_(t) {
                    t && (this._$_firstAbsoluteUpdate$_ = t.firstAbsoluteUpdate, 
                    this._$_saveState$_ = t.saveState);
                }
                _$_GetPropertyKeyframeStubs$_(t, e = !1) {
                    const s = [];
                    for (const i of t) {
                        const r = i._$GetTrack$_()._$GetStartOffset$_();
                        for (const n of i._$GetPropertyKeyframeDataItems$_()) (e && 0 === n._$GetTime$_() || !e) && s.push({
                            time: r + n._$GetTime$_(),
                            value: n._$GetAbsoluteValue$_()
                        });
                    }
                    return s.sort((t, e) => t.time - e.time);
                }
                _$_GetLastPropertyKeyframeStub$_(t, e, s) {
                    return this._$_GetPropertyKeyframeStubLowerThanPlayhead$_(e, s);
                }
                _$_GetPropertyKeyframeStubLowerThanPlayhead$_(e, s) {
                    for (let t = s.length - 1; 0 <= t; t--) {
                        const i = s[t].time;
                        if (i <= e) return s[t];
                    }
                    return null;
                }
            };
        }
        {
            const C33 = self._$C3$_, TMP_COLORS_MAP = new Map(), TMP_COLOR = [ 0, 0, 0 ];
            class ColorInterpolationAdapter extends C33._$PropertyTrackState$_._$PropertyInterpolationAdapter$_ {
                constructor(t) {
                    super(t);
                }
                _$SetResetState$_() {}
                _$SetInitialState$_() {}
                _$SetResumeState$_() {}
                _$GetCurrentState$_() {
                    const t = this._$_propertyTrack$_._$GetSourceAdapterId$_(), e = this._$_GetTarget$_(), s = this._$_GetIndex$_();
                    switch (t) {
                      case "behavior":
                        return this._$_ToColorArray$_(e._$GetPropertyValueByIndex$_(s));

                      case "effect":
                        return this._$_ToColorArray$_(e[s]);

                      case "plugin":
                        return this._$_ToColorArray$_(e._$GetPropertyValueByIndex$_(s));

                      case "world-instance":
                        return this._$_ToColorArray$_(this._$_Getter$_());
                    }
                }
                _$CompareInitialStateWithCurrent$_() {
                    const t = this._$_FirstKeyframeGetter$_();
                    return !this._$_CompareColors$_(t, this._$_Getter$_());
                }
                _$CompareSaveStateWithCurrent$_() {
                    return !C33._$IsNullOrUndefined$_(this._$_saveState$_) && !this._$_CompareColors$_(this._$_saveState$_, this._$_Getter$_());
                }
                _$_CompareColors$_(t, e) {
                    return t = this._$_GetColorFromArray$_(t), e = this._$_GetColorFromArray$_(e), 
                    t._$equalsIgnoringAlpha$_(e);
                }
                _$_FirstKeyframeGetter$_() {
                    const t = super._$_FirstKeyframeGetter$_();
                    return this._$_GetColorFromArray$_(t);
                }
                _$_CurrentKeyframeGetter$_() {
                    const t = super._$_CurrentKeyframeGetter$_();
                    return this._$_GetColorFromArray$_(t);
                }
                _$_GetAbsoluteInitialValue$_(t) {}
                _$_ToColorArray$_(t) {
                    return (C33._$IsInstanceOf$_(t, C33._$Color$_) ? t.toArray() : t).slice(0, 3);
                }
                _$_GetColorFromArray$_(t) {
                    return C33._$IsInstanceOf$_(t, C33._$Color$_) ? t : new C33._$Color$_(t[0], t[1], t[2], 1);
                }
                _$CanChange$_(t) {
                    return !0;
                }
                _$MayNeedBeforeAndAfterInterpolate$_() {
                    return !0;
                }
                _$BeforeChangeProperty$_() {
                    const t = this._$_propertyTrack$_._$GetTimeline$_(), e = this._$_propertyTrack$_._$GetInstance$_(), s = this._$_propertyTrack$_._$GetSourceAdapter$_(), i = t._$GetSimilarPropertyTracks$_(e, s, this._$_property$_, this._$_propertyTrack$_);
                    if (i && 1 < i.length) {
                        TMP_COLORS_MAP.has(e) || TMP_COLORS_MAP.set(e, new Map());
                        const r = TMP_COLORS_MAP.get(e), n = this._$_propertyTrack$_._$GetSourceAdapterId$_(), h = (r.has(n) || r.set(n, new Map()), 
                        r.get(n));
                        h.has(this._$_property$_) || h.set(this._$_property$_, {
                            _$used$_: !1,
                            color: new C33._$Color$_(0, 0, 0, 1)
                        });
                    }
                }
                _$_GetTmpColor$_(t, e, s) {
                    const i = TMP_COLORS_MAP.get(t).get(e).get(s);
                    return i._$used$_ = !0, i.color;
                }
                _$ChangeProperty$_(t, e, s, i, r, n, h, o) {
                    const a = this._$_propertyTrack$_._$GetTimeline$_(), l = this._$_propertyTrack$_._$GetTrack$_(), u = this._$_propertyTrack$_._$GetInstance$_(), c = this._$_propertyTrack$_._$GetSourceAdapter$_(), f = this._$_propertyTrack$_._$GetSourceAdapterId$_(), d = this._$_property$_, p = a._$GetSimilarPropertyTracks$_(u, c, d, this._$_propertyTrack$_);
                    if (p && 1 < p.length) {
                        const m = this._$_GetPropertyKeyframeStubs$_(p, !0), C = this._$_GetLastPropertyKeyframeStub$_(a, a._$GetTime$_(), m);
                        if (C) {
                            const g = l._$GetStartOffset$_(), S = C.time - g;
                            if (0 == S) this._$_GetTmpColor$_(u, f, this._$_property$_)._$addRgb$_(e[0], e[1], e[2]); else if (!(S < 0)) {
                                const _ = e[0], T = e[1], y = e[2], E = this._$_propertyTrack$_._$Interpolate$_(S, !1, !0), A = C33._$Color$_._$DiffChannel$_(_, E[0]), I = C33._$Color$_._$DiffChannel$_(T, E[1]), M = C33._$Color$_._$DiffChannel$_(y, E[2]);
                                this._$_GetTmpColor$_(u, f, this._$_property$_)._$addRgb$_(A, I, M);
                            }
                        }
                    } else this._$_Setter$_(e[0], e[1], e[2]);
                }
                _$AfterChangeProperty$_() {
                    const t = this._$_propertyTrack$_._$GetInstance$_();
                    if (TMP_COLORS_MAP.has(t)) {
                        const e = TMP_COLORS_MAP.get(t), s = this._$_propertyTrack$_._$GetSourceAdapterId$_();
                        if (e.has(s)) {
                            const i = e.get(s);
                            if (i.has(this._$_property$_)) {
                                const r = i.get(this._$_property$_), n = r._$used$_, h = r.color;
                                n && this._$_Setter$_(h._$getR$_(), h._$getG$_(), h._$getB$_()), 
                                0 === i.size && e.delete(s), 0 === e.size && TMP_COLORS_MAP.delete(t);
                            }
                        }
                    }
                }
                _$_Getter$_() {
                    const t = this._$_propertyTrack$_._$GetSourceAdapterId$_(), e = this._$_GetTarget$_(), s = this._$_GetIndex$_();
                    switch (t) {
                      case "behavior":
                        return this._$_GetColorFromArray$_(e._$GetPropertyValueByIndex$_(s));

                      case "effect":
                        return e[s].clone();

                      case "plugin":
                        return this._$_GetColorFromArray$_(e._$GetPropertyValueByIndex$_(s));

                      case "world-instance":
                        return this._$GetWorldInfo$_()._$GetUnpremultipliedColor$_().clone();
                    }
                }
                _$_Setter$_(t, e, s) {
                    const i = this._$_propertyTrack$_._$GetSourceAdapterId$_(), r = this._$_GetTarget$_(), n = this._$_GetIndex$_();
                    switch (i) {
                      case "behavior":
                        TMP_COLOR[0] = t, TMP_COLOR[1] = e, TMP_COLOR[2] = s, r._$SetPropertyValueByIndex$_(n, TMP_COLOR);
                        break;

                      case "effect":
                        r[n]._$setRgb$_(t, e, s);
                        break;

                      case "plugin":
                        TMP_COLOR[0] = t, TMP_COLOR[1] = e, TMP_COLOR[2] = s, r._$SetPropertyValueByIndex$_(n, TMP_COLOR);
                        break;

                      case "world-instance":
                        this._$GetWorldInfo$_()._$SetUnpremultipliedColorRGB$_(t, e, s);
                    }
                }
                _$_SaveToJson$_() {}
                _$_LoadFromJson$_(t) {}
            }
            C33._$PropertyTrackState$_._$PropertyInterpolationAdapter$_._$ColorInterpolationAdapter$_ = ColorInterpolationAdapter;
        }
        {
            const C33 = self._$C3$_, NS = C33._$PropertyTrackState$_;
            class NoInterpolationAdapter extends C33._$PropertyTrackState$_._$PropertyInterpolationAdapter$_ {
                constructor(t) {
                    super(t);
                }
                _$SetResetState$_() {}
                _$SetInitialState$_() {}
                _$SetResumeState$_() {}
                _$GetCurrentState$_() {
                    return this._$_Getter$_();
                }
                _$CompareInitialStateWithCurrent$_() {
                    const t = this._$_FirstKeyframeGetter$_();
                    return t !== this._$GetCurrentState$_();
                }
                _$CompareSaveStateWithCurrent$_() {
                    return !C33._$IsNullOrUndefined$_(this._$_saveState$_) && this._$_saveState$_ !== this._$GetCurrentState$_();
                }
                _$MayNeedBeforeAndAfterInterpolate$_() {
                    return !1;
                }
                _$ChangeProperty$_(t, e, s, i, r, n, h, o) {
                    const a = this._$_propertyTrack$_, l = a._$GetTrack$_(), u = a._$GetSourceAdapterId$_(), c = a._$GetTimeline$_(), f = l._$GetInstance$_(), d = a._$GetSourceAdapter$_(), p = this._$_property$_, m = c._$GetSimilarPropertyTracks$_(f, d, p, a);
                    if (m && 1 < m.length) {
                        const g = this._$_GetPropertyKeyframeStubs$_(m), S = t + l._$GetStartOffset$_(), _ = this._$_GetLastPropertyKeyframeStub$_(c, S, g);
                        _ && (e = _.value);
                    }
                    const C = a._$GetPropertyKeyframeType$_();
                    switch (C) {
                      case "numeric":
                        if (NS._$NumericTypeAdapter$_._$WillChange$_(this._$_GetIndex$_(), this._$_GetTarget$_(), e, u)) break;
                        return;

                      case "angle":
                        if (NS._$AngleTypeAdapter$_._$WillChange$_(this._$_GetIndex$_(), this._$_GetTarget$_(), e, u)) break;
                        return;

                      case "boolean":
                        if (NS._$BooleanTypeAdapter$_._$WillChange$_(this._$_GetIndex$_(), this._$_GetTarget$_(), e, u)) break;
                        return;

                      case "color":
                        if (NS._$ColorTypeAdapter$_._$WillChange$_(this._$_GetIndex$_(), this._$_GetTarget$_(), e, u)) break;
                        return;

                      case "text":
                        if (!NS._$TextTypeAdapter$_._$WillChange$_(this._$_GetIndex$_(), this._$_GetTarget$_(), e, u)) return;
                    }
                    this._$_Setter$_(e);
                }
                _$_Getter$_() {
                    const t = this._$_propertyTrack$_._$GetSourceAdapterId$_(), e = this._$_GetTarget$_(), s = this._$_GetIndex$_();
                    switch (t) {
                      case "behavior":
                        return e._$GetPropertyValueByIndex$_(s);

                      case "effect":
                        return e[s];

                      case "instance-variable":
                        return e._$GetInstanceVariableValue$_(s);

                      case "plugin":
                        return e._$GetPropertyValueByIndex$_(s);
                    }
                }
                _$_Setter$_(t) {
                    const e = this._$_propertyTrack$_._$GetSourceAdapterId$_(), s = this._$_GetTarget$_(), i = this._$_GetIndex$_();
                    switch (e) {
                      case "behavior":
                        s._$SetPropertyValueByIndex$_(i, t);
                        break;

                      case "effect":
                        s[i] = t;
                        break;

                      case "instance-variable":
                        s._$SetInstanceVariableValue$_(i, t);
                        break;

                      case "plugin":
                        s._$SetPropertyValueByIndex$_(i, t);
                    }
                }
            }
            C33._$PropertyTrackState$_._$PropertyInterpolationAdapter$_._$NoInterpolationAdapter$_ = NoInterpolationAdapter;
        }
        {
            const C33 = self._$C3$_, NS = C33._$PropertyTrackState$_._$PropertyInterpolationAdapter$_, INSTANCE_FUNC_MAP = new Map(), add2 = (t, e, s, i, r, n = !1, h = null, o = null) => {
                INSTANCE_FUNC_MAP.set(t, {
                    _$setter$_: e,
                    _$absolute_setter$_: s,
                    _$getter$_: i,
                    round: r,
                    _$fRound$_: n,
                    init: h,
                    reset: o
                });
            };
            add2("offsetX", (t, e, s, i) => {
                "relative" === i._$_propertyTrack$_._$GetResultMode$_() ? t._$OffsetX$_(e, s._$GetTimeline$_()._$GetTransformWithSceneGraph$_()) : t._$OffsetX$_(e);
            }, (t, e) => t._$SetX$_(e), t => t._$GetX$_(), !0), add2("offsetY", (t, e, s, i) => {
                "relative" === i._$_propertyTrack$_._$GetResultMode$_() ? t._$OffsetY$_(e, s._$GetTimeline$_()._$GetTransformWithSceneGraph$_()) : t._$OffsetY$_(e);
            }, (t, e) => t._$SetY$_(e), t => t._$GetY$_(), !0), add2("offsetWidth", (e, t, o, s, i) => {
                if (0 !== t) {
                    const r = "relative" === s._$_propertyTrack$_._$GetResultMode$_(), l = 1 === s._$_typeAdapter$_._$GetType$_();
                    if ((r || l) && e._$HasParent$_() && e._$GetTransformWithParentWidth$_()) {
                        if (isNaN(s._$_absoluteToFactor$_)) {
                            let i = [], t = e._$GetParent$_();
                            for (;t; ) i.push(t), t = t._$GetParent$_();
                            i.reverse();
                            let a = (t, e) => e._$GetTimeline$_()._$GetTrackFromInstance$_(t._$GetInstance$_()), r = (t, e) => {
                                const s = a(t, e);
                                if (s) return s._$GetOriginalWidth$_();
                                const i = t._$GetInstance$_()._$GetSdkInstance$_();
                                return i._$IsOriginalSizeKnown$_() ? i._$GetOriginalWidth$_() : t._$_GetSceneGraphInfo$_()._$_GetStartWidth$_();
                            }, n = (t, e, s, i = 0) => {
                                const r = a(t, e);
                                if (!r) return i;
                                const n = r._$GetPropertyTrack$_(s);
                                if (!n) return i;
                                const h = n._$GetPropertyTrackDataItem$_()._$GetPropertyKeyframeData$_();
                                if (!h) return i;
                                const o = h._$GetLastPropertyKeyframeDataItem$_();
                                return o ? o._$GetValue$_() : i;
                            }, h;
                            if (l) {
                                let t = i[i.length - 1];
                                h = t._$GetWidth$_();
                            } else {
                                let e = i[0], t = e._$_GetSceneGraphInfo$_()._$_GetStartWidth$_(), s = e._$_GetSceneGraphInfo$_()._$GetStartScaleX$_();
                                h = t * s, h = (h += n(e, o, "offsetWidth")) + r(e, o) * n(e, o, "offsetScaleX");
                                for (let t = 1; t < i.length; t++) {
                                    const u = (e = i[t])._$_GetSceneGraphInfo$_()._$GetStartScaleX$_();
                                    h = (h = (h *= u) + n(e, o, "offsetWidth")) + r(e, o) * n(e, o, "offsetScaleX");
                                }
                            }
                            s._$_absoluteToFactor$_ = 0 === h ? Number.EPSILON : h;
                        }
                        i || e._$OffsetWidth$_(t / s._$_absoluteToFactor$_, !0);
                    } else e._$OffsetWidth$_(t);
                }
            }, (t, e) => t._$SetWidth$_(e), t => t._$GetWidth$_(), !0), add2("offsetHeight", (e, t, o, s, i) => {
                if (0 !== t) {
                    const r = "relative" === s._$_propertyTrack$_._$GetResultMode$_(), a = 1 === s._$_typeAdapter$_._$GetType$_();
                    if ((r || a) && e._$HasParent$_() && e._$GetTransformWithParentHeight$_()) {
                        if (isNaN(s._$_absoluteToFactor$_)) {
                            let i = [], t = e._$GetParent$_();
                            for (;t; ) i.push(t), t = t._$GetParent$_();
                            i.reverse();
                            let r = (t, e) => {
                                i = t;
                                const s = e._$GetTimeline$_()._$GetTrackFromInstance$_(i._$GetInstance$_());
                                var i;
                                if (s) return s._$GetOriginalHeight$_();
                                const r = t._$GetInstance$_()._$GetSdkInstance$_();
                                return r._$IsOriginalSizeKnown$_() ? r._$GetOriginalHeight$_() : t._$_GetSceneGraphInfo$_()._$_GetStartHeight$_();
                            }, n = (t, e, s, i = 0) => {
                                const r = e._$GetTimeline$_()._$GetTrackFromInstance$_(t._$GetInstance$_());
                                if (!r) return i;
                                const n = r._$GetPropertyTrack$_(s);
                                if (!n) return i;
                                const h = n._$GetPropertyTrackDataItem$_()._$GetPropertyKeyframeData$_();
                                if (!h) return i;
                                const o = h._$GetLastPropertyKeyframeDataItem$_();
                                return o ? o._$GetValue$_() : i;
                            }, h;
                            if (a) {
                                let t = i[i.length - 1];
                                h = t._$GetHeight$_();
                            } else {
                                let e = i[0], t = e._$_GetSceneGraphInfo$_()._$_GetStartHeight$_(), s = e._$_GetSceneGraphInfo$_()._$GetStartScaleY$_();
                                h = t * s, h = (h += n(e, o, "offsetHeight")) + r(e, o) * n(e, o, "offsetScaleY");
                                for (let t = 1; t < i.length; t++) {
                                    const l = (e = i[t])._$_GetSceneGraphInfo$_()._$GetStartScaleY$_();
                                    h = (h = (h *= l) + n(e, o)) + r(e, o) * n(e, o, "offsetScaleY");
                                }
                            }
                            s._$_absoluteToFactor$_ = 0 === h ? Number.EPSILON : h;
                        }
                        i || e._$OffsetHeight$_(t / s._$_absoluteToFactor$_, !0);
                    } else e._$OffsetHeight$_(t);
                }
            }, (t, e) => t._$SetHeight$_(e), t => t._$GetHeight$_(), !0), add2("offsetAngle", (t, e, s, i, r) => {
                t._$OffsetAngle$_(e);
            }, (t, e) => t._$SetAngle$_(e), t => t.GetAngle(), !1, !0), add2("offsetOpacity", (t, e, s, i, r) => {
                const n = i._$_opacityFactor$_ || 1, h = (e /= n, t._$GetOpacity$_()), o = h + e;
                if (0 === i._$_clampAccumulator$_) 1 < o ? i._$_clampAccumulator$_ += o - 1 : o < 0 && (i._$_clampAccumulator$_ += o), 
                t._$OffsetOpacity$_(e); else {
                    const a = t._$GetOpacity$_() + e;
                    0 < e && 0 < i._$_clampAccumulator$_ ? 1 < a && (i._$_clampAccumulator$_ += a - 1) : 0 < e && i._$_clampAccumulator$_ < 0 ? (i._$_clampAccumulator$_ += e, 
                    0 < i._$_clampAccumulator$_ && (t._$OffsetOpacity$_(i._$_clampAccumulator$_), 
                    i._$_clampAccumulator$_ = 0)) : e < 0 && 0 < i._$_clampAccumulator$_ ? (i._$_clampAccumulator$_ += e, 
                    i._$_clampAccumulator$_ < 0 && (t._$OffsetOpacity$_(i._$_clampAccumulator$_), 
                    i._$_clampAccumulator$_ = 0)) : e < 0 && i._$_clampAccumulator$_ < 0 && a < 0 && (i._$_clampAccumulator$_ += a);
                }
            }, (t, e) => {
                t._$SetOpacity$_(e);
            }, t => t._$GetOpacity$_(), !1, !0, (n, r, h) => {
                switch (n._$_clampAccumulator$_ = 0, n._$_propertyTrack$_._$GetResultMode$_()) {
                  case "relative":
                    {
                        n._$_propertyTrack$_._$GetPropertyTrackData$_();
                        let t = n._$_propertyTrack$_._$GetPropertyTrackDataItem$_(), e = t._$GetPropertyKeyframeData$_(), s = e._$GetPropertyKeyframeDataItemArray$_(), i = n._$GetWorldInfo$_()._$GetOpacity$_(), r = i;
                        for (const o of s) {
                            const a = o._$GetTime$_(), l = n._$_propertyTrack$_._$GetInterpolatedValue$_(a);
                            r = i + l, r = C33._$clamp$_(r, 0, 1);
                        }
                        n._$_totalForewardOpacityDelta$_ = i - r, n._$_totalForewardOpacityDelta$_ = Math.round(100 * (n._$_totalForewardOpacityDelta$_ + Number.EPSILON)) / 100, 
                        r = i;
                        for (let t = s.length - 1; 0 <= t; t--) {
                            const u = s[t]._$GetTime$_(), c = n._$_propertyTrack$_._$GetInterpolatedValue$_(u);
                            r -= c, r = C33._$clamp$_(r, 0, 1);
                        }
                        n._$_totalBackwardOpacityDelta$_ = r, n._$_totalBackwardOpacityDelta$_ = Math.round(100 * (n._$_totalBackwardOpacityDelta$_ + Number.EPSILON)) / 100;
                        break;
                    }
                }
                const t = "relative" === n._$_propertyTrack$_._$GetResultMode$_(), e = 1 === n._$_typeAdapter$_._$GetType$_();
                if ((t || e) && r._$HasParent$_() && r._$GetTransformWithParentOpacity$_()) {
                    let e = [], t = r._$GetParent$_();
                    for (;t; ) e.push(t), t = t._$GetParent$_();
                    e.reverse();
                    let s = (t, e, s) => {
                        const i = e._$GetTimeline$_()._$GetTrackFromInstance$_(t._$GetInstance$_());
                        if (!i) return 0;
                        const r = i._$GetPropertyTrack$_(s);
                        if (!r) return 0;
                        const n = r._$GetPropertyTrackDataItem$_()._$GetPropertyKeyframeData$_();
                        if (!n) return 0;
                        const h = n._$GetLastPropertyKeyframeDataItem$_();
                        return h ? h._$GetValue$_() : 0;
                    }, i = e[0]._$_GetSceneGraphInfo$_()._$GetStartOpacity$_();
                    i += s(e[0], h, "offsetOpacity");
                    for (let t = 1; t < e.length; t++) i += s(e[t], h, "offsetOpacity");
                    n._$_opacityFactor$_ = 0 === i ? 1 : i;
                }
            }, s => {
                switch (s._$_propertyTrack$_._$GetResultMode$_()) {
                  case "relative":
                    {
                        s._$_clampAccumulator$_ = 0;
                        let t = s._$GetWorldInfo$_(), e = t._$GetOpacity$_();
                        e = Math.round(100 * (e + Number.EPSILON)) / 100, s._$_propertyTrack$_._$GetTimeline$_()._$IsForwardPlayBack$_() ? (t._$SetOpacity$_(e + s._$_totalForewardOpacityDelta$_), 
                        s._$_lastValue$_ = 0) : (t._$SetOpacity$_(e - s._$_totalBackwardOpacityDelta$_), 
                        s._$_lastValue$_ = s._$GetSourceAdapter$_()._$GetValueAtTime$_());
                        break;
                    }
                }
            }), add2("offsetOriginX", (t, e) => t._$OffsetOriginX$_(e), (t, e) => t._$SetOriginX$_(e), t => t._$GetOriginX$_(), !1), 
            add2("offsetOriginY", (t, e) => t._$OffsetOriginY$_(e), (t, e) => t._$SetOriginY$_(e), t => t._$GetOriginY$_(), !1), 
            add2("offsetZElevation", (t, e) => t._$OffsetZElevation$_(e), (t, e) => t._$SetZElevation$_(e), t => t._$GetZElevation$_(), !0), 
            add2("offsetScaleX", (t, e, s, i) => {
                if (0 !== e) {
                    const r = t._$GetWidth$_() < 0 ? -1 : 1;
                    if ("relative" === i._$_propertyTrack$_._$GetResultMode$_() && t._$HasParent$_() && t._$GetTransformWithParentWidth$_()) {
                        const n = s._$GetOriginalWidth$_() * r * e;
                        isNaN(i._$_absoluteToFactor$_) && INSTANCE_FUNC_MAP.get("offsetWidth")._$setter$_(t, 1, s, i, !0), 
                        t._$OffsetWidth$_(n / i._$_absoluteToFactor$_, !0);
                    } else t._$OffsetWidth$_(s._$GetOriginalWidth$_() * r * e);
                }
            }, (t, e, s) => {
                t._$SetWidth$_(s._$GetOriginalWidth$_() * e);
            }, (i, r) => {
                const n = i._$GetWidth$_() < 0 ? -1 : 1;
                if (i._$GetTransformWithParentWidth$_()) {
                    let t = i._$GetParent$_(), e = r._$GetTimeline$_()._$GetTrackFromInstance$_(t._$GetInstance$_()), s = NaN;
                    if (e) s = t._$GetWidth$_() / e._$GetOriginalWidth$_(); else {
                        const h = t._$GetInstance$_()._$GetSdkInstance$_();
                        s = h._$IsOriginalSizeKnown$_() ? t._$GetWidth$_() / h._$GetOriginalWidth$_() : 1;
                    }
                    return i._$GetWidth$_() * n / (r._$GetOriginalWidth$_() * s);
                }
                return i._$GetWidth$_() * n / r._$GetOriginalWidth$_();
            }, !1), add2("offsetScaleY", (t, e, s, i) => {
                if (0 !== e) {
                    const r = t._$GetHeight$_() < 0 ? -1 : 1;
                    if ("relative" === i._$_propertyTrack$_._$GetResultMode$_() && t._$HasParent$_() && t._$GetTransformWithParentHeight$_()) {
                        const n = s._$GetOriginalHeight$_() * r * e;
                        isNaN(i._$_absoluteToFactor$_) && INSTANCE_FUNC_MAP.get("offsetHeight")._$setter$_(t, 1, s, i, !0), 
                        t._$OffsetHeight$_(n / i._$_absoluteToFactor$_, !0);
                    } else t._$OffsetHeight$_(s._$GetOriginalHeight$_() * r * e);
                }
            }, (t, e, s) => {
                t._$SetHeight$_(s._$GetOriginalHeight$_() * e);
            }, (i, r) => {
                const n = i._$GetHeight$_() < 0 ? -1 : 1;
                if (i._$GetTransformWithParentHeight$_()) {
                    let t = i._$GetParent$_(), e = r._$GetTimeline$_()._$GetTrackFromInstance$_(t._$GetInstance$_()), s = NaN;
                    if (e) s = t._$GetHeight$_() / e._$GetOriginalHeight$_(); else {
                        const h = t._$GetInstance$_()._$GetSdkInstance$_();
                        s = h._$IsOriginalSizeKnown$_() ? t._$GetHeight$_() / h._$GetOriginalHeight$_() : 1;
                    }
                    return i._$GetHeight$_() * n / (r._$GetOriginalHeight$_() * s);
                }
                return i._$GetHeight$_() * n / r._$GetOriginalHeight$_();
            }, !1);
            class NumericInterpolationAdapter extends C33._$PropertyTrackState$_._$PropertyInterpolationAdapter$_ {
                constructor(t) {
                    super(t), this._$_lastValue$_ = 0, this._$_clampAccumulator$_ = 0, 
                    this._$_totalForewardOpacityDelta$_ = 0, this._$_totalBackwardOpacityDelta$_ = 0, 
                    this._$_opacityFactor$_ = NaN, this._$_absoluteToFactor$_ = NaN, 
                    this._$_angleReflectMirrorOrFlip$_ = void 0, this._$_angleReflectMirrorAndFlip$_ = void 0, 
                    this._$_instance_getter$_ = null, this._$_instance_setter$_ = null, 
                    this._$_instance_absolute_setter$_ = null, this._$_reset_action$_ = null, 
                    this._$_init_action$_ = null, this._$_source_adapter_getter$_ = null, 
                    this._$_source_adapter_setter$_ = null, this._$_source_adapter_absolute_setter$_ = null, 
                    this._$_round$_ = !1, this._$_fRound$_ = !1, C33._$IsInstanceOf$_(this._$_propertyTrack$_._$GetTimeline$_(), C33._$TweenState$_) ? this._$_typeAdapter$_ = new C33._$PropertyTrackState$_._$PropertyInterpolationAdapter$_._$NumericInterpolationAdapterForTween$_(this) : this._$_typeAdapter$_ = new C33._$PropertyTrackState$_._$PropertyInterpolationAdapter$_._$NumericInterpolationAdapterForTimeline$_(this);
                    const e = this._$_propertyTrack$_._$GetPropertyName$_();
                    switch (this._$_propertyTrack$_._$GetSourceAdapterId$_()) {
                      case "world-instance":
                        {
                            const s = INSTANCE_FUNC_MAP.get(e);
                            this._$_instance_getter$_ = s._$getter$_, this._$_instance_setter$_ = s._$setter$_, 
                            this._$_instance_absolute_setter$_ = s._$absolute_setter$_, 
                            this._$_round$_ = s.round, this._$_fRound$_ = s._$fRound$_, 
                            this._$_init_action$_ = s.init, this._$_reset_action$_ = s.reset;
                            break;
                        }

                      case "audio":
                        this._$_source_adapter_getter$_ = t._$Getter$_, this._$_source_adapter_setter$_ = t._$Setter$_, 
                        this._$_source_adapter_absolute_setter$_ = t._$AbsoluteSetter$_, 
                        this._$_round$_ = !!t._$DoesRounding$_(), this._$_fRound$_ = !1;
                    }
                }
                _$Release$_() {
                    this._$_typeAdapter$_ = null, this._$_instance_getter$_ = null, 
                    this._$_instance_setter$_ = null, this._$_instance_absolute_setter$_ = null, 
                    this._$_reset_action$_ = null, this._$_init_action$_ = null, 
                    this._$_source_adapter_getter$_ = null, this._$_source_adapter_setter$_ = null, 
                    this._$_source_adapter_absolute_setter$_ = null, super._$Release$_();
                }
                _$MayNeedBeforeAndAfterInterpolate$_() {
                    return this._$_typeAdapter$_._$MayNeedBeforeAndAfterInterpolate$_();
                }
                _$GetLastValue$_() {
                    return this._$_lastValue$_;
                }
                _$SetLastValue$_(t) {
                    this._$_lastValue$_ = t;
                }
                _$SetResetState$_() {
                    this._$_reset_action$_ && this._$_reset_action$_(this);
                }
                _$SetInitialState$_() {
                    const t = this._$_typeAdapter$_._$SetInitialState$_();
                    if ("number" == typeof t && (this._$_lastValue$_ = t), this._$_init_action$_) {
                        const e = this._$GetWorldInfo$_(), s = this._$_propertyTrack$_._$GetTrack$_();
                        this._$_init_action$_(this, e, s);
                    }
                }
                _$SetResumeState$_() {
                    const t = this._$_typeAdapter$_._$SetResumeState$_();
                    "number" == typeof t && (this._$_lastValue$_ = t);
                }
                _$GetCurrentState$_() {
                    return this._$_Getter$_();
                }
                _$CompareInitialStateWithCurrent$_() {
                    const t = this._$_FirstKeyframeGetter$_();
                    return t !== this._$GetCurrentState$_();
                }
                _$CompareSaveStateWithCurrent$_() {
                    return !C33._$IsNullOrUndefined$_(this._$_saveState$_) && this._$_saveState$_ !== this._$GetCurrentState$_();
                }
                _$BeforeChangeProperty$_() {
                    this._$_typeAdapter$_._$BeforeChangeProperty$_();
                }
                _$ChangeProperty$_(t, e, s, i, r, n, h, o) {
                    return this._$_typeAdapter$_._$ChangeProperty$_(t, e, s, i, r, n, h, o);
                }
                _$AfterChangeProperty$_() {
                    this._$_typeAdapter$_._$AfterChangeProperty$_();
                }
                _$_Getter$_() {
                    const t = this._$_GetTarget$_(), e = this._$_GetIndex$_(), s = this._$GetWorldInfo$_(), i = this._$_propertyTrack$_._$GetTrack$_(), r = this._$_propertyTrack$_._$GetSourceAdapterId$_();
                    switch (r) {
                      case "behavior":
                        return t._$GetPropertyValueByIndex$_(e);

                      case "effect":
                        return t[e];

                      case "instance-variable":
                        return t._$GetInstanceVariableValue$_(e);

                      case "plugin":
                        return t._$GetPropertyValueByIndex$_(e);

                      case "world-instance":
                        return this._$_instance_getter$_(s, i);

                      case "audio":
                        return this._$_source_adapter_getter$_.call(this._$GetSourceAdapter$_(), s, i);
                    }
                }
                _$_Setter$_(t, e, s) {
                    const i = this._$_GetTarget$_(), r = this._$_GetIndex$_(), n = this._$GetWorldInfo$_(), h = this._$_propertyTrack$_._$GetTrack$_(), o = this._$_propertyTrack$_._$GetSourceAdapterId$_();
                    switch (o) {
                      case "behavior":
                        i._$OffsetPropertyValueByIndex$_(r, t);
                        break;

                      case "effect":
                        i[r] += t;
                        break;

                      case "instance-variable":
                        i._$SetInstanceVariableOffset$_(r, t);
                        break;

                      case "plugin":
                        i._$OffsetPropertyValueByIndex$_(r, t, this._$GetSourceAdapter$_()._$GetOptionalCallbacks$_());
                        break;

                      case "world-instance":
                        this._$_instance_setter$_(n, t, h, this);
                        break;

                      case "audio":
                        this._$_source_adapter_setter$_.call(this._$GetSourceAdapter$_(), n, t, h, this);
                    }
                }
                _$_SetterAbsolute$_(t, e, s) {
                    let i = this._$_propertyTrack$_._$GetInterpolationMode$_();
                    if ("discrete" !== (i = "default" === i ? "continuous" : i) || e) {
                        if ("discrete" === i && s) {
                            const l = this._$_propertyTrack$_._$GetTimeline$_(), u = l._$GetTime$_(), c = this._$_propertyTrack$_._$GetPropertyKeyFrameDataItemAtTime$_(u);
                            if (!c) return;
                        }
                        const r = this._$_GetTarget$_(), n = this._$_GetIndex$_(), h = this._$GetWorldInfo$_(), o = this._$_propertyTrack$_._$GetTrack$_(), a = this._$_propertyTrack$_._$GetSourceAdapterId$_();
                        switch (a) {
                          case "behavior":
                            r._$SetPropertyValueByIndex$_(n, t);
                            break;

                          case "effect":
                            r[n] = t;
                            break;

                          case "instance-variable":
                            r._$SetInstanceVariableValue$_(n, t);
                            break;

                          case "plugin":
                            r._$SetPropertyValueByIndex$_(n, t, this._$GetSourceAdapter$_()._$GetOptionalCallbacks$_());
                            break;

                          case "world-instance":
                            this._$_instance_absolute_setter$_(h, t, o);
                            break;

                          case "audio":
                            this._$_source_adapter_absolute_setter$_.call(this._$GetSourceAdapter$_(), h, t, o);
                        }
                    }
                }
                _$_MaybeEnsureValue$_(t, e, s, i, r, n, h, o) {
                    this._$_typeAdapter$_._$_MaybeEnsureValue$_(t, e, s, i, r, n, h, o);
                }
                _$_AddDelta$_(t, e, s, i, r) {
                    let n = (t = "angle" === this._$_propertyTrack$_._$GetPropertyType$_() ? C33._$toDegrees$_(t) : t).toString(), h = n.split(".")[1] || "", o = h.length, a = this._$_Getter$_(), l;
                    switch (l = 0 === o ? this._$_round$_ ? Math.round(a) : this._$_fRound$_ ? "angle" === this._$_propertyTrack$_._$GetPropertyType$_() ? C33._$toRadians$_(Math.round(C33._$toDegrees$_(a))) : Number(C33.toFixed(a, 2)) : a : this._$_round$_ ? Number(C33.toFixed(a, o)) : (this._$_fRound$_, 
                    a), this._$_Setter$_(l - a, e, s), this._$_propertyTrack$_._$GetPropertyName$_()) {
                      case "offsetWidth":
                      case "offsetScaleX":
                        {
                            const u = this._$GetWorldInfo$_(), c = u._$GetWidth$_(), f = Number(C33.toFixed(c, 2));
                            u._$OffsetWidth$_(f - c);
                            break;
                        }

                      case "offsetHeight":
                      case "offsetScaleY":
                        {
                            const d = this._$GetWorldInfo$_(), p = d._$GetHeight$_(), m = Number(C33.toFixed(p, 2));
                            d._$OffsetHeight$_(m - p);
                            break;
                        }
                    }
                }
                _$_SaveToJson$_() {
                    return Object.assign(super._$_SaveToJson$_(), {
                        v: this._$_lastValue$_,
                        a: this._$_clampAccumulator$_,
                        fod: this._$_totalForewardOpacityDelta$_,
                        bod: this._$_totalBackwardOpacityDelta$_,
                        of: this._$_opacityFactor$_,
                        sf: this._$_absoluteToFactor$_,
                        armorf: this._$_angleReflectMirrorOrFlip$_,
                        armandf: this._$_angleReflectMirrorAndFlip$_
                    });
                }
                _$_LoadFromJson$_(t) {
                    t && (super._$_LoadFromJson$_(t), this._$_lastValue$_ = t.v, 
                    this._$_clampAccumulator$_ = t.a, this._$_totalForewardOpacityDelta$_ = C33._$IsFiniteNumber$_(t.fod) ? t.fod : 0, 
                    this._$_totalBackwardOpacityDelta$_ = C33._$IsFiniteNumber$_(t.bod) ? t.bod : 0, 
                    this._$_opacityFactor$_ = C33._$IsFiniteNumber$_(t.of) ? t.of : NaN, 
                    this._$_absoluteToFactor$_ = C33._$IsFiniteNumber$_(t.sf) ? t.sf : NaN, 
                    this._$_angleReflectMirrorOrFlip$_ = C33._$IsFiniteNumber$_(t.armorf) ? t.armorf : void 0, 
                    this._$_angleReflectMirrorAndFlip$_ = C33._$IsFiniteNumber$_(t.armandf) ? t.armandf : void 0);
                }
            }
            C33._$PropertyTrackState$_._$PropertyInterpolationAdapter$_._$NumericInterpolationAdapter$_ = NumericInterpolationAdapter;
        }
        {
            const C33 = self._$C3$_;
            class AbsoluteValueObject {
                constructor(t) {
                    this._$_used$_ = !1, this._$_value$_ = 0, this._$_propertyKeyframeReached$_ = !1, 
                    this._$_endState$_ = !1, this._$_propertyTracks$_ = t;
                    for (let t = 0, e = this._$_propertyTracks$_.length; t < e; t++) this._$_propertyTracks$_[t]._$SetAbsoluteValueObject$_(this);
                }
                _$GetPropertyTracks$_() {
                    return this._$_propertyTracks$_;
                }
                _$SetUsed$_() {
                    this._$_used$_ = !0;
                }
                _$GetUsed$_() {
                    return this._$_used$_;
                }
                _$SetValue$_(t) {
                    this._$_value$_ = t;
                }
                _$GetValue$_() {
                    return this._$_value$_;
                }
                _$SetPropertyKeyframeReached$_(t) {
                    this._$_propertyKeyframeReached$_ = t;
                }
                _$GetPropertyKeyframeReached$_() {
                    return this._$_propertyKeyframeReached$_;
                }
                _$SetEndState$_(t) {
                    this._$_endState$_ = t;
                }
                _$GetEndState$_() {
                    return this._$_endState$_;
                }
                _$Reset$_() {
                    this._$_used$_ = !1, this._$_value$_ = 0, this._$_propertyKeyframeReached$_ = !1, 
                    this._$_endState$_ = !1;
                }
            }
            class NumericInterpolationAdapterForTimeline {
                constructor(t) {
                    this._$_numericInterpolationAdapter$_ = t;
                }
                _$Release$_() {
                    this._$_numericInterpolationAdapter$_ = null;
                }
                _$GetType$_() {
                    return 0;
                }
                _$SetInitialState$_() {
                    const t = this._$_numericInterpolationAdapter$_;
                    return this._$_numericInterpolationAdapter$_._$GetPropertyTrack$_(), 
                    t._$_PickResultMode$_(() => t._$_PickTimelinePlaybackMode$_(() => 0, () => t._$GetSourceAdapter$_()._$GetValueAtTime$_()), () => {});
                }
                _$SetResumeState$_() {}
                _$MayNeedBeforeAndAfterInterpolate$_() {
                    this._$_numericInterpolationAdapter$_;
                    const t = this._$_numericInterpolationAdapter$_._$GetPropertyTrack$_();
                    switch (t._$GetResultMode$_()) {
                      case "relative":
                        return !1;

                      case "absolute":
                        return !0;
                    }
                }
                _$BeforeChangeProperty$_() {
                    this._$_numericInterpolationAdapter$_;
                    const t = this._$_numericInterpolationAdapter$_._$GetPropertyTrack$_(), e = t._$GetPropertyName$_();
                    switch (t._$GetResultMode$_()) {
                      case "relative":
                        break;

                      case "absolute":
                        if (t._$HasAbsoluteValueObject$_()) {
                            const s = t._$GetAbsoluteValueObject$_();
                            s._$Reset$_();
                        } else {
                            const i = t._$GetTimeline$_(), r = t._$GetInstance$_(), n = t._$GetSourceAdapter$_(), h = i._$GetSimilarPropertyTracks$_(r, n, e, t);
                            h && 1 < h.length && new AbsoluteValueObject(h);
                        }
                    }
                }
                _$ChangeProperty$_(t, e, s, i, r, n, h, o) {
                    const a = this._$_numericInterpolationAdapter$_, l = this._$_numericInterpolationAdapter$_._$GetPropertyTrack$_();
                    switch (l._$GetResultMode$_()) {
                      case "relative":
                        {
                            const u = a._$GetLastValue$_();
                            a._$_Setter$_(e - u, s, i), n && this._$_MaybeEnsureValue$_(t, s, i, r, u, e), 
                            a._$SetLastValue$_(e);
                            break;
                        }

                      case "absolute":
                        {
                            const c = l._$GetTimeline$_(), f = l._$GetTrack$_();
                            if (l._$GetInstance$_(), l._$GetSourceAdapter$_(), l._$HasAbsoluteValueObject$_()) {
                                const d = l._$GetAbsoluteValueObject$_(), p = d._$GetPropertyTracks$_(), m = a._$_GetPropertyKeyframeStubs$_(p, !0), C = a._$_GetLastPropertyKeyframeStub$_(c, c._$GetTime$_(), m);
                                if (C) {
                                    const g = f._$GetStartOffset$_(), S = C.time - g;
                                    if (0 == S) d._$SetEndState$_(h), d._$SetPropertyKeyframeReached$_(o), 
                                    d._$SetUsed$_(), d._$SetValue$_(d._$GetValue$_() + e); else {
                                        if (S < 0) return;
                                        const _ = l._$GetInterpolatedValue$_(S);
                                        d._$SetEndState$_(h), d._$SetPropertyKeyframeReached$_(o), 
                                        d._$SetUsed$_(), d._$SetValue$_(d._$GetValue$_() + (e - _));
                                    }
                                }
                            } else a._$_SetterAbsolute$_(e, o, h);
                            break;
                        }
                    }
                }
                _$AfterChangeProperty$_() {
                    const t = this._$_numericInterpolationAdapter$_, e = this._$_numericInterpolationAdapter$_._$GetPropertyTrack$_();
                    switch (e._$GetResultMode$_()) {
                      case "relative":
                        break;

                      case "absolute":
                        if (e._$HasAbsoluteValueObject$_()) {
                            const s = e._$GetAbsoluteValueObject$_();
                            s._$GetUsed$_() && t._$_SetterAbsolute$_(s._$GetValue$_(), s._$GetPropertyKeyframeReached$_(), s._$GetEndState$_());
                        }
                    }
                }
                _$_MaybeEnsureValue$_(t, e, s, i, r, n) {
                    const h = this._$_numericInterpolationAdapter$_;
                    i || (e && t === e._$GetTime$_() ? h._$_AddDelta$_(e._$GetValueWithResultMode$_(), e, s) : s && t === s._$GetTime$_() ? h._$_AddDelta$_(s._$GetValueWithResultMode$_(), e, s) : n - r == 0 && h._$_AddDelta$_(e._$GetValueWithResultMode$_(), e, s));
                }
            }
            C33._$PropertyTrackState$_._$PropertyInterpolationAdapter$_._$NumericInterpolationAdapterForTimeline$_ = NumericInterpolationAdapterForTimeline;
        }
        {
            const C33 = self._$C3$_;
            class NumericInterpolationAdapterForTween {
                constructor(t) {
                    this._$_numericInterpolationAdapter$_ = t;
                }
                _$Release$_() {
                    this._$_numericInterpolationAdapter$_ = null;
                }
                _$GetType$_() {
                    return 1;
                }
                _$SetInitialState$_() {
                    const t = this._$_numericInterpolationAdapter$_;
                    return t._$SetFirstAbsoluteUpdate$_(!0), this._$_GetAbsoluteInitialValue$_(t._$_FirstKeyframeGetter$_());
                }
                _$SetResumeState$_() {
                    const t = this._$_numericInterpolationAdapter$_;
                    if (t._$_FirstKeyframeGetter$_() !== t._$_CurrentKeyframeGetter$_()) return t._$SetFirstAbsoluteUpdate$_(!0), 
                    this._$_GetAbsoluteInitialValue$_(t._$_CurrentKeyframeGetter$_());
                }
                _$MayNeedBeforeAndAfterInterpolate$_() {
                    return !1;
                }
                _$BeforeChangeProperty$_() {}
                _$ChangeProperty$_(t, e, s, i, r, n, h, o) {
                    const a = this._$_numericInterpolationAdapter$_, l = a._$GetLastValue$_();
                    switch (a._$GetPropertyTrack$_()._$GetResultMode$_()) {
                      case "relative":
                        a._$_Setter$_(e - l, s, i), n && this._$_MaybeEnsureValue$_(t, s, i, r, l, e, !1, h);
                        break;

                      case "absolute":
                        a._$GetFirstAbsoluteUpdate$_() ? (a._$SetFirstAbsoluteUpdate$_(!1), 
                        a._$_Setter$_(l, s, i)) : 0 === t && 0 === a._$GetPropertyTrack$_()._$GetTimeline$_()._$GetTotalTime$_() ? a._$_SetterAbsolute$_(e, !0, !1) : (a._$_Setter$_(e - l, s, i), 
                        n && this._$_MaybeEnsureValue$_(t, s, i, r, l, e, this._$_ForceEndValue$_(), h));
                    }
                    a._$SetLastValue$_(e);
                }
                _$AfterChangeProperty$_() {}
                _$_GetAbsoluteInitialValue$_(t) {
                    const e = this._$_numericInterpolationAdapter$_;
                    return t - e._$GetCurrentState$_();
                }
                _$_ForceEndValue$_() {
                    let t = this._$_numericInterpolationAdapter$_, e = t._$GetWorldInfo$_()._$GetInstance$_(), s = t._$GetPropertyTrack$_()._$GetRuntime$_(), i = s._$GetTimelineManager$_(), r = 0;
                    for (const n of i._$GetPlayingTimelines$_()) 0 === n._$GetType$_() ? n._$HasTrackInstance$_(e) && r++ : 1 === n._$GetType$_() && n._$GetInstance$_() === e && r++;
                    return r <= 1;
                }
                _$_MaybeEnsureValue$_(t, e, s, i, r, n, h, o) {
                    const a = this._$_numericInterpolationAdapter$_;
                    i ? e && t === e._$GetTime$_() ? a._$_AddDelta$_(e._$GetValueWithResultMode$_(), e, s, h, o) : s && t === s._$GetTime$_() ? a._$_AddDelta$_(s._$GetValueWithResultMode$_(), e, s, h, o) : s || a._$_AddDelta$_(e._$GetValueWithResultMode$_(), e, s, h, o) : e && t === e._$GetTime$_() ? a._$_AddDelta$_(e._$GetValueWithResultMode$_(), e, s, h, o) : s && t === s._$GetTime$_() ? a._$_AddDelta$_(s._$GetValueWithResultMode$_(), e, s, h, o) : n - r == 0 && a._$_AddDelta$_(e._$GetValueWithResultMode$_(), e, s, h, o);
                }
            }
            C33._$PropertyTrackState$_._$PropertyInterpolationAdapter$_._$NumericInterpolationAdapterForTween$_ = NumericInterpolationAdapterForTween;
        }
        {
            const C33 = self._$C3$_, Ease = self._$Ease$_;
            C33._$PropertyTrackState$_._$NumericTypeAdapter$_ = class {
                constructor() {}
                static _$WillChange$_(t, e, s, i) {
                    let r;
                    switch (i) {
                      case "behavior":
                        r = e._$GetPropertyValueByIndex$_(t);
                        break;

                      case "effect":
                        r = e[t];
                        break;

                      case "instance-variable":
                        r = e._$GetInstanceVariableValue$_(t);
                        break;

                      case "plugin":
                        r = e._$GetPropertyValueByIndex$_(t);
                    }
                    return r !== s;
                }
                static _$Interpolate$_(n, h, o, a) {
                    if (!o) {
                        let t = a._$GetPropertyTrackDataItem$_(), e = a._$GetPropertyTrackData$_();
                        return (t = e._$GetLastPropertyKeyframeDataItem$_(t))._$GetValueWithResultMode$_();
                    }
                    let l = a._$GetInterpolationMode$_();
                    if ("default" === l && (l = "continuous"), "discrete" === (l = "combo" === a._$GetPropertyType$_() ? "discrete" : l)) return h._$GetValueWithResultMode$_();
                    if ("continuous" === l || "step" === l) {
                        const u = a._$GetTimeline$_()._$GetStep$_();
                        if ("step" === l && 0 !== u) {
                            const C = 1 / u;
                            n = Math.floor(n * C) / C;
                        }
                        const c = h._$GetValueWithResultMode$_(), f = o._$GetValueWithResultMode$_(), d = h._$GetAddOn$_("cubic-bezier"), p = o._$GetAddOn$_("cubic-bezier"), m = d && d._$GetStartEnable$_() && p && p._$GetEndEnable$_();
                        if (!m && c === f) return c;
                        let t = h._$GetTime$_(), e = o._$GetTime$_(), s = ("step" === l && 0 !== u && (n = C33._$clamp$_(n, t, e)), 
                        C33.normalize(n, t, e)), i = h._$GetEase$_(), r;
                        if (m) {
                            const g = e - t;
                            r = Ease._$GetRuntimeEase$_(i)(g * s, 0, 1, g), r = Ease._$GetRuntimeEase$_("cubicbezier")(r, c, c + d._$GetStartAnchor$_(), f + p._$GetEndAnchor$_(), f);
                        } else r = Ease._$GetRuntimeEase$_(i)((e - t) * s, c, f - c, e - t);
                        return "integer" === a._$GetPropertyType$_() ? Math.floor(r) : r;
                    }
                }
            };
        }
        {
            const C33 = self._$C3$_;
            C33._$PropertyTrackState$_._$AngleTypeAdapter$_ = class {
                constructor() {}
                static _$WillChange$_(t, e, s, i) {
                    let r;
                    switch (i) {
                      case "behavior":
                        r = e._$GetPropertyValueByIndex$_(t);
                        break;

                      case "effect":
                        r = e[t];
                        break;

                      case "instance-variable":
                        r = e._$GetInstanceVariableValue$_(t);
                        break;

                      case "plugin":
                        r = e._$GetPropertyValueByIndex$_(t);
                    }
                    return r !== s;
                }
                static _$Interpolate$_(t, e, s, i) {
                    if (!s) {
                        let t = i._$GetPropertyTrackDataItem$_(), e = i._$GetPropertyTrackData$_();
                        return (t = e._$GetLastPropertyKeyframeDataItem$_(t))._$GetValueWithResultMode$_();
                    }
                    let r = i._$GetInterpolationMode$_();
                    if ("default" === r && (r = "continuous"), "discrete" === (r = "combo" === i._$GetPropertyType$_() ? "discrete" : r)) return e._$GetValueWithResultMode$_();
                    if ("continuous" === r || "step" === r) {
                        const n = i._$GetTimeline$_()._$GetStep$_();
                        if ("step" === r && 0 !== n) {
                            const c = 1 / n;
                            t = Math.floor(t * c) / c;
                        }
                        const h = e._$GetTime$_(), o = s._$GetTime$_(), a = e._$GetValueWithResultMode$_(), l = s._$GetValueWithResultMode$_(), u = ("step" === r && 0 !== n && (t = C33._$clamp$_(t, h, o)), 
                        e._$GetAddOn$_("angle"));
                        if (!u) {
                            if (a === l) return a;
                            const f = C33.normalize(t, h, o), d = self._$Ease$_._$GetRuntimeEase$_(e._$GetEase$_());
                            return C33._$angleLerp$_(a, l, d(f, 0, 1, 1));
                        }
                        {
                            const p = u._$GetRevolutions$_();
                            if (a === l && 0 === p) return a;
                            const m = C33.normalize(t, h, o), C = self._$Ease$_._$GetRuntimeEase$_(e._$GetEase$_()), g = C(m, 0, 1, 1);
                            switch (u._$GetDirection$_()) {
                              case "closest":
                                return C33._$angleLerp$_(a, l, g, p);

                              case "clockwise":
                                return C33._$angleLerpClockwise$_(a, l, g, p);

                              case "anti-clockwise":
                                return C33._$angleLerpAntiClockwise$_(a, l, g, p);
                            }
                        }
                    }
                }
            };
        }
        {
            const C33 = self._$C3$_;
            C33._$PropertyTrackState$_._$BooleanTypeAdapter$_ = class {
                constructor() {}
                static _$WillChange$_(t, e, s, i) {
                    let r;
                    switch (i) {
                      case "behavior":
                        r = e._$GetPropertyValueByIndex$_(t);
                        break;

                      case "effect":
                        r = e[t];
                        break;

                      case "instance-variable":
                        r = e._$GetInstanceVariableValue$_(t);
                        break;

                      case "plugin":
                        r = e._$GetPropertyValueByIndex$_(t);
                    }
                    return !!r != !!s;
                }
                static _$Interpolate$_(t, e, s, i) {
                    if (s) return e._$GetValueWithResultMode$_() ? 1 : 0;
                    {
                        let t = i._$GetPropertyTrackDataItem$_(), e = i._$GetPropertyTrackData$_();
                        return (t = e._$GetLastPropertyKeyframeDataItem$_(t))._$GetValueWithResultMode$_() ? 1 : 0;
                    }
                }
            };
        }
        {
            const C33 = self._$C3$_, TEMP_COLOR_ARRAY = [ 0, 0, 0 ], TEMP_COLOR_ARRAY_2 = [ 0, 0, 0 ], TEMP_COLOR_ARRAY_3 = [ 0, 0, 0 ];
            C33._$PropertyTrackState$_._$ColorTypeAdapter$_ = class {
                constructor() {}
                static _$WillChange$_(t, e, s, i) {
                    let r;
                    switch (i) {
                      case "behavior":
                        r = e._$GetPropertyValueByIndex$_(t);
                        break;

                      case "effect":
                        r = e[t];
                        break;

                      case "instance-variable":
                        r = e._$GetInstanceVariableValue$_(t);
                        break;

                      case "plugin":
                        r = e._$GetPropertyValueByIndex$_(t);
                    }
                    return Array.isArray(s) ? (TEMP_COLOR_ARRAY[0] = s[0], TEMP_COLOR_ARRAY[1] = s[1], 
                    TEMP_COLOR_ARRAY[2] = s[2]) : (TEMP_COLOR_ARRAY_3._$parseCommaSeparatedRgb$_(s), 
                    TEMP_COLOR_ARRAY[0] = Math.floor(255 * TEMP_COLOR_ARRAY_3._$getR$_()), 
                    TEMP_COLOR_ARRAY[1] = Math.floor(255 * TEMP_COLOR_ARRAY_3._$getG$_()), 
                    TEMP_COLOR_ARRAY[2] = Math.floor(255 * TEMP_COLOR_ARRAY_3._$getB$_())), 
                    Array.isArray(r) ? (TEMP_COLOR_ARRAY_2[0] = r[0], TEMP_COLOR_ARRAY_2[1] = r[1], 
                    TEMP_COLOR_ARRAY_2[2] = r[2]) : (TEMP_COLOR_ARRAY_3._$parseCommaSeparatedRgb$_(r), 
                    TEMP_COLOR_ARRAY_2[0] = Math.floor(255 * TEMP_COLOR_ARRAY_3._$getR$_()), 
                    TEMP_COLOR_ARRAY_2[1] = Math.floor(255 * TEMP_COLOR_ARRAY_3._$getG$_()), 
                    TEMP_COLOR_ARRAY_2[2] = Math.floor(255 * TEMP_COLOR_ARRAY_3._$getB$_())), 
                    TEMP_COLOR_ARRAY[0] !== TEMP_COLOR_ARRAY_2[0] || TEMP_COLOR_ARRAY[1] !== TEMP_COLOR_ARRAY_2[1] || TEMP_COLOR_ARRAY[2] !== TEMP_COLOR_ARRAY_2[2];
                }
                static _$Interpolate$_(t, e, s, i) {
                    if (!s) {
                        let t = i._$GetPropertyTrackDataItem$_(), e = i._$GetPropertyTrackData$_(), s = (t = e._$GetLastPropertyKeyframeDataItem$_(t))._$GetValueWithResultMode$_();
                        return TEMP_COLOR_ARRAY[0] = s[0], TEMP_COLOR_ARRAY[1] = s[1], 
                        TEMP_COLOR_ARRAY[2] = s[2], TEMP_COLOR_ARRAY;
                    }
                    let r = i._$GetInterpolationMode$_();
                    if ("discrete" === (r = "default" === r ? "continuous" : r)) {
                        const n = e._$GetValueWithResultMode$_();
                        return TEMP_COLOR_ARRAY[0] = n[0], TEMP_COLOR_ARRAY[1] = n[1], 
                        TEMP_COLOR_ARRAY[2] = n[2], TEMP_COLOR_ARRAY;
                    }
                    if ("continuous" === r || "step" === r) {
                        const h = i._$GetTimeline$_()._$GetStep$_();
                        if ("step" === r && 0 !== h) {
                            const E = 1 / h;
                            t = Math.floor(t * E) / E;
                        }
                        const o = e._$GetTime$_(), a = s._$GetTime$_(), l = e._$GetValueWithResultMode$_(), u = s._$GetValueWithResultMode$_(), c = ("step" === r && 0 !== h && (t = C33._$clamp$_(t, o, a)), 
                        C33.normalize(t, o, a)), f = e._$GetEase$_(), d = l[0], p = l[1], m = l[2], C = u[0], g = u[1], S = u[2], _ = self._$Ease$_._$GetRuntimeEase$_(f), T = a - o, y = T * c;
                        return TEMP_COLOR_ARRAY[0] = d === C ? d : _(y, d, C - d, T), 
                        TEMP_COLOR_ARRAY[1] = p === g ? p : _(y, p, g - p, T), TEMP_COLOR_ARRAY[2] = m === S ? m : _(y, m, S - m, T), 
                        TEMP_COLOR_ARRAY;
                    }
                }
            };
        }
        {
            const C33 = self._$C3$_;
            C33._$PropertyTrackState$_._$TextTypeAdapter$_ = class {
                constructor() {}
                static _$WillChange$_(t, e, s, i) {
                    let r;
                    switch (i) {
                      case "behavior":
                        r = e._$GetPropertyValueByIndex$_(t);
                        break;

                      case "effect":
                        r = e[t];
                        break;

                      case "instance-variable":
                        r = e._$GetInstanceVariableValue$_(t);
                        break;

                      case "plugin":
                        r = e._$GetPropertyValueByIndex$_(t);
                    }
                    return r !== s;
                }
                static _$Interpolate$_(t, e, s, i) {
                    if (s) return e._$GetValueWithResultMode$_();
                    {
                        let t = i._$GetPropertyTrackDataItem$_(), e = i._$GetPropertyTrackData$_();
                        return (t = e._$GetLastPropertyKeyframeDataItem$_(t))._$GetValueWithResultMode$_();
                    }
                }
            };
        }
        {
            const C33 = self._$C3$_;
            C33._$TimelineDataManager$_ = class {
                constructor() {
                    this._$_timelineDataItems$_ = new Map();
                }
                _$Release$_() {
                    for (const t of this._$_timelineDataItems$_.values()) t._$Release$_();
                    this._$_timelineDataItems$_.clear(), this._$_timelineDataItems$_ = null;
                }
                _$Add$_(t) {
                    const e = new C33._$TimelineDataItem$_(t), s = e._$GetName$_();
                    this._$_timelineDataItems$_.set(s, e);
                }
                _$Get$_(t) {
                    return this._$_timelineDataItems$_.get(t);
                }
                _$GetNameId$_() {
                    return 0;
                }
                static _$_CreateDataItems$_(t, e, s, i) {
                    if (e) for (const r of e) C33._$TimelineDataManager$_._$_CreateDataItem$_("create", r, t, s, i);
                }
                static _$_CreateDataItemsIncludingDisabled$_(t, e, s, i) {
                    if (e) for (const r of e) C33._$TimelineDataManager$_._$_CreateDataItem$_("create-including-disabled", r, t, s, i);
                }
                static _$_LoadDataItemsFromJson$_(s, t, e, i) {
                    s.length ? t.forEach((t, e) => {
                        s[e]._$_LoadFromJson$_(t);
                    }) : t.forEach(t => {
                        C33._$TimelineDataManager$_._$_CreateDataItem$_("load", t, s, e, i);
                    });
                }
                static _$_CreateDataItem$_(t, e, s, i, r) {
                    let n;
                    if ("function" == typeof i) switch (t) {
                      case "load":
                        n = new i(null, r);
                        break;

                      case "create":
                      case "create-including-disabled":
                        n = new i(e, r);
                    } else if ("object" == typeof i) {
                        const h = i.prop, o = e[h], a = i.map.get(o);
                        switch (t) {
                          case "load":
                            n = new a(null, r);
                            break;

                          case "create":
                          case "create-including-disabled":
                            n = new a(e, r);
                        }
                    }
                    switch (t) {
                      case "load":
                        n._$_LoadFromJson$_(e), s.push(n);
                        break;

                      case "create":
                        if ("function" == typeof n._$GetEnable$_ && !n._$GetEnable$_()) return n._$Release$_();
                        s.push(n);
                        break;

                      case "create-including-disabled":
                        s.push(n);
                    }
                }
            };
        }
        {
            const C33 = self._$C3$_, NAME = 0, TOTAL_TIME = 1, STEP = 2, INTERPOLATION_MODE = 3, RESULT_MODE = 4, TRACKS = 5, LOOP = 6, PING_PONG = 7, REPEAT_COUNT = 8, START_ON_LAYOUT = 9, TRANSFORM_WITH_SCENE_GRAPH = 10, USE_SYSTEM_TIMESCALE = 11;
            C33._$TimelineDataItem$_ = class {
                constructor(t) {
                    this._$_name$_ = "", this._$_totalTime$_ = NaN, this._$_step$_ = 0, 
                    this._$_interpolationMode$_ = "default", this._$_resultMode$_ = "default", 
                    this._$_loop$_ = !1, this._$_pingPong$_ = !1, this._$_repeatCount$_ = 1, 
                    this._$_trackData$_ = null, this._$_startOnLayout$_ = "", this._$_transformWithSceneGraph$_ = !1, 
                    this._$_useSystemTimescale$_ = !0, t && (this._$_name$_ = t[NAME], 
                    this._$_totalTime$_ = t[TOTAL_TIME], this._$_step$_ = t[STEP], 
                    this._$_interpolationMode$_ = t[INTERPOLATION_MODE], this._$_resultMode$_ = t[RESULT_MODE], 
                    this._$_loop$_ = !!t[LOOP], this._$_pingPong$_ = !!t[PING_PONG], 
                    this._$_repeatCount$_ = t[REPEAT_COUNT], this._$_startOnLayout$_ = t[START_ON_LAYOUT], 
                    this._$_transformWithSceneGraph$_ = !!t[TRANSFORM_WITH_SCENE_GRAPH], 
                    this._$_useSystemTimescale$_ = !!t[USE_SYSTEM_TIMESCALE], this._$_trackData$_ = new C33._$TrackData$_(t[TRACKS], this));
                }
                _$Release$_() {
                    this._$_trackData$_._$Release$_(), this._$_trackData$_ = null;
                }
                _$GetTrackData$_() {
                    return this._$_trackData$_ || (this._$_trackData$_ = new C33._$TrackData$_(null, this)), 
                    this._$_trackData$_;
                }
                _$GetName$_() {
                    return this._$_name$_;
                }
                _$SetName$_(t) {
                    this._$_name$_ = t;
                }
                _$GetTotalTime$_() {
                    return this._$_totalTime$_;
                }
                _$SetTotalTime$_(t) {
                    this._$_totalTime$_ = t;
                }
                _$GetStep$_() {
                    return this._$_step$_;
                }
                _$SetStep$_(t) {
                    this._$_step$_ = t;
                }
                _$GetInterpolationMode$_() {
                    return this._$_interpolationMode$_;
                }
                _$SetInterpolationMode$_(t) {
                    this._$_interpolationMode$_ = t;
                }
                _$GetResultMode$_() {
                    return this._$_resultMode$_;
                }
                _$SetResultMode$_(t) {
                    this._$_resultMode$_ = t;
                }
                _$GetLoop$_() {
                    return this._$_loop$_;
                }
                _$SetLoop$_(t) {
                    this._$_loop$_ = t;
                }
                _$GetPingPong$_() {
                    return this._$_pingPong$_;
                }
                _$SetPingPong$_(t) {
                    this._$_pingPong$_ = t;
                }
                _$GetRepeatCount$_() {
                    return this._$_repeatCount$_;
                }
                _$SetRepeatCount$_(t) {
                    this._$_repeatCount$_ = t;
                }
                _$GetStartOnLayout$_() {
                    return this._$_startOnLayout$_;
                }
                _$GetTransformWithSceneGraph$_() {
                    return this._$_transformWithSceneGraph$_;
                }
                _$GetUseSystemTimescale$_() {
                    return this._$_useSystemTimescale$_;
                }
                _$_SaveToJson$_() {
                    return {
                        trackDataJson: this._$_trackData$_._$_SaveToJson$_(),
                        name: this._$_name$_,
                        totalTime: this._$_totalTime$_,
                        step: this._$_step$_,
                        interpolationMode: this._$_interpolationMode$_,
                        resultMode: this._$_resultMode$_,
                        loop: this._$_loop$_,
                        pingPong: this._$_pingPong$_,
                        repeatCount: this._$_repeatCount$_,
                        startOnLayout: this._$_startOnLayout$_,
                        transformWithSceneGraph: !!this._$_transformWithSceneGraph$_,
                        useSystemTimescale: this._$_useSystemTimescale$_
                    };
                }
                _$_LoadFromJson$_(t) {
                    t && (this._$GetTrackData$_()._$_LoadFromJson$_(t.trackDataJson), 
                    this._$_name$_ = t.name, this._$_totalTime$_ = t.totalTime, 
                    this._$_step$_ = t.step, this._$_interpolationMode$_ = t.interpolationMode, 
                    this._$_resultMode$_ = t.resultMode, this._$_loop$_ = t.loop, 
                    this._$_pingPong$_ = t.pingPong, this._$_repeatCount$_ = t.repeatCount, 
                    this._$_startOnLayout$_ = t.startOnLayout, this._$_transformWithSceneGraph$_ = !!t.transformWithSceneGraph, 
                    this._$_useSystemTimescale$_ = !!t.useSystemTimescale);
                }
            };
        }
        {
            const C33 = self._$C3$_, WI_DATA = 0, OC_INDEX = 1, WI_UID = 2, INTERPOLATION_MODE = 1, RESULT_MODE = 2, ENABLED = 3, KEYFRAMES = 4, PROPERTY_TRACKS = 5, ID = 6, NESTED_DATA = 7, START_OFFSET = 0, LOCAL_TOTAL_TIME = 1, WI_ADDITIONAL_DATA = 8, ORIGINAL_WIDTH = 0, ORIGINAL_HEIGHT = 1, TRACK_TYPE = 9, TRACK_NAME = 10;
            class TrackDataItem {
                constructor(t, e) {
                    this._$_trackData$_ = e, this._$_instanceData$_ = null, this._$_additionalInstanceData$_ = null, 
                    this._$_instanceUid$_ = NaN, this._$_objectClassIndex$_ = NaN, 
                    this._$_interpolationMode$_ = "default", this._$_resultMode$_ = "default", 
                    this._$_enabled$_ = !1, this._$_keyframeData$_ = null, this._$_propertyTrackData$_ = null, 
                    this._$_id$_ = "", this._$_nestedData$_ = null, this._$_startOffset$_ = 0, 
                    this._$_localTotalTime$_ = this._$_trackData$_._$GetTimelineDataItem$_()._$GetTotalTime$_(), 
                    this._$_type$_ = 0, this._$_name$_ = "", t && (t[WI_DATA] && (this._$_instanceData$_ = t[WI_DATA], 
                    this._$_instanceUid$_ = t[WI_DATA][WI_UID], this._$_objectClassIndex$_ = t[WI_DATA][OC_INDEX]), 
                    this._$_interpolationMode$_ = t[INTERPOLATION_MODE], this._$_resultMode$_ = t[RESULT_MODE], 
                    this._$_enabled$_ = !!t[ENABLED], t[ID] && (this._$_id$_ = t[ID]), 
                    t[NESTED_DATA] && (this._$_nestedData$_ = t[NESTED_DATA], this._$_startOffset$_ = t[NESTED_DATA][START_OFFSET], 
                    this._$_localTotalTime$_ = t[NESTED_DATA][LOCAL_TOTAL_TIME]), 
                    t[WI_ADDITIONAL_DATA] && (this._$_additionalInstanceData$_ = t[WI_ADDITIONAL_DATA]), 
                    t[WI_ADDITIONAL_DATA] && (this._$_additionalInstanceData$_ = t[WI_ADDITIONAL_DATA]), 
                    t[TRACK_TYPE] && (this._$_type$_ = t[TRACK_TYPE]), t[TRACK_NAME] && (this._$_name$_ = t[TRACK_NAME]), 
                    this._$_keyframeData$_ = new C33._$KeyframeData$_(t[KEYFRAMES], this), 
                    this._$_propertyTrackData$_ = new C33._$PropertyTrackData$_(t[PROPERTY_TRACKS], this));
                }
                _$Release$_() {
                    this._$_instanceData$_ = null, this._$_trackData$_ = null, this._$_keyframeData$_ && (this._$_keyframeData$_._$Release$_(), 
                    this._$_keyframeData$_ = null), this._$_propertyTrackData$_ && (this._$_propertyTrackData$_._$Release$_(), 
                    this._$_propertyTrackData$_ = null), this._$_nestedData$_ = null;
                }
                _$GetTrackData$_() {
                    return this._$_trackData$_;
                }
                _$GetKeyframeData$_() {
                    return this._$_keyframeData$_ || (this._$_keyframeData$_ = new C33._$KeyframeData$_(null, this)), 
                    this._$_keyframeData$_;
                }
                _$GetPropertyTrackData$_() {
                    return this._$_propertyTrackData$_ || (this._$_propertyTrackData$_ = new C33._$PropertyTrackData$_(null, this)), 
                    this._$_propertyTrackData$_;
                }
                _$GetInstanceData$_() {
                    return this._$_instanceData$_;
                }
                _$GetObjectClassIndex$_() {
                    return this._$_objectClassIndex$_;
                }
                _$SetObjectClassIndex$_(t) {
                    this._$_objectClassIndex$_ = t;
                }
                _$GetInstanceUID$_() {
                    return this._$_instanceUid$_;
                }
                _$SetInstanceUID$_(t) {
                    this._$_instanceUid$_ = t;
                }
                _$GetInterpolationMode$_() {
                    return this._$_interpolationMode$_;
                }
                _$SetInterpolationMode$_(t) {
                    this._$_interpolationMode$_ = t;
                }
                _$GetResultMode$_() {
                    return this._$_resultMode$_;
                }
                _$SetResultMode$_(t) {
                    this._$_resultMode$_ = t;
                }
                _$GetEnable$_() {
                    return this._$_enabled$_;
                }
                _$SetEnable$_(t) {
                    this._$_enabled$_ = !!t;
                }
                _$GetId$_() {
                    return this._$_id$_;
                }
                _$GetStartOffset$_() {
                    return this._$_startOffset$_;
                }
                _$GetLocalTotalTime$_() {
                    return this._$_localTotalTime$_;
                }
                _$SetLocalTotalTime$_(t) {
                    this._$_localTotalTime$_ = t;
                }
                _$GetOriginalWidth$_() {
                    return this._$_additionalInstanceData$_[ORIGINAL_WIDTH];
                }
                _$SetOriginalWidth$_(t) {
                    this._$_additionalInstanceData$_ || (this._$_additionalInstanceData$_ = []), 
                    this._$_additionalInstanceData$_[ORIGINAL_WIDTH] = t;
                }
                _$GetOriginalHeight$_() {
                    return this._$_additionalInstanceData$_ || (this._$_additionalInstanceData$_ = []), 
                    this._$_additionalInstanceData$_[ORIGINAL_HEIGHT];
                }
                _$SetOriginalHeight$_(t) {
                    this._$_additionalInstanceData$_ || (this._$_additionalInstanceData$_ = []), 
                    this._$_additionalInstanceData$_[ORIGINAL_HEIGHT] = t;
                }
                _$GetType$_() {
                    return this._$_type$_;
                }
                _$GetName$_() {
                    return this._$_name$_;
                }
                _$_SaveToJson$_() {
                    return {
                        keyframeDataJson: this._$_keyframeData$_._$_SaveToJson$_(),
                        propertyTrackDataJson: this._$_propertyTrackData$_._$_SaveToJson$_(),
                        instanceData: this._$_instanceData$_,
                        additionalInstanceData: this._$_additionalInstanceData$_,
                        instanceUid: this._$_instanceUid$_,
                        objectClassIndex: this._$_objectClassIndex$_,
                        interpolationMode: this._$_interpolationMode$_,
                        resultMode: this._$_resultMode$_,
                        enabled: this._$_enabled$_,
                        id: this._$_id$_,
                        nestedData: this._$_nestedData$_,
                        type: this._$_type$_,
                        name: this._$_name$_
                    };
                }
                _$_LoadFromJson$_(t) {
                    t && (this._$_instanceData$_ = t.instanceData, this._$_instanceUid$_ = t.instanceUid, 
                    this._$_objectClassIndex$_ = t.objectClassIndex, this._$_interpolationMode$_ = t.interpolationMode, 
                    this._$_resultMode$_ = t.resultMode, this._$_enabled$_ = t.enabled, 
                    this._$_id$_ = t.id, this._$_type$_ = t.type || 0, this._$_name$_ = t.name || "", 
                    this._$_localTotalTime$_ = this._$_trackData$_._$GetTimelineDataItem$_()._$GetTotalTime$_(), 
                    t.nestedData && (this._$_nestedData$_ = t.nestedData, this._$_startOffset$_ = this._$_nestedData$_[START_OFFSET], 
                    this._$_localTotalTime$_ = this._$_nestedData$_[LOCAL_TOTAL_TIME]), 
                    t.additionalInstanceData && (this._$_additionalInstanceData$_ = t.additionalInstanceData), 
                    this._$GetKeyframeData$_()._$_LoadFromJson$_(t.keyframeDataJson), 
                    this._$GetPropertyTrackData$_()._$_LoadFromJson$_(t.propertyTrackDataJson));
                }
            }
            C33._$TrackData$_ = class {
                constructor(t, e) {
                    this._$_timelineDataItem$_ = e, this._$_trackDataItems$_ = [], 
                    C33._$TimelineDataManager$_._$_CreateDataItems$_(this._$_trackDataItems$_, t, TrackDataItem, this);
                }
                _$Release$_() {
                    this._$_timelineDataItem$_ = null;
                    for (const t of this._$_trackDataItems$_) t._$Release$_();
                    C33._$clearArray$_(this._$_trackDataItems$_), this._$_trackDataItems$_ = null;
                }
                _$GetTimelineDataItem$_() {
                    return this._$_timelineDataItem$_;
                }
                _$AddEmptyTrackDataItem$_() {
                    const t = new TrackDataItem(null, this);
                    return this._$_trackDataItems$_.push(t), t;
                }
                _$GetFirstKeyframeDataItem$_(t) {
                    return t._$GetKeyframeData$_()._$GetKeyframeDataItemArray$_()[0];
                }
                _$GetLastKeyframeDataItem$_(t) {
                    const e = t._$GetKeyframeData$_()._$GetKeyframeDataItemArray$_();
                    return e.at(-1);
                }
                _$GetKeyFrameDataItemAtTime$_(e, t) {
                    const s = t._$GetKeyframeData$_()._$GetKeyframeDataItemArray$_(), i = s.length;
                    for (let t = 0; t < i; t++) {
                        const r = s[t];
                        if (r._$GetTime$_() === e) return r;
                    }
                }
                _$GetFirstKeyFrameDataItemHigherThan$_(e, t) {
                    const s = t._$GetKeyframeData$_()._$GetKeyframeDataItemArray$_(), i = s.length;
                    for (let t = 0; t < i; t++) {
                        const r = s[t];
                        if (r._$GetTime$_() > e) return r;
                    }
                }
                _$GetFirstKeyFrameDataItemHigherOrEqualThan$_(e, t) {
                    const s = t._$GetKeyframeData$_()._$GetKeyframeDataItemArray$_(), i = s.length;
                    for (let t = 0; t < i; t++) {
                        const r = s[t];
                        if (r._$GetTime$_() >= e) return r;
                    }
                }
                _$GetFirstKeyFrameDataItemLowerOrEqualThan$_(e, t) {
                    const s = t._$GetKeyframeData$_()._$GetKeyframeDataItemArray$_();
                    for (let t = s.length - 1; 0 <= t; t--) {
                        const i = s[t];
                        if (i._$GetTime$_() <= e) return i;
                    }
                }
                *_$trackDataItems$_() {
                    for (const t of this._$_trackDataItems$_) yield t;
                }
                _$_SaveToJson$_() {
                    return {
                        trackDataItemsJson: this._$_trackDataItems$_.map(t => t._$_SaveToJson$_())
                    };
                }
                _$_LoadFromJson$_(t) {
                    t && C33._$TimelineDataManager$_._$_LoadDataItemsFromJson$_(this._$_trackDataItems$_, t.trackDataItemsJson, TrackDataItem, this);
                }
            };
        }
        {
            const C33 = self._$C3$_, SOURCE_DATA = 0, SOURCE = 0, PROPERTY = 1, TYPE = 2, MIN = 3, MAX = 4, INTERPOLATION_MODE = 5, RESULT_MODE = 6, ENABLED = 7, PROPERTY_KEYFRAMES = 8, CAN_HAVE_PROPERTY_KEYFRAMES = 9;
            class PropertyTrackDataItem {
                constructor(t, e) {
                    this._$_propertyTrackData$_ = e, this._$_sourceAdapterId$_ = "", 
                    this._$_sourceAdapterArguments$_ = null, this._$_property$_ = null, 
                    this._$_type$_ = null, this._$_min$_ = NaN, this._$_max$_ = NaN, 
                    this._$_interpolationMode$_ = "default", this._$_resultMode$_ = "default", 
                    this._$_enabled$_ = !1, this._$_propertyKeyframeData$_ = null, 
                    this._$_canHavePropertyKeyframes$_ = !0, t && (this._$_sourceAdapterId$_ = t[SOURCE_DATA][SOURCE], 
                    this._$_sourceAdapterArguments$_ = t[SOURCE_DATA].slice(1), 
                    this._$_property$_ = t[PROPERTY], this._$_type$_ = t[TYPE], 
                    this._$_min$_ = t[MIN], this._$_max$_ = t[MAX], this._$_interpolationMode$_ = t[INTERPOLATION_MODE], 
                    this._$_resultMode$_ = t[RESULT_MODE], this._$_enabled$_ = !!t[ENABLED], 
                    this._$_propertyKeyframeData$_ = new C33._$PropertyKeyframeData$_(t[PROPERTY_KEYFRAMES], this), 
                    this._$_canHavePropertyKeyframes$_ = t[CAN_HAVE_PROPERTY_KEYFRAMES]);
                }
                _$Release$_() {
                    this._$_propertyKeyframeData$_._$Release$_(), this._$_propertyKeyframeData$_ = null, 
                    this._$_propertyTrackData$_ = null, this._$_sourceAdapterArguments$_ = null;
                }
                _$GetPropertyTrackData$_() {
                    return this._$_propertyTrackData$_;
                }
                _$GetPropertyKeyframeData$_() {
                    return this._$_propertyKeyframeData$_ || (this._$_propertyKeyframeData$_ = new C33._$PropertyKeyframeData$_(null, this)), 
                    this._$_propertyKeyframeData$_;
                }
                _$GetSourceAdapterId$_() {
                    return this._$_sourceAdapterId$_;
                }
                _$SetSourceAdapterId$_(t) {
                    this._$_sourceAdapterId$_ = t;
                }
                _$GetSourceAdapterArguments$_() {
                    return this._$_sourceAdapterArguments$_;
                }
                _$SetSourceAdapterArguments$_(t) {
                    this._$_sourceAdapterArguments$_ = t;
                }
                _$GetProperty$_() {
                    return this._$_property$_;
                }
                _$SetProperty$_(t) {
                    this._$_property$_ = t;
                }
                _$GetType$_() {
                    return this._$_type$_;
                }
                SetType(t) {
                    this._$_type$_ = t;
                }
                _$GetMin$_() {
                    return this._$_min$_;
                }
                _$SetMin$_(t) {
                    this._$_min$_ = t;
                }
                _$GetMax$_() {
                    return this._$_max$_;
                }
                _$SetMax$_(t) {
                    this._$_max$_ = t;
                }
                _$GetInterpolationMode$_() {
                    return this._$_interpolationMode$_;
                }
                _$SetInterpolationMode$_(t) {
                    this._$_interpolationMode$_ = t;
                }
                _$GetResultMode$_() {
                    return this._$_resultMode$_;
                }
                _$SetResultMode$_(t) {
                    this._$_resultMode$_ = t;
                }
                _$GetEnable$_() {
                    return this._$_enabled$_;
                }
                _$SetEnable$_(t) {
                    this._$_enabled$_ = !!t;
                }
                _$CanHavePropertyKeyframes$_() {
                    return !!this._$_canHavePropertyKeyframes$_;
                }
                _$_SaveToJson$_() {
                    return {
                        propertyKeyframeDataJson: this._$_propertyKeyframeData$_._$_SaveToJson$_(),
                        sourceAdapterId: this._$_sourceAdapterId$_,
                        sourceAdapterArguments: this._$_sourceAdapterArguments$_,
                        property: this._$_property$_,
                        type: this._$_type$_,
                        min: this._$_min$_,
                        max: this._$_max$_,
                        interpolationMode: this._$_interpolationMode$_,
                        resultMode: this._$_resultMode$_,
                        enabled: this._$_enabled$_,
                        canHavePropertyKeyframes: this._$_canHavePropertyKeyframes$_
                    };
                }
                _$_LoadFromJson$_(t) {
                    t && (this._$_sourceAdapterId$_ = t.sourceAdapterId, this._$_sourceAdapterArguments$_ = t.sourceAdapterArguments, 
                    this._$_property$_ = t.property, this._$_type$_ = t.type, this._$_min$_ = t.min, 
                    this._$_max$_ = t.max, this._$_interpolationMode$_ = t.interpolationMode, 
                    this._$_resultMode$_ = t.resultMode, this._$_enabled$_ = t.enabled, 
                    this._$_canHavePropertyKeyframes$_ = t.canHavePropertyKeyframes, 
                    this._$GetPropertyKeyframeData$_()._$_LoadFromJson$_(t.propertyKeyframeDataJson));
                }
            }
            C33._$PropertyTrackData$_ = class {
                constructor(t, e) {
                    this._$_trackDataItem$_ = e, this._$_propertyTrackDataItems$_ = [], 
                    C33._$TimelineDataManager$_._$_CreateDataItems$_(this._$_propertyTrackDataItems$_, t, PropertyTrackDataItem, this);
                }
                _$Release$_() {
                    this._$_trackDataItem$_ = null;
                    for (const t of this._$_propertyTrackDataItems$_) t._$Release$_();
                    C33._$clearArray$_(this._$_propertyTrackDataItems$_), this._$_propertyTrackDataItems$_ = null;
                }
                _$GetTrackDataItem$_() {
                    return this._$_trackDataItem$_;
                }
                _$AddEmptyPropertyTrackDataItem$_() {
                    const t = new PropertyTrackDataItem(null, this);
                    return this._$_propertyTrackDataItems$_.push(t), t;
                }
                _$GetFirstPropertyKeyframeDataItem$_(t) {
                    const e = t._$GetPropertyKeyframeData$_();
                    return e._$GetPropertyKeyframeDataItemArray$_()[0];
                }
                _$GetLastPropertyKeyframeDataItem$_(t) {
                    const e = t._$GetPropertyKeyframeData$_(), s = e._$GetPropertyKeyframeDataItemArray$_();
                    return s.at(-1);
                }
                _$GetPropertyKeyFrameDataItemAtTime$_(e, t) {
                    const s = t._$GetPropertyKeyframeData$_(), i = s._$GetPropertyKeyframeDataItemArray$_(), r = i.length;
                    for (let t = 0; t < r; t++) {
                        const n = i[t];
                        if (n._$GetTime$_() === e) return n;
                    }
                }
                _$GetFirstPropertyKeyFrameDataItemHigherThan$_(e, t) {
                    const s = t._$GetPropertyKeyframeData$_(), i = s._$GetPropertyKeyframeDataItemArray$_(), r = i.length;
                    for (let t = 0; t < r; t++) {
                        const n = i[t];
                        if (n._$GetTime$_() > e) return n;
                    }
                }
                _$GetFirstPropertyKeyFrameDataItemHigherOrEqualThan$_(e, t) {
                    const s = t._$GetPropertyKeyframeData$_(), i = s._$GetPropertyKeyframeDataItemArray$_(), r = i.length;
                    for (let t = 0; t < r; t++) {
                        const n = i[t];
                        if (n._$GetTime$_() >= e) return n;
                    }
                }
                _$GetFirstPropertyKeyFrameDataItemLowerOrEqualThan$_(e, t) {
                    const s = t._$GetPropertyKeyframeData$_(), i = s._$GetPropertyKeyframeDataItemArray$_();
                    for (let t = i.length - 1; 0 <= t; t--) {
                        const r = i[t];
                        if (r._$GetTime$_() <= e) return r;
                    }
                }
                *_$propertyTrackDataItems$_() {
                    for (const t of this._$_propertyTrackDataItems$_) yield t;
                }
                _$_SaveToJson$_() {
                    return {
                        propertyTrackDataItemsJson: this._$_propertyTrackDataItems$_.map(t => t._$_SaveToJson$_())
                    };
                }
                _$_LoadFromJson$_(t) {
                    t && C33._$TimelineDataManager$_._$_LoadDataItemsFromJson$_(this._$_propertyTrackDataItems$_, t.propertyTrackDataItemsJson, PropertyTrackDataItem, this);
                }
            };
        }
        {
            const C33 = self._$C3$_, TIME = 0, EASE = 1, ENABLE = 2, TAGS = 3;
            class KeyframeDataItem {
                constructor(t, e) {
                    if (this._$_keyframeData$_ = e, this._$_time$_ = -1, this._$_ease$_ = "noease", 
                    this._$_enable$_ = !1, this._$_tags$_ = null, this._$_lowerTags$_ = null, 
                    t) {
                        this._$_time$_ = t[TIME], this._$_ease$_ = t[EASE], this._$_enable$_ = !!t[ENABLE];
                        const s = t[TAGS];
                        this._$_tags$_ = s ? s.split(" ") : [], this._$_lowerTags$_ = new Set(this._$_tags$_.map(t => t.toLowerCase())), 
                        this._$_next$_ = null;
                    }
                }
                _$Release$_() {
                    this._$_keyframeData$_ = null, C33._$clearArray$_(this._$_tags$_), 
                    this._$_tags$_ = null, this._$_lowerTags$_.clear(), this._$_lowerTags$_ = null, 
                    this._$_next$_ = null;
                }
                _$GetKeyframeData$_() {
                    return this._$_keyframeData$_;
                }
                _$GetNext$_() {
                    return this._$_next$_;
                }
                _$SetNext$_(t) {
                    this._$_next$_ = t;
                }
                _$GetTime$_() {
                    return this._$_time$_;
                }
                _$SetTime$_(t) {
                    this._$_time$_ = t, this._$_keyframeData$_._$_LinkKeyframeDataItems$_();
                }
                _$GetEase$_() {
                    return this._$_ease$_;
                }
                _$SetEase$_(t) {
                    this._$_ease$_ = t;
                }
                _$GetEnable$_() {
                    return this._$_enable$_;
                }
                _$SetEnable$_(t) {
                    this._$_enable$_ = !!t;
                }
                _$GetTags$_() {
                    return this._$_tags$_;
                }
                _$SetTags$_(t) {
                    this._$_tags$_ = t ? t.split(" ") : [], this._$_lowerTags$_ = new Set(this._$_tags$_.map(t => t.toLowerCase()));
                }
                _$GetLowerTags$_() {
                    return this._$_lowerTags$_;
                }
                _$HasTag$_(t) {
                    return this._$_lowerTags$_.has(t.toLowerCase());
                }
                _$_SaveToJson$_() {
                    return {
                        time: this._$_time$_,
                        ease: this._$_ease$_,
                        enable: this._$_enable$_,
                        tags: this._$_tags$_
                    };
                }
                _$_LoadFromJson$_(t) {
                    t && (this._$_time$_ = t.time, this._$_ease$_ = t.ease, this._$_enable$_ = t.enable, 
                    this._$_tags$_ = t.tags, this._$_lowerTags$_ = new Set(this._$_tags$_.map(t => t.toLowerCase())));
                }
            }
            C33._$KeyframeData$_ = class {
                constructor(t, e) {
                    this._$_trackDataItem$_ = e, this._$_keyframeDataItems$_ = [], 
                    C33._$TimelineDataManager$_._$_CreateDataItems$_(this._$_keyframeDataItems$_, t, KeyframeDataItem, this), 
                    this._$_LinkKeyframeDataItems$_();
                }
                _$Release$_() {
                    this._$_trackDataItem$_ = null;
                    for (const t of this._$_keyframeDataItems$_) t._$Release$_();
                    C33._$clearArray$_(this._$_keyframeDataItems$_), this._$_keyframeDataItems$_ = null;
                }
                _$_LinkKeyframeDataItems$_() {
                    this._$_keyframeDataItems$_.sort((t, e) => t._$GetTime$_() - e._$GetTime$_());
                    for (let t = 0; t < this._$_keyframeDataItems$_.length; t++) {
                        const e = this._$_keyframeDataItems$_[t];
                        e._$SetNext$_(this._$_keyframeDataItems$_[t + 1]);
                    }
                }
                _$GetTrackDataItem$_() {
                    return this._$_trackDataItem$_;
                }
                _$GetKeyframeDataItemCount$_() {
                    return this._$_keyframeDataItems$_.length;
                }
                _$GetKeyframeDataItemArray$_() {
                    return this._$_keyframeDataItems$_;
                }
                _$AddEmptyKeyframeDataItem$_() {
                    const t = new KeyframeDataItem(null, this);
                    return this._$_keyframeDataItems$_.push(t), this._$_LinkKeyframeDataItems$_(), 
                    t;
                }
                _$DeleteKeyframeDataItems$_(t) {
                    for (const e of this._$_keyframeDataItems$_) if (t(e)) {
                        const s = this._$_keyframeDataItems$_.indexOf(e);
                        -1 !== s && (e._$Release$_(), this._$_keyframeDataItems$_.splice(s, 1));
                    }
                    this._$SortKeyframeDataItems$_(), this._$_LinkKeyframeDataItems$_();
                }
                _$SortKeyframeDataItems$_() {
                    this._$_keyframeDataItems$_.sort((t, e) => t._$GetTime$_() - e._$GetTime$_());
                }
                _$GetKeyframeDataItemIndex$_(t) {
                    return this._$_keyframeDataItems$_.indexOf(t);
                }
                _$GetKeyframeDataItemFromIndex$_(t) {
                    return this._$_keyframeDataItems$_[t];
                }
                *_$keyframeDataItems$_() {
                    for (const t of this._$_keyframeDataItems$_) yield t;
                }
                *_$keyframeDataItemsReverse$_() {
                    for (let t = this._$_keyframeDataItems$_.length - 1; 0 <= t; t--) yield this._$_keyframeDataItems$_[t];
                }
                _$_SaveToJson$_() {
                    return {
                        keyframeDataItemsJson: this._$_keyframeDataItems$_.map(t => t._$_SaveToJson$_())
                    };
                }
                _$_LoadFromJson$_(t) {
                    t && (C33._$TimelineDataManager$_._$_LoadDataItemsFromJson$_(this._$_keyframeDataItems$_, t.keyframeDataItemsJson, KeyframeDataItem, this), 
                    this._$_LinkKeyframeDataItems$_());
                }
            };
        }
        {
            const C33 = self._$C3$_, VALUE_DATA = 0, VALUE_DATA_VALUE = 0, VALUE_DATA_ABSOLUTE_VALUE = 1, VALUE_DATA_TYPE = 2, TIME = 1, EASE = 2, ENABLE = 3, ADDONS = 4, PATH_MODE = 5;
            class PropertyKeyframeDataItem {
                constructor(t, e) {
                    this._$_propertyKeyframeData$_ = e, this._$_value$_ = null, 
                    this._$_aValue$_ = null, this._$_type$_ = "", this._$_time$_ = NaN, 
                    this._$_ease$_ = "noease", this._$_enable$_ = !1, this._$_addonData$_ = null, 
                    this._$_addonInstance$_ = void 0, this._$_pathMode$_ = "line", 
                    t && (this._$_value$_ = t[VALUE_DATA][VALUE_DATA_VALUE], this._$_aValue$_ = t[VALUE_DATA][VALUE_DATA_ABSOLUTE_VALUE], 
                    this._$_type$_ = t[VALUE_DATA][VALUE_DATA_TYPE], this._$_time$_ = t[TIME], 
                    this._$_ease$_ = t[EASE], this._$_enable$_ = !!t[ENABLE], this._$_pathMode$_ = t[PATH_MODE], 
                    this._$_addonData$_ = null, t[ADDONS] && (this._$_addonData$_ = new C33._$AddonData$_(t[ADDONS], this)), 
                    this._$_next$_ = null, this._$_prev$_ = null);
                }
                _$Release$_() {
                    this._$_propertyKeyframeData$_ = null, this._$_addonData$_ && (this._$_addonData$_._$Release$_(), 
                    this._$_addonData$_ = null), this._$_next$_ = null, this._$_prev$_ = null;
                }
                _$GetAddonData$_() {
                    return this._$_addonData$_;
                }
                _$SetNext$_(t) {
                    this._$_next$_ = t;
                }
                _$GetNext$_() {
                    return this._$_next$_;
                }
                _$SetPrevious$_(t) {
                    this._$_prev$_ = t;
                }
                _$GetPrevious$_() {
                    return this._$_prev$_;
                }
                _$GetValue$_() {
                    return this._$_value$_;
                }
                _$SetValue$_(t) {
                    "color" === this._$_type$_ && C33._$IsFiniteNumber$_(t) ? (this._$_value$_[0] = C33._$GetRValue$_(t), 
                    this._$_value$_[1] = C33._$GetGValue$_(t), this._$_value$_[2] = C33._$GetBValue$_(t)) : this._$_value$_ = t;
                }
                _$GetAbsoluteValue$_() {
                    return this._$_aValue$_;
                }
                _$SetAbsoluteValue$_(t) {
                    "color" === this._$_type$_ && C33._$IsFiniteNumber$_(t) ? (this._$_aValue$_[0] = C33._$GetRValue$_(t), 
                    this._$_aValue$_[1] = C33._$GetGValue$_(t), this._$_aValue$_[2] = C33._$GetBValue$_(t)) : this._$_aValue$_ = t;
                }
                _$GetValueWithResultMode$_() {
                    const t = this._$_propertyKeyframeData$_._$GetPropertyTrackDataItem$_()._$GetResultMode$_();
                    return "relative" === t ? this._$GetValue$_() : "absolute" === t ? this._$GetAbsoluteValue$_() : void 0;
                }
                _$GetType$_() {
                    return this._$_type$_;
                }
                SetType(t) {
                    this._$_type$_ = t;
                }
                _$GetTime$_() {
                    return this._$_time$_;
                }
                _$SetTime$_(t) {
                    this._$_time$_ = t, this._$_propertyKeyframeData$_._$_LinkPropertyKeyframeDataItems$_();
                }
                _$GetEase$_() {
                    return this._$_ease$_;
                }
                _$SetEase$_(t) {
                    this._$_ease$_ = t;
                }
                _$GetEnable$_() {
                    return this._$_enable$_;
                }
                _$SetEnable$_(t) {
                    this._$_enable$_ = !!t;
                }
                _$GetPathMode$_() {
                    return this._$_pathMode$_;
                }
                _$GetAddOn$_(e) {
                    if (this._$_addonData$_) {
                        if (!this._$_addonInstance$_ && null !== this._$_addonInstance$_) {
                            const s = this._$_addonData$_._$GetAddDataItemArray$_();
                            if (s) {
                                const i = s.length;
                                for (let t = 0; t < i; t++) {
                                    const r = s[t];
                                    if (r._$GetId$_() === e) return this._$_addonInstance$_ = r, 
                                    this._$_addonInstance$_;
                                }
                            }
                            this._$_addonInstance$_ = null;
                        }
                        return this._$_addonInstance$_;
                    }
                }
                _$_SaveToJson$_() {
                    const t = this._$_addonData$_;
                    return {
                        addonDataJson: t && t._$_SaveToJson$_(),
                        value: this._$_value$_,
                        aValue: this._$_aValue$_,
                        type: this._$_type$_,
                        time: this._$_time$_,
                        ease: this._$_ease$_,
                        enable: this._$_enable$_
                    };
                }
                _$_LoadFromJson$_(t) {
                    t && (t.addonDataJson && this._$_addonData$_._SetFromJson(t.addonDataJson), 
                    this._$_value$_ = t.value, this._$_aValue$_ = t.aValue, this._$_type$_ = t.type, 
                    this._$_time$_ = t.time, this._$_ease$_ = t.ease, this._$_enable$_ = t.enable);
                }
            }
            C33._$PropertyKeyframeData$_ = class {
                constructor(t, e) {
                    this._$_propertyTrackDataItem$_ = e, this._$_propertyKeyframeDataItems$_ = [], 
                    this._$_propertyKeyframeDataItemsIncludingDisabled$_ = [], C33._$TimelineDataManager$_._$_CreateDataItems$_(this._$_propertyKeyframeDataItems$_, t, PropertyKeyframeDataItem, this), 
                    C33._$TimelineDataManager$_._$_CreateDataItemsIncludingDisabled$_(this._$_propertyKeyframeDataItemsIncludingDisabled$_, t, PropertyKeyframeDataItem, this), 
                    this._$_LinkPropertyKeyframeDataItems$_();
                }
                _$Release$_() {
                    this._$_propertyTrackDataItem$_ = null;
                    for (const t of this._$_propertyKeyframeDataItems$_) t._$Release$_();
                    C33._$clearArray$_(this._$_propertyKeyframeDataItems$_), this._$_propertyKeyframeDataItems$_ = null;
                    for (const e of this._$_propertyKeyframeDataItemsIncludingDisabled$_) e._$Release$_();
                    C33._$clearArray$_(this._$_propertyKeyframeDataItemsIncludingDisabled$_), 
                    this._$_propertyKeyframeDataItemsIncludingDisabled$_ = null;
                }
                _$_LinkPropertyKeyframeDataItems$_() {
                    let e = this._$_propertyKeyframeDataItems$_;
                    e.sort((t, e) => t._$GetTime$_() - e._$GetTime$_());
                    for (let t = 0; t < e.length; t++) {
                        const s = e[t];
                        t + 1 < e.length && s._$SetNext$_(e[t + 1]), 0 <= t - 1 && s._$SetPrevious$_(e[t - 1]);
                    }
                    (e = this._$_propertyKeyframeDataItemsIncludingDisabled$_).sort((t, e) => t._$GetTime$_() - e._$GetTime$_());
                    for (let t = 0; t < e.length; t++) {
                        const i = e[t];
                        t + 1 < e.length && i._$SetNext$_(e[t + 1]), 0 <= t - 1 && i._$SetPrevious$_(e[t - 1]);
                    }
                }
                _$AddEmptyPropertyKeyframeDataItem$_() {
                    const t = new PropertyKeyframeDataItem(null, this);
                    return this._$_propertyKeyframeDataItems$_.push(t), this._$_LinkPropertyKeyframeDataItems$_(), 
                    t;
                }
                _$DeletePropertyKeyframeDataItems$_(t) {
                    for (const e of this._$_propertyKeyframeDataItems$_) if (t(e)) {
                        const s = this._$_propertyKeyframeDataItems$_.indexOf(e);
                        -1 !== s && (e._$Release$_(), this._$_propertyKeyframeDataItems$_.splice(s, 1));
                    }
                    this._$SortPropertyKeyFrameDataItems$_(), this._$_LinkPropertyKeyframeDataItems$_();
                }
                _$SortPropertyKeyFrameDataItems$_() {
                    this._$_propertyKeyframeDataItems$_.sort((t, e) => t._$GetTime$_() - e._$GetTime$_());
                }
                _$GetPropertyTrackDataItem$_() {
                    return this._$_propertyTrackDataItem$_;
                }
                _$GetPropertyKeyframeDataItemCount$_() {
                    return this._$_propertyKeyframeDataItems$_.length;
                }
                _$GetLastPropertyKeyframeDataItem$_() {
                    return this._$_propertyKeyframeDataItems$_[this._$_propertyKeyframeDataItems$_.length - 1];
                }
                _$GetPropertyKeyframeDataItemArray$_() {
                    return this._$_propertyKeyframeDataItems$_;
                }
                _$GetPropertyKeyframeDataItemArrayIncludingDisabled$_() {
                    return this._$_propertyKeyframeDataItemsIncludingDisabled$_;
                }
                *_$propertyKeyframeDataItems$_() {
                    for (const t of this._$_propertyKeyframeDataItems$_) yield t;
                }
                *_$propertyKeyframeDataItemsReverse$_() {
                    for (let t = this._$_propertyKeyframeDataItems$_.length - 1; 0 <= t; t--) yield this._$_propertyKeyframeDataItems$_[t];
                }
                _$_SaveToJson$_() {
                    const t = this._$_propertyKeyframeDataItems$_, e = this._$_propertyKeyframeDataItemsIncludingDisabled$_;
                    return {
                        propertyKeyframeDataItemsJson: t.map(t => t._$_SaveToJson$_()),
                        propertyKeyframeDataItemsIncludingDisabledJson: e.map(t => t._$_SaveToJson$_())
                    };
                }
                _$_LoadFromJson$_(t) {
                    t && (C33._$TimelineDataManager$_._$_LoadDataItemsFromJson$_(this._$_propertyKeyframeDataItems$_, t.propertyKeyframeDataItemsJson, PropertyKeyframeDataItem, this), 
                    C33._$TimelineDataManager$_._$_LoadDataItemsFromJson$_(this._$_propertyKeyframeDataItemsIncludingDisabled$_, t.propertyKeyframeDataItemsIncludingDisabledJson, PropertyKeyframeDataItem, this), 
                    this._$_LinkPropertyKeyframeDataItems$_());
                }
            };
        }
        {
            const C33 = self._$C3$_, ADDON_ID = 0, ADDON_DATA = 1;
            class AddonDataItem {
                constructor(t, e) {
                    this._$_addonData$_ = e, this._$_id$_ = t[ADDON_ID], this._$_data$_ = t[ADDON_DATA];
                }
                _$Release$_() {
                    this._$_addonData$_ = null, this._$_data$_ = null;
                }
                _$GetAddonData$_() {
                    return this._$_addonData$_;
                }
                _$GetId$_() {
                    return this._$_id$_;
                }
                _$_SaveToJson$_() {
                    return {
                        id: this._$_id$_,
                        data: this._$_data$_
                    };
                }
                _$_LoadFromJson$_(t) {
                    t && (this._$_id$_ = t.id, this._$_data$_ = t.data);
                }
            }
            const START_ANCHOR = 0, START_ENABLE = 1, END_ANCHOR = 2, END_ENABLE = 3;
            class AddonDataCubicBezierItem extends AddonDataItem {
                constructor(t, e) {
                    super(t, e), this._$_startAnchor$_ = this._$_data$_[START_ANCHOR], 
                    this._$_startEnable$_ = !!this._$_data$_[START_ENABLE], this._$_endAnchor$_ = this._$_data$_[END_ANCHOR], 
                    this._$_endEnable$_ = !!this._$_data$_[END_ENABLE];
                }
                _$Release$_() {
                    super._$Release$_();
                }
                _$GetStartAnchor$_() {
                    return this._$_startAnchor$_;
                }
                _$GetStartEnable$_() {
                    return this._$_startEnable$_;
                }
                _$GetEndAnchor$_() {
                    return this._$_endAnchor$_;
                }
                _$GetEndEnable$_() {
                    return this._$_endEnable$_;
                }
                _$_SaveToJson$_() {
                    return Object.assign(super._$_SaveToJson$_(), {
                        startAnchor: this._$_startAnchor$_,
                        startEnable: !!this._$_startEnable$_,
                        endAnchor: this._$_endAnchor$_,
                        endEnable: !!this._$_endEnable$_
                    });
                }
                _$_LoadFromJson$_(t) {
                    t && (super._$_LoadFromJson$_(t), this._$_startAnchor$_ = t.startAnchor, 
                    this._$_startEnable$_ = !!t.startEnable, this._$_endAnchor$_ = t.endAnchor, 
                    this._$_endEnable$_ = !!t.endEnable);
                }
            }
            const DIRECTION = 0, REVOLUTIONS = 1;
            class AddonDataAngleItem extends AddonDataItem {
                constructor(t, e) {
                    super(t, e), this._$_direction$_ = this._$_data$_[DIRECTION], 
                    this._$_revolutions$_ = this._$_data$_[REVOLUTIONS];
                }
                _$Release$_() {
                    super._$Release$_();
                }
                _$GetDirection$_() {
                    return this._$_direction$_;
                }
                _$GetRevolutions$_() {
                    return this._$_revolutions$_;
                }
                _$_SaveToJson$_() {
                    return Object.assign(super._$_SaveToJson$_(), {
                        direction: this._$_direction$_,
                        revolutions: this._$_revolutions$_
                    });
                }
                _$_LoadFromJson$_(t) {
                    t && (super._$_LoadFromJson$_(t), this._$_direction$_ = t.direction, 
                    this._$_revolutions$_ = t.revolutions);
                }
            }
            C33._$AddonData$_ = class {
                constructor(t, e) {
                    this._$_propertyKeyframeDataItem$_ = e, this._$_addonDataItems$_ = [], 
                    C33._$TimelineDataManager$_._$_CreateDataItems$_(this._$_addonDataItems$_, t, {
                        prop: 0,
                        map: new Map([ [ "cubic-bezier", AddonDataCubicBezierItem ], [ "angle", AddonDataAngleItem ] ])
                    }, this);
                }
                _$Release$_() {
                    this._$_propertyKeyframeDataItem$_ = null;
                    for (const t of this._$_addonDataItems$_) t._$Release$_();
                    C33._$clearArray$_(this._$_addonDataItems$_), this._$_addonDataItems$_ = null;
                }
                _$GetPropertyKeyframeDataItem$_() {
                    return this._$_propertyKeyframeDataItem$_;
                }
                _$GetAddDataItemArray$_() {
                    return this._$_addonDataItems$_;
                }
                *_$addonDataItems$_() {
                    for (const t of this._$_addonDataItems$_) yield t;
                }
                _$_SaveToJson$_() {
                    return {
                        addonDataItemsJson: this._$_addonDataItems$_.map(t => t._$_SaveToJson$_())
                    };
                }
                _$_LoadFromJson$_(t) {
                    t && C33._$TimelineDataManager$_._$_LoadDataItemsFromJson$_(this._$_addonDataItems$_, t.addonDataItemsJson, {
                        prop: "id",
                        map: new Map([ [ "cubic-bezier", AddonDataCubicBezierItem ], [ "angle", AddonDataAngleItem ] ])
                    }, this);
                }
            };
        }
        {
            let C33 = self._$C3$_, INITIAL_VALUE_MODE_START_VALUE = "start-value", INITIAL_VALUE_MODE_CURRENT_STATE = "current-state", PING_PONG_BEGIN = 0, PING_PONG_END = 1, createdTweens = 0;
            C33._$TweenState$_ = class extends C33._$TimelineState$_ {
                constructor(t, e) {
                    super("tween-" + createdTweens++, t, e), this._$_id$_ = "", 
                    this._$_destroyInstanceOnComplete$_ = !1, this._$_initialValueMode$_ = INITIAL_VALUE_MODE_START_VALUE, 
                    this._$_instance$_ = null, this._$_on_completed_callbacks$_ = null, 
                    this._$_on_started_callbacks$_ = null, this._$_track$_ = null, 
                    this._$_iTweenState$_ = null;
                }
                _$FireReleaseEvent$_(t) {
                    const e = C33._$New$_(C33.Event, "tweenstatereleased");
                    e._$tweenState$_ = this, t.dispatchEvent(e);
                }
                _$GetType$_() {
                    return 1;
                }
                _$CreateTrackStates$_() {
                    for (const t of this._$_timelineDataItem$_._$GetTrackData$_()._$trackDataItems$_()) this._$_tracks$_.push(C33._$TweenTrackState$_._$Create$_(this, t));
                    this._$_track$_ = this._$_tracks$_[0];
                }
                _$AddTrack$_() {
                    const t = this._$_timelineDataItem$_._$GetTrackData$_()._$AddEmptyTrackDataItem$_(), e = C33._$TweenTrackState$_._$Create$_(this, t);
                    return this._$_tracks$_.push(e), this._$_CacheTrack$_(), e;
                }
                _$_CacheTrack$_() {
                    this._$_track$_ = this._$_tracks$_[0];
                }
                _$GetPropertyTrack$_(t) {
                    return this._$_track$_._$GetPropertyTracks$_()[0];
                }
                _$SetPropertyType$_(t) {
                    this._$_propertyType$_ = t;
                }
                _$GetInstance$_() {
                    const t = this._$GetTracks$_();
                    if (t && t.length) {
                        const e = t[0];
                        if (this._$_track$_ = e) {
                            const s = e._$GetInstance$_();
                            return e._$IsInstanceValid$_() ? s : void 0;
                        }
                    }
                }
                _$AddStartedCallback$_(t) {
                    this._$_on_started_callbacks$_ || (this._$_on_started_callbacks$_ = []), 
                    this._$_on_started_callbacks$_.push(t);
                }
                _$AddCompletedCallback$_(t) {
                    this._$_on_completed_callbacks$_ || (this._$_on_completed_callbacks$_ = []), 
                    this._$_on_completed_callbacks$_.push(t);
                }
                _$RemoveStartedCallback$_(t) {
                    if (this._$_on_started_callbacks$_) {
                        const e = this._$_on_started_callbacks$_.indexOf(t);
                        -1 !== e && this._$_on_started_callbacks$_.splice(e, 1);
                    }
                }
                _$RemoveCompletedCallback$_(t) {
                    if (this._$_on_completed_callbacks$_) {
                        const e = this._$_on_completed_callbacks$_.indexOf(t);
                        -1 !== e && this._$_on_completed_callbacks$_.splice(e, 1);
                    }
                }
                _$SetStartValue$_(t, e) {
                    for (const s of this._$_tracks$_) for (const i of s._$_propertyTracks$_) if (i._$GetPropertyName$_() === e) {
                        const r = i._$GetPropertyTrackData$_(), n = i._$GetPropertyTrackDataItem$_(), h = r._$GetFirstPropertyKeyframeDataItem$_(n);
                        h._$SetValue$_(t), h._$SetAbsoluteValue$_(t);
                    }
                }
                _$_GetPropertyTrackState$_(t) {
                    for (const e of this._$_tracks$_) for (const s of e._$_propertyTracks$_) if (s._$GetPropertyName$_() === t) return s;
                }
                _$BeforeSetEndValues$_(t) {
                    for (const e of t) {
                        const s = this._$_GetPropertyTrackState$_(e);
                        this._$SetStartValue$_(s._$GetCurrentState$_(), e);
                    }
                    if (this._$IsForwardPlayBack$_()) {
                        const i = this._$GetTotalTime$_() - this._$GetTime$_();
                        this._$SetTotalTime$_(i);
                        for (const r of this._$_tracks$_) r._$SetLocalTotalTime$_(i);
                        this._$_SetTime$_(0);
                    } else {
                        const n = this._$GetTime$_();
                        this._$SetTotalTime$_(n);
                        for (const h of this._$_tracks$_) h._$SetLocalTotalTime$_(n);
                        this._$_SetTime$_(n);
                    }
                    this._$SetInitialStateFromSetTime$_();
                }
                _$SetEndValue$_(t, e) {
                    const s = this._$_GetPropertyTrackState$_(e), i = s._$GetPropertyTrackData$_(), r = s._$GetPropertyTrackDataItem$_(), n = i._$GetLastPropertyKeyframeDataItem$_(r);
                    n._$SetTime$_(this._$GetTotalTime$_()), n._$SetValue$_(t), n._$SetAbsoluteValue$_(t);
                }
                _$SetId$_(t) {
                    this._$_id$_ = t;
                }
                _$GetId$_() {
                    return this._$_id$_;
                }
                _$SetInitialValueMode$_(t) {
                    this._$_initialValueMode$_ = t;
                }
                _$GetInitialValueMode$_() {
                    return this._$_initialValueMode$_;
                }
                _$SetDestroyInstanceOnComplete$_(t) {
                    this._$_destroyInstanceOnComplete$_ = t;
                }
                _$GetDestroyInstanceOnComplete$_() {
                    return this._$_destroyInstanceOnComplete$_;
                }
                _$OnStarted$_() {
                    if (this._$_on_started_callbacks$_) for (const t of this._$_on_started_callbacks$_) t(this);
                    if (!this._$IsComplete$_()) for (const e of this._$_tracks$_) e._$CompareSaveStateWithCurrent$_();
                }
                _$OnCompleted$_() {
                    this._$_completedTick$_ = this._$_runtime$_._$GetTickCount$_();
                }
                _$FinishTriggers$_() {
                    if (!this._$_finishedTriggers$_ && (this._$_finishedTriggers$_ = !0, 
                    this._$_on_completed_callbacks$_)) for (const t of this._$_on_completed_callbacks$_) t(this);
                }
                _$SetTime$_(t) {
                    this._$_DeleteIntermediateKeyframes$_(), super._$SetTime$_(t);
                }
                _$_SetTimeAndReset$_(t) {
                    (t = C33._$IsFiniteNumber$_(t) ? t : this._$GetTotalTime$_()) < 0 ? this._$_playheadTime$_ = 0 : t >= this._$GetTotalTime$_() ? this._$_playheadTime$_ = this._$GetTotalTime$_() : this._$_playheadTime$_ = t, 
                    this._$_track$_._$SetResetState$_();
                }
                _$SetInitialState$_(t) {
                    if (!this._$InitialStateSet$_() && this._$GetInitialValueMode$_() === INITIAL_VALUE_MODE_CURRENT_STATE) for (const e of this._$_tracks$_) e._$CompareInitialStateWithCurrent$_();
                    super._$SetInitialState$_(t);
                }
                _$Stop$_(t = !1) {
                    if (super._$Stop$_(t), !this._$IsComplete$_()) for (const e of this._$_tracks$_) e._$SaveState$_();
                }
                _$Reset$_(t = !0, e = !1) {
                    this._$_DeleteIntermediateKeyframes$_(), super._$Reset$_(t, e);
                }
                _$_DeleteIntermediateKeyframes$_() {
                    for (const t of this._$_tracks$_) {
                        const e = t => {
                            const e = t._$GetTime$_(), s = this._$GetTotalTime$_();
                            return 0 !== e && e !== s;
                        };
                        t._$DeleteKeyframes$_(e), t._$DeletePropertyKeyframes$_(e);
                    }
                }
                _$_OnBeforeChangeLayout$_() {
                    if (!this._$IsReleased$_()) {
                        const t = this._$GetInstance$_();
                        if (t && t._$GetObjectClass$_()._$IsGlobal$_()) return !1;
                        this._$_timelineManager$_._$CompleteTimelineBeforeChangeOfLayout$_(this), 
                        this._$ResetBeforeChangeLayout$_();
                    }
                    return !0;
                }
                _$Tick$_(r, t, e) {
                    if (this._$_instance$_ || (this._$_instance$_ = this._$GetInstance$_()), 
                    !this._$_instance$_ || this._$_instance$_._$IsDestroyed$_()) this._$Stop$_(!0), 
                    this._$OnCompleted$_(); else {
                        const s = this._$_instance$_._$GetTimeScale$_();
                        if (0 !== (r = -1 !== s ? e * s : r) || 0 !== this._$_lastDelta$_) {
                            this._$_lastDelta$_ = r;
                            const n = this._$_playheadTime$_ + this._$_overshoot$_, h = r * this._$_playbackRate$_, o = n + h, a = this._$_timelineDataItem$_._$_totalTime$_;
                            o < 0 ? (this._$_playheadTime$_ = 0, this._$_overshoot$_ = -o) : a <= o ? (this._$_playheadTime$_ = a, 
                            this._$_overshoot$_ = this._$_playheadTime$_ - o) : (this._$_playheadTime$_ = o, 
                            this._$_overshoot$_ = 0);
                            let t = !1, e = !1, s = this._$GetLoop$_(), i = this._$GetPingPong$_();
                            s || i ? s && !i ? 0 < this._$_playbackRate$_ ? this._$_playheadTime$_ >= a && (this._$_SetTimeAndReset$_(0), 
                            this._$_TweenTrigger$_(C33._$Behaviors$_._$Tween$_._$Cnds$_._$OnAnyTweenLoop$_), 
                            this._$_TweenTrigger$_(C33._$Behaviors$_._$Tween$_._$Cnds$_._$OnTweensLoop$_), 
                            e = !0) : this._$_playheadTime$_ <= 0 && (this._$_SetTimeAndReset$_(a), 
                            this._$_TweenTrigger$_(C33._$Behaviors$_._$Tween$_._$Cnds$_._$OnAnyTweenLoop$_), 
                            this._$_TweenTrigger$_(C33._$Behaviors$_._$Tween$_._$Cnds$_._$OnTweensLoop$_), 
                            e = !0) : !s && i ? 0 < this._$_playbackRate$_ ? this._$_playheadTime$_ >= a && (this._$_SetTime$_(a), 
                            this._$SetPlaybackRate$_(-1 * this._$GetPlaybackRate$_()), 
                            e = !0, this._$_pingPongState$_ === PING_PONG_END ? this._$_currentRepeatCount$_ < this._$GetRepeatCount$_() ? (this._$_currentRepeatCount$_++, 
                            this._$_TweenTrigger$_(C33._$Behaviors$_._$Tween$_._$Cnds$_._$OnAnyTweenLoop$_), 
                            this._$_TweenTrigger$_(C33._$Behaviors$_._$Tween$_._$Cnds$_._$OnTweensLoop$_), 
                            this._$_TweenTrigger$_(C33._$Behaviors$_._$Tween$_._$Cnds$_._$OnAnyTweenPingPong$_), 
                            this._$_TweenTrigger$_(C33._$Behaviors$_._$Tween$_._$Cnds$_._$OnTweensPingPong$_), 
                            this._$_pingPongState$_ = PING_PONG_BEGIN) : (this._$_TweenTrigger$_(C33._$Behaviors$_._$Tween$_._$Cnds$_._$OnAnyTweenPingPong$_), 
                            this._$_TweenTrigger$_(C33._$Behaviors$_._$Tween$_._$Cnds$_._$OnTweensPingPong$_), 
                            t = !0) : this._$_pingPongState$_ === PING_PONG_BEGIN && (this._$_TweenTrigger$_(C33._$Behaviors$_._$Tween$_._$Cnds$_._$OnAnyTweenPingPong$_), 
                            this._$_TweenTrigger$_(C33._$Behaviors$_._$Tween$_._$Cnds$_._$OnTweensPingPong$_), 
                            this._$_pingPongState$_ = PING_PONG_END)) : this._$_playheadTime$_ <= 0 && (this._$_SetTime$_(0), 
                            this._$SetPlaybackRate$_(-1 * this._$GetPlaybackRate$_()), 
                            e = !0, this._$_pingPongState$_ === PING_PONG_END ? this._$_currentRepeatCount$_ < this._$GetRepeatCount$_() ? (this._$_currentRepeatCount$_++, 
                            this._$_TweenTrigger$_(C33._$Behaviors$_._$Tween$_._$Cnds$_._$OnAnyTweenLoop$_), 
                            this._$_TweenTrigger$_(C33._$Behaviors$_._$Tween$_._$Cnds$_._$OnTweensLoop$_), 
                            this._$_TweenTrigger$_(C33._$Behaviors$_._$Tween$_._$Cnds$_._$OnAnyTweenPingPong$_), 
                            this._$_TweenTrigger$_(C33._$Behaviors$_._$Tween$_._$Cnds$_._$OnTweensPingPong$_), 
                            this._$_pingPongState$_ = PING_PONG_BEGIN) : (t = !0, 
                            this._$_TweenTrigger$_(C33._$Behaviors$_._$Tween$_._$Cnds$_._$OnAnyTweenPingPong$_), 
                            this._$_TweenTrigger$_(C33._$Behaviors$_._$Tween$_._$Cnds$_._$OnTweensPingPong$_)) : this._$_pingPongState$_ === PING_PONG_BEGIN && (this._$_TweenTrigger$_(C33._$Behaviors$_._$Tween$_._$Cnds$_._$OnAnyTweenPingPong$_), 
                            this._$_TweenTrigger$_(C33._$Behaviors$_._$Tween$_._$Cnds$_._$OnTweensPingPong$_), 
                            this._$_pingPongState$_ = PING_PONG_END)) : s && i && (0 < this._$_playbackRate$_ ? this._$_playheadTime$_ >= a && (this._$_SetTime$_(a), 
                            this._$SetPlaybackRate$_(-1 * this._$GetPlaybackRate$_()), 
                            e = !0, this._$_pingPongState$_ === PING_PONG_BEGIN && (this._$_TweenTrigger$_(C33._$Behaviors$_._$Tween$_._$Cnds$_._$OnAnyTweenPingPong$_), 
                            this._$_TweenTrigger$_(C33._$Behaviors$_._$Tween$_._$Cnds$_._$OnTweensPingPong$_)), 
                            this._$_pingPongState$_ === PING_PONG_END && (this._$_TweenTrigger$_(C33._$Behaviors$_._$Tween$_._$Cnds$_._$OnAnyTweenLoop$_), 
                            this._$_TweenTrigger$_(C33._$Behaviors$_._$Tween$_._$Cnds$_._$OnTweensLoop$_), 
                            this._$_TweenTrigger$_(C33._$Behaviors$_._$Tween$_._$Cnds$_._$OnAnyTweenPingPong$_), 
                            this._$_TweenTrigger$_(C33._$Behaviors$_._$Tween$_._$Cnds$_._$OnTweensPingPong$_)), 
                            this._$_pingPongState$_++, this._$_pingPongState$_ = C33.wrap(this._$_pingPongState$_, 0, 2)) : this._$_playheadTime$_ <= 0 && (this._$_SetTime$_(0), 
                            this._$SetPlaybackRate$_(-1 * this._$GetPlaybackRate$_()), 
                            e = !0, this._$_pingPongState$_ === PING_PONG_BEGIN && (this._$_TweenTrigger$_(C33._$Behaviors$_._$Tween$_._$Cnds$_._$OnAnyTweenPingPong$_), 
                            this._$_TweenTrigger$_(C33._$Behaviors$_._$Tween$_._$Cnds$_._$OnTweensPingPong$_)), 
                            this._$_pingPongState$_ === PING_PONG_END && (this._$_TweenTrigger$_(C33._$Behaviors$_._$Tween$_._$Cnds$_._$OnAnyTweenLoop$_), 
                            this._$_TweenTrigger$_(C33._$Behaviors$_._$Tween$_._$Cnds$_._$OnTweensLoop$_), 
                            this._$_TweenTrigger$_(C33._$Behaviors$_._$Tween$_._$Cnds$_._$OnAnyTweenPingPong$_), 
                            this._$_TweenTrigger$_(C33._$Behaviors$_._$Tween$_._$Cnds$_._$OnTweensPingPong$_)), 
                            this._$_pingPongState$_++, this._$_pingPongState$_ = C33.wrap(this._$_pingPongState$_, 0, 2))) : 0 < this._$_playbackRate$_ ? this._$_playheadTime$_ >= a && (this._$_currentRepeatCount$_ < this._$GetRepeatCount$_() ? (this._$_currentRepeatCount$_++, 
                            this._$_SetTimeAndReset$_(0), this._$_TweenTrigger$_(C33._$Behaviors$_._$Tween$_._$Cnds$_._$OnAnyTweenLoop$_), 
                            this._$_TweenTrigger$_(C33._$Behaviors$_._$Tween$_._$Cnds$_._$OnTweensLoop$_), 
                            e = !0) : (this._$_SetTime$_(a), t = !0)) : this._$_playheadTime$_ <= 0 && (this._$_currentRepeatCount$_ < this._$GetRepeatCount$_() ? (this._$_currentRepeatCount$_++, 
                            this._$_SetTimeAndReset$_(a), this._$_TweenTrigger$_(C33._$Behaviors$_._$Tween$_._$Cnds$_._$OnAnyTweenLoop$_), 
                            this._$_TweenTrigger$_(C33._$Behaviors$_._$Tween$_._$Cnds$_._$OnTweensLoop$_), 
                            e = !0) : (this._$_SetTime$_(0), t = !0)), t ? (this._$_track$_._$SetEndState$_(), 
                            this._$Stop$_(!0), this._$OnCompleted$_()) : (this._$_track$_._$Interpolate$_(this._$_playheadTime$_, !0, !1, e, this._$_firstTick$_, !1), 
                            this._$_firstTick$_ && (this._$_firstTick$_ = !1));
                        }
                    }
                }
                _$_TweenTrigger$_(t) {
                    const e = this._$GetInstance$_(), s = e._$GetBehaviorSdkInstanceFromCtor$_(C33._$Behaviors$_._$Tween$_);
                    s._$PushTriggerTween$_(this), this._$_runtime$_._$Trigger$_(t, e, s._$GetBehaviorType$_()), 
                    s._$PopTriggerTween$_();
                }
                _$_SaveToJson$_() {
                    const t = super._$_SaveToJson$_(), e = this._$GetTimelineDataItem$_();
                    return Object.assign(t, {
                        tweenDataItemJson: e._$_SaveToJson$_(),
                        id: this._$_id$_,
                        destroyInstanceOnComplete: this._$_destroyInstanceOnComplete$_,
                        initialValueMode: this._$_initialValueMode$_
                    });
                }
                _$_LoadFromJson$_(t) {
                    if (t) {
                        const e = this._$GetTimelineDataItem$_();
                        e._$_LoadFromJson$_(t.tweenDataItemJson), super._$_LoadFromJson$_(t), 
                        this._$_id$_ = t.id, this._$_destroyInstanceOnComplete$_ = t.destroyInstanceOnComplete, 
                        this._$_initialValueMode$_ = t.initialValueMode, this._$_CacheTrack$_();
                    }
                }
                static IsPlaying(t) {
                    return t.IsPlaying();
                }
                static _$IsPaused$_(t) {
                    return t._$IsPaused$_();
                }
                static _$IsPing$_(t) {
                    return !!t._$GetPingPong$_() && t._$GetPingPongState$_() === PING_PONG_BEGIN;
                }
                static _$IsPong$_(t) {
                    return !!t._$GetPingPong$_() && t._$GetPingPongState$_() === PING_PONG_END;
                }
                static _$Build$_(t) {
                    const e = t.runtime._$GetTimelineManager$_(), s = new C33._$TimelineDataItem$_();
                    if (t.json) {
                        s._$_LoadFromJson$_(t.json.tweenDataItemJson);
                        const i = new C33._$TweenState$_(s, e);
                        return i._$_LoadFromJson$_(t.json), i;
                    }
                    {
                        const r = new C33._$TweenState$_(s, e), n = (C33._$IsArray$_(t._$propertyTracksConfig$_) || (t._$propertyTracksConfig$_ = [ t._$propertyTracksConfig$_ ]), 
                        r._$SetId$_(t.id), r._$SetTags$_(t.tags), r._$SetInitialValueMode$_(t.initialValueMode), 
                        r._$SetDestroyInstanceOnComplete$_(t._$releaseOnComplete$_), 
                        r._$SetLoop$_(t.loop), r._$SetPingPong$_(t.pingPong), r._$SetTotalTime$_(t.time), 
                        r._$SetStep$_(0), r._$SetInterpolationMode$_("default"), 
                        r._$SetResultMode$_(t._$propertyTracksConfig$_[0].resultMode), 
                        r._$SetRepeatCount$_(t.repeatCount), r._$AddTrack$_()), h = (n._$SetInstanceUID$_(t.instance._$GetUID$_()), 
                        n._$SetInterpolationMode$_("default"), n._$SetResultMode$_(t._$propertyTracksConfig$_[0].resultMode), 
                        n._$SetEnable$_(!0), n._$SetObjectClassIndex$_(t.instance._$GetObjectClass$_()._$GetIndex$_()), 
                        t.instance._$GetSdkInstance$_()), o = h._$IsOriginalSizeKnown$_() ? h._$GetOriginalWidth$_() : t.instance._$GetWorldInfo$_()._$GetWidth$_(), a = h._$IsOriginalSizeKnown$_() ? h._$GetOriginalHeight$_() : t.instance._$GetWorldInfo$_()._$GetHeight$_(), l = (n._$SetOriginalWidth$_(o), 
                        n._$SetOriginalHeight$_(a), n._$AddKeyframe$_()), u = (l._$SetTime$_(0), 
                        l._$SetEase$_("noease"), l._$SetEnable$_(!0), l._$SetTags$_(""), 
                        n._$AddKeyframe$_());
                        u._$SetTime$_(t.time), u._$SetEase$_("noease"), u._$SetEnable$_(!0), 
                        u._$SetTags$_("");
                        for (const c of t._$propertyTracksConfig$_) {
                            const f = n._$AddPropertyTrack$_(), d = (f._$SetSourceAdapterId$_(c._$sourceId$_), 
                            f._$SetSourceAdapterArgs$_(c._$sourceArgs$_), f._$SetPropertyName$_(c.property), 
                            f._$SetPropertyType$_(c.type), f._$SetMin$_(NaN), f._$SetMax$_(NaN), 
                            f._$SetInterpolationMode$_("default"), f._$SetResultMode$_(c.resultMode), 
                            f._$SetEnable$_(!0), f._$AddPropertyKeyframe$_()), p = (d.SetType(c.valueType), 
                            d._$SetTime$_(0), d._$SetEase$_(c.ease), d._$SetEnable$_(!0), 
                            d._$SetValue$_(c._$startValue$_), d._$SetAbsoluteValue$_(c._$startValue$_), 
                            f._$AddPropertyKeyframe$_());
                            p.SetType(c.valueType), p._$SetTime$_(t.time), p._$SetEase$_(c.ease), 
                            p._$SetEnable$_(!0), p._$SetValue$_(c._$endValue$_), 
                            p._$SetAbsoluteValue$_(c._$endValue$_), f._$GetSourceAdapter$_();
                        }
                        return r;
                    }
                }
                static _$SetInstanceUID$_(t, e) {
                    if (!isNaN(e)) for (const s of t._$GetTracks$_()) s._$SetInstanceUID$_(e);
                }
                _$GetITweenState$_(t, e) {
                    return this._$_iTweenState$_ || (this._$_iTweenState$_ = C33._$New$_(self._$ITweenState$_, this, t, e)), 
                    this._$_iTweenState$_;
                }
            };
        }
        {
            const C33 = self._$C3$_;
            C33._$TweenTrackState$_ = class extends C33._$TrackState$_ {
                constructor(t, e) {
                    super(t, e), this._$_firstPropertyTrack$_ = null, this._$_secondPropertyTrack$_ = null;
                }
                static _$Create$_(t, e) {
                    return C33._$New$_(C33._$TweenTrackState$_, t, e);
                }
                _$_CachePropertyTracks$_() {
                    1 === this._$_propertyTracks$_.length ? this._$_firstPropertyTrack$_ = this._$_propertyTracks$_[0] : (this._$_firstPropertyTrack$_ = this._$_propertyTracks$_[0], 
                    this._$_secondPropertyTrack$_ = this._$_propertyTracks$_[1]);
                }
                _$CreatePropertyTrackStates$_() {
                    for (const t of this._$_trackDataItem$_._$GetPropertyTrackData$_()._$propertyTrackDataItems$_()) this._$_propertyTracks$_.push(C33._$TweenPropertyTrackState$_._$Create$_(this, t));
                    this._$_CachePropertyTracks$_();
                }
                _$AddPropertyTrack$_() {
                    const t = this._$_trackDataItem$_._$GetPropertyTrackData$_(), e = t._$AddEmptyPropertyTrackDataItem$_(), s = C33._$TweenPropertyTrackState$_._$Create$_(this, e);
                    return this._$_propertyTracks$_.push(s), this._$_CachePropertyTracks$_(), 
                    s;
                }
                _$SetInitialState$_() {
                    if (this._$MaybeGetInstance$_(), this._$IsInstanceValid$_() || !this._$IsInstanceTrack$_()) {
                        const t = this._$GetTimeline$_(), e = t._$IsForwardPlayBack$_(), s = e ? 0 : this._$GetLocalTotalTime$_();
                        for (const r of this._$_propertyTracks$_) r._$SetInitialState$_(s), 
                        0 === this._$_worldInfoChange$_ && 1 === r._$GetWorldInfoChange$_() && (this._$_worldInfoChange$_ = 1), 
                        0 === this._$_renderChange$_ && 1 === r._$GetRenderChange$_() && (this._$_renderChange$_ = 1);
                        this._$_needsBeforeAndAfter$_ = 0;
                        const i = this._$_propertyTracks$_.some(t => t._$GetNeedsBeforeAndAfter$_());
                        i && (this._$_needsBeforeAndAfter$_ = 1), this._$_lastKeyframeDataItem$_ = this._$_GetLastKeyFrameBeforeTime$_(s), 
                        this._$_initialStateOfNestedSet$_ = !1, this._$_endStateOfNestedSet$_ = !1, 
                        this._$Interpolate$_(s);
                    }
                }
                _$BeforeInterpolate$_() {}
                _$Interpolate$_(t, e = 0, s = !1, i = !1, r, n = !1, h = !1) {
                    if (this._$_instance$_ || this._$GetInstance$_(), this._$_instance$_) {
                        const o = !this._$_instance$_._$IsDestroyed$_();
                        return o && (!n || !this._$GetObjectClass$_()._$IsGlobal$_()) && ((this._$_secondPropertyTrack$_ ? (this._$_firstPropertyTrack$_._$Interpolate$_(t, s, i, h), 
                        this._$_secondPropertyTrack$_) : this._$_firstPropertyTrack$_)._$Interpolate$_(t, s, i, h), 
                        void (0 !== this._$_firstPropertyTrack$_._$GetWorldInfoChange$_() && (this._$_worldInfo$_ || (this._$_worldInfo$_ = this._$_instance$_._$GetWorldInfo$_()), 
                        this._$_worldInfo$_) && this._$_worldInfo$_._$SetBboxChanged$_()));
                    }
                }
                _$AfterInterpolate$_() {}
                _$_LoadFromJson$_(t) {
                    super._$_LoadFromJson$_(t), this._$_CachePropertyTracks$_();
                }
            };
        }
        {
            const C33 = self._$C3$_;
            C33._$TweenPropertyTrackState$_ = class extends C33._$PropertyTrackState$_ {
                constructor(t, e) {
                    super(t, e), this._$_basic$_ = !1;
                }
                static _$Create$_(t, e) {
                    return C33._$New$_(C33._$TweenPropertyTrackState$_, t, e);
                }
                _$Interpolate$_(t, e = !1, s = !1, i = !1) {
                    let r, n;
                    if (this._$_basic$_) r = this._$_propertyKeyframeDataItems$_[0], 
                    n = this._$_propertyKeyframeDataItems$_[1]; else {
                        if (e) r = this._$_propertyTrackData$_._$GetFirstPropertyKeyFrameDataItemLowerOrEqualThan$_(t, this._$_propertyTrackDataItem$_); else {
                            if (this._$_lastPropertyKeyframeDataItem$_) {
                                const h = this._$GetTimeline$_(), o = this._$_lastPropertyKeyframeDataItem$_._$GetNext$_(), a = this._$_lastPropertyKeyframeDataItem$_._$GetTime$_(), l = o ? o._$GetTime$_() : h._$GetTotalTime$_();
                                (t <= a || l <= t) && (this._$_lastPropertyKeyframeDataItem$_ = this._$_propertyTrackData$_._$GetFirstPropertyKeyFrameDataItemLowerOrEqualThan$_(t, this._$_propertyTrackDataItem$_));
                            } else this._$_lastPropertyKeyframeDataItem$_ = this._$_propertyTrackData$_._$GetFirstPropertyKeyFrameDataItemLowerOrEqualThan$_(t, this._$_propertyTrackDataItem$_);
                            r = this._$_lastPropertyKeyframeDataItem$_;
                        }
                        n = r._$GetNext$_();
                    }
                    this._$_sourceAdapter$_._$Interpolate$_(t, r, n, e, s, i);
                }
                _$AddPropertyKeyframe$_() {
                    const t = this._$_propertyTrackDataItem$_._$GetPropertyKeyframeData$_(), e = t._$AddEmptyPropertyKeyframeDataItem$_();
                    return this._$_lastPropertyKeyframeDataItem$_ = null, this._$_basic$_ = this._$GetPropertyKeyframeDataItems$_().length <= 2, 
                    e;
                }
                _$DeletePropertyKeyframes$_(t) {
                    this._$_lastPropertyKeyframeDataItem$_ = null;
                    const e = this._$_propertyTrackDataItem$_._$GetPropertyKeyframeData$_();
                    e._$DeletePropertyKeyframeDataItems$_(t), this._$_basic$_ = this._$GetPropertyKeyframeDataItems$_().length <= 2;
                }
                _$_SaveToJson$_() {
                    return {
                        sourceAdapterJson: this._$GetSourceAdapter$_()._$_SaveToJson$_(),
                        basic: this._$_basic$_
                    };
                }
                _$_LoadFromJson$_(t) {
                    t && (this._$GetSourceAdapter$_()._$_LoadFromJson$_(t.sourceAdapterJson), 
                    this._$_basic$_ = t.basic);
                }
            };
        }
        {
            const C33 = self._$C3$_, Ease = self._$Ease$_, NAME = 0, TRANSITION_KEYFRAMES = 1, LINEAR = 2;
            C33._$Transition$_ = class extends C33._$DefendedBase$_ {
                constructor(t, e = !0) {
                    super(), this._$_name$_ = t[NAME], this._$_linear$_ = t[LINEAR], 
                    this._$_transitionKeyframes$_ = [];
                    for (const s of t[TRANSITION_KEYFRAMES]) {
                        const i = C33._$TransitionKeyframe$_._$Create$_(this, s);
                        this._$_transitionKeyframes$_.push(i);
                    }
                    for (let t = 0; t < this._$_transitionKeyframes$_.length; t++) {
                        const r = this._$_transitionKeyframes$_[t], n = this._$_transitionKeyframes$_[t + 1], h = this._$_transitionKeyframes$_[t - 1];
                        r._$SetNext$_(n), r._$SetPrevious$_(h);
                    }
                    this._$_precalculatedSamples$_ = new Map(), this._$_transitionKeyframeCache$_ = new Map(), 
                    this._$_PreCalcSamples$_(), e && Ease._$AddCustomEase$_(this._$_name$_, (t, e, s, i) => this._$Interpolate$_(t, e, s, i), null, {
                        transition: this
                    });
                }
                static _$Create$_(t) {
                    return C33._$New$_(C33._$Transition$_, t);
                }
                _$Release$_() {
                    for (const t of this._$_transitionKeyframes$_) t._$Release$_();
                    C33._$clearArray$_(this._$_transitionKeyframes$_), this._$_transitionKeyframes$_ = null, 
                    this._$_precalculatedSamples$_.clear(), this._$_precalculatedSamples$_ = null, 
                    this._$_transitionKeyframeCache$_.clear(), this._$_transitionKeyframeCache$_ = null;
                }
                _$MakeLinear$_(t) {
                    this._$_linear$_ = !!t;
                }
                _$GetTransitionKeyFrameAt$_(t) {
                    const e = this._$_transitionKeyframeCache$_.get(t);
                    if (e) return e;
                    for (const s of this._$_transitionKeyframes$_) if (s._$GetValueX$_() === t) return this._$_transitionKeyframeCache$_.set(t, s), 
                    s;
                }
                _$GetFirstTransitionKeyFrameLowerOrEqualThan$_(e) {
                    for (let t = this._$_transitionKeyframes$_.length - 1; 0 <= t; t--) {
                        const s = this._$_transitionKeyframes$_[t], i = s._$GetValueX$_();
                        if (i <= e) {
                            let t = s;
                            if (i < e) return t;
                            if (i === e) {
                                for (;t; ) {
                                    const r = t._$GetPrevious$_();
                                    if (!r) break;
                                    if (r._$GetValueX$_() !== t._$GetValueX$_()) break;
                                    t = r;
                                }
                                return t;
                            }
                        }
                    }
                }
                _$Interpolate$_(t, e, s, i) {
                    let r = t / i;
                    if (this._$_linear$_) {
                        const S = this._$GetTransitionKeyFrameAt$_(0), _ = this._$GetTransitionKeyFrameAt$_(1), T = e + (e + s) * S._$GetValueY$_(), y = (e + s) * _._$GetValueY$_(), E = y - T;
                        return 0 === i ? T + E : Ease._$NoEase$_(t, T, E, i);
                    }
                    0 === i && (r = 1);
                    let n = this._$GetFirstTransitionKeyFrameLowerOrEqualThan$_(r), h = n._$GetNext$_();
                    if (!h) {
                        const A = n._$GetPrevious$_(), I = n;
                        n = A, h = I;
                    }
                    const o = h._$GetValueX$_() - n._$GetValueX$_(), a = C33._$mapToRange$_(r, n._$GetValueX$_(), h._$GetValueX$_(), 0, o);
                    if (n._$IsSegmentLinear$_() || 0 == o) {
                        const M = e + (e + s) * n._$GetValueY$_(), w = (e + s) * h._$GetValueY$_(), v = w - M;
                        return 0 == o ? 1 === a ? M + v : M : Ease._$NoEase$_(a, M, v, o);
                    }
                    let l = n._$GetValueX$_(), u = n._$GetValueY$_(), c = n._$GetValueX$_() + n._$GetStartAnchorX$_(), f = n._$GetValueY$_() + n._$GetStartAnchorY$_(), d = h._$GetValueX$_() + h._$GetEndAnchorX$_(), p = h._$GetValueY$_() + h._$GetEndAnchorY$_(), m = h._$GetValueX$_(), C = h._$GetValueY$_(), g = Ease._$GetRuntimeEase$_("spline")(a, l, u, c, f, d, p, m, C, this._$_precalculatedSamples$_.get(n));
                    return (1 - (g += n._$GetValueY$_())) * e + g * (e + s);
                }
                _$_PreCalcSamples$_() {
                    this._$_precalculatedSamples$_.clear();
                    for (let t = 0; t < this._$_transitionKeyframes$_.length - 1; t++) {
                        const e = this._$_transitionKeyframes$_[t];
                        if (e._$GetStartEnable$_()) {
                            const s = e, i = this._$_transitionKeyframes$_[t + 1];
                            if (i._$GetEndEnable$_()) {
                                const r = s._$GetValueX$_(), n = s._$GetValueX$_() + s._$GetStartAnchorX$_(), h = i._$GetValueX$_() + i._$GetEndAnchorX$_(), o = i._$GetValueX$_();
                                this._$_precalculatedSamples$_.set(s, Ease._$GetBezierSamples$_(r, n, h, o));
                            }
                        }
                    }
                }
            };
        }
        {
            const C33 = self._$C3$_, VALUE_X = 0, VALUE_Y = 1, START_ANCHOR_X = 2, START_ANCHOR_Y = 3, END_ANCHOR_X = 4, END_ANCHOR_Y = 5, START_ENABLE = 6, END_ENABLE = 7, SEGMENT_MODE = 8;
            C33._$TransitionKeyframe$_ = class extends C33._$DefendedBase$_ {
                constructor(t, e) {
                    super(), this._$_transition$_ = t, this._$_valueX$_ = e[VALUE_X], 
                    this._$_valueY$_ = e[VALUE_Y], this._$_startAnchorX$_ = e[START_ANCHOR_X], 
                    this._$_startAnchorY$_ = e[START_ANCHOR_Y], this._$_endAnchorX$_ = e[END_ANCHOR_X], 
                    this._$_endAnchorY$_ = e[END_ANCHOR_Y], this._$_startEnable$_ = e[START_ENABLE], 
                    this._$_endEnable$_ = e[END_ENABLE], this._$_segmentMode$_ = e[SEGMENT_MODE], 
                    this._$_next$_ = null, this._$_prev$_ = null;
                }
                _$Release$_() {
                    this._$_transition$_ = null;
                }
                static _$Create$_(t, e) {
                    return C33._$New$_(C33._$TransitionKeyframe$_, t, e);
                }
                _$SetNext$_(t) {
                    this._$_next$_ = t;
                }
                _$GetNext$_() {
                    return this._$_next$_;
                }
                _$SetPrevious$_(t) {
                    this._$_prev$_ = t;
                }
                _$GetPrevious$_() {
                    return this._$_prev$_;
                }
                _$GetValueX$_() {
                    return this._$_valueX$_;
                }
                _$GetValueY$_() {
                    return this._$_valueY$_;
                }
                _$GetStartAnchorX$_() {
                    return this._$_startAnchorX$_;
                }
                _$GetStartAnchorY$_() {
                    return this._$_startAnchorY$_;
                }
                _$GetEndAnchorX$_() {
                    return this._$_endAnchorX$_;
                }
                _$GetEndAnchorY$_() {
                    return this._$_endAnchorY$_;
                }
                _$GetStartEnable$_() {
                    return this._$_startEnable$_;
                }
                _$GetEndEnable$_() {
                    return this._$_endEnable$_;
                }
                _$IsSegmentLinear$_() {
                    return "linear" === this._$_segmentMode$_;
                }
                _$IsSegmentCubic$_() {
                    return "cubic" === this._$_segmentMode$_;
                }
            };
        }
        {
            const C33 = self._$C3$_;
            C33._$TransitionManager$_ = class extends C33._$DefendedBase$_ {
                constructor(t) {
                    super(), this._$_runtime$_ = t, this._$_transitions$_ = [];
                }
                _$Release$_() {
                    for (const t of this._$_transitions$_) t._$Release$_();
                    C33._$clearArray$_(this._$_transitions$_), this._$_transitions$_ = null;
                }
                _$Create$_(t) {
                    this._$_transitions$_.push(C33._$Transition$_._$Create$_(t));
                }
            };
        }
        {
            const C33 = self._$C3$_;
            C33._$TemplateManager$_ = class extends C33._$DefendedBase$_ {
                constructor(t) {
                    super(), this._$_runtime$_ = t, this._$_templateDataMap$_ = null, 
                    this._$_instanceToTemplateNameMap$_ = null, this._$_instanceDestroy$_ = t => this._$_OnInstanceDestroy$_(t.instance);
                }
                _$Release$_() {
                    if (this._$RemoveRuntimeListeners$_(), this._$_templateDataMap$_) {
                        for (const t of this._$_templateDataMap$_.values()) t.clear();
                        this._$_templateDataMap$_.clear();
                    }
                    this._$_templateDataMap$_ = null, this._$_runtime$_ = null;
                }
                _$Create$_(t) {
                    if (this._$_templateDataMap$_ || (this._$_templateDataMap$_ = new Map()), 
                    t) {
                        const e = t[0][16], s = e[0], i = t[1], r = (this._$_templateDataMap$_.has(i) || this._$_templateDataMap$_.set(i, new Map()), 
                        this._$_templateDataMap$_.get(i));
                        r.set(s, t);
                    }
                }
                _$AddRuntimeListeners$_() {
                    const t = this._$_runtime$_._$Dispatcher$_();
                    t && t.addEventListener("instancedestroy", this._$_instanceDestroy$_);
                }
                _$RemoveRuntimeListeners$_() {
                    const t = this._$_runtime$_._$Dispatcher$_();
                    t && t.removeEventListener("instancedestroy", this._$_instanceDestroy$_);
                }
                _$HasTemplates$_() {
                    return !!this._$_templateDataMap$_ && 0 !== this._$_templateDataMap$_.size;
                }
                _$GetTemplateData$_(t, e) {
                    let s;
                    if (s = t instanceof C33._$ObjectClass$_ ? t._$GetIndex$_() : t, 
                    this._$_templateDataMap$_.has(s)) {
                        const i = this._$_templateDataMap$_.get(s).get(e);
                        return i ? JSON.parse(JSON.stringify(i)) : void 0;
                    }
                }
                _$MapInstanceToTemplateName$_(t, e) {
                    this._$_instanceToTemplateNameMap$_ || (this._$_instanceToTemplateNameMap$_ = new WeakMap()), 
                    this._$_instanceToTemplateNameMap$_.has(t) || this._$_instanceToTemplateNameMap$_.set(t, e);
                }
                _$GetInstanceTemplateName$_(t) {
                    if (!this._$_instanceToTemplateNameMap$_) return "";
                    const e = this._$_instanceToTemplateNameMap$_.get(t);
                    return e || "";
                }
                _$_OnInstanceDestroy$_(t) {
                    this._$_instanceToTemplateNameMap$_ && this._$_instanceToTemplateNameMap$_.has(t) && this._$_instanceToTemplateNameMap$_.delete(t);
                }
            };
        }
        {
            const C33 = self._$C3$_;
            C33._$FlowchartManager$_ = class {
                constructor(t) {
                    this._$_runtime$_ = t, this._$_flowchartDataManager$_ = new C33._$FlowchartDataManager$_();
                }
                _$Release$_() {
                    this._$_flowchartDataManager$_._$Release$_(), this._$_flowchartDataManager$_ = null, 
                    this._$_runtime$_ = null;
                }
                _$GetRuntime$_() {
                    return this._$_runtime$_;
                }
                _$Create$_(t) {
                    this._$_flowchartDataManager$_._$Add$_(t);
                }
                _$GetFlowchartDataItemByName$_(t) {
                    return this._$_flowchartDataManager$_._$Get$_(t);
                }
                _$HasFlowcharts$_() {
                    return this._$_flowchartDataManager$_._$HasFlowcharts$_();
                }
            };
        }
        {
            const C33 = self._$C3$_;
            C33._$FlowchartState$_ = class {
                constructor(t, e, s, i, r, n, h) {
                    this._$_runtime$_ = r._$GetRuntime$_(), this._$_flowchartManager$_ = r, 
                    this._$_flowchartName$_ = t, this._$_startNodeTag$_ = s, this._$_flowchartDataItem$_ = i, 
                    this._$_tag$_ = e, this._$_pluginInstance$_ = n, this._$_pluginUID$_ = h ?? n._$GetInstance$_()._$GetUID$_(), 
                    this._$_SetStartFlowchartNode$_(), this._$_currentFlowchartNodeId$_ = this._$_startFlowchartNode$_?._$GetFlowchartId$_() ?? -1, 
                    this._$_previousFlowchartNodeIds$_ = [], this._$_previousFlowchartState$_ = null, 
                    this._$_previousFlowchartStateStartNodeId$_ = NaN, this._$_referenceFlowchartStates$_ = null, 
                    this._$_currentReferenceFlowchartState$_ = null, this._$_rootFlowchartState$_ = null, 
                    this._$_previousFlowchartStateTag$_ = "", this._$_referenceFlowchartStatesJson$_ = null, 
                    this._$_currentReferenceFlowchartStateTag$_ = "", this._$_rootFlowchartStateTag$_ = "", 
                    this._$_triggerCount$_ = 0, this._$_markForRelease$_ = !1, this._$_released$_ = !1;
                }
                _$Release$_() {
                    this._$_released$_ || (C33._$clearArray$_(this._$_previousFlowchartNodeIds$_), 
                    this._$_previousFlowchartNodeIds$_ = null, this._$_runtime$_ = null, 
                    this._$_flowchartManager$_ = null, this._$_flowchartDataItem$_ = null, 
                    this._$_pluginInstance$_ = null, this._$_previousFlowchartState$_ = null, 
                    this._$_previousFlowchartStateStartNodeId$_ = NaN, this._$_referenceFlowchartStates$_ && this._$_referenceFlowchartStates$_.clear(), 
                    this._$_referenceFlowchartStates$_ = null, this._$_currentReferenceFlowchartState$_ = null, 
                    this._$_rootFlowchartState$_ = null, this._$_previousFlowchartStateTag$_ = "", 
                    this._$_referenceFlowchartStatesJson$_ = null, this._$_currentReferenceFlowchartStateTag$_ = "", 
                    this._$_rootFlowchartStateTag$_ = "", this._$_released$_ = !0);
                }
                _$WasReleased$_() {
                    return this._$_released$_;
                }
                _$GetFlowchartManager$_() {
                    return this._$_flowchartManager$_;
                }
                _$GetRuntime$_() {
                    return this._$_runtime$_;
                }
                _$GetName$_() {
                    return this._$_flowchartName$_;
                }
                _$GetFlowchartDataItem$_() {
                    return this._$_flowchartDataItem$_;
                }
                _$GetTag$_() {
                    return this._$_tag$_;
                }
                _$GetPluginInstance$_() {
                    return this._$_pluginInstance$_ || (this._$_pluginInstance$_ = this._$_runtime$_._$GetInstanceByUID$_(this._$_pluginUID$_)._$GetSdkInstance$_()), 
                    this._$_pluginInstance$_;
                }
                _$GetCurrentNode$_() {
                    return this._$GetFlowchartElementById$_(this._$_currentFlowchartNodeId$_);
                }
                _$GetCurrentNodeTag$_() {
                    const t = this._$GetCurrentNode$_();
                    return t ? t._$GetTag$_() : "";
                }
                _$GetCurrentNodeTags$_() {
                    const t = this._$GetCurrentNode$_();
                    return t ? t._$GetTags$_() : [];
                }
                _$CurrentNodeHasTags$_(t) {
                    const e = this._$GetCurrentNodeTags$_();
                    if (!e) return !1;
                    if (!e.length) return !1;
                    const s = C33._$FlowchartState$_._$_GetTagArray$_(t);
                    return !(!s || !s.length) && s.every(C33._$FlowchartState$_._$_HasTag$_, e);
                }
                _$CurrentNodeCompareTags$_(t, e) {
                    const s = this._$GetCurrentNodeTags$_();
                    if (!s) return !1;
                    if (!s.length) return !1;
                    const i = C33._$FlowchartState$_._$_GetTagArray$_(t);
                    return !(!i || !i.length) && i.every(t => C33._$FlowchartState$_._$_CompareTag$_.call(s, t, e));
                }
                static _$_HasTag$_(t) {
                    return "" === t ? 1 === this.length && "" === this[0] : this.map(t => t.trim().toLowerCase()).includes(t.trim().toLowerCase());
                }
                static _$_GetTagArray$_(t) {
                    return t.trim().split(" ");
                }
                static _$_CompareTag$_(e, s) {
                    return "" === e ? 1 === this.length && "" === this[0] : this.some(t => C33.compare(t.trim(), s, e.trim()));
                }
                _$GetCurrentNodeParent$_(t) {
                    const e = this._$GetCurrentNode$_();
                    if (e) {
                        if (C33._$IsFiniteNumber$_(t)) {
                            const s = e._$GetParentFlowchartIds$_(), i = s ? s[t] : void 0;
                            if (C33._$IsFiniteNumber$_(i)) return this._$GetFlowchartElementById$_(i);
                        }
                        if ("string" == typeof t) for (const r of e._$GetParentFlowchartIds$_()) {
                            const n = this._$GetFlowchartElementById$_(r);
                            if (n._$HasTags$_(t)) return this._$GetFlowchartElementById$_(n._$GetFlowchartId$_());
                        }
                    }
                }
                _$GetCurrentNodeParentTag$_(t) {
                    const e = this._$GetCurrentNodeParent$_(t);
                    return e ? e._$GetTag$_() : "";
                }
                _$GetCurrentNodeParentTags$_(t) {
                    const e = this._$GetCurrentNodeParent$_(t);
                    return e ? e._$GetTags$_() : "";
                }
                _$GetCurrentNodeParentIndex$_(t) {
                    const e = this._$GetCurrentNode$_();
                    if (!e) return -1;
                    const s = e._$GetParentFlowchartIds$_();
                    if (!s) return -1;
                    const i = this._$GetCurrentNodeParent$_(t);
                    return i ? s.indexOf(i._$GetFlowchartId$_()) : -1;
                }
                _$GetCurrentNodeParentCount$_() {
                    const t = this._$GetCurrentNode$_();
                    if (!t) return 0;
                    const e = t._$GetParentFlowchartIds$_();
                    return e ? e.length : 0;
                }
                _$GetFlowchartElementById$_(t) {
                    return this._$_flowchartDataItem$_._$GetFlowchartElementById$_(t);
                }
                _$Reset$_() {
                    const t = this._$_GetRootFlowchartState$_();
                    t._$_Reset$_(!0);
                }
                _$_Reset$_(t) {
                    if (this._$_GetReferenceFlowchartStates$_()) {
                        for (const [ e, s ] of this._$_GetReferenceFlowchartStates$_().entries()) s._$_Reset$_(!1);
                        this._$_GetReferenceFlowchartStates$_().clear();
                    }
                    if (this._$_referenceFlowchartStates$_ = null, this._$_previousFlowchartState$_ = null, 
                    this._$_previousFlowchartStateStartNode$_ = null, this._$_currentReferenceFlowchartState$_ = null, 
                    this._$_previousFlowchartStateTag$_ = "", this._$_referenceFlowchartStatesJson$_ = null, 
                    this._$_currentReferenceFlowchartStateTag$_ = "", this._$_rootFlowchartStateTag$_ = "", 
                    this._$_previousFlowchartNodeIds$_ = [], t) {
                        this._$_flowchartManager$_._$SetCurrentFlowchartState$_(this);
                        const i = this._$_startFlowchartNode$_._$GetFlowchartId$_();
                        i !== this._$_currentFlowchartNodeId$_ && this._$_GotoFlowchartNode$_(i);
                    } else this._$_currentFlowchartNodeId$_ = this._$_startFlowchartNode$_._$GetFlowchartId$_();
                }
                _$GetCurrentNodeOutputCount$_() {
                    const t = this._$_flowchartDataItem$_._$GetFlowchartElementById$_(this._$_currentFlowchartNodeId$_);
                    return t ? t._$GetFlowchartNodeOutputData$_()._$GetFlowchartNodeOutputDataItemCount$_() : 0;
                }
                _$GetCurrentNodeOutputNameAt$_(t) {
                    const e = this._$_GetFlowchartNodeOutputAt$_(t);
                    return e ? e._$GetName$_() : "";
                }
                _$GetCurrentNodeOutputValueAt$_(t) {
                    let e;
                    return C33._$IsFiniteNumber$_(t) && (e = this._$_GetFlowchartNodeOutputAt$_(t)), 
                    "string" == typeof t && (e = this._$_GetFlowchartNodeOutputByName$_(t)), 
                    "number" != typeof t && "string" != typeof t && console.warn("[Flowcharts] unexpected argument type in GetCurrentNodeOutputValueAt expression"), 
                    e ? e._$GetValue$_() : "";
                }
                _$GotoNextFlowchartNode$_(t) {
                    let e;
                    if (C33._$IsFiniteNumber$_(t) && (e = this._$_GetFlowchartNodeOutputAt$_(t)), 
                    e = "string" == typeof t ? this._$_GetFlowchartNodeOutputByName$_(t) : e) {
                        const s = e._$GetConnectedFlowchartNodeFlowchartId$_();
                        C33._$IsFiniteNumber$_(s) && (this._$_previousFlowchartNodeIds$_.push(this._$_currentFlowchartNodeId$_), 
                        this._$_GotoFlowchartNode$_(s));
                    }
                }
                _$GotoAnyFlowchartNode$_(t) {
                    const e = this._$_flowchartDataItem$_._$GetFlowchartNodeByTags$_(t);
                    if (e) {
                        const s = this._$_flowchartDataItem$_._$GetFlowchartElementById$_(e._$GetFlowchartId$_());
                        s && (this._$_previousFlowchartNodeIds$_.push(this._$_currentFlowchartNodeId$_), 
                        this._$_GotoFlowchartNode$_(s._$GetFlowchartId$_()));
                    }
                }
                _$GotoPreviousFlowchartNode$_() {
                    const t = this._$_previousFlowchartNodeIds$_.pop();
                    C33._$IsFiniteNumber$_(t) ? this._$_GotoFlowchartNode$_(t) : this._$_GetPreviousFlowchartState$_() && (this._$_flowchartManager$_._$SetCurrentFlowchartState$_(this._$_GetPreviousFlowchartState$_(), !0, !1, !1), 
                    this._$_GetPreviousFlowchartState$_()._$_GotoFlowchartNode$_(this._$_GetPreviousFlowchartStateStartNodeId$_()), 
                    this._$_GetRootFlowchartState$_()._$_SetCurrentReferenceFlowchart$_(this._$_GetPreviousFlowchartState$_()));
                }
                _$GotoParentFlowchartNode$_(t) {
                    const e = this._$GetCurrentNode$_();
                    if (e) {
                        e._$GetFlowchartId$_();
                        const s = this._$GetCurrentNodeParent$_(t);
                        s && (this._$_previousFlowchartNodeIds$_.push(this._$_currentFlowchartNodeId$_), 
                        this._$_GotoFlowchartNode$_(s._$GetFlowchartId$_()));
                    }
                }
                _$HasOutput$_(e) {
                    if (C33._$IsFiniteNumber$_(e)) {
                        const t = this._$_flowchartDataItem$_._$GetFlowchartElementById$_(this._$_currentFlowchartNodeId$_), s = t._$GetFlowchartNodeOutputData$_()._$GetFlowchartNodeOutputDataItems$_();
                        return !!s[e];
                    }
                    if ("string" == typeof e) {
                        const i = this._$_flowchartDataItem$_._$GetFlowchartElementById$_(this._$_currentFlowchartNodeId$_), r = i._$GetFlowchartNodeOutputData$_()._$GetFlowchartNodeOutputDataItems$_();
                        for (let t = 0; t < r.length; t++) if (r[t]._$GetName$_() === e) return !0;
                    }
                    return !1;
                }
                _$MarkForRelease$_() {
                    this._$_markForRelease$_ = !0;
                }
                _$IsInTriggerState$_() {
                    return 0 < this._$_triggerCount$_;
                }
                _$PushIsTriggerState$_() {
                    this._$_triggerCount$_++;
                }
                _$PopIsTriggerState$_() {
                    this._$_triggerCount$_--, 0 === this._$_triggerCount$_ && this._$_markForRelease$_ && this._$_flowchartManager$_._$RemoveFlowchartState$_(this);
                }
                _$_GotoFlowchartNode$_(t) {
                    const s = this._$_currentFlowchartNodeId$_, e = this._$GetPluginInstance$_()._$GetInstance$_();
                    if (this._$PushIsTriggerState$_(), this._$_flowchartManager$_._$PushFlowchartState$_(this), 
                    this._$_runtime$_._$Trigger$_(C33._$Plugins$_.Flowchart._$Cnds$_.OnBeforeAnyNodeChange, e), 
                    this._$_runtime$_._$Trigger$_(C33._$Plugins$_.Flowchart._$Cnds$_.OnBeforeTaggedNodeChange, e), 
                    this._$_runtime$_._$Trigger$_(C33._$Plugins$_.Flowchart._$Cnds$_.OnBeforeAnyNodeChangeInFlowchart, e), 
                    this._$_runtime$_._$Trigger$_(C33._$Plugins$_.Flowchart._$Cnds$_.OnBeforeTaggedNodeChangeInFlowchart, e), 
                    this._$_currentFlowchartNodeId$_ = t, this._$_runtime$_._$Trigger$_(C33._$Plugins$_.Flowchart._$Cnds$_.OnAnyNodeChange, e), 
                    this._$_runtime$_._$Trigger$_(C33._$Plugins$_.Flowchart._$Cnds$_.OnTaggedNodeChange, e), 
                    this._$_runtime$_._$Trigger$_(C33._$Plugins$_.Flowchart._$Cnds$_.OnAnyNodeChangeInFlowchart, e), 
                    this._$_runtime$_._$Trigger$_(C33._$Plugins$_.Flowchart._$Cnds$_.OnTaggedNodeChangeInFlowchart, e), 
                    this._$_flowchartManager$_._$PopFlowchartState$_(), this._$PopIsTriggerState$_(), 
                    !this._$WasReleased$_()) {
                        const i = this._$GetFlowchartElementById$_(this._$_currentFlowchartNodeId$_);
                        if ("reference" === i._$GetType$_()) {
                            const r = i._$GetReferenceFlowchartName$_();
                            if (this._$_HasReferenceFlowchartState$_(i)) {
                                this._$_previousFlowchartNodeIds$_.pop();
                                const n = this._$_GetReferenceFlowchartState$_(i), h = (this._$_flowchartManager$_._$SetCurrentFlowchartState$_(n, !0, !0, !1), 
                                n._$_SetPreviousFlowchart$_(this, s), this._$_GetRootFlowchartState$_());
                                h._$_SetCurrentReferenceFlowchart$_(n);
                            } else {
                                const o = i._$GetReferenceFlowchartStartNodeTag$_();
                                if (r) {
                                    this._$_previousFlowchartNodeIds$_.pop();
                                    let e = i._$GetReferenceFlowchartTag$_();
                                    if (e) {
                                        let t = this._$_flowchartManager$_._$GetFlowchartState$_(e);
                                        for (;t; ) e = C33._$IncrementNumberAtEndOf$_(e), 
                                        t = this._$_flowchartManager$_._$GetFlowchartState$_(e);
                                    } else {
                                        e = r + "-ref";
                                        let t = this._$_flowchartManager$_._$GetFlowchartState$_(e);
                                        for (;t; ) e = C33._$IncrementNumberAtEndOf$_(e), 
                                        t = this._$_flowchartManager$_._$GetFlowchartState$_(e);
                                    }
                                    const a = this._$_flowchartManager$_._$AddFlowchartState$_(r, o, e, this._$_pluginInstance$_, !0), l = (a._$_SetPreviousFlowchart$_(this, s), 
                                    this._$_SetReferenceFlowchartState$_(i, a), 
                                    this._$_GetRootFlowchartState$_());
                                    a._$_SetRootFlowchartState$_(l), l._$_SetCurrentReferenceFlowchart$_(a);
                                }
                            }
                        }
                    }
                }
                _$_GetFlowchartNodeOutputAt$_(t) {
                    const e = this._$_flowchartDataItem$_._$GetFlowchartElementById$_(this._$_currentFlowchartNodeId$_);
                    if (!e) return null;
                    const s = e._$GetFlowchartNodeOutputData$_()._$GetFlowchartNodeOutputDataItems$_();
                    if (!s) return null;
                    const i = s[t];
                    return i || null;
                }
                _$_GetFlowchartNodeOutputByName$_(t) {
                    const e = this._$_flowchartDataItem$_._$GetFlowchartElementById$_(this._$_currentFlowchartNodeId$_);
                    if (!e) return null;
                    const s = e._$GetFlowchartNodeOutputData$_()._$GetFlowchartNodeOutputDataItemByName$_(t);
                    return s || null;
                }
                _$_SetStartFlowchartNode$_(e) {
                    if ("number" == typeof e) {
                        let t = this._$GetFlowchartElementById$_(e);
                        t = t || this._$_flowchartDataItem$_._$GetFlowchartStartNode$_(), 
                        this._$_startFlowchartNode$_ = t;
                    } else {
                        let t = this._$_flowchartDataItem$_._$GetFlowchartNodeByTags$_(this._$_startNodeTag$_);
                        t = t || this._$_flowchartDataItem$_._$GetFlowchartStartNode$_(), 
                        this._$_startFlowchartNode$_ = t;
                    }
                }
                _$_SaveToJson$_() {
                    return this._$_markForRelease$_ ? null : {
                        flowchartName: this._$_flowchartName$_,
                        flowchartTag: this._$_tag$_,
                        startNodeTag: this._$_startNodeTag$_,
                        currentNodeId: this._$_currentFlowchartNodeId$_,
                        previousNodeIds: this._$_previousFlowchartNodeIds$_,
                        pluginUID: this._$_pluginInstance$_._$GetInstance$_()._$GetUID$_(),
                        reference: {
                            previousFlowchartTag: this._$_GetPreviousFlowchartState$_() ? this._$_GetPreviousFlowchartState$_()._$GetTag$_() : "",
                            previousStartNodeId: C33._$IsFiniteNumber$_(this._$_GetPreviousFlowchartStateStartNodeId$_()) ? this._$_GetPreviousFlowchartStateStartNodeId$_() : NaN,
                            referencesJson: this._$_GetFlowchartReferencesJson$_(),
                            currentReferenceFlowchartTag: this._$GetCurrentReferenceFlowchart$_() ? this._$GetCurrentReferenceFlowchart$_()._$GetTag$_() : "",
                            rootFlowchartTag: this._$_GetRootFlowchartState$_() ? this._$_GetRootFlowchartState$_()._$GetTag$_() : ""
                        }
                    };
                }
                _$_GetFlowchartReferencesJson$_() {
                    if (!this._$_HasReferenceFlowchartStates$_()) return null;
                    const t = [];
                    for (const [ e, s ] of this._$_GetReferenceFlowchartStates$_().entries()) t.push({
                        flowchartElementId: e._$GetFlowchartId$_(),
                        flowchartStateTag: s._$GetTag$_()
                    });
                    return t.length ? t : null;
                }
                _$_LoadFromJson$_(t) {
                    if (t) {
                        if (this._$_flowchartName$_ = t.flowchartName, this._$_tag$_ = t.flowchartTag, 
                        this._$_startNodeTag$_ = t.startNodeTag, this._$_currentFlowchartNodeId$_ = t.currentNodeId, 
                        this._$_previousFlowchartNodeIds$_ = t.previousNodeIds, 
                        this._$_pluginUID$_ = t.pluginUID, t.hasOwnProperty("reference")) {
                            const e = t.reference;
                            this._$_previousFlowchartStateTag$_ = e.previousFlowchartTag, 
                            this._$_previousFlowchartStateStartNodeId$_ = e.previousStartNodeId, 
                            this._$_referenceFlowchartStatesJson$_ = e.referencesJson, 
                            this._$_currentReferenceFlowchartStateTag$_ = e.currentReferenceFlowchartTag, 
                            this._$_rootFlowchartStateTag$_ = e.rootFlowchartTag;
                        }
                        this._$_SetStartFlowchartNode$_();
                    }
                }
                _$_GetPreviousFlowchartState$_() {
                    return "string" == typeof this._$_previousFlowchartStateTag$_ && this._$_previousFlowchartStateTag$_ && (this._$_previousFlowchartState$_ = this._$_flowchartManager$_._$GetFlowchartState$_(this._$_previousFlowchartStateTag$_), 
                    this._$_previousFlowchartStateTag$_ = ""), this._$_previousFlowchartState$_;
                }
                _$_GetPreviousFlowchartStateStartNodeId$_() {
                    return this._$_previousFlowchartStateStartNodeId$_;
                }
                _$_SetPreviousFlowchart$_(t, e) {
                    this._$_previousFlowchartState$_ = t, this._$_previousFlowchartStateStartNodeId$_ = e;
                }
                _$GetCurrentReferenceFlowchart$_() {
                    return "string" == typeof this._$_currentReferenceFlowchartStateTag$_ && this._$_currentReferenceFlowchartStateTag$_ && (this._$_currentReferenceFlowchartState$_ = this._$_flowchartManager$_._$GetFlowchartState$_(this._$_currentReferenceFlowchartStateTag$_), 
                    this._$_currentReferenceFlowchartStateTag$_ = ""), this._$_currentReferenceFlowchartState$_;
                }
                _$_SetCurrentReferenceFlowchart$_(t) {
                    this._$_currentReferenceFlowchartState$_ = t, this._$_currentReferenceFlowchartState$_ === this && (this._$_currentReferenceFlowchartState$_ = null);
                }
                _$_GetRootFlowchartState$_() {
                    return "string" == typeof this._$_rootFlowchartStateTag$_ && this._$_rootFlowchartStateTag$_ && (this._$_rootFlowchartState$_ = this._$_flowchartManager$_._$GetFlowchartState$_(this._$_rootFlowchartStateTag$_), 
                    this._$_rootFlowchartStateTag$_ = ""), this._$_rootFlowchartState$_ || this;
                }
                _$_SetRootFlowchartState$_(t) {
                    this._$_rootFlowchartState$_ = t;
                }
                _$_HasReferenceFlowchartStates$_() {
                    return this._$_RebuildReferenceFlowchartStates$_(), !!this._$_referenceFlowchartStates$_;
                }
                _$_HasReferenceFlowchartState$_(t) {
                    return this._$_RebuildReferenceFlowchartStates$_(), this._$_referenceFlowchartStates$_ && this._$_referenceFlowchartStates$_.has(t);
                }
                _$_RebuildReferenceFlowchartStates$_() {
                    if (this._$_referenceFlowchartStatesJson$_) {
                        this._$_referenceFlowchartStates$_ && this._$_referenceFlowchartStates$_.clear(), 
                        this._$_referenceFlowchartStates$_ || (this._$_referenceFlowchartStates$_ = new Map());
                        for (const t of this._$_referenceFlowchartStatesJson$_) {
                            const e = this._$_flowchartManager$_._$GetFlowchartState$_(t.flowchartStateTag), s = e._$GetFlowchartElementById$_(t.flowchartElementId);
                            this._$_referenceFlowchartStates$_.set(s, e);
                        }
                        this._$_referenceFlowchartStatesJson$_ = null;
                    }
                }
                _$_GetReferenceFlowchartStates$_() {
                    return this._$_RebuildReferenceFlowchartStates$_(), this._$_referenceFlowchartStates$_;
                }
                _$_GetReferenceFlowchartState$_(t) {
                    return this._$_RebuildReferenceFlowchartStates$_(), this._$_referenceFlowchartStates$_.get(t);
                }
                _$_SetReferenceFlowchartState$_(t, e) {
                    this._$_referenceFlowchartStates$_ || (this._$_referenceFlowchartStates$_ = new Map()), 
                    this._$_referenceFlowchartStates$_.set(t, e);
                }
            };
        }
        {
            const C33 = self._$C3$_;
            C33._$FlowchartStateManager$_ = class {
                constructor(t) {
                    this._$_runtime$_ = t, this._$_flowchartStates$_ = new Map(), 
                    this._$_currentFlowchartState$_ = null, this._$_flowchartStateStack$_ = [], 
                    this._$_on_after_load$_ = () => this._$_OnAfterLoad$_(), this._$_loadJson$_ = null;
                }
                _$Release$_() {
                    C33._$clearArray$_(this._$_flowchartStateStack$_), this._$_flowchartStateStack$_ = null, 
                    this._$_flowchartStates$_.clear(), this._$_flowchartStates$_ = null, 
                    this._$_currentFlowchartState$_ = null, this._$_runtime$_ = null, 
                    this._$_loadJson$_ = null;
                }
                _$GetRuntime$_() {
                    return this._$_runtime$_;
                }
                _$AddFlowchartState$_(t, e, s, i, r, n) {
                    const h = this._$_runtime$_._$GetFlowchartManager$_()._$GetFlowchartDataItemByName$_(t);
                    if (h) {
                        if (!this._$_flowchartStates$_.has(s)) {
                            const o = new C33._$FlowchartState$_(t, s, e, h, this, i, n);
                            return this._$_flowchartStates$_.set(s, o), r && this._$SetCurrentFlowchartState$_(o, !0), 
                            o;
                        }
                        {
                            const a = this._$_flowchartStates$_.get(s);
                            a && this._$RemoveFlowchartState$_(a);
                        }
                    } else console.warn(`[Flowcharts] no flowchart found with name '${t}'`);
                }
                _$RemoveFlowchartState$_(t) {
                    if (t._$MarkForRelease$_(), !t._$IsInTriggerState$_()) {
                        const e = t._$GetTag$_();
                        this._$_flowchartStates$_.delete(e), t._$Release$_(), this._$_currentFlowchartState$_ === t && (this._$_currentFlowchartState$_ = null);
                    }
                }
                _$ResetFlowchartState$_(t) {
                    t._$Reset$_();
                }
                _$GetFlowchartState$_(t) {
                    return this._$_flowchartStates$_.get(t);
                }
                _$PushFlowchartState$_(t) {
                    this._$_flowchartStateStack$_.push(t);
                }
                _$PopFlowchartState$_() {
                    this._$_flowchartStateStack$_.pop();
                }
                _$SetCurrentFlowchartState$_(t, e = !1, s = !1, i = !0) {
                    if (i) {
                        const r = t._$GetCurrentReferenceFlowchart$_();
                        t = r || t;
                    }
                    t !== this._$_currentFlowchartState$_ && (this._$_TriggerBeforeFlowchartChange$_(), 
                    this._$_TriggerAfterFlowchartChange$_(t, e, s));
                }
                _$GetCurrentFlowchartState$_(t) {
                    return "string" == typeof t ? this._$GetFlowchartState$_(t) : this._$_flowchartStateStack$_.length ? this._$_flowchartStateStack$_[this._$_flowchartStateStack$_.length - 1] : this._$_currentFlowchartState$_;
                }
                _$_TriggerBeforeFlowchartChange$_() {
                    if (this._$_currentFlowchartState$_ && !this._$_currentFlowchartState$_._$WasReleased$_()) {
                        const t = this._$_currentFlowchartState$_._$GetPluginInstance$_()._$GetInstance$_();
                        this._$_currentFlowchartState$_._$PushIsTriggerState$_(), 
                        this._$PushFlowchartState$_(this._$_currentFlowchartState$_), 
                        this._$_runtime$_._$Trigger$_(C33._$Plugins$_.Flowchart._$Cnds$_.OnBeforeFlowchartChange, t), 
                        this._$PopFlowchartState$_(), this._$_currentFlowchartState$_._$PopIsTriggerState$_();
                    }
                }
                _$_TriggerAfterFlowchartChange$_(t, e = !1, s = !1) {
                    if (this._$_currentFlowchartState$_ = t, this._$_currentFlowchartState$_ && !this._$_currentFlowchartState$_._$WasReleased$_()) {
                        const i = this._$_currentFlowchartState$_._$GetPluginInstance$_()._$GetInstance$_();
                        this._$_currentFlowchartState$_._$PushIsTriggerState$_(), 
                        this._$PushFlowchartState$_(this._$_currentFlowchartState$_), 
                        this._$_runtime$_._$Trigger$_(C33._$Plugins$_.Flowchart._$Cnds$_.OnFlowchartChange, i), 
                        !0 !== s && "number" != typeof s || this._$_currentFlowchartState$_._$_SetStartFlowchartNode$_(s), 
                        e && (this._$_runtime$_._$Trigger$_(C33._$Plugins$_.Flowchart._$Cnds$_.OnAnyNodeChange, i), 
                        this._$_runtime$_._$Trigger$_(C33._$Plugins$_.Flowchart._$Cnds$_.OnTaggedNodeChange, i)), 
                        this._$PopFlowchartState$_(), this._$_currentFlowchartState$_._$PopIsTriggerState$_();
                    }
                }
                _$_SaveToJson$_() {
                    return {
                        flowchartJsonObjects: [ ...this._$_flowchartStates$_.values() ].map(t => t._$_SaveToJson$_()),
                        currentFlowchartTag: this._$_currentFlowchartState$_ ? this._$_currentFlowchartState$_._$GetTag$_() : null
                    };
                }
                _$_LoadFromJson$_(t) {
                    if (t) {
                        this._$_loadJson$_ = t;
                        const e = new Map();
                        for (const s of this._$_loadJson$_.flowchartJsonObjects) {
                            const i = s.flowchartTag;
                            if (this._$_flowchartStates$_.has(i)) {
                                const r = this._$_flowchartStates$_.get(i);
                                r._$_LoadFromJson$_(s), e.set(i, r);
                            } else {
                                const n = this._$AddFlowchartState$_(s.flowchartName, s.startNodeTag, s.flowchartTag, null, !1, s.pluginUID);
                                n._$_LoadFromJson$_(s), e.set(s.flowchartTag, n);
                            }
                        }
                        for (const [ h, o ] of this._$_flowchartStates$_.entries()) e.has(h) || o._$Release$_();
                        this._$_flowchartStates$_.clear(), this._$_flowchartStates$_ = e, 
                        this._$_runtime$_._$IsLoadingState$_() ? this._$_runtime$_._$Dispatcher$_().addEventListener("afterload", this._$_on_after_load$_) : this._$_OnAfterLoad$_();
                    }
                }
                _$_OnAfterLoad$_() {
                    this._$_runtime$_._$Dispatcher$_().removeEventListener("afterload", this._$_on_after_load$_);
                    const t = this._$_flowchartStates$_.get(this._$_loadJson$_.currentFlowchartTag);
                    t && this._$SetCurrentFlowchartState$_(t, !0), this._$_loadJson$_ = null;
                }
            };
        }
        {
            const C33 = self._$C3$_;
            C33._$FlowchartDataManager$_ = class {
                constructor() {
                    this._$_flowchartDataItems$_ = new Map();
                }
                _$Release$_() {
                    for (const t of this._$_flowchartDataItems$_.values()) t._$Release$_();
                    this._$_flowchartDataItems$_.clear(), this._$_flowchartDataItems$_ = null;
                }
                _$Add$_(t) {
                    const e = new C33._$FlowchartDataItem$_(t), s = e._$GetName$_();
                    this._$_flowchartDataItems$_.set(s, e);
                }
                _$Get$_(t) {
                    return this._$_flowchartDataItems$_.get(t);
                }
                _$HasFlowcharts$_() {
                    return !!this._$_flowchartDataItems$_.size;
                }
                static _$CreateDataItems$_(t, e, s, i) {
                    if (e) for (const r of e) {
                        const n = new s(r, i);
                        t.push(n);
                    }
                }
            };
        }
        {
            const C33 = self._$C3$_, NAME = 0, NODES = 1;
            C33._$FlowchartDataItem$_ = class {
                constructor(t) {
                    this._$_name$_ = t[NAME], this._$_flowchartNodeData$_ = new C33._$FlowchartNodeData$_(t[NODES], this);
                }
                _$Release$_() {
                    this._$_flowchartNodeData$_._$Release$_(), this._$_flowchartNodeData$_ = null;
                }
                _$GetFlowchartNodeData$_() {
                    return this._$_flowchartNodeData$_;
                }
                _$GetFlowchartElementById$_(t) {
                    return this._$_flowchartNodeData$_._$GetFlowchartElementById$_(t);
                }
                _$GetFlowchartNodeByTags$_(t) {
                    return this._$_flowchartNodeData$_._$GetFlowchartNodeByTags$_(t);
                }
                _$GetFlowchartStartNode$_() {
                    return this._$_flowchartNodeData$_._$GetFlowchartStartNode$_();
                }
                _$GetName$_() {
                    return this._$_name$_;
                }
            };
        }
        {
            const C33 = self._$C3$_, FLOWCHART_ID = 0, TAG = 1, PARENT_FLOWCHART_IDS = 2, PARENT_OUTPUT_FLOWCHART_IDS = 3, CHILDREN_FLOWCHART_IDS = 4, OUTPUTS = 5, IS_START = 6, TYPE = 7, REFERENCE_FLOWCHART = 8, REFERENCE_FLOWCHART_START_NODE = 9, REFERENCE_FLOWCHART_TAG = 10;
            class FlowchartNodeDataItem {
                constructor(t, e) {
                    this._$_flowchartNodeData$_ = e, this._$_type$_ = t[TYPE], this._$_flowchartId$_ = t[FLOWCHART_ID], 
                    this._$_tag$_ = t[TAG], this._$_tag$_ ? this._$_tags$_ = this._$_tag$_.trim().split(" ").map(t => t.trim()) : this._$_tags$_ = [], 
                    this._$_parentFlowchartIds$_ = t[PARENT_FLOWCHART_IDS], this._$_parentOutputFlowchartIds$_ = null, 
                    this._$_childrenFlowchartIds$_ = null, "dictionary" === this._$_type$_ && (this._$_parentOutputFlowchartIds$_ = t[PARENT_OUTPUT_FLOWCHART_IDS], 
                    this._$_childrenFlowchartIds$_ = t[CHILDREN_FLOWCHART_IDS]), 
                    this._$_isStart$_ = t[IS_START], this._$_referenceFlowchartName$_ = null, 
                    this._$_referenceFlowchartStartNodeTag$_ = null, this._$_referenceFlowchartTag$_ = null, 
                    "reference" === this._$_type$_ && (this._$_referenceFlowchartName$_ = t[REFERENCE_FLOWCHART], 
                    this._$_referenceFlowchartStartNodeTag$_ = t[REFERENCE_FLOWCHART_START_NODE], 
                    this._$_referenceFlowchartTag$_ = t[REFERENCE_FLOWCHART_TAG]), 
                    this._$_flowchartNodeOutputData$_ = new C33._$FlowchartNodeOutputData$_(t[OUTPUTS], this);
                }
                _$Release$_() {
                    this._$_flowchartNodeData$_ = null;
                }
                _$GetFlowchartNodeData$_() {
                    return this._$_flowchartNodeData$_;
                }
                _$GetFlowchartNodeOutputData$_() {
                    return this._$_flowchartNodeOutputData$_;
                }
                _$GetFlowchartId$_() {
                    return this._$_flowchartId$_;
                }
                _$GetTag$_() {
                    return this._$_tag$_;
                }
                _$GetTags$_() {
                    return this._$_tags$_;
                }
                _$HasTags$_(t) {
                    if (!this._$_tags$_) return !1;
                    if (!this._$_tags$_.length) return !1;
                    const e = C33._$FlowchartState$_._$_GetTagArray$_(t);
                    return !(!e || !e.length) && e.every(C33._$FlowchartState$_._$_HasTag$_, this._$_tags$_);
                }
                _$GetIsStart$_() {
                    return this._$_isStart$_;
                }
                _$GetParentFlowchartIds$_() {
                    return this._$_parentFlowchartIds$_;
                }
                _$GetParentOutputFlowchartIds$_() {
                    return this._$_parentOutputFlowchartIds$_;
                }
                _$GetChildrenFlowchartIds$_() {
                    return this._$_childrenFlowchartIds$_;
                }
                _$GetType$_() {
                    return this._$_type$_;
                }
                _$GetReferenceFlowchartName$_() {
                    return this._$_referenceFlowchartName$_;
                }
                _$GetReferenceFlowchartStartNodeTag$_() {
                    return this._$_referenceFlowchartStartNodeTag$_;
                }
                _$GetReferenceFlowchartTag$_() {
                    return this._$_referenceFlowchartTag$_;
                }
            }
            C33._$FlowchartNodeData$_ = class {
                constructor(t, e) {
                    this._$_flowchartDataItem$_ = e, this._$_flowchartNodeItems$_ = [], 
                    this._$_flowchartNodeItemsIdMap$_ = new Map(), this._$_flowchartNodeItemsTagMap$_ = new Map(), 
                    this._$_flowchartNodeStartItem$_ = null, C33._$FlowchartDataManager$_._$CreateDataItems$_(this._$_flowchartNodeItems$_, t, FlowchartNodeDataItem, this);
                    for (const s of this._$_flowchartNodeItems$_) {
                        const i = s._$GetFlowchartId$_(), r = s._$GetTag$_(), n = s._$GetTags$_(), h = s._$GetIsStart$_();
                        if (this._$_flowchartNodeItemsIdMap$_.set(i, s), r) for (const a of n) this._$_flowchartNodeItemsTagMap$_.has(a) || this._$_flowchartNodeItemsTagMap$_.set(a, new Set()), 
                        this._$_flowchartNodeItemsTagMap$_.get(a).add(s);
                        h && (this._$_flowchartNodeStartItem$_ = s);
                        const o = s._$GetFlowchartNodeOutputData$_();
                        for (const l of o._$flowchartNodeOutputDataItems$_()) {
                            const u = l._$GetFlowchartId$_();
                            this._$_flowchartNodeItemsIdMap$_.set(u, l);
                        }
                    }
                }
                _$Release$_() {
                    this._$_flowchartDataItem$_ = null;
                    for (const t of this._$_flowchartNodeItems$_) t._$Release$_();
                    C33._$clearArray$_(this._$_flowchartNodeItems$_), this._$_flowchartNodeItems$_ = null;
                }
                _$GetFlowchartDataItem$_() {
                    return this._$_flowchartDataItem$_;
                }
                _$GetFlowchartElementById$_(t) {
                    return this._$_flowchartNodeItemsIdMap$_.get(t);
                }
                _$GetFlowchartNodeByTags$_(t) {
                    if (!t || !t.length) return null;
                    const s = [];
                    for (const i of t.trim().split(" ")) {
                        let t = this._$_flowchartNodeItemsTagMap$_.get(i.trim()) ?? new Set();
                        if (0 === t.size) return null;
                        s.push(t);
                    }
                    const e = s.reduce((t, e) => e.size < t.size ? e : t);
                    return [ ...e ].filter(e => s.every(t => t.has(e)))[0];
                }
                _$GetFlowchartStartNode$_() {
                    return this._$_flowchartNodeStartItem$_;
                }
                *_$flowchartNodeDataItems$_() {
                    for (const t of this._$_flowchartNodeItems$_) yield t;
                }
            };
        }
        {
            const C33 = self._$C3$_, FLOWCHART_ID = 0, NAME = 1, VALUE = 2, CONNECTED_FLOWCHART_NODE_FLOWCHART_ID = 3;
            class FlowchartNodeDataOutputItem {
                constructor(t, e) {
                    this._$_flowchartNodeOutputData$_ = e, this._$_flowchartId$_ = t[FLOWCHART_ID], 
                    this._$_name$_ = t[NAME], this._$_value$_ = t[VALUE], this._$_connectedFlowchartNodeFlowchartId$_ = t[CONNECTED_FLOWCHART_NODE_FLOWCHART_ID];
                }
                _$Release$_() {
                    this._$_flowchartNodeOutputData$_ = null;
                }
                _$GetFlowchartNodeOutputData$_() {
                    return this._$_flowchartNodeOutputData$_;
                }
                _$GetFlowchartId$_() {
                    return this._$_flowchartId$_;
                }
                _$GetName$_() {
                    return this._$_name$_;
                }
                _$GetValue$_() {
                    return this._$_value$_;
                }
                _$GetConnectedFlowchartNodeFlowchartId$_() {
                    return this._$_connectedFlowchartNodeFlowchartId$_;
                }
            }
            C33._$FlowchartNodeOutputData$_ = class {
                constructor(t, e) {
                    this._$_flowchartDataNodeItem$_ = e, this._$_flowchartNodeOutputItems$_ = [], 
                    this._$_flowchartNodeOutputItemsNameMap$_ = new Map(), C33._$FlowchartDataManager$_._$CreateDataItems$_(this._$_flowchartNodeOutputItems$_, t, FlowchartNodeDataOutputItem, this);
                    for (const s of this._$_flowchartNodeOutputItems$_) this._$_flowchartNodeOutputItemsNameMap$_.set(s._$GetName$_(), s);
                }
                _$Release$_() {
                    this._$_flowchartDataNodeItem$_ = null;
                    for (const t of this._$_flowchartNodeOutputItems$_) t._$Release$_();
                    C33._$clearArray$_(this._$_flowchartNodeOutputItems$_), this._$_flowchartNodeOutputItems$_ = null;
                }
                _$GetFlowchartNodeDataItem$_() {
                    return this._$_flowchartDataNodeItem$_;
                }
                _$GetFlowchartNodeOutputDataItemCount$_() {
                    return this._$_flowchartNodeOutputItems$_.length;
                }
                _$GetFlowchartNodeOutputDataItems$_() {
                    return this._$_flowchartNodeOutputItems$_;
                }
                _$GetFlowchartNodeOutputDataItemByName$_(t) {
                    return this._$_flowchartNodeOutputItemsNameMap$_.get(t);
                }
                *_$flowchartNodeOutputDataItems$_() {
                    for (const t of this._$_flowchartNodeOutputItems$_) yield t;
                }
            };
        }
        {
            const C33 = self._$C3$_;
            C33._$SolStack$_ = class extends C33._$DefendedBase$_ {
                constructor(t) {
                    super(), this._$_objectClass$_ = t, this._$_stack$_ = [], this._$_stack$_.push(C33._$New$_(C33._$Sol$_, this)), 
                    this._$_index$_ = 0, this._$_current$_ = this._$_stack$_[0];
                }
                _$Release$_() {
                    for (const t of this._$_stack$_) t._$Release$_();
                    C33._$clearArray$_(this._$_stack$_), this._$_current$_ = null, 
                    this._$_objectClass$_ = null;
                }
                _$GetObjectClass$_() {
                    return this._$_objectClass$_;
                }
                _$GetCurrentSol$_() {
                    return this._$_current$_;
                }
                _$GetOneBelowCurrentSol$_() {
                    return this._$_stack$_[this._$_index$_ - 1];
                }
                _$Clear$_() {
                    this._$GetCurrentSol$_()._$Clear$_();
                }
                _$PushClean$_() {
                    const t = this._$_stack$_, e = ++this._$_index$_;
                    if (e === t.length) {
                        const s = C33._$New$_(C33._$Sol$_, this);
                        t.push(s), this._$_current$_ = s;
                    } else {
                        const i = t[e];
                        i._$Reset$_(), this._$_current$_ = i;
                    }
                }
                _$PushCopy$_() {
                    const t = this._$_stack$_, e = ++this._$_index$_, s = (e === t.length && t.push(C33._$New$_(C33._$Sol$_, this)), 
                    t[e]);
                    s._$Copy$_(t[e - 1]), this._$_current$_ = s;
                }
                _$Pop$_() {
                    this._$_current$_ = this._$_stack$_[--this._$_index$_];
                }
                _$RemoveInstances$_(s) {
                    const i = this._$_stack$_;
                    for (let t = 0, e = i.length; t < e; ++t) i[t]._$RemoveInstances$_(s);
                }
            };
        }
        {
            const C33 = self._$C3$_;
            C33._$Sol$_ = class extends C33._$DefendedBase$_ {
                constructor(t) {
                    super(), this._$_stack$_ = t, this._$_objectClass$_ = this._$_stack$_._$GetObjectClass$_(), 
                    this._$_eventStack$_ = this._$_objectClass$_._$GetRuntime$_()._$GetEventStack$_(), 
                    this._$_selectAll$_ = !0, this._$_instances$_ = [], this._$_elseInstances$_ = [];
                }
                _$Release$_() {
                    this._$ClearArrays$_(), this._$_stack$_ = null, this._$_objectClass$_ = null, 
                    this._$_eventStack$_ = null;
                }
                _$ClearArrays$_() {
                    C33._$clearArray$_(this._$_instances$_), C33._$clearArray$_(this._$_elseInstances$_);
                }
                _$GetObjectClass$_() {
                    return this._$_objectClass$_;
                }
                _$IsSelectAll$_() {
                    return this._$_selectAll$_;
                }
                _$HasAnyInstances$_() {
                    return this._$_selectAll$_ ? !!this._$_objectClass$_._$GetInstanceCount$_() : !!this._$_instances$_.length;
                }
                _$GetInstances$_() {
                    return this._$_selectAll$_ ? this._$_objectClass$_._$GetInstances$_() : this._$_instances$_;
                }
                _$HasAnyElseInstances$_() {
                    return !!this._$_elseInstances$_.length;
                }
                _$GetElseInstances$_() {
                    return this._$_elseInstances$_;
                }
                _$GetExpressionInstances$_() {
                    const t = this._$GetInstances$_();
                    return t.length ? t : this._$_elseInstances$_;
                }
                _$Reset$_() {
                    this._$_selectAll$_ = !0, C33._$clearArray$_(this._$_elseInstances$_);
                }
                _$Clear$_() {
                    this._$_selectAll$_ = !0;
                }
                _$Copy$_(t) {
                    t._$IsSelectAll$_() ? this._$Reset$_() : (this._$_selectAll$_ = !1, 
                    C33._$shallowAssignArray$_(this._$_instances$_, t._$_instances$_), 
                    C33._$clearArray$_(this._$_elseInstances$_));
                }
                _$_PushInstance$_(t) {
                    this._$_instances$_.push(t);
                }
                _$_PushElseInstance$_(t) {
                    this._$_elseInstances$_.push(t);
                }
                _$_SetSelectAll$_(t) {
                    this._$_selectAll$_ = !!t;
                }
                _$_GetOwnInstances$_() {
                    return this._$_instances$_;
                }
                _$_GetOwnElseInstances$_() {
                    return this._$_elseInstances$_;
                }
                _$SetSinglePicked$_(t) {
                    this._$_selectAll$_ = !1, C33._$clearArray$_(this._$_instances$_), 
                    this._$_instances$_.push(t);
                }
                _$SetArrayPicked$_(t) {
                    this._$_selectAll$_ = !1, C33._$shallowAssignArray$_(this._$_instances$_, t);
                }
                _$SetSetPicked$_(t) {
                    this._$_selectAll$_ = !1, C33._$clearArray$_(this._$_instances$_);
                    for (const e of t) this._$_instances$_.push(e);
                }
                _$AddElseInstances$_(t, e) {
                    for (const s of e) t.has(s) || this._$_elseInstances$_.push(s);
                }
                _$TransferElseInstancesToOwn$_(t) {
                    for (const e of t) this._$_instances$_.push(e);
                    C33._$arrayRemoveAllInSet$_(this._$_elseInstances$_, t);
                }
                _$ClearElseInstances$_() {
                    C33._$clearArray$_(this._$_elseInstances$_);
                }
                _$PickOne$_(t) {
                    if (t) if (this._$_eventStack$_._$GetCurrentStackFrame$_()._$GetCurrentEvent$_()._$IsOrBlock$_()) {
                        this._$IsSelectAll$_() && (C33._$clearArray$_(this._$_instances$_), 
                        C33._$shallowAssignArray$_(this._$_elseInstances$_, t._$GetObjectClass$_()._$GetInstances$_()), 
                        this._$_selectAll$_ = !1);
                        const e = this._$_elseInstances$_.indexOf(t);
                        -1 !== e && (this._$_instances$_.push(this._$_elseInstances$_[e]), 
                        this._$_elseInstances$_.splice(e, 1));
                    } else this._$SetSinglePicked$_(t);
                }
                _$RemoveInstances$_(t) {
                    C33._$arrayRemoveAllInSet$_(this._$_instances$_, t), C33._$arrayRemoveAllInSet$_(this._$_elseInstances$_, t);
                }
            };
        }
        {
            const C33 = self._$C3$_;
            C33._$EventStack$_ = class extends C33._$DefendedBase$_ {
                constructor(t) {
                    super(), this._$_eventSheetManager$_ = t, this._$_runtime$_ = this._$_eventSheetManager$_._$GetRuntime$_(), 
                    this._$_stack$_ = [], this._$_stack$_.push(C33._$New$_(C33._$EventStackFrame$_, this, null)), 
                    this._$_index$_ = 0, this._$_expFuncStack$_ = [];
                }
                _$Release$_() {
                    for (const t of this._$_stack$_) t._$Release$_();
                    C33._$clearArray$_(this._$_stack$_), C33._$clearArray$_(this._$_expFuncStack$_), 
                    this._$_eventSheetManager$_ = null, this._$_runtime$_ = null;
                }
                _$GetEventSheetManager$_() {
                    return this._$_eventSheetManager$_;
                }
                _$GetRuntime$_() {
                    return this._$_runtime$_;
                }
                _$GetCurrentStackFrame$_() {
                    return this._$_stack$_[this._$_index$_];
                }
                _$GetAllStackFrames$_() {
                    return this._$_stack$_;
                }
                _$GetCurrentStackFrameIndex$_() {
                    return this._$_index$_;
                }
                _$Push$_(t) {
                    const e = this._$_stack$_, s = ++this._$_index$_;
                    if (s === e.length) {
                        const i = C33._$New$_(C33._$EventStackFrame$_, this, t);
                        return e.push(i), i;
                    }
                    {
                        const r = e[s];
                        return r._$Reset$_(t), r;
                    }
                }
                _$Pop$_() {
                    --this._$_index$_;
                }
                _$PushExpFunc$_(t) {
                    this._$_expFuncStack$_.push(t);
                }
                _$PopExpFunc$_() {
                    this._$_expFuncStack$_.pop();
                }
                _$GetCurrentExpFuncStackFrame$_() {
                    const t = this._$_expFuncStack$_;
                    return 0 === t.length ? null : t.at(-1);
                }
            };
        }
        {
            const C33 = self._$C3$_;
            C33._$EventStackFrame$_ = class extends C33._$DefendedBase$_ {
                constructor(t, e) {
                    super(), this._$_stack$_ = t, this._$_runtime$_ = this._$_stack$_._$GetRuntime$_(), 
                    this._$_currentEvent$_ = e, this._$_cndIndex$_ = 0, this._$_actIndex$_ = 0, 
                    this._$_lastEventTrue$_ = !1, this._$_elseBranchRan$_ = !1, 
                    this._$_expressionObjectClass$_ = null, this._$_functionReturnType$_ = 0, 
                    this._$_functionReturnValue$_ = 0, this._$_dynamicSolModifiers$_ = null;
                }
                _$Release$_() {
                    this._$Reset$_(null), this._$_stack$_ = null, this._$_runtime$_ = null;
                }
                _$Reset$_(t) {
                    this._$_currentEvent$_ = t, this._$_cndIndex$_ = 0, this._$_actIndex$_ = 0, 
                    this._$_lastEventTrue$_ = !1, this._$_elseBranchRan$_ = !1, 
                    this._$_dynamicSolModifiers$_ = null;
                }
                _$_Restore$_(t, e) {
                    this._$_currentEvent$_ = t, this._$_cndIndex$_ = 0, this._$_actIndex$_ = e;
                }
                _$ResetQuick$_() {
                    this._$_cndIndex$_ = 0, this._$_actIndex$_ = 0;
                }
                _$GetCurrentEvent$_() {
                    return this._$_currentEvent$_;
                }
                _$SetCurrentEvent$_(t) {
                    this._$_currentEvent$_ = t;
                }
                _$GetConditionIndex$_() {
                    return this._$_cndIndex$_;
                }
                _$SetConditionIndex$_(t) {
                    this._$_cndIndex$_ = t;
                }
                _$GetActionIndex$_() {
                    return this._$_actIndex$_;
                }
                _$SetActionIndex$_(t) {
                    this._$_actIndex$_ = t;
                }
                _$SetLastEventTrue$_(t) {
                    this._$_lastEventTrue$_ = !!t;
                }
                _$GetLastEventTrue$_() {
                    return this._$_lastEventTrue$_;
                }
                _$SetElseBranchRan$_(t) {
                    this._$_elseBranchRan$_ = !!t;
                }
                _$GetElseBranchRan$_() {
                    return this._$_elseBranchRan$_;
                }
                _$SetExpressionObjectClass$_(t) {
                    this._$_expressionObjectClass$_ = t;
                }
                _$GetExpressionObjectClass$_() {
                    return this._$_expressionObjectClass$_;
                }
                _$InitCallFunctionExpression$_(t, e) {
                    this._$_functionReturnType$_ = t, this._$_functionReturnValue$_ = e;
                }
                _$GetFunctionReturnType$_() {
                    return this._$_functionReturnType$_;
                }
                _$SetFunctionReturnValue$_(t) {
                    this._$_functionReturnValue$_ = t;
                }
                _$GetFunctionReturnValue$_() {
                    return this._$_functionReturnValue$_;
                }
                _$IsSolModifierAfterCnds$_() {
                    const t = this._$_currentEvent$_;
                    return !!t._$IsSolWriterAfterCnds$_() || this._$_cndIndex$_ < t._$GetConditionCount$_() - 1 && !!t._$GetSolModifiers$_().length;
                }
                _$SetDynamicSolModifiers$_(t) {
                    this._$_dynamicSolModifiers$_ = t;
                }
                _$GetDynamicSolModifiers$_() {
                    return this._$_dynamicSolModifiers$_;
                }
            };
        }
        {
            const C33 = self._$C3$_;
            C33._$LocalVarStack$_ = class extends C33._$DefendedBase$_ {
                constructor(t) {
                    super(), this._$_eventSheetManager$_ = t, this._$_runtime$_ = this._$_eventSheetManager$_._$GetRuntime$_(), 
                    this._$_stack$_ = [], this._$_index$_ = -1, this._$_current$_ = null, 
                    this._$_initialValues$_ = [];
                }
                _$Release$_() {
                    C33._$clearArray$_(this._$_stack$_), this._$_eventSheetManager$_ = null, 
                    this._$_runtime$_ = null;
                }
                _$_SetInitialValues$_(t) {
                    this._$_initialValues$_ = t;
                    const e = this._$_initialValues$_.slice(0);
                    this._$_stack$_.push(e), this._$_index$_ = 0, this._$_current$_ = e;
                }
                _$GetEventSheetManager$_() {
                    return this._$_eventSheetManager$_;
                }
                _$GetRuntime$_() {
                    return this._$_runtime$_;
                }
                _$GetCurrent$_() {
                    return this._$_current$_;
                }
                _$Push$_() {
                    const t = ++this._$_index$_, e = this._$_stack$_;
                    t === e.length ? e.push(this._$_initialValues$_.slice(0)) : C33._$shallowAssignArray$_(e[t], this._$_initialValues$_), 
                    this._$_current$_ = e[t];
                }
                _$Pop$_() {
                    this._$_current$_ = this._$_stack$_[--this._$_index$_];
                }
            };
        }
        {
            const C33 = self._$C3$_;
            C33._$LoopStack$_ = class extends C33._$DefendedBase$_ {
                constructor(t) {
                    super(), this._$_eventSheetManager$_ = t, this._$_runtime$_ = this._$_eventSheetManager$_._$GetRuntime$_(), 
                    this._$_stack$_ = [], this._$_index$_ = -1;
                }
                _$Release$_() {
                    C33._$clearArray$_(this._$_stack$_), this._$_eventSheetManager$_ = null, 
                    this._$_runtime$_ = null;
                }
                _$GetEventSheetManager$_() {
                    return this._$_eventSheetManager$_;
                }
                _$GetRuntime$_() {
                    return this._$_runtime$_;
                }
                _$IsInLoop$_() {
                    return 0 <= this._$_index$_;
                }
                _$GetCurrent$_() {
                    return this._$_stack$_[this._$_index$_];
                }
                _$Push$_() {
                    if (++this._$_index$_, this._$_index$_ === this._$_stack$_.length) {
                        const t = C33._$New$_(C33._$Loop$_, this);
                        return this._$_stack$_.push(t), t;
                    }
                    {
                        const e = this._$_stack$_[this._$_index$_];
                        return e._$Reset$_(), e;
                    }
                }
                _$Pop$_() {
                    --this._$_index$_;
                }
                _$FindByName$_(e) {
                    const s = this._$_stack$_;
                    for (let t = this._$_index$_; 0 <= t; --t) {
                        const i = s[t];
                        if (i._$GetName$_() === e) return i;
                    }
                    return null;
                }
                _$_GetStack$_() {
                    return this._$_stack$_.slice(0, this._$_index$_ + 1);
                }
            };
        }
        {
            const C33 = self._$C3$_;
            C33._$Loop$_ = class extends C33._$DefendedBase$_ {
                constructor(t) {
                    super(), this._$_loopStack$_ = t, this._$_name$_ = "", this._$_index$_ = 0, 
                    this._$_isStopped$_ = !1, this._$_end$_ = NaN;
                }
                _$Reset$_() {
                    this._$_name$_ = "", this._$_index$_ = 0, this._$_isStopped$_ = !1, 
                    this._$_end$_ = NaN;
                }
                _$SetName$_(t) {
                    this._$_name$_ = t;
                }
                _$GetName$_() {
                    return this._$_name$_;
                }
                _$SetIndex$_(t) {
                    this._$_index$_ = t;
                }
                _$GetIndex$_() {
                    return this._$_index$_;
                }
                _$Stop$_() {
                    this._$_isStopped$_ = !0;
                }
                _$IsStopped$_() {
                    return this._$_isStopped$_;
                }
                _$SetEnd$_(t) {
                    this._$_end$_ = t;
                }
                _$GetEnd$_() {
                    return this._$_end$_;
                }
            };
        }
        {
            const C33 = self._$C3$_;
            C33._$ArrayStack$_ = class extends C33._$DefendedBase$_ {
                constructor() {
                    super(), this._$_stack$_ = [], this._$_index$_ = -1;
                }
                _$Release$_() {
                    C33._$clearArray$_(this._$_stack$_);
                }
                _$GetCurrent$_() {
                    return this._$_stack$_[this._$_index$_];
                }
                _$Push$_() {
                    if (++this._$_index$_, this._$_index$_ !== this._$_stack$_.length) return this._$_stack$_[this._$_index$_];
                    {
                        const t = [];
                        return this._$_stack$_.push(t), t;
                    }
                }
                _$Pop$_() {
                    --this._$_index$_;
                }
            };
        }
        {
            let SortSolArray2 = function(t, e) {
                return t._$GetIndex$_() - e._$GetIndex$_();
            }, IsSolArrayIdentical2 = function(s, i) {
                for (let t = 0, e = s.length; t < e; ++t) if (s[t] !== i[t]) return !1;
                return !0;
            };
            SortSolArray = SortSolArray2, IsSolArrayIdentical = IsSolArrayIdentical2;
            const C33 = self._$C3$_, assert = self.assert;
            C33._$EventSheetManager$_ = class extends C33._$DefendedBase$_ {
                constructor(t) {
                    super(), this._$_runtime$_ = t, this._$_allSheets$_ = [], this._$_sheetsByName$_ = new Map(), 
                    this._$_allGroups$_ = [], this._$_groupsByName$_ = new Map(), 
                    this._$_blocksBySid$_ = new Map(), this._$_cndsBySid$_ = new Map(), 
                    this._$_actsBySid$_ = new Map(), this._$_allUniqueSolModifiers$_ = new Map(), 
                    this._$_eventVarsBySid$_ = new Map(), this._$_nextLocalVarIndex$_ = 0, 
                    this._$_allGlobalVars$_ = [], this._$_allLocalVars$_ = [], this._$_localVarInitialValues$_ = [], 
                    this._$_functionBlocksByName$_ = new Map(), this._$_customActionBlocksMap$_ = new Map(), 
                    this._$_eventStack$_ = C33._$New$_(C33._$EventStack$_, this), 
                    this._$_localVarStack$_ = C33._$New$_(C33._$LocalVarStack$_, this), 
                    this._$_loopStack$_ = C33._$New$_(C33._$LoopStack$_, this), 
                    this._$_triggersToPostInit$_ = [], this._$_queuedTriggers$_ = [], 
                    this._$_queuedDebugTriggers$_ = [], this._$_runningEventsDepth$_ = 0, 
                    this._$_executingTriggerDepth$_ = 0, this._$_blockFlushingDepth$_ = 0, 
                    this._$_scheduledWaits$_ = [], this._$_asyncActionPromises$_ = [], 
                    this._$_signalTags$_ = [], this._$_signalPromises$_ = new Map(), 
                    this._$_instSignals$_ = new Map(), self.c3_callFunction = (t, e) => this._$_InvokeFunctionFromJS$_(t, e);
                }
                _$Release$_() {
                    this._$ClearAllScheduledWaits$_(), this._$_eventStack$_._$Release$_(), 
                    this._$_eventStack$_ = null, this._$_localVarStack$_._$Release$_(), 
                    this._$_localVarStack$_ = null, C33._$clearArray$_(this._$_queuedTriggers$_), 
                    C33._$clearArray$_(this._$_queuedDebugTriggers$_), this._$_runtime$_ = null, 
                    C33._$clearArray$_(this._$_allSheets$_), this._$_sheetsByName$_.clear();
                }
                _$Create$_(t) {
                    const e = C33._$New$_(C33._$EventSheet$_, this, t);
                    this._$_allSheets$_.push(e), this._$_sheetsByName$_.set(e._$GetName$_().toLowerCase(), e);
                }
                _$_AddTriggerToPostInit$_(t) {
                    this._$_triggersToPostInit$_.push(t);
                }
                _$_PostInit$_() {
                    for (const t of this._$_customActionBlocksMap$_.values()) t._$_CheckOverrideState$_();
                    for (const e of this._$_functionBlocksByName$_.values()) e._$_PostInit$_();
                    for (const s of this._$_customActionBlocksMap$_.values()) s._$_PostInit$_();
                    for (const i of this._$_allSheets$_) i._$_PostInit$_();
                    for (const r of this._$_allSheets$_) r._$_UpdateDeepIncludes$_();
                    for (const n of this._$_triggersToPostInit$_) n._$_PostInit$_(!1);
                    C33._$clearArray$_(this._$_triggersToPostInit$_), this._$_localVarStack$_._$_SetInitialValues$_(this._$_localVarInitialValues$_);
                }
                _$GetRuntime$_() {
                    return this._$_runtime$_;
                }
                _$GetEventSheetByName$_(t) {
                    return this._$_sheetsByName$_.get(t.toLowerCase()) || null;
                }
                _$_RegisterGroup$_(t) {
                    this._$_allGroups$_.push(t), this._$_groupsByName$_.set(t._$GetGroupName$_(), t);
                }
                _$_RegisterEventBlock$_(t) {
                    this._$_blocksBySid$_.set(t._$GetSID$_(), t);
                }
                _$_RegisterCondition$_(t) {
                    this._$_cndsBySid$_.set(t._$GetSID$_(), t);
                }
                _$_RegisterAction$_(t) {
                    this._$_actsBySid$_.set(t._$GetSID$_(), t);
                }
                _$_RegisterFunctionBlock$_(t) {
                    switch (t._$GetFunctionType$_()) {
                      case 0:
                        this._$_functionBlocksByName$_.set(t._$GetFunctionName$_().toLowerCase(), t);
                        break;

                      case 1:
                        this._$_customActionBlocksMap$_.set(t._$GetFunctionName$_().toLowerCase(), t);
                    }
                }
                _$_RegisterEventVariable$_(t) {
                    this._$_eventVarsBySid$_.set(t._$GetSID$_(), t), (t._$IsGlobal$_() ? this._$_allGlobalVars$_ : this._$_allLocalVars$_).push(t);
                }
                _$_DeduplicateSolModifierList$_(s) {
                    2 <= s.length && s.sort(SortSolArray2);
                    let i = this._$_allUniqueSolModifiers$_.get(s.length);
                    i || (i = [], this._$_allUniqueSolModifiers$_.set(s.length, i));
                    for (let t = 0, e = i.length; t < e; ++t) {
                        const r = i[t];
                        if (IsSolArrayIdentical2(s, r)) return r;
                    }
                    return i.push(s), s;
                }
                _$_GetNextLocalVarIndex$_(t) {
                    return this._$_localVarInitialValues$_.push(t._$GetInitialValue$_()), 
                    this._$_nextLocalVarIndex$_++;
                }
                _$GetEventStack$_() {
                    return this._$_eventStack$_;
                }
                _$GetCurrentEventStackFrame$_() {
                    return this._$GetEventStack$_()._$GetCurrentStackFrame$_();
                }
                _$GetCurrentEvent$_() {
                    return this._$GetCurrentEventStackFrame$_()._$GetCurrentEvent$_();
                }
                _$GetCurrentCondition$_() {
                    const t = this._$GetCurrentEventStackFrame$_(), e = t._$GetCurrentEvent$_();
                    return e._$GetConditionAt$_(t._$GetConditionIndex$_());
                }
                _$GetCurrentAction$_() {
                    const t = this._$GetCurrentEventStackFrame$_(), e = t._$GetCurrentEvent$_();
                    return e._$GetActionAt$_(t._$GetActionIndex$_());
                }
                _$GetLocalVarStack$_() {
                    return this._$_localVarStack$_;
                }
                _$GetLoopStack$_() {
                    return this._$_loopStack$_;
                }
                _$GetAllLocalVariablesInScope$_(t) {
                    const e = [];
                    for (t = t._$GetScopeParent$_(); t; ) C33._$appendArray$_(e, t._$_GetAllLocalVariablesInScope$_()), 
                    t = t._$GetScopeParent$_();
                    return e;
                }
                _$_GetLocalVariablesScriptInterface$_(t) {
                    const e = {};
                    for (const s of this._$GetAllLocalVariablesInScope$_(t)) e[s._$GetJsPropName$_()] = s._$_GetScriptInterfaceDescriptor$_();
                    return Object.create(Object.prototype, e);
                }
                _$GetEventVariableBySID$_(t) {
                    return this._$_eventVarsBySid$_.get(t) || null;
                }
                _$GetEventBlockBySID$_(t) {
                    return this._$_blocksBySid$_.get(t) || null;
                }
                _$GetConditionBySID$_(t) {
                    return this._$_cndsBySid$_.get(t) || null;
                }
                _$GetActionBySID$_(t) {
                    return this._$_actsBySid$_.get(t) || null;
                }
                _$GetFunctionBlockByName$_(t) {
                    return this._$_functionBlocksByName$_.get(t.toLowerCase()) || null;
                }
                _$GetCustomActionBlockByName$_(t, e) {
                    let s = this._$_customActionBlocksMap$_.get((t._$GetName$_() + "." + e).toLowerCase());
                    if (s) return s;
                    if (!t._$IsFamily$_()) for (const i of t._$GetFamilies$_()) if (s = this._$_customActionBlocksMap$_.get((i._$GetName$_() + "." + e).toLowerCase())) return s;
                    return null;
                }
                _$GetAllGlobalVariables$_() {
                    return this._$_allGlobalVars$_;
                }
                _$GetAllLocalVariables$_() {
                    return this._$_allLocalVars$_;
                }
                _$ResetAllGlobalsToInitialValue$_(t) {
                    for (const e of this._$_allGlobalVars$_) e._$ResetToInitialValue$_();
                    if (t) for (const s of this._$_allLocalVars$_) s._$IsStatic$_() && s._$ResetToInitialValue$_();
                }
                _$GetEventGroupByName$_(t) {
                    return this._$_groupsByName$_.get(t.toLowerCase()) || null;
                }
                _$GetEventGroupBySID$_(t) {
                    const e = this._$_blocksBySid$_.get(t);
                    return e && e._$IsGroup$_() ? e : null;
                }
                _$GetAllGroups$_() {
                    return this._$_allGroups$_;
                }
                _$ResetAllGroupsInitialActivation$_() {
                    for (const t of this._$_allGroups$_) t._$ResetInitialActivation$_();
                }
                _$_ResetAllHasRunFlags$_() {
                    for (const t of this._$_allSheets$_) t._$_ResetHasRunFlag$_();
                }
                _$RunEvents$_(t) {
                    this._$_ResetAllHasRunFlags$_(), this._$_runningEventsDepth$_++;
                    for (const e of t._$runningLayouts$_()) {
                        const s = e._$GetEventSheet$_();
                        s && (this._$_runtime$_._$PushCurrentLayout$_(e), s._$Run$_(), 
                        this._$_runtime$_._$PopCurrentLayout$_());
                    }
                    this._$_runningEventsDepth$_--;
                }
                async _$DebugRunEvents$_(t) {
                    this._$_ResetAllHasRunFlags$_(), this._$_runningEventsDepth$_++;
                    for (const e of this._$_DebugRunEventsGen$_(t)) await this._$_runtime$_._$DebugBreak$_(e);
                    this._$_runningEventsDepth$_--;
                }
                *_$_DebugRunEventsGen$_(t) {
                    for (const e of t._$runningLayouts$_()) {
                        const s = e._$GetEventSheet$_();
                        s && (this._$_runtime$_._$PushCurrentLayout$_(e), yield* s._$DebugRun$_(), 
                        this._$_runtime$_._$PopCurrentLayout$_());
                    }
                }
                _$_Trigger$_(t, e, s, i) {
                    let r = !1;
                    if (!t._$GetMainRunningLayout$_()) return this._$QueueTrigger$_(e, s, i);
                    this._$_executingTriggerDepth$_++;
                    for (const n of t._$runningLayouts$_()) {
                        const h = n._$GetEventSheet$_();
                        if (h) {
                            this._$_runtime$_._$PushCurrentLayout$_(n);
                            for (const a of h._$deepIncludes$_()) {
                                const l = a._$_Trigger$_(e, s, i);
                                r = r || l;
                            }
                            const o = h._$_Trigger$_(e, s, i);
                            r = r || o, this._$_runtime$_._$PopCurrentLayout$_();
                        }
                    }
                    return this._$_executingTriggerDepth$_--, r;
                }
                *_$_DebugTrigger$_(t, e, s, i) {
                    let r = !1;
                    if (!t._$GetMainRunningLayout$_()) return this._$QueueTrigger$_(e, s, i);
                    this._$_executingTriggerDepth$_++;
                    for (const n of t._$runningLayouts$_()) {
                        const h = n._$GetEventSheet$_();
                        if (h) {
                            this._$_runtime$_._$PushCurrentLayout$_(n);
                            for (const a of h._$deepIncludes$_()) {
                                const l = yield* a._$_DebugTrigger$_(e, s, i);
                                r = r || l;
                            }
                            const o = yield* h._$_DebugTrigger$_(e, s, i);
                            r = r || o, this._$_runtime$_._$PopCurrentLayout$_();
                        }
                    }
                    return this._$_executingTriggerDepth$_--, r;
                }
                _$QueueTrigger$_(t, e, s) {
                    return this._$_queuedTriggers$_.push([ t, e, s ]), !1;
                }
                _$QueueDebugTrigger$_(t, e, s) {
                    let i = null, r = new Promise(t => i = t);
                    return this._$_queuedDebugTriggers$_.push([ t, e, s, i ]), r;
                }
                *_$_RunQueuedDebugTriggersGen$_() {
                    if (this._$_runtime$_._$HitBreakpoint$_()) throw new Error("should not be in breakpoint");
                    const t = this._$_runtime$_._$GetLayoutManager$_();
                    for (;this._$_queuedDebugTriggers$_.length; ) {
                        const [ e, s, i, r ] = this._$_queuedDebugTriggers$_.shift(), n = yield* this._$_DebugTrigger$_(t, e, s, i);
                        r(n);
                    }
                }
                async _$RunQueuedDebugTriggersAsync$_() {
                    for (const t of this._$_RunQueuedDebugTriggersGen$_()) await this._$_runtime$_._$DebugBreak$_(t);
                }
                _$_FastTrigger$_(t, s, i, r) {
                    let n = !1, e = t._$GetMainRunningLayout$_(), h = e._$GetEventSheet$_();
                    if (h) {
                        this._$_executingTriggerDepth$_++, this._$_runtime$_._$PushCurrentLayout$_(e);
                        const o = h._$deepIncludes$_();
                        for (let t = 0, e = o.length; t < e; ++t) {
                            const l = o[t]._$_FastTrigger$_(s, i, r);
                            n = n || l;
                        }
                        const a = h._$_FastTrigger$_(s, i, r);
                        return n = n || a, this._$_runtime$_._$PopCurrentLayout$_(), 
                        this._$_executingTriggerDepth$_--, n;
                    }
                }
                *_$_DebugFastTrigger$_(t, s, i, r) {
                    let n = !1, e = t._$GetMainRunningLayout$_(), h = e._$GetEventSheet$_();
                    if (h) {
                        this._$_executingTriggerDepth$_++, this._$_runtime$_._$PushCurrentLayout$_(e);
                        const o = h._$deepIncludes$_();
                        for (let t = 0, e = o.length; t < e; ++t) {
                            const l = yield* o[t]._$_DebugFastTrigger$_(s, i, r);
                            n = n || l;
                        }
                        const a = yield* h._$_DebugFastTrigger$_(s, i, r);
                        return n = n || a, this._$_runtime$_._$PopCurrentLayout$_(), 
                        this._$_executingTriggerDepth$_--, n;
                    }
                }
                _$GetTriggerDepth$_() {
                    return this._$_executingTriggerDepth$_;
                }
                _$IsInTrigger$_() {
                    return 0 < this._$GetTriggerDepth$_();
                }
                _$_IncTriggerDepth$_() {
                    return ++this._$_executingTriggerDepth$_;
                }
                _$_DecTriggerDepth$_() {
                    --this._$_executingTriggerDepth$_;
                }
                _$IsRunningEvents$_() {
                    return 0 < this._$_runningEventsDepth$_;
                }
                _$IsInEventEngine$_() {
                    return this._$IsRunningEvents$_() || this._$IsInTrigger$_();
                }
                _$_RunQueuedTriggers$_(t) {
                    for (const [ e, s, i ] of this._$_queuedTriggers$_) this._$_Trigger$_(t, e, s, i);
                    C33._$clearArray$_(this._$_queuedTriggers$_);
                }
                _$BlockFlushingInstances$_(t) {
                    t ? this._$_blockFlushingDepth$_++ : this._$_blockFlushingDepth$_--;
                }
                _$IsFlushingBlocked$_() {
                    return 0 < this._$_blockFlushingDepth$_;
                }
                _$ClearSol$_(s) {
                    for (let t = 0, e = s.length; t < e; ++t) s[t]._$GetSolStack$_()._$Clear$_();
                }
                _$PushCleanSol$_(s) {
                    for (let t = 0, e = s.length; t < e; ++t) s[t]._$GetSolStack$_()._$PushClean$_();
                }
                _$PushCopySol$_(s) {
                    for (let t = 0, e = s.length; t < e; ++t) s[t]._$GetSolStack$_()._$PushCopy$_();
                }
                _$PopSol$_(s) {
                    for (let t = 0, e = s.length; t < e; ++t) s[t]._$GetSolStack$_()._$Pop$_();
                }
                _$GetDynamicSolModifiersSet$_(e) {
                    const s = new Set(), i = this._$_eventStack$_._$GetAllStackFrames$_(), r = this._$_eventStack$_._$GetCurrentStackFrameIndex$_();
                    for (let t = 0; t <= r; ++t) {
                        const n = i[t]._$GetDynamicSolModifiers$_();
                        if (n) for (const h of n) e && e.has(h) || s.add(h);
                    }
                    return s;
                }
                _$PushCleanSolDynamic$_(t) {
                    const e = new Set([ ...t ]), s = this._$GetDynamicSolModifiersSet$_(e);
                    if (0 < s.size) {
                        for (const i of s) i._$GetSolStack$_()._$PushClean$_();
                        return [ ...s ];
                    }
                    return null;
                }
                _$AddScheduledWait$_() {
                    const t = C33._$New$_(C33._$ScheduledWait$_, this);
                    return this._$_scheduledWaits$_.push(t), t;
                }
                _$scheduledWaits$_() {
                    return this._$_scheduledWaits$_;
                }
                _$RunScheduledWaits$_() {
                    if (this._$_scheduledWaits$_.length) {
                        let s = this._$GetCurrentEventStackFrame$_(), i = !1;
                        this._$_runningEventsDepth$_++;
                        for (let t = 0, e = this._$_scheduledWaits$_.length; t < e; ++t) {
                            const r = this._$_scheduledWaits$_[t];
                            r._$_ShouldRun$_() && r._$_Run$_(s), r._$ShouldRelease$_() && (i = !0);
                        }
                        i && (this._$_FilterScheduledWaitsToRelease$_(), s._$Reset$_(null)), 
                        this._$_runningEventsDepth$_--;
                    }
                }
                async _$DebugRunScheduledWaits$_() {
                    if (this._$_scheduledWaits$_.length) {
                        let s = this._$GetCurrentEventStackFrame$_(), i = !1;
                        this._$_runningEventsDepth$_++;
                        for (let t = 0, e = this._$_scheduledWaits$_.length; t < e; ++t) {
                            const r = this._$_scheduledWaits$_[t];
                            r._$_ShouldRun$_() && await r._$_DebugRun$_(s), r._$ShouldRelease$_() && (i = !0);
                        }
                        i && (this._$_FilterScheduledWaitsToRelease$_(), s._$Reset$_(null)), 
                        this._$_runningEventsDepth$_--;
                    }
                }
                _$_FilterScheduledWaitsToRelease$_() {
                    const t = C33._$arrayFilterOut$_(this._$_scheduledWaits$_, t => t._$ShouldRelease$_());
                    for (const e of t) e._$Release$_();
                }
                _$ClearAllScheduledWaits$_() {
                    for (const t of this._$_scheduledWaits$_) t._$Release$_();
                    C33._$clearArray$_(this._$_scheduledWaits$_);
                }
                _$_OnInstancesReleased$_(t) {
                    for (const e of this._$_scheduledWaits$_) e._$RemoveInstances$_(t);
                    for (const s of t) {
                        const i = this._$_instSignals$_.get(s);
                        if (this._$_instSignals$_.delete(s), i) for (const {
                            resolve: r
                        } of i._$signalPromises$_.values()) r(!0);
                    }
                }
                _$AddAsyncActionPromise$_(t) {
                    this._$_asyncActionPromises$_.push({
                        promise: t,
                        _$triggerDepth$_: this._$GetTriggerDepth$_()
                    });
                }
                _$ClearAsyncActionPromises$_() {
                    C33._$clearArray$_(this._$_asyncActionPromises$_);
                }
                _$ClearNestedAsyncActionPromises$_() {
                    const e = this._$GetTriggerDepth$_();
                    this._$_asyncActionPromises$_ = this._$_asyncActionPromises$_.filter(t => t._$triggerDepth$_ <= e);
                }
                _$GetPromiseForAllAsyncActions$_() {
                    const t = Promise.all(this._$_asyncActionPromises$_.map(t => t.promise));
                    return this._$_asyncActionPromises$_ = [], t;
                }
                _$Signal$_(t) {
                    const e = t.toLowerCase();
                    this._$_signalTags$_.push(e), this._$_runtime$_._$Trigger$_(C33._$Plugins$_._$System$_._$Cnds$_._$OnSignal$_, null), 
                    this._$_signalTags$_.pop();
                    for (const i of this._$_runtime$_._$GetEventSheetManager$_()._$scheduledWaits$_()) i._$IsSignal$_() && i._$GetSignalTag$_() === e && i._$SetSignalled$_();
                    const s = this._$_signalPromises$_.get(e);
                    s && (s.resolve(), this._$_signalPromises$_.delete(e));
                }
                _$WaitForSignal$_(t) {
                    const s = t.toLowerCase(), e = this._$_signalPromises$_.get(s);
                    if (e) return e.promise;
                    {
                        let e = null, t = new Promise(t => e = t);
                        return this._$_signalPromises$_.set(s, {
                            promise: t,
                            resolve: e
                        }), t;
                    }
                }
                _$GetCurrentSignalTag$_() {
                    if (0 === this._$_signalTags$_.length) throw new Error("not in a signal");
                    return this._$_signalTags$_.at(-1);
                }
                _$_GetInstanceSignalState$_(t) {
                    let e = this._$_instSignals$_.get(t);
                    return e || (e = {
                        _$signalTags$_: [],
                        _$signalPromises$_: new Map()
                    }, this._$_instSignals$_.set(t, e)), e;
                }
                _$InstanceSignal$_(t, e) {
                    const s = this._$_GetInstanceSignalState$_(t), i = e.toLowerCase();
                    s._$signalTags$_.push(i), this._$_runtime$_._$Trigger$_(t._$GetPlugin$_()._$GetConstructor$_()._$Cnds$_._$OnInstanceSignal$_, t), 
                    s._$signalTags$_.pop();
                    for (const n of this._$_runtime$_._$GetEventSheetManager$_()._$scheduledWaits$_()) n._$IsInstanceSignals$_() && n._$GetSignalTag$_() === i && n._$SetInstanceSignalled$_(t);
                    const r = s._$signalPromises$_.get(i);
                    r && (r.resolve(!1), s._$signalPromises$_.delete(i)), 0 === s._$signalTags$_.length && 0 === s._$signalPromises$_.size && this._$_instSignals$_.delete(t);
                }
                _$WaitForInstanceSignal$_(t, e) {
                    const s = this._$_GetInstanceSignalState$_(t), i = e.toLowerCase(), r = s._$signalPromises$_.get(i);
                    if (r) return r.promise;
                    {
                        let e = null, t = new Promise(t => e = t);
                        return s._$signalPromises$_.set(i, {
                            promise: t,
                            resolve: e
                        }), t;
                    }
                }
                _$GetCurrentInstanceSignalTag$_(t) {
                    const e = this._$_GetInstanceSignalState$_(t);
                    if (e && 0 !== e._$signalTags$_.length) return e._$signalTags$_.at(-1);
                    throw new Error("not in a signal");
                }
                _$_SaveToJson$_() {
                    return {
                        groups: this._$_SaveGroupsToJson$_(),
                        cnds: this._$_SaveCndsToJson$_(),
                        acts: this._$_SaveActsToJson$_(),
                        vars: this._$_SaveVarsToJson$_(),
                        waits: this._$_SaveScheduledWaitsToJson$_()
                    };
                }
                _$_LoadFromJson$_(t) {
                    this._$_LoadGroupsFromJson$_(t.groups), this._$_LoadCndsFromJson$_(t.cnds), 
                    this._$_LoadActsFromJson$_(t.acts), this._$_LoadVarsFromJson$_(t.vars), 
                    this._$_LoadScheduledWaitsFromJson$_(t.waits);
                }
                _$_SaveGroupsToJson$_() {
                    const t = {};
                    for (const e of this._$GetAllGroups$_()) t[e._$GetSID$_().toString()] = e._$IsGroupActive$_();
                    return t;
                }
                _$_LoadGroupsFromJson$_(t) {
                    for (const [ e, s ] of Object.entries(t)) {
                        const i = parseInt(e, 10), r = this._$GetEventGroupBySID$_(i);
                        r && r._$SetGroupActive$_(s);
                    }
                }
                _$_SaveCndsToJson$_() {
                    const t = {};
                    for (const [ e, s ] of this._$_cndsBySid$_) {
                        const i = s._$_SaveToJson$_();
                        i && (t[e.toString()] = i);
                    }
                    return t;
                }
                _$_LoadCndsFromJson$_(t) {
                    const e = new Map();
                    for (const [ s, i ] of Object.entries(t)) e.set(parseInt(s, 10), i);
                    for (const [ r, n ] of this._$_cndsBySid$_) n._$_LoadFromJson$_(e.get(r) || null);
                }
                _$_SaveActsToJson$_() {
                    const t = {};
                    for (const [ e, s ] of this._$_actsBySid$_) {
                        const i = s._$_SaveToJson$_();
                        i && (t[e.toString()] = i);
                    }
                    return t;
                }
                _$_LoadActsFromJson$_(t) {
                    const e = new Map();
                    for (const [ s, i ] of Object.entries(t)) e.set(parseInt(s, 10), i);
                    for (const [ r, n ] of this._$_actsBySid$_) n._$_LoadFromJson$_(e.get(r) || null);
                }
                _$_SaveVarsToJson$_() {
                    const t = {};
                    for (const [ e, s ] of this._$_eventVarsBySid$_) s._$IsConstant$_() || !s._$IsGlobal$_() && !s._$IsStatic$_() || (t[e.toString()] = s._$GetValue$_());
                    return t;
                }
                _$_LoadVarsFromJson$_(t) {
                    for (const [ e, s ] of Object.entries(t)) {
                        const i = parseInt(e, 10), r = this._$GetEventVariableBySID$_(i);
                        r && r._$SetValue$_(s);
                    }
                }
                _$_SaveScheduledWaitsToJson$_() {
                    return this._$_scheduledWaits$_.filter(t => !t._$IsPromise$_()).map(t => t._$_SaveToJson$_());
                }
                _$_LoadScheduledWaitsFromJson$_(t) {
                    this._$ClearAllScheduledWaits$_();
                    for (const e of t) {
                        const s = C33._$ScheduledWait$_._$_CreateFromJson$_(this, e);
                        s && this._$_scheduledWaits$_.push(s);
                    }
                }
                _$_GetPerfRecords$_() {
                    return [ ...this._$_runtime$_._$GetLayoutManager$_()._$runningLayouts$_() ].map(t => t._$GetEventSheet$_()).filter(t => t).map(t => t._$_GetPerfRecord$_());
                }
                _$FindFirstFunctionBlockParent$_(t) {
                    for (;t; ) {
                        const e = t._$GetScopeParent$_();
                        if (e instanceof C33._$FunctionBlock$_) return e;
                        t = e;
                    }
                    return null;
                }
                _$_InvokeFunctionFromJS$_(t, e) {
                    Array.isArray(e) || (e = []);
                    const s = this._$GetFunctionBlockByName$_(t.toLowerCase());
                    if (!s) return null;
                    if (!s._$IsEnabled$_()) return s._$GetDefaultReturnValue$_();
                    const i = s._$GetFunctionParameters$_();
                    if (e.length < i.length) for (e = e.slice(0); e.push(i[e.length]._$GetInitialValue$_()), 
                    e.length < i.length; );
                    const r = s._$GetEventBlock$_();
                    return r._$RunAsExpressionFunctionCall$_(r._$GetSolModifiersIncludingParents$_(), !1, s._$GetReturnType$_(), s._$GetDefaultReturnValue$_(), ...e);
                }
            };
        }
        {
            const C33 = self._$C3$_;
            C33._$EventSheet$_ = class extends C33._$DefendedBase$_ {
                constructor(t, e) {
                    super(), this._$_eventSheetManager$_ = t, this._$_runtime$_ = t._$GetRuntime$_(), 
                    this._$_name$_ = e[0], this._$_events$_ = [], this._$_triggers$_ = new Map(), 
                    this._$_fastTriggers$_ = new Map(), this._$_eventsByDisplayNumber$_ = new Map(), 
                    this._$_hasRun$_ = !1, this._$_shallowIncludes$_ = [], this._$_deepIncludes$_ = [], 
                    this._$_alreadyIncludedSheets$_ = new Set();
                    for (const s of e[1]) this._$_CreateEvent$_(s, null, this._$_events$_);
                    this._$_perfRecord$_ = this._$_runtime$_._$IsDebug$_() ? {
                        type: "sheet",
                        name: this._$_name$_,
                        _$totalTimeCounter$_: 0,
                        children: []
                    } : null;
                }
                _$Release$_() {
                    this._$_eventSheetManager$_ = null, this._$_runtime$_ = null;
                }
                _$_CreateEvent$_(t, e, s) {
                    switch (t[0]) {
                      case 0:
                      case 3:
                        this._$_CreateEventBlock$_(t, e, s);
                        break;

                      case 1:
                        this._$_CreateEventVariable$_(t, e, s);
                        break;

                      case 2:
                        this._$_CreateInclude$_(t, e, s);
                        break;

                      case 4:
                        this._$_CreateFunctionBlock$_(t, e);
                        break;

                      case 5:
                        this._$_CreateScriptBlock$_(t, e, s);
                        break;

                      case 6:
                        this._$_CreateCustomACEBlock$_(t, e);
                        break;

                      default:
                        throw new Error("invalid event type");
                    }
                }
                _$_CreateEventBlock$_(t, e, s) {
                    const i = C33._$EventBlock$_._$Create$_(this, e, t);
                    if (i._$IsOrBlock$_()) {
                        s.push(i);
                        const r = i._$GetConditions$_();
                        for (let t = 0, e = r.length; t < e; ++t) r[t]._$IsTrigger$_() && this._$_InitTrigger$_(i, t);
                    } else i._$IsTrigger$_() ? this._$_InitTrigger$_(i, 0) : s.push(i);
                }
                _$_CreateFunctionBlock$_(t, e) {
                    const s = C33._$FunctionBlock$_._$CreateFunctionBlock$_(this, e, t);
                    this._$_eventSheetManager$_._$_RegisterFunctionBlock$_(s);
                }
                _$_CreateCustomACEBlock$_(t, e) {
                    const s = C33._$FunctionBlock$_._$CreateCustomACEBlock$_(this, e, t);
                    this._$_eventSheetManager$_._$_RegisterFunctionBlock$_(s);
                }
                _$_CreateEventVariable$_(t, e, s) {
                    const i = C33._$EventVariable$_._$Create$_(this, e, t);
                    s.push(i);
                }
                _$_CreateInclude$_(t, e, s) {
                    const i = C33._$EventInclude$_._$Create$_(this, e, t);
                    s.push(i);
                }
                _$_CreateScriptBlock$_(t, e, s) {
                    const i = C33._$EventScript$_._$Create$_(this, e, t);
                    s.push(i);
                }
                _$_InitTrigger$_(r, n) {
                    r._$IsOrBlock$_() || this._$_eventSheetManager$_._$_AddTriggerToPostInit$_(r);
                    const h = r._$GetConditionAt$_(n), o = h._$_GetFunc$_(), a = h._$GetObjectClass$_();
                    if (h._$IsFastTrigger$_()) {
                        let t = this._$_fastTriggers$_.get(a), e = (t || (t = new Map(), 
                        this._$_fastTriggers$_.set(a, t)), h._$GetFastTriggerValue$_().toLowerCase()), s = t.get(o), i = (s || (s = new Map(), 
                        t.set(o, s)), s.get(e));
                        i || (i = [], s.set(e, i)), i.push([ r, n ]);
                    } else {
                        let t = this._$_triggers$_.get(a), e = (t || (t = {
                            _$methodMap$_: new Map(),
                            _$behaviors$_: new Map()
                        }, this._$_triggers$_.set(a, t)), h._$GetBehaviorType$_()), s, i = (e ? (s = t._$behaviors$_.get(e)) || (s = new Map(), 
                        t._$behaviors$_.set(e, s)) : s = t._$methodMap$_, s.get(o));
                        i || (i = [], s.set(o, i)), i.push([ r, n ]);
                    }
                }
                _$_PostInit$_() {
                    const s = this._$_events$_;
                    for (let t = 0, e = s.length; t < e; ++t) {
                        const i = t < e - 1 && s[t + 1] instanceof C33._$EventBlock$_ && s[t + 1]._$IsElseBlock$_();
                        s[t]._$_PostInit$_(i);
                    }
                }
                _$_AddShallowInclude$_(t) {
                    this._$_shallowIncludes$_.push(t);
                }
                _$_UpdateDeepIncludes$_() {
                    C33._$clearArray$_(this._$_deepIncludes$_), this._$_AddDeepIncludes$_(this), 
                    this._$_alreadyIncludedSheets$_.clear();
                }
                _$_AddDeepIncludes$_(t) {
                    const e = t._$_deepIncludes$_, s = t._$_alreadyIncludedSheets$_;
                    for (const i of this._$_shallowIncludes$_) {
                        const r = i._$GetIncludeSheet$_();
                        i._$IsActive$_() && t !== r && !s.has(r) && (s.add(r), r._$_AddDeepIncludes$_(t), 
                        e.push(r));
                    }
                }
                _$deepIncludes$_() {
                    return this._$_deepIncludes$_;
                }
                _$GetEventSheetManager$_() {
                    return this._$_eventSheetManager$_;
                }
                _$GetRuntime$_() {
                    return this._$_runtime$_;
                }
                _$GetName$_() {
                    return this._$_name$_;
                }
                _$_RegisterEventByDisplayNumber$_(t, e) {
                    this._$_eventsByDisplayNumber$_.set(e, t);
                }
                _$_GetEventByDisplayNumber$_(t) {
                    return this._$_eventsByDisplayNumber$_.get(t) || null;
                }
                _$_ResetHasRunFlag$_() {
                    this._$_hasRun$_ = !1;
                }
                _$Run$_() {
                    if (!this._$_hasRun$_) {
                        const t = this._$_runtime$_, e = t._$IsCPUProfiling$_(), s = e ? performance.now() : 0, i = (this._$_hasRun$_ = !0, 
                        this._$GetEventSheetManager$_()), r = i._$GetCurrentEventStackFrame$_();
                        for (const n of this._$_events$_) n._$Run$_(r), i._$ClearSol$_(n._$GetSolModifiers$_()), 
                        i._$ClearAsyncActionPromises$_(), t._$FlushPendingInstances$_();
                        r._$Reset$_(null), e && (this._$_perfRecord$_._$totalTimeCounter$_ += performance.now() - s);
                    }
                }
                *_$DebugRun$_() {
                    if (!this._$_hasRun$_) {
                        this._$_hasRun$_ = !0;
                        const t = this._$_runtime$_, e = this._$GetEventSheetManager$_(), s = e._$GetCurrentEventStackFrame$_();
                        for (const i of this._$_events$_) yield* i._$DebugRun$_(s), 
                        e._$ClearSol$_(i._$GetSolModifiers$_()), e._$ClearAsyncActionPromises$_(), 
                        t._$FlushPendingInstances$_();
                        s._$Reset$_(null);
                    }
                }
                _$_Trigger$_(i, r, n) {
                    if (!r) return this._$_TriggerForClass$_(i, r, null, null);
                    {
                        let t = r._$GetObjectClass$_(), e = !1, s = this._$_TriggerForClass$_(i, r, t, n);
                        e = e || s;
                        for (const h of t._$GetFamilies$_()) s = this._$_TriggerForClass$_(i, r, h, n), 
                        e = e || s;
                    }
                }
                _$_TriggerForClass$_(t, e, s, i) {
                    const r = this._$_triggers$_.get(s);
                    if (!r) return !1;
                    const n = i ? r._$behaviors$_.get(i) : r._$methodMap$_;
                    if (!n) return !1;
                    const h = n.get(t);
                    if (!h) return !1;
                    let o = !1;
                    for (const [ a, l ] of h) {
                        const u = this._$_ExecuteTrigger$_(e, a, l);
                        o = o || u;
                    }
                    return o;
                }
                *_$_DebugTrigger$_(i, r, n) {
                    if (!r) return yield* this._$_DebugTriggerForClass$_(i, r, null, null);
                    {
                        let t = r._$GetObjectClass$_(), e = !1, s = yield* this._$_DebugTriggerForClass$_(i, r, t, n);
                        e = e || s;
                        for (const h of t._$GetFamilies$_()) s = yield* this._$_DebugTriggerForClass$_(i, r, h, n), 
                        e = e || s;
                    }
                }
                *_$_DebugTriggerForClass$_(t, e, s, i) {
                    const r = this._$_triggers$_.get(s);
                    if (!r) return !1;
                    const n = i ? r._$behaviors$_.get(i) : r._$methodMap$_;
                    if (!n) return !1;
                    const h = n.get(t);
                    if (!h) return !1;
                    let o = !1;
                    for (const [ a, l ] of h) {
                        let t;
                        t = a._$DebugCanRunFast$_() ? this._$_ExecuteTrigger$_(e, a, l) : yield* this._$_DebugExecuteTrigger$_(e, a, l), 
                        o = o || t;
                    }
                    return o;
                }
                _$_FastTrigger$_(t, e, s) {
                    const i = e._$GetObjectClass$_(), r = this._$_fastTriggers$_.get(i);
                    if (!r) return !1;
                    const n = r.get(t);
                    if (!n) return !1;
                    const h = n.get(s);
                    if (!h) return !1;
                    let o = !1;
                    for (let t = 0, e = h.length; t < e; ++t) {
                        const a = h[t], l = this._$_ExecuteTrigger$_(null, a[0], a[1]);
                        o = o || l;
                    }
                    return o;
                }
                *_$_DebugFastTrigger$_(t, e, s) {
                    const i = e._$GetObjectClass$_(), r = this._$_fastTriggers$_.get(i);
                    if (!r) return !1;
                    const n = r.get(t);
                    if (!n) return !1;
                    const h = n.get(s);
                    if (!h) return !1;
                    let o = !1;
                    for (let r = 0, t = h.length; r < t; ++r) {
                        let t = h[r], e = t[0], s = t[1], i;
                        i = e._$DebugCanRunFast$_() ? this._$_ExecuteTrigger$_(null, e, s) : yield* this._$_DebugExecuteTrigger$_(null, e, s), 
                        o = o || i;
                    }
                    return o;
                }
                _$_ExecuteTrigger$_(t, e, s) {
                    let i = this._$_runtime$_, r = this._$_eventSheetManager$_, n = r._$GetCurrentEvent$_(), h = r._$GetEventStack$_(), o = r._$GetTriggerDepth$_(), a = !1;
                    n && r._$PushCleanSol$_(n._$GetSolModifiersIncludingParents$_()), 
                    r._$PushCleanSol$_(e._$GetSolModifiersIncludingParents$_());
                    const l = 1 < o, u = (l && r._$GetLocalVarStack$_()._$Push$_(), 
                    h._$Push$_(e));
                    if (t) {
                        const f = e._$GetConditions$_()[s]._$GetObjectClass$_(), d = f._$GetCurrentSol$_();
                        d._$SetSinglePicked$_(t), t._$IsInContainer$_() && t._$SetSiblingsSinglePicked$_();
                    }
                    let c = !0;
                    if (e._$GetParent$_()) {
                        const p = e._$GetTriggerParents$_();
                        for (let t = 0, e = p.length; t < e; ++t) if (!p[t]._$RunPreTrigger$_(u)) {
                            c = !1;
                            break;
                        }
                    }
                    return c && (e._$IsOrBlock$_() ? e._$RunOrBlockTrigger$_(u, s) : e._$Run$_(u), 
                    a = u._$GetLastEventTrue$_()), h._$Pop$_(), l && r._$GetLocalVarStack$_()._$Pop$_(), 
                    r._$PopSol$_(e._$GetSolModifiersIncludingParents$_()), n && r._$PopSol$_(n._$GetSolModifiersIncludingParents$_()), 
                    n || 1 !== o || (r._$ClearAsyncActionPromises$_(), r._$IsFlushingBlocked$_()) || i._$FlushPendingInstances$_(), 
                    a;
                }
                *_$_DebugExecuteTrigger$_(t, e, s) {
                    let i = this._$_runtime$_, r = this._$_eventSheetManager$_, n = r._$GetCurrentEvent$_(), h = r._$GetEventStack$_(), o = r._$GetTriggerDepth$_(), a = !1;
                    n && r._$PushCleanSol$_(n._$GetSolModifiersIncludingParents$_()), 
                    r._$PushCleanSol$_(e._$GetSolModifiersIncludingParents$_());
                    const l = 1 < o, u = (l && r._$GetLocalVarStack$_()._$Push$_(), 
                    h._$Push$_(e));
                    if (t) {
                        const f = e._$GetConditions$_()[s]._$GetObjectClass$_(), d = f._$GetCurrentSol$_();
                        d._$SetSinglePicked$_(t), t._$IsInContainer$_() && t._$SetSiblingsSinglePicked$_();
                    }
                    let c = !0;
                    if (e._$GetParent$_()) {
                        const p = e._$GetTriggerParents$_();
                        for (let t = 0, e = p.length; t < e; ++t) if (!(yield* p[t]._$DebugRunPreTrigger$_(u))) {
                            c = !1;
                            break;
                        }
                    }
                    return c && (e._$IsOrBlock$_() ? yield* e._$DebugRunOrBlockTrigger$_(u, s) : yield* e._$DebugRun$_(u), 
                    a = u._$GetLastEventTrue$_()), h._$Pop$_(), l && r._$GetLocalVarStack$_()._$Pop$_(), 
                    r._$PopSol$_(e._$GetSolModifiersIncludingParents$_()), n && r._$PopSol$_(n._$GetSolModifiersIncludingParents$_()), 
                    n || 1 !== o || (r._$ClearAsyncActionPromises$_(), r._$IsFlushingBlocked$_()) || i._$FlushPendingInstances$_(), 
                    a;
                }
                _$_GetPerfRecord$_() {
                    return this._$_perfRecord$_;
                }
            };
        }
        {
            let NoActions2 = function(t, e) {
                return !0;
            };
            NoActions = NoActions2;
            const C33 = self._$C3$_, EMPTY_ARRAY = [];
            function* DebugNoActions(t, e) {
                return !0;
            }
            C33._$EventBlock$_ = class extends C33._$DefendedBase$_ {
                constructor(t, e, s) {
                    super(), this._$_eventSheet$_ = t, this._$_runtime$_ = t._$GetRuntime$_(), 
                    this._$_parent$_ = e, this._$_scopeParent$_ = null, this._$_eventStack$_ = this._$_runtime$_._$GetEventSheetManager$_()._$GetEventStack$_(), 
                    this._$_solModifiers$_ = [], this._$_solModifiersIncludingParents$_ = [], 
                    this._$_hasGotSolModifiersIncludingParents$_ = !1, this._$_isSolWriterAfterCnds$_ = !1, 
                    this._$_isTopLevelGroup$_ = !1, this._$_hasElseBlock$_ = !1, 
                    this._$_isOrBlock$_ = !!s[2], this._$_isElseBlock$_ = !1, this._$_triggerParents$_ = null, 
                    this._$_conditions$_ = [], this._$_actions$_ = [], this._$_subEvents$_ = [], 
                    this._$_RunActions$_ = NoActions2, this._$_DebugRunActions$_ = DebugNoActions, 
                    this._$_isGroup$_ = !1, this._$_isInitiallyActive$_ = !1, this._$_groupName$_ = "", 
                    this._$_isGroupActive$_ = !1, this._$_containedIncludes$_ = null, 
                    this._$_perfRecord$_ = null, this._$_sid$_ = s[4], this._$_displayNumber$_ = s[5], 
                    this._$_eventSheet$_._$_RegisterEventByDisplayNumber$_(this, this._$_displayNumber$_), 
                    this._$_debugData$_ = this._$_runtime$_._$IsDebug$_() ? {
                        _$isBreakpoint$_: s[3][0],
                        _$isBreakable$_: s[3][1],
                        _$canRunAllConditionsFast$_: !1,
                        _$canRunAllActionsFast$_: !1,
                        _$canRunAllSubEventsFast$_: !1,
                        _$canRunSelfFast$_: !1
                    } : null, this._$GetEventSheetManager$_()._$_RegisterEventBlock$_(this), 
                    3 === s[0] && this._$_InitGroup$_(s[1]);
                    let i = 0;
                    for (const r of s[6]) {
                        const n = C33._$Condition$_._$Create$_(this, r, i++);
                        this._$_conditions$_.push(n), this._$_AddSolModifier$_(n._$GetObjectClass$_());
                    }
                    i = 0;
                    for (const h of s[7]) {
                        const o = C33._$Action$_._$Create$_(this, h, i++);
                        this._$_actions$_.push(o);
                    }
                    if (9 === s.length) {
                        const a = s[8];
                        for (const l of a) this._$_eventSheet$_._$_CreateEvent$_(l, this, this._$_subEvents$_);
                    }
                    this._$_conditions$_.length && (this._$_isElseBlock$_ = null === this._$_conditions$_[0]._$GetObjectClass$_() && this._$_conditions$_[0]._$_GetFunc$_() === C33._$Plugins$_._$System$_._$Cnds$_._$Else$_), 
                    0 === this._$_conditions$_.length && (this._$_conditions$_ = EMPTY_ARRAY), 
                    0 === this._$_actions$_.length && (this._$_actions$_ = EMPTY_ARRAY), 
                    0 === this._$_subEvents$_.length && (this._$_subEvents$_ = EMPTY_ARRAY);
                }
                static _$Create$_(t, e, s) {
                    return C33._$New$_(C33._$EventBlock$_, t, e, s);
                }
                _$_InitGroup$_(t) {
                    this._$_isGroup$_ = !0, this._$_isInitiallyActive$_ = !!t[0], 
                    this._$_isGroupActive$_ = this._$_isInitiallyActive$_, this._$_groupName$_ = t[1].toLowerCase(), 
                    this._$_containedIncludes$_ = [], this._$GetEventSheetManager$_()._$_RegisterGroup$_(this), 
                    this._$_runtime$_._$IsDebug$_() && (this._$_perfRecord$_ = {
                        type: "group",
                        name: t[1],
                        _$totalTimeCounter$_: 0,
                        children: []
                    });
                }
                _$_AddContainedInclude$_(t) {
                    this._$_containedIncludes$_.push(t);
                }
                _$_AddContainerSolModifierToList$_(t, e) {
                    for (const s of t._$GetContainer$_()._$objectTypes$_()) e.includes(s) || e.push(s);
                }
                _$_AddSolModifierToList$_(t, e) {
                    if (t) if (e.includes(t) || e.push(t), t._$IsFamily$_()) for (const s of t._$GetFamilyMembers$_()) s._$IsInContainer$_() && this._$_AddContainerSolModifierToList$_(s, e); else t._$IsInContainer$_() && this._$_AddContainerSolModifierToList$_(t, e);
                }
                _$_AddSolModifier$_(t) {
                    this._$_AddSolModifierToList$_(t, this._$_solModifiers$_);
                }
                _$_AddParentSolModifier$_(t) {
                    this._$_AddSolModifierToList$_(t, this._$_solModifiersIncludingParents$_);
                }
                _$SetAllSolModifiers$_() {
                    this._$_solModifiers$_ = this._$_runtime$_._$GetAllObjectClasses$_();
                }
                _$_PostInit$_(t) {
                    this._$_hasElseBlock$_ = !!t, this._$_IdentifyTopLevelGroup$_(), 
                    this._$_IdentifyTriggerParents$_();
                    for (const e of this._$_conditions$_) e._$_PostInit$_();
                    if (0 < this._$_actions$_.length) {
                        let t = !1;
                        for (const i of this._$_actions$_) i._$_PostInit$_(), i._$HasReturnType$_() && (t = !0);
                        t ? (this._$_RunActions$_ = this._$_RunActions_ReturnValue$_, 
                        this._$_DebugRunActions$_ = this._$_DebugRunActions_ReturnValue$_) : (this._$_RunActions$_ = this._$_RunActions_Fast$_, 
                        this._$_DebugRunActions$_ = this._$_DebugRunActions_Fast$_);
                    }
                    const s = this._$_subEvents$_;
                    for (let t = 0, e = s.length; t < e; ++t) {
                        const r = t < e - 1 && s[t + 1] instanceof C33._$EventBlock$_ && s[t + 1]._$IsElseBlock$_();
                        s[t]._$_PostInit$_(r);
                    }
                    this._$_debugData$_ && this._$_UpdateCanRunFast$_(), this._$_perfRecord$_ && this._$_GetPerfRecordParent$_()._$_GetPerfRecord$_().children.push(this._$_perfRecord$_);
                }
                _$_GetPerfRecord$_() {
                    return this._$_perfRecord$_;
                }
                _$_GetPerfRecordParent$_() {
                    let t = this._$GetParent$_();
                    for (;t; ) {
                        if (t._$IsGroup$_()) return t;
                        t = t._$GetParent$_();
                    }
                    return this._$_eventSheet$_;
                }
                _$_UpdateCanRunFast$_() {
                    const t = this._$_debugData$_;
                    t._$canRunAllConditionsFast$_ = this._$_conditions$_.every(t => t._$DebugCanRunFast$_()), 
                    t._$canRunAllActionsFast$_ = this._$_actions$_.every(t => t._$DebugCanRunFast$_()), 
                    t._$canRunAllSubEventsFast$_ = this._$_subEvents$_.every(t => t._$DebugCanRunFast$_()), 
                    t._$canRunSelfFast$_ = t._$canRunAllConditionsFast$_ && t._$canRunAllActionsFast$_ && t._$canRunAllSubEventsFast$_;
                }
                _$_UpdateCanRunFastRecursive$_() {
                    let t = this;
                    for (;t._$_UpdateCanRunFast$_(), t = t._$GetParent$_(); );
                }
                _$_IdentifyTopLevelGroup$_() {
                    if (this._$IsGroup$_()) {
                        let t = this._$GetParent$_();
                        for (this._$_isTopLevelGroup$_ = !0; t; ) {
                            if (!t._$IsGroup$_()) {
                                this._$_isTopLevelGroup$_ = !1;
                                break;
                            }
                            t = t._$GetParent$_();
                        }
                    }
                }
                _$_IdentifySolModifiersIncludingParents$_() {
                    const t = this._$_runtime$_._$GetAllObjectClasses$_();
                    if (this._$_solModifiers$_ === t) this._$_solModifiersIncludingParents$_ = t; else {
                        this._$_solModifiersIncludingParents$_ = C33._$cloneArray$_(this._$_solModifiers$_);
                        let t = this._$GetParent$_();
                        for (;t; ) {
                            for (const s of t._$_solModifiers$_) this._$_AddParentSolModifier$_(s);
                            t = t._$GetParent$_();
                        }
                        const e = this._$GetEventSheetManager$_();
                        this._$_solModifiers$_ = e._$_DeduplicateSolModifierList$_(this._$_solModifiers$_), 
                        this._$_solModifiersIncludingParents$_ = e._$_DeduplicateSolModifierList$_(this._$_solModifiersIncludingParents$_);
                    }
                }
                _$_IdentifyTriggerParents$_() {
                    if (this._$HasAnyTriggeredCondition$_()) {
                        this._$_triggerParents$_ = [];
                        let t = this._$GetParent$_();
                        for (;t; ) this._$_triggerParents$_.push(t), t = t._$GetParent$_();
                        this._$_triggerParents$_.reverse();
                    }
                }
                _$SetSolWriterAfterCnds$_() {
                    this._$_isSolWriterAfterCnds$_ = !0, this._$_parent$_ && this._$_parent$_._$SetSolWriterAfterCnds$_();
                }
                _$IsSolWriterAfterCnds$_() {
                    return this._$_isSolWriterAfterCnds$_;
                }
                _$GetSolModifiers$_() {
                    return this._$_solModifiers$_;
                }
                _$GetSolModifiersIncludingParents$_() {
                    return this._$_hasGotSolModifiersIncludingParents$_ || (this._$_hasGotSolModifiersIncludingParents$_ = !0, 
                    this._$_IdentifySolModifiersIncludingParents$_()), this._$_solModifiersIncludingParents$_;
                }
                _$HasSolModifier$_(t) {
                    return this._$_solModifiers$_.includes(t);
                }
                _$GetTriggerParents$_() {
                    return this._$_triggerParents$_;
                }
                _$GetEventSheet$_() {
                    return this._$_eventSheet$_;
                }
                _$GetEventSheetManager$_() {
                    return this._$_eventSheet$_._$GetEventSheetManager$_();
                }
                _$GetRuntime$_() {
                    return this._$_runtime$_;
                }
                _$GetParent$_() {
                    return this._$_parent$_;
                }
                _$_SetScopeParent$_(t) {
                    this._$_scopeParent$_ = t;
                }
                _$GetScopeParent$_() {
                    return this._$_scopeParent$_ || this._$_parent$_;
                }
                _$GetDisplayNumber$_() {
                    return this._$_displayNumber$_;
                }
                _$IsDebugBreakable$_() {
                    return this._$_debugData$_ && this._$_debugData$_._$isBreakable$_;
                }
                _$IsDebugBreakpoint$_() {
                    return this._$IsDebugBreakable$_() && this._$_debugData$_._$isBreakpoint$_;
                }
                _$_SetDebugBreakpoint$_(t) {
                    this._$_debugData$_._$isBreakpoint$_ = !!t, this._$_UpdateCanRunFastRecursive$_();
                }
                _$IsGroup$_() {
                    return this._$_isGroup$_;
                }
                _$IsTopLevelGroup$_() {
                    return this._$_isTopLevelGroup$_;
                }
                _$IsElseBlock$_() {
                    return this._$_isElseBlock$_;
                }
                _$HasElseBlock$_() {
                    return this._$_hasElseBlock$_;
                }
                _$GetGroupName$_() {
                    return this._$_groupName$_;
                }
                _$IsGroupActive$_() {
                    return this._$_isGroupActive$_;
                }
                _$ResetInitialActivation$_() {
                    this._$SetGroupActive$_(this._$_isInitiallyActive$_);
                }
                _$SetGroupActive$_(t) {
                    if (t = !!t, !this._$_isGroup$_) throw new Error("not a group");
                    if (this._$_isGroupActive$_ !== t) {
                        this._$_isGroupActive$_ = t;
                        for (const e of this._$_containedIncludes$_) e._$UpdateActive$_();
                        if (this._$_containedIncludes$_.length) {
                            const s = this._$_runtime$_._$GetCurrentLayout$_(), i = s._$GetEventSheet$_();
                            i && i._$_UpdateDeepIncludes$_();
                        }
                    }
                }
                _$GetSID$_() {
                    return this._$_sid$_;
                }
                _$IsOrBlock$_() {
                    return this._$_isOrBlock$_;
                }
                _$IsTrigger$_() {
                    return this._$_conditions$_.length && this._$_conditions$_[0]._$IsTrigger$_();
                }
                _$IsForFunctionBlock$_() {
                    return this._$_scopeParent$_ && this._$_scopeParent$_ instanceof C33._$FunctionBlock$_;
                }
                _$HasAnyTriggeredCondition$_() {
                    return this._$IsForFunctionBlock$_() || this._$_conditions$_.some(t => t._$IsTrigger$_());
                }
                _$GetConditions$_() {
                    return this._$_conditions$_;
                }
                _$GetConditionCount$_() {
                    return this._$_conditions$_.length;
                }
                _$GetConditionAt$_(t) {
                    if ((t = Math.floor(t)) < 0 || t >= this._$_conditions$_.length) throw new RangeError("invalid condition index");
                    return this._$_conditions$_[t];
                }
                _$GetConditionByDebugIndex$_(t) {
                    return this._$GetConditionAt$_(t);
                }
                _$IsFirstConditionOfType$_(t) {
                    let e = t._$GetIndex$_();
                    if (0 !== e) {
                        --e;
                        const s = t._$IsSystemOrSingleGlobalCondition$_() ? t._$GetFirstObjectParameterObjectClass$_() : t._$GetObjectClass$_();
                        for (;0 <= e; --e) {
                            const i = this._$_conditions$_[e];
                            if (s === i._$GetObjectClass$_() || i._$IsSystemOrSingleGlobalCondition$_() && i._$GetFirstObjectParameterObjectClass$_() === s) return !1;
                        }
                    }
                    return !0;
                }
                _$GetActions$_() {
                    return this._$_actions$_;
                }
                _$GetActionCount$_() {
                    return this._$_actions$_.length;
                }
                _$GetActionAt$_(t) {
                    if ((t = Math.floor(t)) < 0 || t >= this._$_actions$_.length) throw new RangeError("invalid action index");
                    return this._$_actions$_[t];
                }
                _$GetActionByDebugIndex$_(e) {
                    e = Math.floor(e);
                    const t = this._$_actions$_.find(t => t._$GetDebugIndex$_() === e);
                    if (t) return t;
                    throw new RangeError("invalid action debug index");
                }
                _$_HasActionIndex$_(t) {
                    return 0 <= (t = Math.floor(t)) && t < this._$_actions$_.length;
                }
                _$GetSubEvents$_() {
                    return this._$_subEvents$_;
                }
                _$_GetAllLocalVariablesInScope$_() {
                    return this._$_subEvents$_.filter(t => t instanceof C33._$EventVariable$_);
                }
                _$RunPreTrigger$_(s) {
                    s._$SetCurrentEvent$_(this);
                    let i = this._$_conditions$_, r = 0 === i.length;
                    for (let t = 0, e = i.length; t < e; ++t) {
                        const n = i[t];
                        if (s._$SetConditionIndex$_(t), n._$IsLooping$_()) throw new Error("trigger cannot be used as sub-event to a loop");
                        if (n._$Run$_()) r = !0; else if (!this._$_isOrBlock$_) return !1;
                    }
                    return !this._$_isOrBlock$_ || r;
                }
                _$RunOrBlockTrigger$_(t, e) {
                    t._$SetCurrentEvent$_(this), t._$SetConditionIndex$_(e), this._$_conditions$_[e]._$Run$_() && (this._$_RunActions$_(t, 0) && this._$_RunSubEvents$_(t), 
                    t._$SetLastEventTrue$_(!0));
                }
                *_$DebugRunPreTrigger$_(s) {
                    s._$SetCurrentEvent$_(this);
                    let i = this._$_conditions$_, r = 0 === i.length;
                    for (let t = 0, e = i.length; t < e; ++t) {
                        const n = i[t];
                        if (s._$SetConditionIndex$_(t), n._$IsLooping$_()) throw new Error("trigger cannot be used as sub-event to a loop");
                        if (n._$DebugCanRunFast$_() ? n._$Run$_() : yield* n._$DebugRun$_()) r = !0; else if (!this._$_isOrBlock$_) return !1;
                    }
                    return !this._$_isOrBlock$_ || r;
                }
                *_$DebugRunOrBlockTrigger$_(t, e) {
                    t._$SetCurrentEvent$_(this), t._$SetConditionIndex$_(e);
                    let s = this._$_conditions$_[e];
                    if (s._$DebugCanRunFast$_() ? s._$Run$_() : yield* s._$DebugRun$_()) (this._$DebugCanRunActionsFast$_() ? this._$_RunActions$_(t, 0) : yield* this._$_DebugRunActions$_(t, 0)) && (this._$DebugCanRunSubEventsFast$_() ? this._$_RunSubEvents$_() : yield* this._$_DebugRunSubEvents$_()), 
                    t._$SetLastEventTrue$_(!0);
                }
                _$Run$_(t) {
                    t._$SetCurrentEvent$_(this), this._$_isElseBlock$_ || t._$SetElseBranchRan$_(!1), 
                    this._$_isOrBlock$_ ? this._$_RunOrBlock$_(t) : this._$_RunAndBlock$_(t);
                }
                *_$DebugRun$_(t) {
                    (this._$IsDebugBreakpoint$_() || this._$_runtime$_._$DebugBreakNext$_()) && (yield this), 
                    t._$SetCurrentEvent$_(this), this._$_isElseBlock$_ || t._$SetElseBranchRan$_(!1), 
                    this._$_isOrBlock$_ ? yield* this._$_DebugRunOrBlock$_(t) : yield* this._$_DebugRunAndBlock$_(t);
                }
                _$_RunOrBlock$_(s) {
                    let i = this._$_conditions$_, r = 0 === i.length;
                    for (let t = 0, e = i.length; t < e; ++t) {
                        const n = i[t];
                        if (!n._$IsTrigger$_()) {
                            s._$SetConditionIndex$_(t);
                            const h = n._$Run$_();
                            r = r || h;
                        }
                    }
                    s._$SetLastEventTrue$_(r), r && (this._$_RunActions$_(s, 0) && this._$_RunSubEvents$_(s), 
                    this._$_hasElseBlock$_) && s._$SetElseBranchRan$_(!0);
                }
                *_$_DebugRunOrBlock$_(s) {
                    let i = this._$_conditions$_, r = 0 === i.length;
                    for (let e = 0, t = i.length; e < t; ++e) {
                        const n = i[e];
                        if (!n._$IsTrigger$_()) {
                            s._$SetConditionIndex$_(e);
                            let t;
                            t = n._$DebugCanRunFast$_() ? n._$Run$_() : yield* n._$DebugRun$_(), 
                            r = r || t;
                        }
                    }
                    if (s._$SetLastEventTrue$_(r), r) (this._$DebugCanRunActionsFast$_() ? this._$_RunActions$_(s, 0) : yield* this._$_DebugRunActions$_(s, 0)) && (this._$DebugCanRunSubEventsFast$_() ? this._$_RunSubEvents$_() : yield* this._$_DebugRunSubEvents$_()), 
                    this._$_hasElseBlock$_ && s._$SetElseBranchRan$_(!0);
                }
                _$_RunAndBlock$_(s) {
                    const i = this._$_conditions$_;
                    for (let t = 0, e = i.length; t < e; ++t) {
                        const r = i[t], n = (s._$SetConditionIndex$_(t), r._$Run$_());
                        if (!n) return void s._$SetLastEventTrue$_(!1);
                    }
                    s._$SetLastEventTrue$_(!0), this._$_RunActions$_(s, 0) && this._$_RunSubEvents$_(s), 
                    s._$GetLastEventTrue$_() && this._$_hasElseBlock$_ && s._$SetElseBranchRan$_(!0);
                }
                *_$_DebugRunAndBlock$_(s) {
                    const i = this._$_conditions$_;
                    for (let t = 0, e = i.length; t < e; ++t) {
                        const r = i[t];
                        s._$SetConditionIndex$_(t);
                        if (!(r._$DebugCanRunFast$_() ? r._$Run$_() : yield* r._$DebugRun$_())) return void s._$SetLastEventTrue$_(!1);
                    }
                    s._$SetLastEventTrue$_(!0);
                    (this._$DebugCanRunActionsFast$_() ? this._$_RunActions$_(s, 0) : yield* this._$_DebugRunActions$_(s, 0)) && (this._$DebugCanRunSubEventsFast$_() ? this._$_RunSubEvents$_() : yield* this._$_DebugRunSubEvents$_()), 
                    s._$GetLastEventTrue$_() && this._$_hasElseBlock$_ && s._$SetElseBranchRan$_(!0);
                }
                _$_RunActions_Fast$_(s, i) {
                    const r = this._$_actions$_;
                    for (let t = i, e = r.length; t < e; ++t) {
                        const n = r[t];
                        s._$SetActionIndex$_(t), n._$Run$_();
                    }
                    return !0;
                }
                *_$_DebugRunActions_Fast$_(s, i) {
                    const r = this._$_actions$_;
                    for (let t = i, e = r.length; t < e; ++t) {
                        const n = r[t];
                        s._$SetActionIndex$_(t), n._$DebugCanRunFast$_() ? n._$Run$_() : yield* n._$DebugRun$_();
                    }
                    return !0;
                }
                _$_RunActions_ReturnValue$_(s, i) {
                    const r = this._$GetEventSheetManager$_(), n = this._$_actions$_;
                    for (let t = i, e = n.length; t < e; ++t) {
                        const h = n[t], o = (s._$SetActionIndex$_(t), h._$Run$_());
                        if (h._$CanBailOut$_() && !0 === o) return !1;
                        h._$IsAsync$_() && o instanceof Promise && r._$AddAsyncActionPromise$_(o);
                    }
                    return !0;
                }
                *_$_DebugRunActions_ReturnValue$_(s, i) {
                    const r = this._$GetEventSheetManager$_(), n = this._$_actions$_;
                    for (let e = i, t = n.length; e < t; ++e) {
                        const h = n[e];
                        s._$SetActionIndex$_(e);
                        let t;
                        if (t = h._$DebugCanRunFast$_() ? h._$Run$_() : yield* h._$DebugRun$_(), 
                        h._$CanBailOut$_() && !0 === t) return !1;
                        h._$IsAsync$_() && t instanceof Promise && r._$AddAsyncActionPromise$_(t);
                    }
                    return !0;
                }
                _$_ResumeActionsAndSubEvents$_(t) {
                    this._$_RunActions$_(t, t._$GetActionIndex$_()) && this._$_RunSubEvents$_();
                }
                *_$_DebugResumeActionsAndSubEvents$_(t) {
                    (yield* this._$_DebugRunActions$_(t, t._$GetActionIndex$_())) && (yield* this._$_DebugRunSubEvents$_());
                }
                _$_RunSubEvents$_() {
                    if (this._$_subEvents$_.length) {
                        const t = this._$IsGroup$_() && this._$_runtime$_._$IsCPUProfiling$_(), e = t ? performance.now() : 0, s = this._$_eventStack$_, i = s._$Push$_(this);
                        this._$_isSolWriterAfterCnds$_ ? this._$_RunSubEvents_SolWriterAfterCnds$_(i) : this._$_RunSubEvents_Fast$_(i), 
                        s._$Pop$_(), t && (this._$_perfRecord$_._$totalTimeCounter$_ += performance.now() - e);
                    }
                }
                _$_RunSubEvents_SolWriterAfterCnds$_(i) {
                    const r = this._$_isGroup$_, n = this._$_isTopLevelGroup$_, h = this._$GetEventSheetManager$_(), o = this._$_subEvents$_;
                    for (let t = 0, e = o.length, s = e - 1; t < e; ++t) {
                        const a = o[t], l = a._$GetSolModifiers$_(), u = !n || !r && t < s;
                        u && h._$PushCopySol$_(l), a._$Run$_(i), u ? h._$PopSol$_(l) : h._$ClearSol$_(l);
                    }
                }
                _$_RunSubEvents_Fast$_(s) {
                    const i = this._$_subEvents$_;
                    for (let t = 0, e = i.length; t < e; ++t) i[t]._$Run$_(s);
                }
                *_$_DebugRunSubEvents$_() {
                    if (this._$_subEvents$_.length) {
                        const t = this._$_eventStack$_, e = t._$Push$_(this);
                        this._$_isSolWriterAfterCnds$_ ? yield* this._$_DebugRunSubEvents_SolWriterAfterCnds$_(e) : yield* this._$_DebugRunSubEvents_Fast$_(e), 
                        t._$Pop$_();
                    }
                }
                *_$_DebugRunSubEvents_SolWriterAfterCnds$_(i) {
                    const r = this._$_isGroup$_, n = this._$_isTopLevelGroup$_, h = this._$GetEventSheetManager$_(), o = this._$_subEvents$_;
                    for (let t = 0, e = o.length, s = e - 1; t < e; ++t) {
                        const a = o[t], l = a._$GetSolModifiers$_(), u = !n || !r && t < s;
                        u && h._$PushCopySol$_(l), yield* a._$DebugRun$_(i), u ? h._$PopSol$_(l) : h._$ClearSol$_(l);
                    }
                }
                *_$_DebugRunSubEvents_Fast$_(s) {
                    const i = this._$_subEvents$_;
                    for (let t = 0, e = i.length; t < e; ++t) yield* i[t]._$DebugRun$_(s);
                }
                _$Retrigger$_(s, i) {
                    i._$ResetQuick$_();
                    const r = this._$_conditions$_;
                    if (!this._$IsOrBlock$_()) for (let t = s._$GetConditionIndex$_() + 1, e = r.length; t < e; ++t) {
                        const n = r[t], h = (i._$SetConditionIndex$_(t), n._$Run$_());
                        if (!h) return !1;
                    }
                    return this._$_RunActions$_(i, 0) && this._$_RunSubEvents$_(i), 
                    !0;
                }
                *_$DebugRetrigger$_(s, i) {
                    i._$ResetQuick$_();
                    const r = this._$_conditions$_;
                    if (!this._$IsOrBlock$_()) for (let t = s._$GetConditionIndex$_() + 1, e = r.length; t < e; ++t) {
                        const n = r[t];
                        i._$SetConditionIndex$_(t);
                        if (!(n._$DebugCanRunFast$_() ? n._$Run$_() : yield* n._$DebugRun$_())) return !1;
                    }
                    return (this._$DebugCanRunActionsFast$_() ? this._$_RunActions$_(i, 0) : yield* this._$_DebugRunActions$_(i, 0)) && (this._$DebugCanRunSubEventsFast$_() ? this._$_RunSubEvents$_() : yield* this._$_DebugRunSubEvents$_()), 
                    !0;
                }
                _$DebugCanRunFast$_() {
                    return !this._$IsDebugBreakpoint$_() && !this._$_runtime$_._$DebugBreakNext$_() && this._$_debugData$_._$canRunSelfFast$_;
                }
                _$DebugCanRunActionsFast$_() {
                    return !this._$_runtime$_._$DebugBreakNext$_() && this._$_debugData$_._$canRunAllActionsFast$_;
                }
                _$DebugCanRunSubEventsFast$_() {
                    return !this._$_runtime$_._$DebugBreakNext$_() && this._$_debugData$_._$canRunAllSubEventsFast$_;
                }
                _$_CheckParentsOKToRun$_(s) {
                    if (this._$GetParent$_()) {
                        const i = this._$GetTriggerParents$_();
                        for (let t = 0, e = i.length; t < e; ++t) if (!i[t]._$RunPreTrigger$_(s)) return !1;
                    }
                    return !0;
                }
                *_$_DebugCheckParentsOKToRun$_(s) {
                    if (this._$GetParent$_()) {
                        const i = this._$GetTriggerParents$_();
                        for (let t = 0, e = i.length; t < e; ++t) if (!(yield* i[t]._$DebugRunPreTrigger$_(s))) return !1;
                    }
                    return !0;
                }
                _$_EvaluateFunctionCallParameters$_(t, e, s) {
                    if (0 < e.length) if (s) {
                        const i = e.map(t => t._$Get$_(0));
                        t._$GetLocalVarStack$_()._$Push$_(), this._$_scopeParent$_._$SetFunctionParameters$_(i);
                    } else this._$_scopeParent$_._$EvaluateFunctionParameters$_(e); else s && t._$GetLocalVarStack$_()._$Push$_();
                }
                _$RunAsFunctionCall$_(t, e, s, i) {
                    let r, n, h = 0 < t.length, o = null, a = this._$_runtime$_, l = this._$_eventStack$_, u = a._$GetEventSheetManager$_(), c = this._$_scopeParent$_, f = c._$IsAsync$_(), d = u._$_IncTriggerDepth$_(), p = 1 < d;
                    if (this._$_EvaluateFunctionCallParameters$_(u, e, p), h && (s ? u._$PushCopySol$_(t) : u._$PushCleanSol$_(t)), 
                    null !== i) {
                        if (i._$copyFromObjectClass$_) {
                            const C = s ? i._$copyFromObjectClass$_._$GetCurrentSol$_() : i._$copyFromObjectClass$_._$GetSolStack$_()._$GetOneBelowCurrentSol$_(), g = i._$copyToObjectClass$_._$GetCurrentSol$_();
                            g._$SetArrayPicked$_(C._$GetInstances$_()), g._$ClearElseInstances$_(), 
                            s || i._$copyToObjectClass$_._$ApplySolToContainer$_();
                        } else if (i._$pickObjectClass$_) {
                            const S = i._$pickObjectClass$_._$GetCurrentSol$_();
                            S._$SetArrayPicked$_(i._$pickInstances$_), S._$ClearElseInstances$_();
                        }
                        i._$pushCleanSolDynamic$_ && (o = u._$PushCleanSolDynamic$_(t));
                    }
                    const m = l._$Push$_(this);
                    return s && m._$SetDynamicSolModifiers$_(t), this._$_CheckParentsOKToRun$_(m) && (m._$SetCurrentEvent$_(this), 
                    f && ([ n, r ] = c._$StartAsyncFunctionCall$_()), this._$_RunAndBlock$_(m), 
                    f) && c._$MaybeFinishAsyncFunctionCall$_(n), l._$Pop$_(), p && u._$GetLocalVarStack$_()._$Pop$_(), 
                    null !== o && u._$PopSol$_(o), h && u._$PopSol$_(t), u._$_DecTriggerDepth$_(), 
                    f || u._$ClearNestedAsyncActionPromises$_(), r;
                }
                *_$DebugRunAsFunctionCall$_(t, e, s, i) {
                    let r, n, h = ((this._$IsDebugBreakpoint$_() || this._$_runtime$_._$DebugBreakNext$_()) && (yield this), 
                    0 < t.length), o = null, a = this._$_runtime$_, l = this._$_eventStack$_, u = a._$GetEventSheetManager$_(), c = this._$_scopeParent$_, f = c._$IsAsync$_(), d = u._$_IncTriggerDepth$_(), p = 1 < d;
                    if (this._$_EvaluateFunctionCallParameters$_(u, e, p), h && (s ? u._$PushCopySol$_(t) : u._$PushCleanSol$_(t)), 
                    null !== i) {
                        if (i._$copyFromObjectClass$_) {
                            const C = s ? i._$copyFromObjectClass$_._$GetCurrentSol$_() : i._$copyFromObjectClass$_._$GetSolStack$_()._$GetOneBelowCurrentSol$_(), g = i._$copyToObjectClass$_._$GetCurrentSol$_();
                            g._$SetArrayPicked$_(C._$GetInstances$_()), g._$ClearElseInstances$_(), 
                            s || i._$copyToObjectClass$_._$ApplySolToContainer$_();
                        } else if (i._$pickObjectClass$_) {
                            const S = i._$pickObjectClass$_._$GetCurrentSol$_();
                            S._$SetArrayPicked$_(i._$pickInstances$_), S._$ClearElseInstances$_();
                        }
                        i._$pushCleanSolDynamic$_ && (o = u._$PushCleanSolDynamic$_(t));
                    }
                    const m = l._$Push$_(this);
                    return s && m._$SetDynamicSolModifiers$_(t), (yield* this._$_DebugCheckParentsOKToRun$_(m)) && (m._$SetCurrentEvent$_(this), 
                    f && ([ n, r ] = c._$StartAsyncFunctionCall$_()), yield* this._$_DebugRunAndBlock$_(m), 
                    f) && c._$MaybeFinishAsyncFunctionCall$_(n), l._$Pop$_(), p && u._$GetLocalVarStack$_()._$Pop$_(), 
                    null !== o && u._$PopSol$_(o), h && u._$PopSol$_(t), u._$_DecTriggerDepth$_(), 
                    f || u._$ClearNestedAsyncActionPromises$_(), r;
                }
                _$RunAsMappedFunctionCall$_(t, e) {
                    const s = this._$GetSolModifiersIncludingParents$_(), i = 0 < s.length, r = this._$_runtime$_, n = this._$_eventStack$_, h = r._$GetEventSheetManager$_(), o = h._$_IncTriggerDepth$_(), a = 1 < o, l = (a && h._$GetLocalVarStack$_()._$Push$_(), 
                    this._$_scopeParent$_._$SetFunctionParameters$_(t), i && (e ? h._$PushCopySol$_(s) : h._$PushCleanSol$_(s)), 
                    n._$Push$_(this));
                    this._$_CheckParentsOKToRun$_(l) && (l._$SetCurrentEvent$_(this), 
                    this._$_RunAndBlock$_(l)), n._$Pop$_(), a && h._$GetLocalVarStack$_()._$Pop$_(), 
                    i && h._$PopSol$_(s), h._$_DecTriggerDepth$_(), h._$ClearNestedAsyncActionPromises$_();
                }
                *_$DebugRunAsMappedFunctionCall$_(t, e) {
                    (this._$IsDebugBreakpoint$_() || this._$_runtime$_._$DebugBreakNext$_()) && (yield this);
                    const s = this._$GetSolModifiersIncludingParents$_(), i = 0 < s.length, r = this._$_runtime$_, n = this._$_eventStack$_, h = r._$GetEventSheetManager$_(), o = h._$_IncTriggerDepth$_(), a = 1 < o, l = (a && h._$GetLocalVarStack$_()._$Push$_(), 
                    this._$_scopeParent$_._$SetFunctionParameters$_(t), i && (e ? h._$PushCopySol$_(s) : h._$PushCleanSol$_(s)), 
                    n._$Push$_(this));
                    (yield* this._$_DebugCheckParentsOKToRun$_(l)) && (l._$SetCurrentEvent$_(this), 
                    yield* this._$_DebugRunAndBlock$_(l)), n._$Pop$_(), a && h._$GetLocalVarStack$_()._$Pop$_(), 
                    i && h._$PopSol$_(s), h._$_DecTriggerDepth$_(), h._$ClearNestedAsyncActionPromises$_();
                }
                _$RunAsExpressionFunctionCall$_(t, e, s, i, ...r) {
                    let n, h, o = 0 < t.length, a = this._$_runtime$_, l = this._$_eventStack$_, u = a._$GetEventSheetManager$_(), c = this._$_scopeParent$_, f = c._$IsAsync$_(), d = u._$_IncTriggerDepth$_(), p = 1 < d, m = (p && u._$GetLocalVarStack$_()._$Push$_(), 
                    0 < r.length && this._$_scopeParent$_._$SetFunctionParameters$_(r), 
                    o && (e ? u._$PushCopySol$_(t) : u._$PushCleanSol$_(t)), l._$Push$_(this));
                    return m._$InitCallFunctionExpression$_(s, i), l._$PushExpFunc$_(m), 
                    a._$SetDebuggingEnabled$_(!1), this._$_CheckParentsOKToRun$_(m) && (m._$SetCurrentEvent$_(this), 
                    f && ([ h, n ] = c._$StartAsyncFunctionCall$_()), this._$_RunAndBlock$_(m), 
                    f) && c._$MaybeFinishAsyncFunctionCall$_(h), a._$SetDebuggingEnabled$_(!0), 
                    l._$Pop$_(), l._$PopExpFunc$_(), p && u._$GetLocalVarStack$_()._$Pop$_(), 
                    o && u._$PopSol$_(t), u._$_DecTriggerDepth$_(), f || u._$ClearNestedAsyncActionPromises$_(), 
                    n || m._$GetFunctionReturnValue$_();
                }
            };
        }
        {
            let C33 = self._$C3$_, EMPTY_SOL_MODIFIERS = [], hadUserScriptException = !1;
            C33._$EventScript$_ = class extends C33._$DefendedBase$_ {
                constructor(t, e, s) {
                    super();
                    const i = t._$GetRuntime$_(), r = t._$GetEventSheetManager$_(), n = (this._$_eventSheet$_ = t, 
                    this._$_eventSheetManager$_ = r, this._$_runtime$_ = t._$GetRuntime$_(), 
                    this._$_parent$_ = e, i._$GetObjectReference$_(s[1]));
                    this._$_func$_ = n, this._$_displayNumber$_ = s[2], this._$_eventSheet$_._$_RegisterEventByDisplayNumber$_(this, this._$_displayNumber$_), 
                    this._$_debugData$_ = i._$IsDebug$_() ? {
                        _$isBreakpoint$_: s[3][0],
                        _$isBreakable$_: s[3][1]
                    } : null;
                }
                static _$Create$_(t, e, s) {
                    return C33._$New$_(C33._$EventScript$_, t, e, s);
                }
                _$_PostInit$_() {
                    const t = this._$_func$_, e = this._$_runtime$_._$GetEventSheetManager$_()._$_GetLocalVariablesScriptInterface$_(this);
                    this._$_func$_ = t.bind(null, this._$_runtime$_._$GetIRuntime$_(), e);
                }
                _$GetParent$_() {
                    return this._$_parent$_;
                }
                _$GetScopeParent$_() {
                    return this._$_parent$_;
                }
                _$GetEventSheet$_() {
                    return this._$_eventSheet$_;
                }
                _$GetDisplayNumber$_() {
                    return this._$_displayNumber$_;
                }
                _$IsDebugBreakable$_() {
                    return this._$_debugData$_ && this._$_debugData$_._$isBreakable$_;
                }
                _$IsDebugBreakpoint$_() {
                    return this._$IsDebugBreakable$_() && this._$_debugData$_._$isBreakpoint$_;
                }
                _$_SetDebugBreakpoint$_(t) {
                    this._$_debugData$_._$isBreakpoint$_ = !!t;
                }
                _$IsElseBlock$_() {
                    return !1;
                }
                _$GetSolModifiers$_() {
                    return EMPTY_SOL_MODIFIERS;
                }
                _$GetSolModifiersIncludingParents$_() {
                    return this._$_parent$_ ? this._$_parent$_._$GetSolModifiersIncludingParents$_() : EMPTY_SOL_MODIFIERS;
                }
                _$Run$_(t) {
                    t._$SetCurrentEvent$_(this), this._$_eventSheetManager$_._$AddAsyncActionPromise$_(this._$_RunUserScript$_());
                }
                async _$_RunUserScript$_() {
                    try {
                        await this._$_func$_();
                    } catch (t) {
                        console.error(`Unhandled exception running script %c${this._$GetEventSheet$_()._$GetName$_()}, event ${this._$GetDisplayNumber$_()}:`, "font-size: 1.2em; font-weight: bold;", t), 
                        self.C3Debugger && self.C3Debugger._SetLastErrorScript(this), 
                        hadUserScriptException || (console.info("%cTip:%c run this to highlight in Construct the last script that had an error: %cgoToLastErrorScript()", "font-weight: bold; text-decoration: underline", "", "font-weight: bold"), 
                        hadUserScriptException = !0);
                    }
                }
                *_$DebugRun$_(t) {
                    t._$SetCurrentEvent$_(this), (this._$IsDebugBreakpoint$_() || this._$_runtime$_._$DebugBreakNext$_()) && (yield this), 
                    this._$Run$_(t);
                }
                _$DebugCanRunFast$_() {
                    return !this._$IsDebugBreakpoint$_() && !this._$_runtime$_._$DebugBreakNext$_();
                }
                static _$HadUserScriptException$_() {
                    return hadUserScriptException;
                }
                static _$SetHadUserScriptException$_() {
                    hadUserScriptException = !0;
                }
            };
        }
        {
            const C33 = self._$C3$_, assert = self.assert;
            C33._$FunctionBlock$_ = class extends C33._$DefendedBase$_ {
                constructor(t, e, s) {
                    super(), this._$_eventSheet$_ = t, this._$_runtime$_ = t._$GetRuntime$_(), 
                    this._$_parent$_ = e, this._$_functionType$_ = 0, this._$_functionName$_ = "", 
                    this._$_returnType$_ = 0, this._$_functionParameters$_ = [], 
                    this._$_isEnabled$_ = !0, this._$_aceName$_ = "", this._$_objectClass$_ = null, 
                    this._$_hasOverrides$_ = !1, this._$_innerLocalVariables$_ = [], 
                    this._$_isCopyPicked$_ = !1, this._$_isAsync$_ = !1, this._$_nextAsyncId$_ = 0, 
                    this._$_currentAsyncId$_ = -1, this._$_asyncMap$_ = new Map(), 
                    this._$_eventBlock$_ = C33._$EventBlock$_._$Create$_(t, e, s), 
                    this._$_eventBlock$_._$_SetScopeParent$_(this);
                }
                _$InitFunctionBlock$_(t) {
                    this._$_functionType$_ = 0, this._$_functionName$_ = t[0], this._$_returnType$_ = t[1], 
                    this._$_functionParameters$_ = t[2].map(t => C33._$EventVariable$_._$Create$_(this._$_eventSheet$_, this, t)), 
                    this._$_isEnabled$_ = t[3], this._$_isAsync$_ = t[4], this._$_isCopyPicked$_ = t[5];
                }
                _$InitCustomACEBlock$_(t) {
                    this._$_functionType$_ = 1, this._$_aceName$_ = t[1], this._$_objectClass$_ = this._$_runtime$_._$GetObjectClassByIndex$_(t[2]), 
                    this._$_eventBlock$_._$_AddSolModifier$_(this._$_objectClass$_), 
                    this._$_functionName$_ = this._$_objectClass$_._$GetName$_() + "." + this._$_aceName$_, 
                    this._$_returnType$_ = t[3], this._$_functionParameters$_ = t[4].map(t => C33._$EventVariable$_._$Create$_(this._$_eventSheet$_, this, t)), 
                    this._$_isEnabled$_ = t[5], this._$_isAsync$_ = t[6], this._$_isCopyPicked$_ = t[7], 
                    this._$_objectClass$_._$AddCustomAction$_(this);
                }
                static _$CreateFunctionBlock$_(t, e, s) {
                    const i = C33._$New$_(C33._$FunctionBlock$_, t, e, s), r = s[1];
                    return i._$InitFunctionBlock$_(r), i;
                }
                static _$CreateCustomACEBlock$_(t, e, s) {
                    const i = C33._$New$_(C33._$FunctionBlock$_, t, e, s), r = s[1];
                    return i._$InitCustomACEBlock$_(r), i;
                }
                _$_CheckOverrideState$_() {
                    if (this._$_objectClass$_ && this._$_objectClass$_._$IsFamily$_()) for (const t of this._$_objectClass$_._$GetFamilyMembers$_()) if (t._$HasOwnCustomActionByName$_(this._$_aceName$_)) {
                        this._$_hasOverrides$_ = !0;
                        break;
                    }
                }
                _$_PostInit$_() {
                    for (const t of this._$_functionParameters$_) t._$_PostInit$_();
                    this._$_eventBlock$_._$_PostInit$_(!1);
                }
                _$GetFunctionType$_() {
                    return this._$_functionType$_;
                }
                _$_GetAllLocalVariablesInScope$_() {
                    return this._$_functionParameters$_;
                }
                _$GetFunctionParameters$_() {
                    return this._$_functionParameters$_;
                }
                _$GetFunctionParameterCount$_() {
                    return this._$_functionParameters$_.length;
                }
                _$_RegisterLocalVariable$_(t) {
                    this._$_innerLocalVariables$_.push(t);
                }
                _$_GetAllInnerLocalVariables$_() {
                    return this._$_innerLocalVariables$_;
                }
                _$EvaluateFunctionParameters$_(s) {
                    const i = this._$_functionParameters$_;
                    for (let t = 0, e = i.length; t < e; ++t) i[t]._$SetValue$_(s[t]._$Get$_(0));
                }
                _$SetFunctionParameters$_(s) {
                    const i = this._$_functionParameters$_;
                    for (let t = 0, e = i.length; t < e; ++t) i[t]._$SetValue$_(s[t]);
                }
                _$CaptureFunctionParameters$_() {
                    return this._$_functionParameters$_.map(t => t._$GetValue$_());
                }
                _$GetParent$_() {
                    return this._$_parent$_;
                }
                _$GetScopeParent$_() {
                    return this._$_parent$_;
                }
                _$GetFunctionName$_() {
                    return this._$_functionName$_;
                }
                _$GetACEName$_() {
                    return this._$_aceName$_;
                }
                _$HasCustomACEOverrides$_() {
                    return this._$_hasOverrides$_;
                }
                _$GetReturnType$_() {
                    return this._$_returnType$_;
                }
                _$GetObjectClass$_() {
                    return this._$_objectClass$_;
                }
                _$IsEnabled$_() {
                    return this._$_isEnabled$_;
                }
                _$GetDefaultReturnValue$_() {
                    switch (this._$_returnType$_) {
                      case 0:
                        return null;

                      case 2:
                        return "";

                      default:
                        return 0;
                    }
                }
                _$GetEventBlock$_() {
                    return this._$_eventBlock$_;
                }
                _$IsCopyPicked$_() {
                    return this._$_isCopyPicked$_;
                }
                _$IsAsync$_() {
                    return this._$_isAsync$_;
                }
                _$StartAsyncFunctionCall$_() {
                    const t = this._$_nextAsyncId$_++;
                    this._$_currentAsyncId$_ = t;
                    let e, s = new Promise(t => e = t);
                    return this._$_asyncMap$_.set(t, {
                        resolve: e,
                        _$pauseCount$_: 0
                    }), [ t, s ];
                }
                _$MaybeFinishAsyncFunctionCall$_(t) {
                    const e = this._$_asyncMap$_.get(t);
                    0 === e._$pauseCount$_ && (e.resolve(), this._$_asyncMap$_.delete(t)), 
                    this._$_currentAsyncId$_ = -1;
                }
                _$PauseCurrentAsyncFunction$_() {
                    const t = this._$_asyncMap$_.get(this._$_currentAsyncId$_);
                    return t._$pauseCount$_++, this._$_currentAsyncId$_;
                }
                _$ResumeAsyncFunction$_(t) {
                    this._$_currentAsyncId$_ = t;
                    const e = this._$_asyncMap$_.get(t);
                    e._$pauseCount$_--;
                }
                _$RunAsFamilyCustomActionWithOverrides$_(t, e) {
                    const s = new Map(), i = [];
                    for (const r of this._$_objectClass$_._$GetCurrentSol$_()._$GetInstances$_()) {
                        const n = r._$GetObjectClass$_();
                        if (n._$HasOwnCustomActionByName$_(this._$_aceName$_)) {
                            const h = s.get(n);
                            Array.isArray(h) ? h.push(r) : s.set(n, [ r ]);
                        } else i.push(r);
                    }
                    if (0 < i.length && this._$_eventBlock$_._$RunAsFunctionCall$_(t, e, this._$_isCopyPicked$_, {
                        _$pickObjectClass$_: this._$_objectClass$_,
                        _$pickInstances$_: i
                    }), 0 < s.size) for (const [ o, a ] of s) {
                        const l = o._$GetOwnCustomActionByName$_(this._$_aceName$_)._$GetEventBlock$_(), u = [ ...new Set([ ...t, ...l._$GetSolModifiers$_() ]) ];
                        l._$RunAsFunctionCall$_(u, e, this._$_isCopyPicked$_, {
                            _$pickObjectClass$_: o,
                            _$pickInstances$_: a
                        });
                    }
                }
                *_$DebugRunAsFamilyCustomActionWithOverrides$_(t, e) {
                    const s = new Map(), i = [];
                    for (const r of this._$_objectClass$_._$GetCurrentSol$_()._$GetInstances$_()) {
                        const n = r._$GetObjectClass$_();
                        if (n._$HasOwnCustomActionByName$_(this._$_aceName$_)) {
                            const h = s.get(n);
                            Array.isArray(h) ? h.push(r) : s.set(n, [ r ]);
                        } else i.push(r);
                    }
                    if (0 < i.length && (yield* this._$_eventBlock$_._$DebugRunAsFunctionCall$_(t, e, this._$_isCopyPicked$_, {
                        _$pickObjectClass$_: this._$_objectClass$_,
                        _$pickInstances$_: i
                    })), 0 < s.size) for (const [ o, a ] of s) {
                        const l = o._$GetOwnCustomActionByName$_(this._$_aceName$_)._$GetEventBlock$_(), u = [ ...new Set([ ...t, ...l._$GetSolModifiers$_() ]) ];
                        yield* l._$DebugRunAsFunctionCall$_(u, e, this._$_isCopyPicked$_, {
                            _$pickObjectClass$_: o,
                            _$pickInstances$_: a
                        });
                    }
                }
            };
        }
        {
            const C33 = self._$C3$_, EMPTY_SOL_MODIFIERS = [];
            C33._$EventVariable$_ = class extends C33._$DefendedBase$_ {
                constructor(t, e, s) {
                    super();
                    const i = t._$GetEventSheetManager$_();
                    this._$_eventSheet$_ = t, this._$_eventSheetManager$_ = i, this._$_runtime$_ = t._$GetRuntime$_(), 
                    this._$_parent$_ = e, this._$_localVarStack$_ = i._$GetLocalVarStack$_(), 
                    this._$_name$_ = s[1], this._$_type$_ = s[2], this._$_initialValue$_ = s[3], 
                    this._$_isStatic$_ = !!s[4], this._$_isConstant$_ = !!s[5], 
                    this._$_isFunctionParameter$_ = e instanceof C33._$FunctionBlock$_, 
                    this._$_sid$_ = s[6], this._$_jsPropName$_ = this._$_runtime$_._$GetJsPropName$_(s[8]), 
                    this._$_scriptSetter$_ = t => this._$SetValue$_(t), this._$_scriptGetter$_ = () => this._$GetValue$_(), 
                    this._$_hasSingleValue$_ = !this._$_parent$_ || this._$_isStatic$_ || this._$_isConstant$_, 
                    this._$_value$_ = this._$_initialValue$_, this._$_localIndex$_ = -1, 
                    this._$IsBoolean$_() && (this._$_value$_ = this._$_value$_ ? 1 : 0), 
                    !this._$IsLocal$_() || this._$IsStatic$_() || this._$IsConstant$_() || (this._$_localIndex$_ = i._$_GetNextLocalVarIndex$_(this)), 
                    i._$_RegisterEventVariable$_(this);
                }
                static _$Create$_(t, e, s) {
                    return C33._$New$_(C33._$EventVariable$_, t, e, s);
                }
                _$_PostInit$_() {
                    if (this._$IsLocal$_() && !this._$IsStatic$_() && !this._$IsConstant$_() && !this._$IsFunctionParameter$_()) {
                        const t = this._$_eventSheetManager$_._$FindFirstFunctionBlockParent$_(this);
                        t && t._$_RegisterLocalVariable$_(this);
                    }
                }
                _$GetName$_() {
                    return this._$_name$_;
                }
                _$GetJsPropName$_() {
                    return this._$_jsPropName$_;
                }
                _$GetParent$_() {
                    return this._$_parent$_;
                }
                _$GetScopeParent$_() {
                    return this._$GetParent$_();
                }
                _$IsGlobal$_() {
                    return !this._$GetParent$_();
                }
                _$IsLocal$_() {
                    return !this._$IsGlobal$_();
                }
                _$IsFunctionParameter$_() {
                    return this._$_isFunctionParameter$_;
                }
                _$IsStatic$_() {
                    return this._$_isStatic$_;
                }
                _$IsConstant$_() {
                    return this._$_isConstant$_;
                }
                _$IsNumber$_() {
                    return 0 === this._$_type$_;
                }
                _$IsString$_() {
                    return 1 === this._$_type$_;
                }
                _$IsBoolean$_() {
                    return 2 === this._$_type$_;
                }
                _$IsElseBlock$_() {
                    return !1;
                }
                _$GetSID$_() {
                    return this._$_sid$_;
                }
                _$GetInitialValue$_() {
                    return this._$_initialValue$_;
                }
                _$GetSolModifiers$_() {
                    return EMPTY_SOL_MODIFIERS;
                }
                _$Run$_(t) {
                    !this._$IsLocal$_() || this._$IsStatic$_() || this._$IsConstant$_() || this._$SetValue$_(this._$GetInitialValue$_());
                }
                _$DebugCanRunFast$_() {
                    return !0;
                }
                *_$DebugRun$_(t) {
                    this._$Run$_(t);
                }
                _$SetValue$_(t) {
                    this._$IsNumber$_() ? "number" != typeof t && (t = parseFloat(t)) : this._$IsString$_() ? "string" != typeof t && (t = t.toString()) : this._$IsBoolean$_() && (t = t ? 1 : 0), 
                    this._$_hasSingleValue$_ ? this._$_value$_ = t : this._$_localVarStack$_._$GetCurrent$_()[this._$_localIndex$_] = t;
                }
                _$GetValue$_() {
                    return this._$_hasSingleValue$_ ? this._$_value$_ : this._$_localVarStack$_._$GetCurrent$_()[this._$_localIndex$_];
                }
                _$GetTypedValue$_() {
                    let t = this._$GetValue$_();
                    return this._$IsBoolean$_() ? !!t : t;
                }
                _$ResetToInitialValue$_() {
                    this._$_value$_ = this._$_initialValue$_;
                }
                _$_GetScriptInterfaceDescriptor$_() {
                    return {
                        configurable: !1,
                        enumerable: !0,
                        get: this._$_scriptGetter$_,
                        set: this._$_scriptSetter$_
                    };
                }
            };
        }
        {
            const C33 = self._$C3$_, assert = self.assert, EMPTY_SOL_MODIFIERS = [];
            C33._$EventInclude$_ = class extends C33._$DefendedBase$_ {
                constructor(t, e, s) {
                    super();
                    const i = t._$GetEventSheetManager$_();
                    this._$_eventSheet$_ = t, this._$_eventSheetManager$_ = i, this._$_runtime$_ = t._$GetRuntime$_(), 
                    this._$_parent$_ = e, this._$_includeSheet$_ = null, this._$_includeSheetName$_ = s[1], 
                    this._$_isActive$_ = !0;
                }
                static _$Create$_(t, e, s) {
                    return C33._$New$_(C33._$EventInclude$_, t, e, s);
                }
                _$_PostInit$_() {
                    this._$_includeSheet$_ = this._$_eventSheetManager$_._$GetEventSheetByName$_(this._$_includeSheetName$_), 
                    this._$_eventSheet$_._$_AddShallowInclude$_(this);
                    let t = this._$GetParent$_();
                    for (;t; ) t instanceof C33._$EventBlock$_ && t._$IsGroup$_() && t._$_AddContainedInclude$_(this), 
                    t = t._$GetParent$_();
                    this._$UpdateActive$_(), this._$_runtime$_._$IsDebug$_() && this._$_eventSheet$_._$_GetPerfRecord$_().children.push(this._$_includeSheet$_._$_GetPerfRecord$_());
                }
                _$GetParent$_() {
                    return this._$_parent$_;
                }
                _$GetSolModifiers$_() {
                    return EMPTY_SOL_MODIFIERS;
                }
                _$GetIncludeSheet$_() {
                    return this._$_includeSheet$_;
                }
                _$Run$_(t) {
                    const e = !!this._$GetParent$_(), s = this._$_runtime$_._$GetAllObjectClasses$_();
                    e && this._$_eventSheetManager$_._$PushCleanSol$_(s), this._$_includeSheet$_._$Run$_(), 
                    e && this._$_eventSheetManager$_._$PopSol$_(s);
                }
                *_$DebugRun$_(t) {
                    const e = !!this._$GetParent$_(), s = this._$_runtime$_._$GetAllObjectClasses$_();
                    e && this._$_eventSheetManager$_._$PushCleanSol$_(s), yield* this._$_includeSheet$_._$DebugRun$_(), 
                    e && this._$_eventSheetManager$_._$PopSol$_(s);
                }
                _$DebugCanRunFast$_() {
                    return !1;
                }
                _$IsActive$_() {
                    return this._$_isActive$_;
                }
                _$UpdateActive$_() {
                    let t = this._$GetParent$_();
                    for (;t; ) {
                        if (t instanceof C33._$EventBlock$_ && t._$IsGroup$_() && !t._$IsGroupActive$_()) return void (this._$_isActive$_ = !1);
                        t = t._$GetParent$_();
                    }
                    this._$_isActive$_ = !0;
                }
            };
        }
        {
            let WrapIndex2 = function(t, e) {
                return e <= t ? t % e : (t < 0 && (t <= -e && (t %= e), t < 0) && (t += e), 
                t);
            };
            WrapIndex = WrapIndex2;
            const C33 = self._$C3$_, assert = self.assert;
            C33._$ExpNode$_ = class extends C33._$DefendedBase$_ {
                constructor(t) {
                    super(), this._$_owner$_ = t, this._$_runtime$_ = t._$GetRuntime$_();
                }
                _$_PostInit$_() {}
                static _$CreateNode$_(t, e) {
                    const s = e[0], i = [ BehaviorExpressionNode, ObjectExpressionNode, InstVarExpressionNode, EventVarExpNode, SystemExpressionExpNode, CallFunctionExpressionExpNode ];
                    return C33._$New$_(i[s], t, e);
                }
            };
            class SystemExpressionExpNode extends C33._$ExpNode$_ {
                constructor(t, e) {
                    super(t), this._$_systemPlugin$_ = this._$_runtime$_._$GetSystemPlugin$_(), 
                    this._$_func$_ = this._$_runtime$_._$GetObjectReference$_(e[1]), 
                    this._$_func$_ !== C33._$Plugins$_._$System$_._$Exps$_.random && this._$_func$_ !== C33._$Plugins$_._$System$_._$Exps$_._$choose$_ || this._$_owner$_._$SetVariesPerInstance$_();
                }
                _$GetBoundMethod$_() {
                    return this._$_systemPlugin$_._$_GetBoundACEMethod$_(this._$_func$_, this._$_systemPlugin$_);
                }
            }
            class CallFunctionExpressionExpNode extends C33._$ExpNode$_ {
                constructor(t, e) {
                    super(t), this._$_functionBlock$_ = null, this._$_functionName$_ = e[1], 
                    this._$_owner$_._$SetVariesPerInstance$_();
                }
                _$_PostInit$_() {
                    const t = this._$_runtime$_._$GetEventSheetManager$_(), e = (this._$_functionBlock$_ = t._$GetFunctionBlockByName$_(this._$_functionName$_), 
                    this._$_functionName$_ = null, this._$_owner$_._$GetEventBlock$_()), s = this._$_functionBlock$_._$GetEventBlock$_();
                    this._$_combinedSolModifiers$_ = [ ...new Set([ ...e._$GetSolModifiersIncludingParents$_(), ...s._$GetSolModifiersIncludingParents$_() ]) ], 
                    this._$_combinedSolModifiers$_ = t._$_DeduplicateSolModifierList$_(this._$_combinedSolModifiers$_);
                }
                _$GetBoundMethod$_() {
                    const t = this._$_functionBlock$_;
                    if (t._$IsEnabled$_()) {
                        const e = t._$GetEventBlock$_();
                        return C33._$EventBlock$_.prototype._$RunAsExpressionFunctionCall$_.bind(e, this._$_combinedSolModifiers$_, t._$IsCopyPicked$_(), t._$GetReturnType$_(), t._$GetDefaultReturnValue$_());
                    }
                    {
                        const s = t._$GetDefaultReturnValue$_();
                        return () => s;
                    }
                }
            }
            class ObjectExpressionNode extends C33._$ExpNode$_ {
                constructor(t, e) {
                    super(t), this._$_objectClass$_ = this._$_runtime$_._$GetObjectClassByIndex$_(e[1]), 
                    this._$_func$_ = this._$_runtime$_._$GetObjectReference$_(e[2]), 
                    this._$_returnsString$_ = !!e[3], this._$_eventStack$_ = this._$_runtime$_._$GetEventSheetManager$_()._$GetEventStack$_(), 
                    this._$_owner$_._$_MaybeVaryFor$_(this._$_objectClass$_);
                }
                _$GetBoundMethod$_() {
                    return this._$_objectClass$_._$GetPlugin$_()._$_GetBoundACEMethod$_(this._$_func$_, this._$_objectClass$_._$GetSingleGlobalInstance$_()._$GetSdkInstance$_());
                }
                _$ExpObject$_(...t) {
                    const e = this._$_objectClass$_, s = e._$GetCurrentSol$_()._$GetExpressionInstances$_(), i = s.length;
                    if (0 === i) return this._$_returnsString$_ ? "" : 0;
                    const r = WrapIndex2(this._$_owner$_._$GetSolIndex$_(), i);
                    return this._$_eventStack$_._$GetCurrentStackFrame$_()._$SetExpressionObjectClass$_(e), 
                    this._$_func$_.apply(s[r]._$GetSdkInstance$_(), t);
                }
                _$ExpObject_InstExpr$_(t, ...e) {
                    const s = this._$_objectClass$_, i = s._$GetInstances$_(), r = i.length;
                    if (0 === r) return this._$_returnsString$_ ? "" : 0;
                    const n = WrapIndex2(t, r);
                    return this._$_eventStack$_._$GetCurrentStackFrame$_()._$SetExpressionObjectClass$_(s), 
                    this._$_func$_.apply(i[n]._$GetSdkInstance$_(), e);
                }
            }
            class InstVarExpressionNode extends C33._$ExpNode$_ {
                constructor(t, e) {
                    super(t), this._$_objectClass$_ = this._$_runtime$_._$GetObjectClassByIndex$_(e[1]), 
                    this._$_varIndex$_ = e[3], this._$_returnsString$_ = !!e[2], 
                    this._$_owner$_._$_MaybeVaryFor$_(this._$_objectClass$_);
                }
                _$ExpInstVar$_() {
                    const t = this._$_objectClass$_._$GetCurrentSol$_()._$GetExpressionInstances$_(), e = t.length;
                    if (0 === e) return this._$_returnsString$_ ? "" : 0;
                    const s = WrapIndex2(this._$_owner$_._$GetSolIndex$_(), e);
                    return t[s]._$_GetInstanceVariableValueUnchecked$_(this._$_varIndex$_);
                }
                _$ExpInstVar_Family$_() {
                    const t = this._$_objectClass$_, e = t._$GetCurrentSol$_()._$GetExpressionInstances$_(), s = e.length;
                    if (0 === s) return this._$_returnsString$_ ? "" : 0;
                    const i = WrapIndex2(this._$_owner$_._$GetSolIndex$_(), s), r = e[i], n = r._$GetObjectClass$_()._$GetFamilyInstanceVariableOffset$_(t._$GetFamilyIndex$_());
                    return r._$_GetInstanceVariableValueUnchecked$_(this._$_varIndex$_ + n);
                }
                _$ExpInstVar_InstExpr$_(t) {
                    const e = this._$_objectClass$_, s = e._$GetInstances$_(), i = s.length;
                    if (0 === i) return this._$_returnsString$_ ? "" : 0;
                    let r = WrapIndex2(t, i), n = s[r], h = 0;
                    return e._$IsFamily$_() && (h = n._$GetObjectClass$_()._$GetFamilyInstanceVariableOffset$_(e._$GetFamilyIndex$_())), 
                    n._$_GetInstanceVariableValueUnchecked$_(this._$_varIndex$_ + h);
                }
            }
            class BehaviorExpressionNode extends C33._$ExpNode$_ {
                constructor(t, e) {
                    super(t), this._$_objectClass$_ = this._$_runtime$_._$GetObjectClassByIndex$_(e[1]), 
                    this._$_behaviorType$_ = this._$_objectClass$_._$GetBehaviorTypeByName$_(e[2]), 
                    this._$_behaviorIndex$_ = this._$_objectClass$_._$GetBehaviorIndexByName$_(e[2]), 
                    this._$_func$_ = this._$_runtime$_._$GetObjectReference$_(e[3]), 
                    this._$_returnsString$_ = !!e[4], this._$_eventStack$_ = this._$_runtime$_._$GetEventSheetManager$_()._$GetEventStack$_(), 
                    this._$_owner$_._$_MaybeVaryFor$_(this._$_objectClass$_);
                }
                _$ExpBehavior$_(...t) {
                    const e = this._$_objectClass$_, s = e._$GetCurrentSol$_()._$GetExpressionInstances$_(), i = s.length;
                    if (0 === i) return this._$_returnsString$_ ? "" : 0;
                    let r = WrapIndex2(this._$_owner$_._$GetSolIndex$_(), i), n = (this._$_eventStack$_._$GetCurrentStackFrame$_()._$SetExpressionObjectClass$_(e), 
                    s[r]), h = 0;
                    return e._$IsFamily$_() && (h = n._$GetObjectClass$_()._$GetFamilyBehaviorOffset$_(e._$GetFamilyIndex$_())), 
                    this._$_func$_.apply(n._$GetBehaviorInstances$_()[this._$_behaviorIndex$_ + h]._$GetSdkInstance$_(), t);
                }
                _$ExpBehavior_InstExpr$_(t, ...e) {
                    const s = this._$_objectClass$_, i = s._$GetInstances$_(), r = i.length;
                    if (0 === r) return this._$_returnsString$_ ? "" : 0;
                    let n = WrapIndex2(t, r), h = (this._$_eventStack$_._$GetCurrentStackFrame$_()._$SetExpressionObjectClass$_(s), 
                    i[n]), o = 0;
                    return s._$IsFamily$_() && (o = h._$GetObjectClass$_()._$GetFamilyBehaviorOffset$_(s._$GetFamilyIndex$_())), 
                    this._$_func$_.apply(h._$GetBehaviorInstances$_()[this._$_behaviorIndex$_ + o]._$GetSdkInstance$_(), e);
                }
            }
            class EventVarExpNode extends C33._$ExpNode$_ {
                constructor(t, e) {
                    super(t), this._$_eventVar$_ = null, this._$_eventVarSid$_ = e[1];
                }
                _$_PostInit$_() {
                    this._$_eventVar$_ = this._$_runtime$_._$GetEventSheetManager$_()._$GetEventVariableBySID$_(this._$_eventVarSid$_);
                }
                _$GetVar$_() {
                    return this._$_eventVar$_;
                }
            }
        }
        {
            let GetExpressionFunc2 = function(t) {
                const e = self._$C3_ExpressionFuncs$_[t];
                if (e) return e;
                throw new Error("invalid expression number");
            };
            GetExpressionFunc = GetExpressionFunc2;
            const C33 = self._$C3$_, assert = self.assert;
            C33._$Parameter$_ = class extends C33._$DefendedBase$_ {
                constructor(t, e, s) {
                    super(), this._$_owner$_ = t, this._$_index$_ = s, this._$_type$_ = e, 
                    this._$Get$_ = null, this._$_variesPerInstance$_ = !1, this._$_isConstant$_ = !1;
                }
                static _$Create$_(t, e, s) {
                    const i = e[0], r = [ ExpressionParameter, StringExpressionParameter, FileParameter, ComboParameter, ObjectParameter, LayerExpressionParameter, LayoutParameter, ExpressionParameter, ComboParameter, ComboParameter, InstVarParameter, EventVarParameter, FileParameter, VariadicParameter, StringExpressionParameter, TimelineParameter, BooleanParameter, FunctionParameter, EaseParameter, TilemapBrushParameter, TemplateExpressionParameter, FlowchartParameter ];
                    return C33._$New$_(r[i], t, i, s, e);
                }
                _$_PostInit$_() {}
                _$SetVariesPerInstance$_() {
                    this._$_variesPerInstance$_ = !0;
                }
                _$_MaybeVaryFor$_(t) {
                    this._$_variesPerInstance$_ || !t || t._$GetPlugin$_()._$IsSingleGlobal$_() || (this._$_variesPerInstance$_ = !0);
                }
                _$VariesPerInstance$_() {
                    return this._$_variesPerInstance$_;
                }
                _$GetIndex$_() {
                    return this._$_index$_;
                }
                _$GetRuntime$_() {
                    return this._$_owner$_._$GetRuntime$_();
                }
                _$GetEventBlock$_() {
                    return this._$_owner$_._$GetEventBlock$_();
                }
                _$IsConstant$_() {
                    return this._$_isConstant$_;
                }
                _$IsObjectParameter$_() {
                    return 4 === this._$_type$_;
                }
            };
            class ExpressionParameter extends C33._$Parameter$_ {
                constructor(t, e, s, i) {
                    super(t, e, s), this._$_solIndex$_ = 0;
                    const r = i[1];
                    this._$_expressionNumber$_ = r[0], this._$_numberedNodes$_ = [], 
                    this._$_expressionFunc$_ = null;
                    for (let t = 1, e = r.length; t < e; ++t) this._$_numberedNodes$_.push(C33._$ExpNode$_._$CreateNode$_(this, r[t]));
                    this._$_numberedNodes$_.length ? this._$Get$_ = this._$GetExpression$_ : (this._$Get$_ = GetExpressionFunc2(this._$_expressionNumber$_), 
                    this._$_isConstant$_ = !0);
                }
                _$_GetNode$_(t) {
                    if (t < 0 || t >= this._$_numberedNodes$_.length) throw new RangeError("invalid numbered node");
                    return this._$_numberedNodes$_[t];
                }
                _$_PostInit$_() {
                    for (const e of this._$_numberedNodes$_) e._$_PostInit$_();
                    const t = GetExpressionFunc2(this._$_expressionNumber$_);
                    this._$_numberedNodes$_.length ? this._$_expressionFunc$_ = t(this) : this._$_expressionFunc$_ = t;
                }
                _$GetSolIndex$_() {
                    return this._$_solIndex$_;
                }
                _$GetExpression$_(t) {
                    return this._$_solIndex$_ = t, this._$_expressionFunc$_();
                }
            }
            class StringExpressionParameter extends ExpressionParameter {
                constructor(t, e, s, i) {
                    super(t, e, s, i), this._$Get$_ = this._$GetStringExpression$_, 
                    14 === e && (this._$GetEventBlock$_()._$SetAllSolModifiers$_(), 
                    this._$_owner$_ instanceof C33._$Action$_) && this._$GetEventBlock$_()._$SetSolWriterAfterCnds$_();
                }
                _$GetStringExpression$_(t) {
                    this._$_solIndex$_ = t;
                    const e = this._$_expressionFunc$_();
                    return "string" == typeof e ? e : "";
                }
                _$_GetFastTriggerValue$_() {
                    return GetExpressionFunc2(this._$_expressionNumber$_)();
                }
            }
            class LayerExpressionParameter extends ExpressionParameter {
                constructor(t, e, s, i) {
                    super(t, e, s, i), 2 <= t._$GetImplementationSdkVersion$_() ? this._$Get$_ = this._$GetILayer$_ : this._$Get$_ = this._$GetLayer$_, 
                    this._$_isConstant$_ = !1;
                }
                _$GetLayer$_(t) {
                    this._$_solIndex$_ = t;
                    const e = this._$_expressionFunc$_(), s = this._$GetRuntime$_()._$GetCurrentLayout$_();
                    return s._$GetLayer$_(e);
                }
                _$GetILayer$_(t) {
                    const e = this._$GetLayer$_(t);
                    return e ? e._$GetILayer$_() : null;
                }
            }
            class ComboParameter extends C33._$Parameter$_ {
                constructor(t, e, s, i) {
                    super(t, e, s), this._$_combo$_ = i[1], this._$Get$_ = this._$GetCombo$_, 
                    this._$_isConstant$_ = !0;
                }
                _$GetCombo$_() {
                    return this._$_combo$_;
                }
            }
            class BooleanParameter extends C33._$Parameter$_ {
                constructor(t, e, s, i) {
                    super(t, e, s), this._$_bool$_ = i[1], this._$Get$_ = this._$GetBoolean$_, 
                    this._$_isConstant$_ = !0;
                }
                _$GetBoolean$_() {
                    return this._$_bool$_;
                }
            }
            class ObjectParameter extends C33._$Parameter$_ {
                constructor(t, e, s, i) {
                    super(t, e, s), this._$_objectClass$_ = this._$GetRuntime$_()._$GetObjectClassByIndex$_(i[1]), 
                    2 <= t._$GetImplementationSdkVersion$_() ? this._$Get$_ = this._$GetIObjectClass$_ : this._$Get$_ = this._$GetObjectClass$_;
                    const r = this._$GetEventBlock$_();
                    r._$_AddSolModifier$_(this._$_objectClass$_), this._$_owner$_ instanceof C33._$Action$_ ? r._$SetSolWriterAfterCnds$_() : r._$GetParent$_() && r._$GetParent$_()._$SetSolWriterAfterCnds$_(), 
                    this._$_isConstant$_ = !0;
                }
                _$GetObjectClass$_() {
                    return this._$_objectClass$_;
                }
                _$GetIObjectClass$_() {
                    return this._$_objectClass$_ ? this._$_objectClass$_._$GetIObjectClass$_() : null;
                }
            }
            class LayoutParameter extends C33._$Parameter$_ {
                constructor(t, e, s, i) {
                    super(t, e, s), this._$_layout$_ = this._$GetRuntime$_()._$GetLayoutManager$_()._$GetLayoutByName$_(i[1]), 
                    2 <= t._$GetImplementationSdkVersion$_() ? this._$Get$_ = this._$GetILayout$_ : this._$Get$_ = this._$GetLayout$_, 
                    this._$_isConstant$_ = !0;
                }
                _$GetLayout$_() {
                    return this._$_layout$_;
                }
                _$GetILayout$_() {
                    return this._$_layout$_ ? this._$_layout$_._$GetILayout$_() : null;
                }
            }
            class TimelineParameter extends C33._$Parameter$_ {
                constructor(t, e, s, i) {
                    super(t, e, s), this._$_timeline$_ = this._$GetRuntime$_()._$GetTimelineManager$_()._$GetTimelineByName$_(i[1]), 
                    2 <= t._$GetImplementationSdkVersion$_() ? this._$Get$_ = this._$GetITimelineState$_ : this._$Get$_ = this._$GetTimeline$_, 
                    this._$_isConstant$_ = !0;
                }
                _$GetTimeline$_() {
                    return this._$_timeline$_;
                }
                _$GetITimelineState$_() {
                    return this._$_timeline$_ ? this._$_timeline$_._$GetITimelineState$_() : null;
                }
            }
            class FileParameter extends C33._$Parameter$_ {
                constructor(t, e, s, i) {
                    super(t, e, s), this._$_fileInfo$_ = i[1], this._$Get$_ = this._$GetFile$_, 
                    this._$_isConstant$_ = !0;
                }
                _$GetFile$_() {
                    return this._$_fileInfo$_;
                }
            }
            class InstVarParameter extends C33._$Parameter$_ {
                constructor(t, e, s, i) {
                    super(t, e, s), this._$_instVarIndex$_ = i[1];
                    const r = this._$_owner$_._$GetObjectClass$_();
                    this._$_owner$_ instanceof C33._$Condition$_ && this._$_owner$_._$IsStatic$_() || !r || !r._$IsFamily$_() ? (this._$Get$_ = this._$GetInstanceVariable$_, 
                    this._$_isConstant$_ = !0) : (this._$Get$_ = this._$GetFamilyInstanceVariable$_, 
                    this._$SetVariesPerInstance$_());
                }
                _$GetInstanceVariable$_() {
                    return this._$_instVarIndex$_;
                }
                _$GetFamilyInstanceVariable$_(t) {
                    t = t || 0;
                    let e = this._$_owner$_._$GetObjectClass$_(), s = e._$GetCurrentSol$_(), i = s._$GetInstances$_(), r = null;
                    if (i.length) r = i[t % i.length]._$GetObjectClass$_(); else if (s._$HasAnyElseInstances$_()) {
                        const n = s._$GetElseInstances$_();
                        r = n[t % n.length]._$GetObjectClass$_();
                    } else {
                        if (!(0 < e._$GetInstanceCount$_())) return 0;
                        {
                            const h = e._$GetInstances$_();
                            r = h[t % h.length]._$GetObjectClass$_();
                        }
                    }
                    return this._$_instVarIndex$_ + r._$GetFamilyInstanceVariableOffset$_(e._$GetFamilyIndex$_());
                }
            }
            class EventVarParameter extends C33._$Parameter$_ {
                constructor(t, e, s, i) {
                    super(t, e, s), this._$_eventVarSid$_ = i[1], this._$_eventVar$_ = null, 
                    2 <= t._$GetImplementationSdkVersion$_() ? this._$Get$_ = this._$GetIEventVariable$_ : this._$Get$_ = this._$GetEventVariable$_, 
                    this._$_isConstant$_ = !0;
                }
                _$_PostInit$_() {
                    this._$_eventVar$_ = this._$GetRuntime$_()._$GetEventSheetManager$_()._$GetEventVariableBySID$_(this._$_eventVarSid$_);
                }
                _$GetEventVariable$_() {
                    return this._$_eventVar$_;
                }
                _$GetIEventVariable$_() {
                    return null;
                }
            }
            class FunctionParameter extends C33._$Parameter$_ {
                constructor(t, e, s, i) {
                    super(t, e, s), this._$_functionBlockName$_ = i[1], this._$_functionBlock$_ = null, 
                    2 <= t._$GetImplementationSdkVersion$_() ? this._$Get$_ = this._$GetIFunction$_ : this._$Get$_ = this._$GetFunction$_, 
                    this._$_isConstant$_ = !0;
                }
                _$_PostInit$_() {
                    this._$_functionBlock$_ = this._$GetRuntime$_()._$GetEventSheetManager$_()._$GetFunctionBlockByName$_(this._$_functionBlockName$_), 
                    this._$_functionBlockName$_ = null;
                }
                _$GetFunction$_() {
                    return this._$_functionBlock$_;
                }
                _$GetIFunction$_() {
                    return null;
                }
            }
            class VariadicParameter extends C33._$Parameter$_ {
                constructor(t, e, s, i) {
                    super(t, e, s), this._$_subParams$_ = [], this._$_variadicRet$_ = [], 
                    this._$_isConstant$_ = !0;
                    for (let t = 1, e = i.length; t < e; ++t) {
                        const r = C33._$Parameter$_._$Create$_(this._$_owner$_, i[t], 0);
                        this._$_subParams$_.push(r), this._$_variadicRet$_.push(0), 
                        r._$IsConstant$_() || (this._$_isConstant$_ = !1);
                    }
                    this._$Get$_ = this._$GetVariadic$_;
                }
                _$_PostInit$_() {
                    for (const t of this._$_subParams$_) t._$_PostInit$_();
                }
                _$GetVariadic$_() {
                    const s = this._$_subParams$_, i = this._$_variadicRet$_;
                    for (let t = 0, e = s.length; t < e; ++t) i[t] = s[t]._$Get$_(0);
                    return i;
                }
            }
            class EaseParameter extends C33._$Parameter$_ {
                constructor(t, e, s, i) {
                    super(t, e, s), this._$_easeIndex$_ = i[1], this._$Get$_ = this._$GetEase$_, 
                    this._$_isConstant$_ = !0;
                }
                _$GetEase$_() {
                    return this._$_easeIndex$_;
                }
            }
            class TilemapBrushParameter extends C33._$Parameter$_ {
                constructor(t, e, s, i) {
                    super(t, e, s), this._$_brushIndex$_ = i[1], this._$Get$_ = this._$GetTilemapBrush$_, 
                    this._$_isConstant$_ = !0;
                }
                _$GetTilemapBrush$_() {
                    return this._$_brushIndex$_;
                }
            }
            class TemplateExpressionParameter extends ExpressionParameter {
                constructor(t, e, s, i) {
                    super(t, e, s, i), this._$Get$_ = this._$GetTemplateName$_, 
                    this._$_isConstant$_ = !1;
                }
                _$GetTemplateName$_() {
                    return this._$_expressionFunc$_();
                }
            }
            class FlowchartParameter extends C33._$Parameter$_ {
                constructor(t, e, s, i) {
                    super(t, e, s), this._$_flowchartDataItem$_ = this._$GetRuntime$_()._$GetFlowchartManager$_()._$GetFlowchartDataItemByName$_(i[1]), 
                    this._$Get$_ = this._$GetFlowchartName$_, this._$_isConstant$_ = !0;
                }
                _$GetFlowchartName$_() {
                    return this._$_flowchartDataItem$_._$GetName$_();
                }
            }
        }
        {
            let EvalParams2 = function(s, i) {
                for (let t = 0, e = s.length; t < e; ++t) i[t] = s[t]._$Get$_(0);
            };
            EvalParams = EvalParams2;
            const C33 = self._$C3$_, assert = self.assert, EMPTY_PARAMS_ARRAY = [], noop = function() {};
            C33._$Condition$_ = class extends C33._$DefendedBase$_ {
                constructor(t, s, e) {
                    if (super(), this._$_eventBlock$_ = t, this._$_runtime$_ = t._$GetRuntime$_(), 
                    this._$_index$_ = e, this._$_func$_ = this._$_runtime$_._$GetObjectReference$_(s[1]), 
                    this._$_isTrigger$_ = 0 < s[3], this._$_isFastTrigger$_ = 2 === s[3], 
                    this._$_isLooping$_ = !!s[4], this._$_isInverted$_ = !!s[5], 
                    this._$_isStatic$_ = !!s[6], this._$_sid$_ = s[7], this._$_isInOrBlock$_ = this._$_eventBlock$_._$IsOrBlock$_(), 
                    this._$_objectClass$_ = null, this._$_behaviorType$_ = null, 
                    this._$_behaviorIndex$_ = -1, this._$_systemPlugin$_ = null, 
                    this._$Run$_ = noop, this._$DebugRun$_ = noop, this._$_parameters$_ = [], 
                    this._$_results$_ = [], this._$_anyParamVariesPerInstance$_ = !1, 
                    this._$_savedData$_ = null, this._$_unsavedData$_ = null, this._$_debugData$_ = this._$_runtime$_._$IsDebug$_() ? {
                        _$isBreakpoint$_: s[8][0],
                        _$canDebug$_: s[8][1]
                    } : null, -1 === s[0] ? this._$_systemPlugin$_ = this._$_runtime$_._$GetSystemPlugin$_() : (this._$_objectClass$_ = this._$_runtime$_._$GetObjectClassByIndex$_(s[0]), 
                    s[2] && (this._$_behaviorType$_ = this._$_objectClass$_._$GetBehaviorTypeByName$_(s[2]), 
                    this._$_behaviorIndex$_ = this._$_objectClass$_._$GetBehaviorIndexByName$_(s[2])), 
                    this._$_eventBlock$_._$GetParent$_() && this._$_eventBlock$_._$GetParent$_()._$SetSolWriterAfterCnds$_()), 
                    10 === s.length) {
                        let e = s[9];
                        for (let t of e) this._$_parameters$_.push(C33._$Parameter$_._$Create$_(this, t, this._$_parameters$_.length)), 
                        this._$_results$_.push(0);
                    }
                    0 === this._$_parameters$_.length && (this._$_parameters$_ = EMPTY_PARAMS_ARRAY, 
                    this._$_results$_ = EMPTY_PARAMS_ARRAY), this._$_eventBlock$_._$GetEventSheetManager$_()._$_RegisterCondition$_(this);
                }
                static _$Create$_(t, e, s) {
                    return C33._$New$_(C33._$Condition$_, t, e, s);
                }
                _$_PostInit$_() {
                    for (const t of this._$_parameters$_) t._$_PostInit$_(), t._$VariesPerInstance$_() && (this._$_anyParamVariesPerInstance$_ = !0);
                    this._$_isFastTrigger$_ ? (this._$Run$_ = this._$_RunFastTrigger$_, 
                    this._$DebugRun$_ = this._$_DebugRunFastTrigger$_) : this._$_systemPlugin$_ ? (this._$_SetSystemRunMethod$_(), 
                    this._$DebugRun$_ = this._$_DebugRunSystem$_) : this._$_objectClass$_._$GetPlugin$_()._$IsSingleGlobal$_() ? (this._$_SetSingleGlobalRunMethod$_(), 
                    this._$DebugRun$_ = this._$_DebugRunSingleGlobal$_) : this._$_isStatic$_ ? (this._$Run$_ = this._$_RunStatic$_, 
                    this._$DebugRun$_ = this._$_DebugRunStatic$_) : (this._$Run$_ = this._$_RunObject$_, 
                    this._$DebugRun$_ = this._$_DebugRunObject$_);
                }
                _$_SetSystemRunMethod$_() {
                    const t = this._$_systemPlugin$_, e = this._$_systemPlugin$_;
                    this._$_SetRunMethodForBoundFunc$_(t, e, this._$_RunSystem$_);
                }
                _$_SetSingleGlobalRunMethod$_() {
                    const t = this._$_objectClass$_._$GetPlugin$_(), e = this._$_objectClass$_._$GetSingleGlobalInstance$_()._$GetSdkInstance$_();
                    this._$_SetRunMethodForBoundFunc$_(t, e, this._$_RunSingleGlobal$_);
                }
                _$_SetRunMethodForBoundFunc$_(t, e, s) {
                    const i = this._$_func$_, r = this._$_isInverted$_, n = this._$_parameters$_;
                    if (0 === n.length) {
                        const h = t._$_GetBoundACEMethod$_(i, e);
                        r ? this._$Run$_ = function() {
                            return C33.xor(h(), r);
                        } : this._$Run$_ = h;
                    } else if (1 === n.length) {
                        const o = n[0];
                        if (!r && o._$IsConstant$_()) this._$Run$_ = t._$_GetBoundACEMethod_1param$_(i, e, o._$Get$_(0)); else {
                            const a = t._$_GetBoundACEMethod$_(i, e);
                            this._$Run$_ = function() {
                                return C33.xor(a(o._$Get$_(0)), r);
                            };
                        }
                    } else if (2 === n.length) {
                        const l = n[0], u = n[1];
                        if (!r && l._$IsConstant$_() && u._$IsConstant$_()) this._$Run$_ = t._$_GetBoundACEMethod_2params$_(i, e, l._$Get$_(0), u._$Get$_(0)); else {
                            const c = t._$_GetBoundACEMethod$_(i, e);
                            this._$Run$_ = function() {
                                return C33.xor(c(l._$Get$_(0), u._$Get$_(0)), r);
                            };
                        }
                    } else if (3 === n.length) {
                        const f = n[0], d = n[1], p = n[2];
                        if (!r && f._$IsConstant$_() && d._$IsConstant$_() && p._$IsConstant$_()) this._$Run$_ = t._$_GetBoundACEMethod_3params$_(i, e, f._$Get$_(0), d._$Get$_(0), p._$Get$_(0)); else {
                            const m = t._$_GetBoundACEMethod$_(i, e);
                            this._$Run$_ = function() {
                                return C33.xor(m(f._$Get$_(0), d._$Get$_(0), p._$Get$_(0)), r);
                            };
                        }
                    } else this._$Run$_ = s;
                }
                _$GetSID$_() {
                    return this._$_sid$_;
                }
                _$_GetFunc$_() {
                    return this._$_func$_;
                }
                _$GetObjectClass$_() {
                    return this._$_objectClass$_;
                }
                _$GetBehaviorType$_() {
                    return this._$_behaviorType$_;
                }
                _$GetImplementationAddon$_() {
                    return this._$_behaviorType$_ ? this._$_behaviorType$_._$GetBehavior$_() : this._$_objectClass$_ ? this._$_objectClass$_._$GetPlugin$_() : null;
                }
                _$GetImplementationSdkVersion$_() {
                    const t = this._$GetImplementationAddon$_();
                    return t ? t._$GetSdkVersion$_() : 1;
                }
                _$GetEventBlock$_() {
                    return this._$_eventBlock$_;
                }
                _$GetRuntime$_() {
                    return this._$_runtime$_;
                }
                _$GetIndex$_() {
                    return this._$_index$_;
                }
                _$GetDebugIndex$_() {
                    return this._$GetIndex$_();
                }
                _$IsTrigger$_() {
                    return this._$_isTrigger$_;
                }
                _$IsFastTrigger$_() {
                    return this._$_isFastTrigger$_;
                }
                _$IsInverted$_() {
                    return this._$_isInverted$_;
                }
                _$IsLooping$_() {
                    return this._$_isLooping$_;
                }
                _$IsStatic$_() {
                    return this._$_isStatic$_;
                }
                _$IsBreakpoint$_() {
                    return this._$_debugData$_._$isBreakpoint$_;
                }
                _$IsSystemCondition$_() {
                    return !!this._$_systemPlugin$_;
                }
                _$IsSystemOrSingleGlobalCondition$_() {
                    return this._$IsSystemCondition$_() || this._$_objectClass$_._$GetPlugin$_()._$IsSingleGlobal$_();
                }
                _$GetFirstObjectParameterObjectClass$_() {
                    for (const t of this._$_parameters$_) if (t._$IsObjectParameter$_()) return t._$GetObjectClass$_();
                    return null;
                }
                _$_SetBreakpoint$_(t) {
                    this._$_debugData$_._$isBreakpoint$_ = !!t, this._$_eventBlock$_._$_UpdateCanRunFastRecursive$_();
                }
                _$_DebugReturnsGenerator$_() {
                    return this._$_debugData$_._$canDebug$_;
                }
                _$DebugCanRunFast$_() {
                    return !this._$IsBreakpoint$_() && !this._$_runtime$_._$DebugBreakNext$_() && !this._$_DebugReturnsGenerator$_();
                }
                _$GetSavedDataMap$_() {
                    return this._$_savedData$_ || (this._$_savedData$_ = new Map()), 
                    this._$_savedData$_;
                }
                _$GetUnsavedDataMap$_() {
                    return this._$_unsavedData$_ || (this._$_unsavedData$_ = new Map()), 
                    this._$_unsavedData$_;
                }
                _$_RunSystem$_() {
                    const t = this._$_results$_;
                    return EvalParams2(this._$_parameters$_, t), C33.xor(this._$_func$_.apply(this._$_systemPlugin$_, t), this._$_isInverted$_);
                }
                *_$_DebugRunSystem$_() {
                    if ((this._$IsBreakpoint$_() || this._$_runtime$_._$DebugBreakNext$_()) && (yield this), 
                    this._$_DebugReturnsGenerator$_()) {
                        const e = this._$_results$_;
                        EvalParams2(this._$_parameters$_, e);
                        let t = this._$_func$_.apply(this._$_systemPlugin$_, e);
                        return C33._$IsIterator$_(t) && (t = yield* t), C33.xor(t, this._$_isInverted$_);
                    }
                    return this._$Run$_();
                }
                _$_RunSingleGlobal$_() {
                    const t = this._$_results$_, e = (EvalParams2(this._$_parameters$_, t), 
                    this._$_objectClass$_._$GetSingleGlobalInstance$_()._$GetSdkInstance$_());
                    return C33.xor(this._$_func$_.apply(e, t), this._$_isInverted$_);
                }
                *_$_DebugRunSingleGlobal$_() {
                    if ((this._$IsBreakpoint$_() || this._$_runtime$_._$DebugBreakNext$_()) && (yield this), 
                    this._$_DebugReturnsGenerator$_()) {
                        let t = this._$_results$_, e = (EvalParams2(this._$_parameters$_, t), 
                        this._$_objectClass$_._$GetSingleGlobalInstance$_()._$GetSdkInstance$_()), s = this._$_func$_.apply(e, t);
                        return C33._$IsIterator$_(s) && (s = yield* s), C33.xor(s, this._$_isInverted$_);
                    }
                    return this._$Run$_();
                }
                _$_RunFastTrigger$_() {
                    return !0;
                }
                *_$_DebugRunFastTrigger$_() {
                    return (this._$IsBreakpoint$_() || this._$_runtime$_._$DebugBreakNext$_()) && (yield this), 
                    !0;
                }
                _$_GetStaticConditionThis$_() {
                    return this._$_behaviorType$_ ? 2 <= this._$_behaviorType$_._$GetBehavior$_()._$GetSdkVersion$_() ? this._$_behaviorType$_._$GetIBehaviorType$_() : this._$_behaviorType$_ : 2 <= this._$_objectClass$_._$GetPlugin$_()._$GetSdkVersion$_() ? this._$_objectClass$_._$GetIObjectClass$_() : this._$_objectClass$_;
                }
                _$_RunStatic$_() {
                    const t = this._$_results$_, e = (EvalParams2(this._$_parameters$_, t), 
                    this._$_func$_.apply(this._$_GetStaticConditionThis$_(), t));
                    return this._$_objectClass$_._$ApplySolToContainer$_(), e;
                }
                *_$_DebugRunStatic$_() {
                    if ((this._$IsBreakpoint$_() || this._$_runtime$_._$DebugBreakNext$_()) && (yield this), 
                    this._$_DebugReturnsGenerator$_()) {
                        const e = this._$_results$_;
                        EvalParams2(this._$_parameters$_, e);
                        let t = this._$_func$_.apply(this._$_GetStaticConditionThis$_(), e);
                        return C33._$IsIterator$_(t) && (t = yield* t), this._$_objectClass$_._$ApplySolToContainer$_(), 
                        t;
                    }
                    return this._$Run$_();
                }
                _$_RunObject$_() {
                    const s = this._$_parameters$_, i = this._$_results$_, t = this._$_objectClass$_._$GetCurrentSol$_();
                    for (let t = 0, e = s.length; t < e; ++t) {
                        const r = s[t];
                        r._$VariesPerInstance$_() || (i[t] = r._$Get$_(0));
                    }
                    return t._$IsSelectAll$_() ? this._$_RunObject_FirstFilter$_(t) : this._$_RunObject_NextFilter$_(t);
                }
                *_$_DebugRunObject$_() {
                    return (this._$IsBreakpoint$_() || this._$_runtime$_._$DebugBreakNext$_()) && (yield this), 
                    this._$_RunObject$_();
                }
                _$_EvaluateVaryingParameters$_(s) {
                    const i = this._$_parameters$_, r = this._$_results$_;
                    for (let t = 0, e = i.length; t < e; ++t) {
                        const n = i[t];
                        n._$VariesPerInstance$_() && (r[t] = n._$Get$_(s));
                    }
                }
                _$_RunObject_FirstFilter$_(s) {
                    const t = this._$_objectClass$_, i = t._$IsFamily$_(), r = t._$GetFamilyIndex$_(), n = this._$_behaviorIndex$_, h = 0 <= n, o = t._$GetInstances$_(), a = this._$_anyParamVariesPerInstance$_, l = this._$_results$_, u = this._$_func$_, c = this._$_isInverted$_, f = this._$_isInOrBlock$_ && !this._$_isTrigger$_;
                    s._$ClearArrays$_();
                    for (let e = 0, t = o.length; e < t; ++e) {
                        const d = o[e];
                        a && this._$_EvaluateVaryingParameters$_(e);
                        let t;
                        if (h) {
                            const p = i ? d._$GetObjectClass$_()._$GetFamilyBehaviorOffset$_(r) : 0;
                            t = u.apply(d._$GetBehaviorInstances$_()[n + p]._$GetSdkInstance$_(), l);
                        } else t = u.apply(d._$GetSdkInstance$_(), l);
                        C33.xor(t, c) ? s._$_PushInstance$_(d) : f && s._$_PushElseInstance$_(d);
                    }
                    return t._$FinishCondition$_(!0), s._$_SetSelectAll$_(!1), t._$ApplySolToContainer$_(), 
                    s._$HasAnyInstances$_();
                }
                _$_RunObject_NextFilter$_(t) {
                    let e = this._$_objectClass$_, s = e._$IsFamily$_(), i = e._$GetFamilyIndex$_(), r = e._$IsInContainer$_(), n = this._$_behaviorIndex$_, h = 0 <= n, o = this._$_anyParamVariesPerInstance$_, a = this._$_results$_, l = this._$_func$_, u = this._$_isInverted$_, c = this._$_isInOrBlock$_ && !this._$_isTrigger$_, f = t._$_GetOwnInstances$_(), d = t._$_GetOwnElseInstances$_(), p = c && !this._$_eventBlock$_._$IsFirstConditionOfType$_(this), m = p ? d : f, C = 0, g = !1;
                    for (let e = 0, t = m.length; e < t; ++e) {
                        const _ = m[e];
                        o && this._$_EvaluateVaryingParameters$_(e);
                        let t;
                        if (h) {
                            const T = s ? _._$GetObjectClass$_()._$GetFamilyBehaviorOffset$_(i) : 0;
                            t = l.apply(_._$GetBehaviorInstances$_()[n + T]._$GetSdkInstance$_(), a);
                        } else t = l.apply(_._$GetSdkInstance$_(), a);
                        C33.xor(t, u) ? (g = !0, p ? (f.push(_), r && _._$_PushSiblingsToSolInstances$_()) : (m[C] = _, 
                        r && _._$_SetSiblingsToSolInstancesIndex$_(C), ++C)) : p ? (m[C] = _, 
                        r && _._$_SetSiblingsToSolElseInstancesIndex$_(C), ++C) : c && (d.push(_), 
                        r) && _._$_PushSiblingsToSolElseInstances$_();
                    }
                    C33._$truncateArray$_(m, C), r && e._$_TruncateContainerSols$_(p, C);
                    const S = g;
                    return p && !g && (g = this._$_OrBlockCheckInstances$_(f)), 
                    e._$FinishCondition$_(S || c), c ? g : t._$HasAnyInstances$_();
                }
                _$_OrBlockCheckInstances$_(s) {
                    const t = this._$_objectClass$_, i = t._$IsFamily$_(), r = t._$GetFamilyIndex$_(), n = this._$_anyParamVariesPerInstance$_, h = this._$_behaviorIndex$_, o = 0 <= h, a = this._$_results$_, l = this._$_func$_, u = this._$_isInverted$_;
                    for (let e = 0, t = s.length; e < t; ++e) {
                        const c = s[e];
                        n && this._$_EvaluateVaryingParameters$_(e);
                        let t;
                        if (o) {
                            const f = i ? c._$GetObjectClass$_()._$GetFamilyBehaviorOffset$_(r) : 0;
                            t = l.apply(c._$GetBehaviorInstances$_()[h + f]._$GetSdkInstance$_(), a);
                        } else t = l.apply(c._$GetSdkInstance$_(), a);
                        if (C33.xor(t, u)) return !0;
                    }
                    return !1;
                }
                _$ReevaluateParameter$_(t, e) {
                    return this._$_parameters$_[t]._$Get$_(e);
                }
                _$GetFastTriggerValue$_() {
                    const t = this._$_parameters$_;
                    if (t.length) return t[0]._$_GetFastTriggerValue$_();
                    throw new Error("no parameters");
                }
                _$_SaveToJson$_() {
                    if (!this._$_savedData$_ || !this._$_savedData$_.size) return null;
                    const e = {};
                    for (const [ s, i ] of this._$_savedData$_.entries()) {
                        let t = i;
                        "collmemory" === s && (t = [ ...i.entries() ].map(t => [ t[0]._$GetUID$_(), t[1]._$GetUID$_(), t[2] ])), 
                        e[s] = t;
                    }
                    return {
                        ex: e
                    };
                }
                _$_LoadFromJson$_(t) {
                    if (this._$_savedData$_ && (this._$_savedData$_.clear(), this._$_savedData$_ = null), 
                    t) {
                        const e = this._$_runtime$_, s = t.ex;
                        if (s) {
                            const i = this._$GetSavedDataMap$_();
                            i.clear();
                            for (const [ r, n ] of Object.entries(s)) {
                                let t = n;
                                "collmemory" === r && (t = C33._$New$_(C33._$PairMap$_, n.map(t => [ e._$GetInstanceByUID$_(t[0]), e._$GetInstanceByUID$_(t[1]), t[2] ]).filter(t => t[0] && t[1]))), 
                                i.set(r, t);
                            }
                        }
                    }
                }
            };
        }
        {
            let EvalParams2 = function(s, i) {
                for (let t = 0, e = s.length; t < e; ++t) i[t] = s[t]._$Get$_(0);
            };
            EvalParams = EvalParams2;
            const C33 = self._$C3$_, assert = self.assert, EMPTY_PARAMS_ARRAY = [], noop = function() {}, noopGenerator = function*() {}, FLAG_CANPICKANYOBJECTCLASS = 1, FLAG_COPYPICKED = 2, FLAG_CUSTOM_ACE = 4, FLAG_IS_ASYNC = 8, FLAG_CAN_BAIL_OUT = 16;
            C33._$Action$_ = class extends C33._$DefendedBase$_ {
                constructor(t, e, s) {
                    super();
                    const i = (this._$_eventBlock$_ = t)._$GetRuntime$_(), r = (this._$_runtime$_ = i, 
                    this._$_index$_ = s, this._$_sid$_ = 4 <= e.length ? e[3] : -1, 
                    this._$_actionType$_ = 5 <= e.length ? 255 & e[4] : 0, this._$_flags$_ = 5 <= e.length ? e[4] >> 8 : 0, 
                    this._$_func$_ = null, this._$_objectClass$_ = null, this._$_behaviorType$_ = null, 
                    this._$_behaviorIndex$_ = -1, this._$_systemPlugin$_ = null, 
                    this._$_callFunctionName$_ = "", this._$_callCustomAceObjectClass$_ = null, 
                    this._$_callEventBlock$_ = null, this._$Run$_ = noop, this._$DebugRun$_ = noop, 
                    this._$_parameters$_ = [], this._$_results$_ = [], this._$_anyParamVariesPerInstance$_ = !1, 
                    this._$_savedData$_ = null, this._$_unsavedData$_ = null, -3 === e[0]), n = r ? e[2] : e[5];
                    if (this._$_debugData$_ = i._$IsDebug$_() || r ? {
                        _$isBreakpoint$_: n[0],
                        _$canDebug$_: n[1],
                        index: n[2]
                    } : null, -1 === e[0]) this._$_systemPlugin$_ = i._$GetSystemPlugin$_(), 
                    this._$_func$_ = i._$GetObjectReference$_(e[1]); else if (-2 === e[0]) this._$_callFunctionName$_ = e[1]; else if (r) {
                        const h = i._$GetObjectReference$_(e[1]);
                        this._$_func$_ = h, this._$Run$_ = this._$RunUserScript$_, 
                        this._$DebugRun$_ = this._$DebugRunUserScript$_, this._$_flags$_ |= FLAG_IS_ASYNC;
                    } else this._$_objectClass$_ = i._$GetObjectClassByIndex$_(e[0]), 
                    this._$_flags$_ & FLAG_CUSTOM_ACE ? (this._$_callFunctionName$_ = e[1], 
                    this._$_callCustomAceObjectClass$_ = i._$GetObjectClassByIndex$_(e[2])) : (e[2] && (this._$_behaviorType$_ = this._$_objectClass$_._$GetBehaviorTypeByName$_(e[2]), 
                    this._$_behaviorIndex$_ = this._$_objectClass$_._$GetBehaviorIndexByName$_(e[2])), 
                    this._$_func$_ = i._$GetObjectReference$_(e[1]));
                    if (7 === e.length) {
                        const o = e[6];
                        for (const a of o) this._$_parameters$_.push(C33._$Parameter$_._$Create$_(this, a, this._$_parameters$_.length)), 
                        this._$_results$_.push(0);
                    }
                    0 === this._$_parameters$_.length && (this._$_parameters$_ = EMPTY_PARAMS_ARRAY, 
                    this._$_results$_ = EMPTY_PARAMS_ARRAY), this._$CanPickAnyObjectClass$_() && (this._$_eventBlock$_._$SetAllSolModifiers$_(), 
                    this._$_eventBlock$_._$SetSolWriterAfterCnds$_()), this._$_eventBlock$_._$GetEventSheetManager$_()._$_RegisterAction$_(this);
                }
                static _$Create$_(t, e, s) {
                    return C33._$New$_(C33._$Action$_, t, e, s);
                }
                _$_PostInit$_() {
                    for (const t of this._$_parameters$_) t._$_PostInit$_(), t._$VariesPerInstance$_() && (this._$_anyParamVariesPerInstance$_ = !0);
                    if (this._$_systemPlugin$_) this._$_SetSystemRunMethod$_(), 
                    this._$DebugRun$_ = this._$_DebugRunSystem$_; else if (this._$_callFunctionName$_) this._$_flags$_ & FLAG_CUSTOM_ACE ? this._$_SetCallCustomActionRunMethod$_() : this._$_SetCallFunctionRunMethod$_(), 
                    this._$_callFunctionName$_ = "", this._$_callCustomAceObjectClass$_ = null; else if (this._$Run$_ === this._$RunUserScript$_) {
                        const e = this._$_func$_, s = this._$_runtime$_._$GetEventSheetManager$_()._$_GetLocalVariablesScriptInterface$_(this._$_eventBlock$_);
                        this._$_func$_ = e.bind(null, this._$_runtime$_._$GetIRuntime$_(), s);
                    } else this._$_behaviorType$_ ? this._$IsAsync$_() ? (this._$Run$_ = this._$_RunBehavior_Async$_, 
                    this._$DebugRun$_ = this._$_DebugRunBehavior_Async$_) : (this._$Run$_ = this._$_RunBehavior$_, 
                    this._$DebugRun$_ = this._$_DebugRunBehavior$_) : this._$_objectClass$_._$GetPlugin$_()._$IsSingleGlobal$_() ? (this._$_SetSingleGlobalRunMethod$_(), 
                    this._$DebugRun$_ = this._$_DebugRunSingleGlobal$_) : this._$IsStatic$_() ? (this._$Run$_ = this._$_RunObject_Static$_, 
                    this._$DebugRun$_ = this._$_DebugRunObject_Static$_) : this._$IsAsync$_() ? (this._$Run$_ = this._$_RunObject_Async$_, 
                    this._$DebugRun$_ = this._$_DebugRunObject_Async$_) : this._$CallBeforeAfterHooks$_() ? (this._$Run$_ = this._$_RunObject_BeforeAfterHooks$_, 
                    this._$DebugRun$_ = this._$_DebugRunObject_BeforeAfterHooks$_) : this._$_parameters$_.length ? this._$_parameters$_.every(t => t._$VariesPerInstance$_()) ? (this._$Run$_ = this._$_RunObject_AllParamsVary$_, 
                    this._$DebugRun$_ = this._$_DebugRunObject_AllParamsVary$_) : this._$_anyParamVariesPerInstance$_ ? (this._$Run$_ = this._$_RunObject_SomeParamsVary$_, 
                    this._$DebugRun$_ = this._$_DebugRunObject_SomeParamsVary$_) : this._$_parameters$_.every(t => t._$IsConstant$_()) ? (EvalParams2(this._$_parameters$_, this._$_results$_), 
                    this._$Run$_ = this._$_RunObject_ParamsConst$_, this._$DebugRun$_ = this._$_DebugRunObject_ParamsConst$_) : (this._$Run$_ = this._$_RunObject_ParamsDontVary$_, 
                    this._$DebugRun$_ = this._$_DebugRunObject_ParamsDontVary$_) : (this._$Run$_ = this._$_RunObject_ParamsConst$_, 
                    this._$DebugRun$_ = this._$_DebugRunObject_ParamsConst$_);
                }
                _$_SetSystemRunMethod$_() {
                    const t = this._$_systemPlugin$_, e = this._$_systemPlugin$_;
                    this._$_SetRunMethodForBoundFunc$_(t, e, this._$_RunSystem$_);
                }
                _$_SetSingleGlobalRunMethod$_() {
                    const t = this._$_objectClass$_._$GetPlugin$_(), e = this._$_objectClass$_._$GetSingleGlobalInstance$_()._$GetSdkInstance$_();
                    this._$_SetRunMethodForBoundFunc$_(t, e, this._$_RunSingleGlobal$_);
                }
                _$_SetCallFunctionRunMethod$_() {
                    const t = this._$_eventBlock$_._$GetEventSheetManager$_(), s = t._$GetFunctionBlockByName$_(this._$_callFunctionName$_);
                    if (s._$IsEnabled$_()) {
                        const i = 0 != (this._$_flags$_ & FLAG_COPYPICKED);
                        this._$_callEventBlock$_ = s._$GetEventBlock$_();
                        let e = [ ...new Set([ ...this._$_eventBlock$_._$GetSolModifiersIncludingParents$_(), ...this._$_callEventBlock$_._$GetSolModifiersIncludingParents$_() ]) ];
                        e = t._$_DeduplicateSolModifierList$_(e);
                        const r = !s._$IsCopyPicked$_() && this._$_HasCopyPickedParent$_() ? {
                            _$pushCleanSolDynamic$_: !0
                        } : null;
                        if (this._$Run$_ = C33._$EventBlock$_.prototype._$RunAsFunctionCall$_.bind(this._$_callEventBlock$_, e, this._$_parameters$_, i, r), 
                        this._$_runtime$_._$IsDebug$_()) {
                            const n = this;
                            this._$DebugRun$_ = function*() {
                                (n._$IsBreakpoint$_() || n._$_runtime$_._$DebugBreakNext$_()) && (yield n);
                                const t = yield* n._$_callEventBlock$_._$DebugRunAsFunctionCall$_(e, n._$_parameters$_, i, r);
                                return t;
                            };
                        } else this._$DebugRun$_ = noopGenerator;
                    } else this._$Run$_ = noop, this._$DebugRun$_ = noopGenerator;
                }
                _$_SetCallCustomActionRunMethod$_() {
                    const n = this._$_eventBlock$_._$GetEventSheetManager$_(), h = n._$GetCustomActionBlockByName$_(this._$_callCustomAceObjectClass$_, this._$_callFunctionName$_);
                    if (h._$IsEnabled$_()) {
                        const o = 0 != (this._$_flags$_ & FLAG_COPYPICKED);
                        this._$_callEventBlock$_ = h._$GetEventBlock$_();
                        let e = [ ...new Set([ ...this._$_eventBlock$_._$GetSolModifiersIncludingParents$_(), ...this._$_callEventBlock$_._$GetSolModifiersIncludingParents$_(), this._$_objectClass$_, h._$GetObjectClass$_() ]) ], t = (e = n._$_DeduplicateSolModifierList$_(e), 
                        !this._$_objectClass$_._$IsFamily$_() && !h._$GetObjectClass$_()._$IsFamily$_()), s = !this._$_objectClass$_._$IsFamily$_() && h._$GetObjectClass$_()._$IsFamily$_(), i = this._$_objectClass$_._$IsFamily$_(), r = null;
                        if (!h._$IsCopyPicked$_() && this._$_HasCopyPickedParent$_() && ((r = r || {})._$pushCleanSolDynamic$_ = !0), 
                        !s && o || ((r = r || {})._$copyFromObjectClass$_ = this._$_objectClass$_, 
                        r._$copyToObjectClass$_ = h._$GetObjectClass$_()), t || s || i && !h._$HasCustomACEOverrides$_() ? this._$Run$_ = C33._$EventBlock$_.prototype._$RunAsFunctionCall$_.bind(this._$_callEventBlock$_, e, this._$_parameters$_, o, r) : i && (this._$Run$_ = C33._$FunctionBlock$_.prototype._$RunAsFamilyCustomActionWithOverrides$_.bind(h, e, this._$_parameters$_)), 
                        this._$_runtime$_._$IsDebug$_()) {
                            const a = this;
                            t || s || i && !h._$HasCustomACEOverrides$_() ? this._$DebugRun$_ = function*() {
                                (a._$IsBreakpoint$_() || a._$_runtime$_._$DebugBreakNext$_()) && (yield a);
                                const t = yield* a._$_callEventBlock$_._$DebugRunAsFunctionCall$_(e, a._$_parameters$_, o, r);
                                return t;
                            } : i && (this._$DebugRun$_ = function*() {
                                (a._$IsBreakpoint$_() || a._$_runtime$_._$DebugBreakNext$_()) && (yield a);
                                const t = yield* h._$DebugRunAsFamilyCustomActionWithOverrides$_(e, a._$_parameters$_);
                                return t;
                            });
                        } else this._$DebugRun$_ = noopGenerator;
                    } else this._$Run$_ = noop, this._$DebugRun$_ = noopGenerator;
                }
                _$_SetRunMethodForBoundFunc$_(t, e, s) {
                    const i = this._$_func$_, r = this._$_parameters$_;
                    if (0 === r.length) this._$Run$_ = t._$_GetBoundACEMethod$_(i, e); else if (1 === r.length) {
                        const n = r[0];
                        if (n._$IsConstant$_()) this._$Run$_ = t._$_GetBoundACEMethod_1param$_(i, e, n._$Get$_(0)); else {
                            const h = t._$_GetBoundACEMethod$_(i, e);
                            this._$Run$_ = function() {
                                return h(n._$Get$_(0));
                            };
                        }
                    } else if (2 === r.length) {
                        const o = r[0], a = r[1];
                        if (o._$IsConstant$_() && a._$IsConstant$_()) this._$Run$_ = t._$_GetBoundACEMethod_2params$_(i, e, o._$Get$_(0), a._$Get$_(0)); else {
                            const l = t._$_GetBoundACEMethod$_(i, e);
                            this._$Run$_ = function() {
                                return l(o._$Get$_(0), a._$Get$_(0));
                            };
                        }
                    } else if (3 === r.length) {
                        const u = r[0], c = r[1], f = r[2];
                        if (u._$IsConstant$_() && c._$IsConstant$_() && f._$IsConstant$_()) this._$Run$_ = t._$_GetBoundACEMethod_3params$_(i, e, u._$Get$_(0), c._$Get$_(0), f._$Get$_(0)); else {
                            const d = t._$_GetBoundACEMethod$_(i, e);
                            this._$Run$_ = function() {
                                return d(u._$Get$_(0), c._$Get$_(0), f._$Get$_(0));
                            };
                        }
                    } else this._$Run$_ = s;
                }
                _$GetSID$_() {
                    return this._$_sid$_;
                }
                _$IsAsync$_() {
                    return 0 != (this._$_flags$_ & FLAG_IS_ASYNC);
                }
                _$CanBailOut$_() {
                    return 0 != (this._$_flags$_ & FLAG_CAN_BAIL_OUT);
                }
                _$CallBeforeAfterHooks$_() {
                    return 1 === this._$_actionType$_;
                }
                _$IsStatic$_() {
                    return 2 === this._$_actionType$_;
                }
                _$CanPickAnyObjectClass$_() {
                    return 0 != (this._$_flags$_ & FLAG_CANPICKANYOBJECTCLASS);
                }
                _$HasReturnType$_() {
                    return this._$IsAsync$_() || this._$CanBailOut$_();
                }
                _$GetObjectClass$_() {
                    return this._$_objectClass$_;
                }
                _$GetImplementationAddon$_() {
                    return this._$_behaviorType$_ ? this._$_behaviorType$_._$GetBehavior$_() : this._$_objectClass$_ ? this._$_objectClass$_._$GetPlugin$_() : null;
                }
                _$GetImplementationSdkVersion$_() {
                    const t = this._$GetImplementationAddon$_();
                    return t ? t._$GetSdkVersion$_() : 1;
                }
                _$GetEventBlock$_() {
                    return this._$_eventBlock$_;
                }
                _$_HasCopyPickedParent$_() {
                    let t = this._$_eventBlock$_;
                    do {
                        if (t instanceof C33._$FunctionBlock$_ && t._$IsCopyPicked$_()) return !0;
                    } while (t = t._$GetScopeParent$_());
                    return !1;
                }
                _$GetRuntime$_() {
                    return this._$_runtime$_;
                }
                _$GetIndex$_() {
                    return this._$_index$_;
                }
                _$GetDebugIndex$_() {
                    return this._$_debugData$_.index;
                }
                _$IsBreakpoint$_() {
                    return this._$_debugData$_._$isBreakpoint$_;
                }
                _$_SetBreakpoint$_(t) {
                    this._$_debugData$_._$isBreakpoint$_ = !!t, this._$_eventBlock$_._$_UpdateCanRunFastRecursive$_();
                }
                _$_DebugReturnsGenerator$_() {
                    return this._$_debugData$_._$canDebug$_;
                }
                _$DebugCanRunFast$_() {
                    return !this._$IsBreakpoint$_() && !this._$_runtime$_._$DebugBreakNext$_() && !this._$_DebugReturnsGenerator$_();
                }
                _$GetSavedDataMap$_() {
                    return this._$_savedData$_ || (this._$_savedData$_ = new Map()), 
                    this._$_savedData$_;
                }
                _$GetUnsavedDataMap$_() {
                    return this._$_unsavedData$_ || (this._$_unsavedData$_ = new Map()), 
                    this._$_unsavedData$_;
                }
                _$_RunSystem$_() {
                    const t = this._$_results$_;
                    return EvalParams2(this._$_parameters$_, t), this._$_func$_.apply(this._$_systemPlugin$_, t);
                }
                *_$_DebugRunSystem$_() {
                    if ((this._$IsBreakpoint$_() || this._$_runtime$_._$DebugBreakNext$_()) && (yield this), 
                    this._$_DebugReturnsGenerator$_()) {
                        const t = this._$_results$_, e = (EvalParams2(this._$_parameters$_, t), 
                        yield* this._$_func$_.apply(this._$_systemPlugin$_, t));
                        return e;
                    }
                    return this._$Run$_();
                }
                _$_RunSingleGlobal$_() {
                    const t = this._$_results$_;
                    return EvalParams2(this._$_parameters$_, t), this._$_func$_.apply(this._$_objectClass$_._$GetSingleGlobalInstance$_()._$GetSdkInstance$_(), t);
                }
                *_$_DebugRunSingleGlobal$_() {
                    if ((this._$IsBreakpoint$_() || this._$_runtime$_._$DebugBreakNext$_()) && (yield this), 
                    this._$_DebugReturnsGenerator$_()) {
                        const t = this._$_results$_, e = (EvalParams2(this._$_parameters$_, t), 
                        yield* this._$_func$_.apply(this._$_objectClass$_._$GetSingleGlobalInstance$_()._$GetSdkInstance$_(), t));
                        return e;
                    }
                    return this._$Run$_();
                }
                _$_RunObject_ParamsConst$_() {
                    const s = this._$_results$_, i = this._$_objectClass$_._$GetCurrentSol$_()._$GetInstances$_();
                    for (let t = 0, e = i.length; t < e; ++t) this._$_func$_.apply(i[t]._$GetSdkInstance$_(), s);
                }
                *_$_DebugRunObject_ParamsConst$_() {
                    if ((this._$IsBreakpoint$_() || this._$_runtime$_._$DebugBreakNext$_()) && (yield this), 
                    this._$_DebugReturnsGenerator$_()) {
                        const s = this._$_results$_, i = this._$_objectClass$_._$GetCurrentSol$_()._$GetInstances$_();
                        for (let t = 0, e = i.length; t < e; ++t) yield* this._$_func$_.apply(i[t]._$GetSdkInstance$_(), s);
                    } else this._$_RunObject_ParamsConst$_();
                }
                _$_RunObject_ParamsDontVary$_() {
                    const s = this._$_results$_, i = (EvalParams2(this._$_parameters$_, s), 
                    this._$_objectClass$_._$GetCurrentSol$_()._$GetInstances$_());
                    for (let t = 0, e = i.length; t < e; ++t) this._$_func$_.apply(i[t]._$GetSdkInstance$_(), s);
                }
                *_$_DebugRunObject_ParamsDontVary$_() {
                    if ((this._$IsBreakpoint$_() || this._$_runtime$_._$DebugBreakNext$_()) && (yield this), 
                    this._$_DebugReturnsGenerator$_()) {
                        const s = this._$_results$_, i = (EvalParams2(this._$_parameters$_, s), 
                        this._$_objectClass$_._$GetCurrentSol$_()._$GetInstances$_());
                        for (let t = 0, e = i.length; t < e; ++t) yield* this._$_func$_.apply(i[t]._$GetSdkInstance$_(), s);
                    } else this._$_RunObject_ParamsDontVary$_();
                }
                _$_RunObject_AllParamsVary$_() {
                    const i = this._$_parameters$_, r = this._$_results$_, e = this._$_func$_, n = this._$_objectClass$_._$GetCurrentSol$_()._$GetInstances$_();
                    for (let s = 0, t = n.length; s < t; ++s) {
                        const h = n[s];
                        for (let t = 0, e = i.length; t < e; ++t) r[t] = i[t]._$Get$_(s);
                        e.apply(h._$GetSdkInstance$_(), r);
                    }
                }
                *_$_DebugRunObject_AllParamsVary$_() {
                    if ((this._$IsBreakpoint$_() || this._$_runtime$_._$DebugBreakNext$_()) && (yield this), 
                    this._$_DebugReturnsGenerator$_()) {
                        const i = this._$_parameters$_, r = this._$_results$_, e = this._$_func$_, n = this._$_objectClass$_._$GetCurrentSol$_()._$GetInstances$_();
                        for (let s = 0, t = n.length; s < t; ++s) {
                            const h = n[s];
                            for (let t = 0, e = i.length; t < e; ++t) r[t] = i[t]._$Get$_(s);
                            yield* e.apply(h._$GetSdkInstance$_(), r);
                        }
                    } else this._$_RunObject_AllParamsVary$_();
                }
                _$_RunObject_SomeParamsVary$_() {
                    const i = this._$_parameters$_, r = this._$_results$_, e = this._$_func$_, n = this._$_objectClass$_._$GetCurrentSol$_()._$GetInstances$_();
                    for (let t = 0, e = i.length; t < e; ++t) {
                        const s = i[t];
                        s._$VariesPerInstance$_() || (r[t] = s._$Get$_(0));
                    }
                    for (let s = 0, t = n.length; s < t; ++s) {
                        const h = n[s];
                        for (let t = 0, e = i.length; t < e; ++t) {
                            const o = i[t];
                            o._$VariesPerInstance$_() && (r[t] = o._$Get$_(s));
                        }
                        e.apply(h._$GetSdkInstance$_(), r);
                    }
                }
                *_$_DebugRunObject_SomeParamsVary$_() {
                    if ((this._$IsBreakpoint$_() || this._$_runtime$_._$DebugBreakNext$_()) && (yield this), 
                    this._$_DebugReturnsGenerator$_()) {
                        const i = this._$_parameters$_, r = this._$_results$_, e = this._$_func$_, n = this._$_objectClass$_._$GetCurrentSol$_()._$GetInstances$_();
                        for (let t = 0, e = i.length; t < e; ++t) {
                            const s = i[t];
                            s._$VariesPerInstance$_() || (r[t] = s._$Get$_(0));
                        }
                        for (let s = 0, t = n.length; s < t; ++s) {
                            const h = n[s];
                            for (let t = 0, e = i.length; t < e; ++t) {
                                const o = i[t];
                                o._$VariesPerInstance$_() && (r[t] = o._$Get$_(s));
                            }
                            yield* e.apply(h._$GetSdkInstance$_(), r);
                        }
                    } else this._$_RunObject_SomeParamsVary$_();
                }
                _$_RunObject_BeforeAfterHooks$_() {
                    const i = this._$_parameters$_, r = this._$_results$_, e = this._$_func$_, t = this._$_objectClass$_, s = t._$GetSdkType$_(), n = t._$GetCurrentSol$_()._$GetInstances$_();
                    s._$BeforeRunAction$_(e);
                    for (let s = 0, t = n.length; s < t; ++s) {
                        const h = n[s];
                        for (let t = 0, e = i.length; t < e; ++t) r[t] = i[t]._$Get$_(s);
                        e.apply(h._$GetSdkInstance$_(), r);
                    }
                    s._$AfterRunAction$_(e);
                }
                *_$_DebugRunObject_BeforeAfterHooks$_() {
                    if ((this._$IsBreakpoint$_() || this._$_runtime$_._$DebugBreakNext$_()) && (yield this), 
                    this._$_DebugReturnsGenerator$_()) {
                        const i = this._$_parameters$_, r = this._$_results$_, e = this._$_func$_, t = this._$_objectClass$_, s = t._$GetSdkType$_(), n = t._$GetCurrentSol$_()._$GetInstances$_();
                        s._$BeforeRunAction$_(e);
                        for (let s = 0, t = n.length; s < t; ++s) {
                            const h = n[s];
                            for (let t = 0, e = i.length; t < e; ++t) r[t] = i[t]._$Get$_(s);
                            yield* e.apply(h._$GetSdkInstance$_(), r);
                        }
                        s._$AfterRunAction$_(e);
                    } else this._$_RunObject_BeforeAfterHooks$_();
                }
                _$_GetStaticActionThis$_() {
                    return this._$_behaviorType$_ ? 2 <= this._$_behaviorType$_._$GetBehavior$_()._$GetSdkVersion$_() ? this._$_behaviorType$_._$GetIBehaviorType$_() : this._$_behaviorType$_ : 2 <= this._$_objectClass$_._$GetPlugin$_()._$GetSdkVersion$_() ? this._$_objectClass$_._$GetIObjectClass$_() : this._$_objectClass$_;
                }
                _$_RunObject_Static$_() {
                    const t = this._$_results$_;
                    return EvalParams2(this._$_parameters$_, t), this._$_func$_.apply(this._$_GetStaticActionThis$_(), t);
                }
                *_$_DebugRunObject_Static$_() {
                    if ((this._$IsBreakpoint$_() || this._$_runtime$_._$DebugBreakNext$_()) && (yield this), 
                    this._$_DebugReturnsGenerator$_()) {
                        const e = this._$_results$_;
                        EvalParams2(this._$_parameters$_, e);
                        let t = this._$_func$_.apply(this._$_GetStaticActionThis$_(), e);
                        return C33._$IsIterator$_(t) ? yield* t : t;
                    }
                    return this._$_RunObject_Static$_();
                }
                _$_RunBehavior$_() {
                    const t = this._$_objectClass$_, e = t._$IsFamily$_(), i = t._$GetFamilyIndex$_(), r = this._$_parameters$_, n = this._$_anyParamVariesPerInstance$_, h = this._$_results$_, o = this._$_func$_, a = this._$_behaviorIndex$_, l = t._$GetCurrentSol$_()._$GetInstances$_();
                    for (let t = 0, e = r.length; t < e; ++t) {
                        const s = r[t];
                        s._$VariesPerInstance$_() || (h[t] = s._$Get$_(0));
                    }
                    for (let s = 0, t = l.length; s < t; ++s) {
                        const u = l[s];
                        if (n) for (let t = 0, e = r.length; t < e; ++t) {
                            const f = r[t];
                            f._$VariesPerInstance$_() && (h[t] = f._$Get$_(s));
                        }
                        const c = e ? u._$GetObjectClass$_()._$GetFamilyBehaviorOffset$_(i) : 0;
                        o.apply(u._$GetBehaviorInstances$_()[a + c]._$GetSdkInstance$_(), h);
                    }
                }
                *_$_DebugRunBehavior$_() {
                    if ((this._$IsBreakpoint$_() || this._$_runtime$_._$DebugBreakNext$_()) && (yield this), 
                    this._$_DebugReturnsGenerator$_()) {
                        const t = this._$_objectClass$_, e = t._$IsFamily$_(), i = t._$GetFamilyIndex$_(), r = this._$_parameters$_, n = this._$_anyParamVariesPerInstance$_, h = this._$_results$_, o = this._$_func$_, a = this._$_behaviorIndex$_, l = t._$GetCurrentSol$_()._$GetInstances$_();
                        for (let t = 0, e = r.length; t < e; ++t) {
                            const s = r[t];
                            s._$VariesPerInstance$_() || (h[t] = s._$Get$_(0));
                        }
                        for (let s = 0, t = l.length; s < t; ++s) {
                            const u = l[s];
                            if (n) for (let t = 0, e = r.length; t < e; ++t) {
                                const f = r[t];
                                f._$VariesPerInstance$_() && (h[t] = f._$Get$_(s));
                            }
                            const c = e ? u._$GetObjectClass$_()._$GetFamilyBehaviorOffset$_(i) : 0;
                            yield* o.apply(u._$GetBehaviorInstances$_()[a + c]._$GetSdkInstance$_(), h);
                        }
                    } else this._$_RunBehavior$_();
                }
                _$_RunObject_Async$_() {
                    const i = this._$_parameters$_, r = this._$_results$_, e = this._$_func$_, n = this._$_objectClass$_._$GetCurrentSol$_()._$GetInstances$_(), h = [];
                    for (let s = 0, t = n.length; s < t; ++s) {
                        const o = n[s];
                        for (let t = 0, e = i.length; t < e; ++t) r[t] = i[t]._$Get$_(s);
                        h.push(e.apply(o._$GetSdkInstance$_(), r));
                    }
                    return Promise.all(h);
                }
                *_$_DebugRunObject_Async$_() {
                    if ((this._$IsBreakpoint$_() || this._$_runtime$_._$DebugBreakNext$_()) && (yield this), 
                    this._$_DebugReturnsGenerator$_()) {
                        const i = this._$_parameters$_, r = this._$_results$_, e = this._$_func$_, n = this._$_objectClass$_._$GetCurrentSol$_()._$GetInstances$_(), h = [];
                        for (let s = 0, t = n.length; s < t; ++s) {
                            const o = n[s];
                            for (let t = 0, e = i.length; t < e; ++t) r[t] = i[t]._$Get$_(s);
                            h.push(yield* e.apply(o._$GetSdkInstance$_(), r));
                        }
                        return Promise.all(h);
                    }
                    return this._$_RunObject_Async$_();
                }
                _$_RunBehavior_Async$_() {
                    const t = this._$_objectClass$_, e = t._$IsFamily$_(), i = t._$GetFamilyIndex$_(), r = this._$_parameters$_, n = this._$_results$_, h = this._$_func$_, o = this._$_behaviorIndex$_, a = t._$GetCurrentSol$_()._$GetInstances$_(), l = [];
                    for (let s = 0, t = a.length; s < t; ++s) {
                        const u = a[s];
                        for (let t = 0, e = r.length; t < e; ++t) n[t] = r[t]._$Get$_(s);
                        const c = e ? u._$GetObjectClass$_()._$GetFamilyBehaviorOffset$_(i) : 0;
                        l.push(h.apply(u._$GetBehaviorInstances$_()[o + c]._$GetSdkInstance$_(), n));
                    }
                    return Promise.all(l);
                }
                *_$_DebugRunBehavior_Async$_() {
                    if ((this._$IsBreakpoint$_() || this._$_runtime$_._$DebugBreakNext$_()) && (yield this), 
                    this._$_DebugReturnsGenerator$_()) {
                        const t = this._$_objectClass$_, e = t._$IsFamily$_(), i = t._$GetFamilyIndex$_(), r = this._$_parameters$_, n = this._$_results$_, h = this._$_func$_, o = this._$_behaviorIndex$_, a = t._$GetCurrentSol$_()._$GetInstances$_(), l = [];
                        for (let s = 0, t = a.length; s < t; ++s) {
                            const u = a[s];
                            for (let t = 0, e = r.length; t < e; ++t) n[t] = r[t]._$Get$_(s);
                            const c = e ? u._$GetObjectClass$_()._$GetFamilyBehaviorOffset$_(i) : 0;
                            l.push(yield* h.apply(u._$GetBehaviorInstances$_()[o + c]._$GetSdkInstance$_(), n));
                        }
                        return Promise.all(l);
                    }
                    return this._$_RunBehavior_Async$_();
                }
                async _$RunUserScript$_() {
                    try {
                        await this._$_func$_();
                    } catch (t) {
                        console.error(`Unhandled exception running script %c${this._$_eventBlock$_._$GetEventSheet$_()._$GetName$_()}, event ${this._$_eventBlock$_._$GetDisplayNumber$_()}, action ${this._$GetDebugIndex$_() + 1}:`, "font-size: 1.2em; font-weight: bold;", t), 
                        self.C3Debugger && self.C3Debugger._SetLastErrorScript(this), 
                        C33._$EventScript$_._$HadUserScriptException$_() || (console.info("%cTip:%c run this to highlight in Construct the last script that had an error: %cgoToLastErrorScript()", "font-weight: bold; text-decoration: underline", "", "font-weight: bold"), 
                        C33._$EventScript$_._$SetHadUserScriptException$_());
                    }
                }
                *_$DebugRunUserScript$_() {
                    return (this._$IsBreakpoint$_() || this._$_runtime$_._$DebugBreakNext$_()) && (yield this), 
                    this._$RunUserScript$_();
                }
                _$_SaveToJson$_() {
                    return this._$_savedData$_ && this._$_savedData$_.size ? {
                        ex: C33._$ToSuperJSON$_(this._$_savedData$_)
                    } : null;
                }
                _$_LoadFromJson$_(t) {
                    if (this._$_savedData$_ && (this._$_savedData$_.clear(), this._$_savedData$_ = null), 
                    t) {
                        const e = t.ex;
                        e && (this._$_savedData$_ = C33._$FromSuperJSON$_(e));
                    }
                }
            };
        }
        {
            let GetInst2 = function(t) {
                return t instanceof IInstance ? runtime._$_UnwrapScriptInterface$_(t) : t._$GetInstance$_();
            }, GetWorldInfo2 = function(t) {
                return GetInst2(t)._$GetWorldInfo$_();
            }, GetInst_SDKv22 = function(t) {
                return runtime._$_UnwrapScriptInterface$_(t);
            }, GetWorldInfo_SDKv22 = function(t) {
                return GetInst_SDKv22(t)._$GetWorldInfo$_();
            }, GetObjectClass2 = function(t) {
                return t instanceof IObjectClass ? runtime._$_UnwrapScriptInterface$_(t) : t;
            }, GetLayer2 = function(t) {
                return t instanceof ILayer ? runtime._$_UnwrapScriptInterface$_(t) : t;
            }, CollMemory_Add2 = function(t, e, s, i) {
                const r = e._$GetUID$_(), n = s._$GetUID$_();
                r < n ? t.Set(e, s, i) : t.Set(s, e, i);
            }, CollMemory_Remove2 = function(t, e, s) {
                const i = e._$GetUID$_(), r = s._$GetUID$_();
                i < r ? t._$Delete$_(e, s) : t._$Delete$_(s, e);
            }, CollMemory_RemoveInstance2 = function(t, e) {
                t._$DeleteEither$_(e);
            }, CollMemory_Get2 = function(t, e, s) {
                const i = e._$GetUID$_(), r = s._$GetUID$_();
                return i < r ? t._$Get$_(e, s) : t._$Get$_(s, e);
            }, DoOverlapCondition2 = function(t, e, s, i) {
                if (!e) return !1;
                const r = 0 !== s || 0 !== i, n = t._$GetWorldInfo$_(), h = runtime._$GetCollisionEngine$_(), o = runtime._$GetCurrentCondition$_(), a = o._$GetEventBlock$_()._$IsOrBlock$_(), l = o._$GetObjectClass$_(), u = o._$IsInverted$_(), c = e._$GetCurrentSol$_(), f = l !== e;
                rPickType = e, needsCollisionFinish = f && !u;
                let d, p = 0, m = 0, C = rPickFromElseInstances = !1;
                c._$IsSelectAll$_() ? (tempRect._$copy$_(n._$GetBoundingBox$_()), 
                tempRect.offset(s, i), h._$GetCollisionCandidates$_(n._$GetLayer$_(), e, tempRect, tempCandidates2), 
                d = tempCandidates2) : !a || runtime._$IsCurrentConditionFirst$_() && !c._$_GetOwnElseInstances$_().length && c._$_GetOwnInstances$_().length ? d = c._$_GetOwnInstances$_() : (d = c._$_GetOwnElseInstances$_(), 
                rPickFromElseInstances = !0), r && (p = n._$GetX$_(), m = n._$GetY$_(), 
                n._$OffsetXY$_(s, i), n._$SetBboxChanged$_());
                for (const g of d) if (h._$TestOverlap$_(t, g)) {
                    if (C = !0, u) break;
                    f && rToPick.add(g);
                }
                return r && (n._$SetXY$_(p, m), n._$SetBboxChanged$_()), C33._$clearArray$_(tempCandidates2), 
                C;
            }, FinishCollisionConditionPicking2 = function(t) {
                const e = runtime._$GetCurrentEvent$_()._$IsOrBlock$_(), s = rPickType._$GetCurrentSol$_(), i = s._$_GetOwnInstances$_(), r = s._$_GetOwnElseInstances$_();
                s._$IsSelectAll$_() ? (s._$SetSetPicked$_(rToPick), e && (C33._$clearArray$_(r), 
                s._$AddElseInstances$_(rToPick, rPickType._$GetInstances$_()))) : e ? rPickFromElseInstances ? s._$TransferElseInstancesToOwn$_(rToPick) : (s._$AddElseInstances$_(rToPick, i), 
                s._$SetSetPicked$_(rToPick)) : s._$SetSetPicked$_(rToPick), rPickType._$ApplySolToContainer$_();
            }, FinishCollisionCondition2 = function(t, e) {
                needsCollisionFinish && (e && FinishCollisionConditionPicking2(t), 
                rToPick.clear(), rPickType = null, needsCollisionFinish = !1);
            }, PickByUID_Normal2 = function(t, e) {
                const s = runtime._$GetInstanceByUID$_(e);
                if (s) {
                    const i = t._$GetCurrentSol$_();
                    if (i._$IsSelectAll$_() || i._$_GetOwnInstances$_().includes(s)) if (t._$IsFamily$_()) {
                        if (s._$GetObjectClass$_()._$BelongsToFamily$_(t)) return i._$PickOne$_(s), 
                        t._$ApplySolToContainer$_(), !0;
                    } else if (s._$GetObjectClass$_() === t) return i._$PickOne$_(s), 
                    t._$ApplySolToContainer$_(), !0;
                }
                return !1;
            }, PickByUID_Inverted2 = function(t, r) {
                const n = t._$GetCurrentSol$_();
                if (n._$IsSelectAll$_()) {
                    n._$_SetSelectAll$_(!1), n._$ClearArrays$_();
                    const s = t._$GetInstances$_();
                    for (let t = 0, e = s.length; t < e; ++t) {
                        const i = s[t];
                        i._$GetUID$_() === r ? n._$_PushElseInstance$_(i) : n._$_PushInstance$_(i);
                    }
                    return t._$ApplySolToContainer$_(), !!n._$_GetOwnInstances$_().length;
                }
                {
                    let s = n._$_GetOwnInstances$_(), i = 0;
                    for (let t = 0, e = s.length; t < e; ++t) {
                        const h = s[t];
                        (s[i] = h)._$GetUID$_() === r ? n._$_PushElseInstance$_(h) : ++i;
                    }
                    return C33._$truncateArray$_(s, i), t._$ApplySolToContainer$_(), 
                    !!s.length;
                }
            }, C33 = (GetInst = GetInst2, GetWorldInfo = GetWorldInfo2, GetInst_SDKv2 = GetInst_SDKv22, 
            GetWorldInfo_SDKv2 = GetWorldInfo_SDKv22, GetObjectClass = GetObjectClass2, 
            GetLayer = GetLayer2, CollMemory_Add = CollMemory_Add2, CollMemory_Remove = CollMemory_Remove2, 
            CollMemory_RemoveInstance = CollMemory_RemoveInstance2, CollMemory_Get = CollMemory_Get2, 
            DoOverlapCondition = DoOverlapCondition2, FinishCollisionConditionPicking = FinishCollisionConditionPicking2, 
            FinishCollisionCondition = FinishCollisionCondition2, PickByUID_Normal = PickByUID_Normal2, 
            PickByUID_Inverted = PickByUID_Inverted2, self._$C3$_), tempColor = new C33._$Color$_(), AnySDK = {}, SDKv1 = {}, SDKv2 = {}, runtime = null, IInstance = (C33._$CommonACES_SetRuntime$_ = function(t) {
                runtime = t;
            }, self._$IInstance$_), IObjectClass = self._$IObjectClass$_, ILayer = self._$ILayer$_, tempRect = (SDKv1._$CompareX$_ = function(t, e) {
                return C33.compare(this._$GetWorldInfo$_()._$GetX$_(), t, e);
            }, SDKv2._$CompareX$_ = function(t, e) {
                return C33.compare(this.x, t, e);
            }, SDKv1._$CompareY$_ = function(t, e) {
                return C33.compare(this._$GetWorldInfo$_()._$GetY$_(), t, e);
            }, SDKv2._$CompareY$_ = function(t, e) {
                return C33.compare(this.y, t, e);
            }, SDKv1._$IsOnScreen$_ = function() {
                return this._$GetWorldInfo$_()._$IsInViewport2$_();
            }, SDKv2._$IsOnScreen$_ = function() {
                return this._$isOnScreen$_();
            }, AnySDK._$IsOutsideLayout$_ = function() {
                const t = GetWorldInfo2(this), e = t._$GetLayout$_(), s = t._$GetBoundingBox$_();
                return s._$getRight$_() < 0 || s._$getBottom$_() < 0 || s._$getLeft$_() > e._$GetWidth$_() || s._$getTop$_() > e._$GetHeight$_();
            }, AnySDK._$PickDistance$_ = function(s, i, r) {
                const t = GetObjectClass2(this), e = t._$GetCurrentSol$_(), n = e._$GetInstances$_();
                if (!n.length) return !1;
                let h = n[0], o = h._$GetWorldInfo$_(), a = h, l = C33._$distanceSquared$_(o._$GetX$_(), o._$GetY$_(), i, r);
                for (let t = 1, e = n.length; t < e; ++t) {
                    h = n[t], o = h._$GetWorldInfo$_();
                    const u = C33._$distanceSquared$_(o._$GetX$_(), o._$GetY$_(), i, r);
                    (0 === s && u < l || 1 === s && u > l) && (l = u, a = h);
                }
                return e._$PickOne$_(a), !0;
            }, SDKv1._$SetX$_ = function(t) {
                const e = this._$GetWorldInfo$_();
                e._$GetX$_() !== t && (e._$SetX$_(t), e._$SetBboxChanged$_());
            }, SDKv2._$SetX$_ = function(t) {
                this.x = +t;
            }, SDKv1._$SetY$_ = function(t) {
                const e = this._$GetWorldInfo$_();
                e._$GetY$_() !== t && (e._$SetY$_(t), e._$SetBboxChanged$_());
            }, SDKv2._$SetY$_ = function(t) {
                this.y = +t;
            }, SDKv1._$SetPos$_ = function(t, e) {
                const s = this._$GetWorldInfo$_();
                s._$EqualsXY$_(t, e) || (s._$SetXY$_(t, e), s._$SetBboxChanged$_());
            }, SDKv2._$SetPos$_ = function(t, e) {
                this.setPosition(t, e);
            }, AnySDK._$SetPosToObject$_ = function(t, e) {
                if (t = GetObjectClass2(t)) {
                    const s = GetInst2(this), i = t._$GetPairedInstance$_(s);
                    if (i) {
                        const [ r, n ] = i._$GetImagePoint$_(e), h = s._$GetWorldInfo$_();
                        h._$GetX$_() === r && h._$GetY$_() === n || (h._$SetXY$_(r, n), 
                        h._$SetBboxChanged$_());
                    }
                }
            }, AnySDK._$MoveForward$_ = function(t) {
                if (0 !== t) {
                    const e = GetWorldInfo2(this);
                    e._$OffsetXY$_(e._$GetCosAngle$_() * t, e._$GetSinAngle$_() * t), 
                    e._$SetBboxChanged$_();
                }
            }, SDKv1._$MoveAtAngle$_ = function(t, e) {
                if (0 !== e) {
                    const s = this._$GetWorldInfo$_();
                    t = C33._$toRadians$_(t), s._$OffsetXY$_(Math.cos(t) * e, Math.sin(t) * e), 
                    s._$SetBboxChanged$_();
                }
            }, SDKv2._$MoveAtAngle$_ = function(t, e) {
                0 !== e && (t = C33._$toRadians$_(t), this._$offsetPosition$_(Math.cos(t) * e, Math.sin(t) * e));
            }, SDKv1._$GetX$_ = function() {
                return this._$GetWorldInfo$_()._$GetX$_();
            }, SDKv2._$GetX$_ = function() {
                return this.x;
            }, SDKv1._$GetY$_ = function() {
                return this._$GetWorldInfo$_()._$GetY$_();
            }, SDKv2._$GetY$_ = function() {
                return this.y;
            }, AnySDK._$GetDt$_ = function() {
                return runtime._$GetDt$_(GetInst2(this));
            }, SDKv1._$CompareWidth$_ = function(t, e) {
                return C33.compare(this._$GetWorldInfo$_()._$GetWidth$_(), t, e);
            }, SDKv2._$CompareWidth$_ = function(t, e) {
                return C33.compare(this.width, t, e);
            }, SDKv1._$CompareHeight$_ = function(t, e) {
                return C33.compare(this._$GetWorldInfo$_()._$GetHeight$_(), t, e);
            }, SDKv2._$CompareHeight$_ = function(t, e) {
                return C33.compare(this.height, t, e);
            }, SDKv1._$SetWidth$_ = function(t) {
                const e = this._$GetWorldInfo$_();
                e._$GetWidth$_() !== t && (e._$SetWidth$_(t), e._$SetBboxChanged$_());
            }, SDKv2._$SetWidth$_ = function(t) {
                this.width = t;
            }, SDKv1._$SetHeight$_ = function(t) {
                const e = this._$GetWorldInfo$_();
                e._$GetHeight$_() !== t && (e._$SetHeight$_(t), e._$SetBboxChanged$_());
            }, SDKv2._$SetHeight$_ = function(t) {
                this.height = t;
            }, SDKv1._$SetSize$_ = function(t, e) {
                const s = GetWorldInfo2(this);
                s._$GetWidth$_() === t && s._$GetHeight$_() === e || (s._$SetSize$_(t, e), 
                s._$SetBboxChanged$_());
            }, SDKv2._$SetSize$_ = function(t, e) {
                this._$setSize$_(t, e);
            }, SDKv1._$GetWidth$_ = function() {
                return this._$GetWorldInfo$_()._$GetWidth$_();
            }, SDKv2._$GetWidth$_ = function() {
                return this.width;
            }, SDKv1._$GetHeight$_ = function() {
                return this._$GetWorldInfo$_()._$GetHeight$_();
            }, SDKv2._$GetHeight$_ = function() {
                return this.height;
            }, AnySDK._$GetBboxLeft$_ = function() {
                return GetWorldInfo2(this)._$GetBoundingBox$_()._$getLeft$_();
            }, AnySDK._$GetBboxTop$_ = function() {
                return GetWorldInfo2(this)._$GetBoundingBox$_()._$getTop$_();
            }, AnySDK._$GetBboxRight$_ = function() {
                return GetWorldInfo2(this)._$GetBoundingBox$_()._$getRight$_();
            }, AnySDK._$GetBboxBottom$_ = function() {
                return GetWorldInfo2(this)._$GetBoundingBox$_()._$getBottom$_();
            }, AnySDK._$GetBboxMidX$_ = function() {
                const t = GetWorldInfo2(this)._$GetBoundingBox$_();
                return (t._$getLeft$_() + t._$getRight$_()) / 2;
            }, AnySDK._$GetBboxMidY$_ = function() {
                const t = GetWorldInfo2(this)._$GetBoundingBox$_();
                return (t._$getTop$_() + t._$getBottom$_()) / 2;
            }, AnySDK._$IsAngleWithin$_ = function(t, e) {
                return C33._$angleDiff$_(GetWorldInfo2(this).GetAngle(), C33._$toRadians$_(e)) <= C33._$toRadians$_(t);
            }, AnySDK._$IsAngleClockwiseFrom$_ = function(t) {
                return C33._$angleClockwise$_(GetWorldInfo2(this).GetAngle(), C33._$toRadians$_(t));
            }, AnySDK._$IsBetweenAngles$_ = function(t, e) {
                const s = C33._$toRadians$_(t), i = C33._$toRadians$_(e), r = GetWorldInfo2(this).GetAngle(), n = !C33._$angleClockwise$_(i, s);
                return n ? !(!C33._$angleClockwise$_(r, s) && C33._$angleClockwise$_(r, i)) : C33._$angleClockwise$_(r, s) && !C33._$angleClockwise$_(r, i);
            }, SDKv1._$SetAngle$_ = function(t) {
                const e = this._$GetWorldInfo$_(), s = C33._$clampAngle$_(C33._$toRadians$_(t));
                isNaN(s) || e.GetAngle() === s || (e._$SetAngle$_(s), e._$SetBboxChanged$_());
            }, SDKv2._$SetAngle$_ = function(t) {
                this._$angleDegrees$_ = t;
            }, AnySDK._$RotateClockwise$_ = function(t) {
                if (!isNaN(t) && 0 !== t) {
                    const e = GetWorldInfo2(this);
                    e._$SetAngle$_(e.GetAngle() + C33._$toRadians$_(t)), e._$SetBboxChanged$_();
                }
            }, AnySDK._$RotateCounterclockwise$_ = function(t) {
                if (!isNaN(t) && 0 !== t) {
                    const e = GetWorldInfo2(this);
                    e._$SetAngle$_(e.GetAngle() - C33._$toRadians$_(t)), e._$SetBboxChanged$_();
                }
            }, AnySDK._$RotateTowardAngle$_ = function(t, e) {
                const s = GetWorldInfo2(this), i = s.GetAngle(), r = C33._$angleRotate$_(i, C33._$toRadians$_(e), C33._$toRadians$_(t));
                isNaN(r) || i === r || (s._$SetAngle$_(r), s._$SetBboxChanged$_());
            }, AnySDK._$RotateTowardPosition$_ = function(t, e, s) {
                const i = GetWorldInfo2(this), r = i.GetAngle(), n = e - i._$GetX$_(), h = s - i._$GetY$_(), o = Math.atan2(h, n), a = C33._$angleRotate$_(r, o, C33._$toRadians$_(t));
                isNaN(a) || r === a || (i._$SetAngle$_(a), i._$SetBboxChanged$_());
            }, AnySDK._$SetTowardPosition$_ = function(t, e) {
                const s = GetWorldInfo2(this), i = s.GetAngle(), r = t - s._$GetX$_(), n = e - s._$GetY$_(), h = Math.atan2(n, r);
                isNaN(h) || i === h || (s._$SetAngle$_(h), s._$SetBboxChanged$_());
            }, SDKv1.GetAngle = function() {
                return C33._$toDegrees$_(this._$GetWorldInfo$_().GetAngle());
            }, SDKv2.GetAngle = function() {
                return this._$angleDegrees$_;
            }, AnySDK._$CompareOpacity$_ = function(t, e) {
                return C33.compare(C33._$roundToDp$_(100 * GetWorldInfo2(this)._$GetOpacity$_(), 6), t, e);
            }, SDKv1._$IsVisible$_ = function() {
                return this._$GetWorldInfo$_()._$IsVisible$_();
            }, SDKv2._$IsVisible$_ = function() {
                return this.isVisible;
            }, AnySDK._$SetVisible$_ = function(t) {
                const e = GetWorldInfo2(this);
                t = 2 === t ? !e._$IsVisible$_() : 0 !== t, e._$IsVisible$_() !== t && (e._$SetVisible$_(t), 
                runtime._$UpdateRender$_());
            }, AnySDK._$SetOpacity$_ = function(t) {
                const e = C33._$clamp$_(t / 100, 0, 1), s = GetWorldInfo2(this);
                if (s._$GetTransformWithParentOpacity$_()) {
                    if (s._$_GetSceneGraphInfo$_()._$GetOwnOpacity$_() === e) return;
                } else if (s._$GetOpacity$_() === e) return;
                s._$SetOpacity$_(e), runtime._$UpdateRender$_();
            }, AnySDK._$SetDefaultColor$_ = function(t) {
                tempColor._$setFromRgbValue$_(t);
                const e = GetWorldInfo2(this);
                e._$GetUnpremultipliedColor$_()._$equalsIgnoringAlpha$_(tempColor) || (e._$SetUnpremultipliedColor$_(tempColor), 
                runtime._$UpdateRender$_());
            }, AnySDK._$GetColor$_ = function() {
                const t = GetWorldInfo2(this)._$GetUnpremultipliedColor$_();
                return C33._$PackRGBAEx$_(t._$getR$_(), t._$getG$_(), t._$getB$_(), t._$getA$_());
            }, AnySDK._$GetOpacity$_ = function() {
                return C33._$roundToDp$_(100 * GetWorldInfo2(this)._$GetOpacity$_(), 6);
            }, AnySDK._$IsOnLayer$_ = function(t) {
                return !!(t = GetLayer2(t)) && GetWorldInfo2(this)._$GetLayer$_() === t;
            }, AnySDK._$PickTopBottom$_ = function(s) {
                const t = GetObjectClass2(this), e = t._$GetCurrentSol$_(), i = e._$GetInstances$_();
                if (!i.length) return !1;
                let r = i[0], n = r;
                for (let t = 1, e = i.length; t < e; ++t) {
                    const h = i[t], o = h._$GetWorldInfo$_(), a = n._$GetWorldInfo$_(), l = o._$GetLayer$_()._$GetIndex$_(), u = a._$GetLayer$_()._$GetIndex$_();
                    0 === s ? (u < l || l === u && o._$GetZIndex$_() > a._$GetZIndex$_()) && (n = h) : (l < u || l === u && o._$GetZIndex$_() < a._$GetZIndex$_()) && (n = h);
                }
                return e._$PickOne$_(n), !0;
            }, SDKv1._$CompareZElevation$_ = function(t, e, s) {
                const i = this._$GetWorldInfo$_(), r = 0 === t ? i._$GetZElevation$_() : i._$GetTotalZElevation$_();
                return C33.compare(r, e, s);
            }, SDKv2._$CompareZElevation$_ = function(t, e, s) {
                const i = 0 === t ? this._$zElevation$_ : this._$totalZElevation$_;
                return C33.compare(i, e, s);
            }, SDKv1._$MoveToTop$_ = function() {
                this._$GetWorldInfo$_()._$ZOrderMoveToTop$_();
            }, SDKv2._$MoveToTop$_ = function() {
                this._$moveToTop$_();
            }, SDKv1._$MoveToBottom$_ = function() {
                this._$GetWorldInfo$_()._$ZOrderMoveToBottom$_();
            }, SDKv2._$MoveToBottom$_ = function() {
                this._$moveToBottom$_();
            }, AnySDK._$MoveToLayer$_ = function(t) {
                (t = GetLayer2(t)) && GetWorldInfo2(this)._$ZOrderMoveToLayer$_(t);
            }, AnySDK._$ZMoveToObject$_ = function(t, e) {
                const s = 0 === t;
                if (e = GetObjectClass2(e)) {
                    const i = GetInst2(this), r = e._$GetFirstPicked$_(i);
                    r && i._$GetWorldInfo$_()._$ZOrderMoveAdjacentToInstance$_(r, s);
                }
            }, SDKv1._$SetZElevation$_ = function(t) {
                const e = this._$GetWorldInfo$_();
                e._$GetZElevation$_() !== t && (e._$SetZElevation$_(t), runtime._$UpdateRender$_());
            }, SDKv2._$SetZElevation$_ = function(t) {
                this._$zElevation$_ = t;
            }, AnySDK._$LayerNumber$_ = function() {
                return GetWorldInfo2(this)._$GetLayer$_()._$GetIndex$_();
            }, AnySDK._$LayerName$_ = function() {
                return GetWorldInfo2(this)._$GetLayer$_()._$GetName$_();
            }, SDKv1._$ZIndex$_ = function() {
                return this._$GetWorldInfo$_()._$GetZIndex$_();
            }, SDKv2._$ZIndex$_ = function() {
                return this.zIndex;
            }, SDKv1._$ZElevation$_ = function() {
                return this._$GetWorldInfo$_()._$GetZElevation$_();
            }, SDKv2._$ZElevation$_ = function() {
                return this._$zElevation$_;
            }, SDKv1._$TotalZElevation$_ = function() {
                return this._$GetWorldInfo$_()._$GetTotalZElevation$_();
            }, SDKv2._$TotalZElevation$_ = function() {
                return this._$totalZElevation$_;
            }, AnySDK._$IsEffectEnabled$_ = function(t) {
                const e = GetInst2(this), s = e._$GetObjectClass$_()._$GetEffectList$_()._$GetEffectTypeByName$_(t);
                if (s) {
                    const i = s._$GetIndex$_(), r = e._$GetWorldInfo$_()._$GetInstanceEffectList$_();
                    return r._$IsEffectIndexActive$_(i);
                }
            }, AnySDK._$SetEffectEnabled$_ = function(t, e) {
                const s = GetInst2(this), i = s._$GetObjectClass$_()._$GetEffectList$_()._$GetEffectTypeByName$_(e);
                if (i) {
                    const r = i._$GetIndex$_(), n = 1 === t, h = s._$GetWorldInfo$_()._$GetInstanceEffectList$_();
                    h._$IsEffectIndexActive$_(r) !== n && (h._$SetEffectIndexActive$_(r, n), 
                    h._$UpdateActiveEffects$_(), runtime._$UpdateRender$_());
                }
            }, AnySDK._$SetEffectParam$_ = function(t, e, s) {
                const i = GetInst2(this), r = i._$GetObjectClass$_()._$GetEffectList$_()._$GetEffectTypeByName$_(t);
                if (r) {
                    e = Math.floor(e);
                    const n = r._$GetShaderProgram$_()._$GetParameterType$_(e);
                    if (n) {
                        "color" === n ? (tempColor._$setFromRgbValue$_(s), s = tempColor) : "percent" === n && (s /= 100);
                        const h = r._$GetIndex$_(), o = i._$GetWorldInfo$_()._$GetInstanceEffectList$_(), a = o._$SetEffectParameter$_(h, e, s);
                        a && o._$IsEffectIndexActive$_(h) && runtime._$UpdateRender$_();
                    }
                }
            }, C33._$New$_(C33.Rect)), tempCandidates1 = [], tempCandidates2 = [], needsCollisionFinish = !1, rPickType = null, rPickFromElseInstances = !1, rToPick = new Set();
            function* DebugOnCollision(S) {
                if (S) {
                    let t = this._$GetRuntime$_(), e = t._$GetCollisionEngine$_(), i = t._$GetEventSheetManager$_(), s = i._$GetEventStack$_(), r = i._$GetCurrentCondition$_(), n = r._$GetObjectClass$_(), h = r._$GetSavedDataMap$_(), o = r._$GetUnsavedDataMap$_(), a = s._$GetCurrentStackFrame$_(), l = t._$GetTickCount$_(), u = l - 1, c = a._$GetCurrentEvent$_(), f = s._$Push$_(c), d = h.get("collmemory"), p = (d || (d = C33._$New$_(C33._$PairMap$_), 
                    h.set("collmemory", d)), o.get("collisionCreatedDestroyCallback") || (o.set("collisionCreatedDestroyCallback", !0), 
                    t._$Dispatcher$_().addEventListener("instancedestroy", t => CollMemory_RemoveInstance2(d, t.instance))), 
                    n._$GetCurrentSol$_()), m = S._$GetCurrentSol$_(), C = p._$GetInstances$_(), g = null;
                    for (let t = 0; t < C.length; ++t) {
                        const _ = C[t];
                        m._$IsSelectAll$_() ? (e._$GetCollisionCandidates$_(_._$GetWorldInfo$_()._$GetLayer$_(), S, _._$GetWorldInfo$_()._$GetBoundingBox$_(), tempCandidates1), 
                        g = tempCandidates1, e._$AddRegisteredCollisionCandidates$_(_, S, g)) : g = m._$GetInstances$_();
                        for (let t = 0; t < g.length; ++t) {
                            const T = g[t];
                            if (e._$TestOverlap$_(_, T) || e._$CheckRegisteredCollision$_(_, T)) {
                                let t = CollMemory_Get2(d, _, T), e = !1, s = -2;
                                "number" == typeof t && (e = !0, s = t);
                                const y = !e || s < u;
                                if (CollMemory_Add2(d, _, T, l), y) {
                                    const E = c._$GetSolModifiers$_(), A = (i._$PushCopySol$_(E), 
                                    n._$GetCurrentSol$_()), I = S._$GetCurrentSol$_();
                                    if (A._$_SetSelectAll$_(!1), I._$_SetSelectAll$_(!1), 
                                    n === S) {
                                        const M = A._$_GetOwnInstances$_();
                                        C33._$clearArray$_(M), M.push(_), M.push(T), 
                                        n._$ApplySolToContainer$_();
                                    } else {
                                        const w = A._$_GetOwnInstances$_(), v = I._$_GetOwnInstances$_();
                                        C33._$clearArray$_(w), C33._$clearArray$_(v), 
                                        w.push(_), v.push(T), n._$ApplySolToContainer$_(), 
                                        S._$ApplySolToContainer$_();
                                    }
                                    yield* c._$DebugRetrigger$_(a, f), i._$PopSol$_(E);
                                }
                            } else CollMemory_Remove2(d, _, T);
                        }
                        C33._$clearArray$_(tempCandidates1);
                    }
                    s._$Pop$_();
                }
                return !1;
            }
            AnySDK._$OnCollision$_ = function(g) {
                const t = GetObjectClass2(this), S = (g = GetObjectClass2(g), t._$GetRuntime$_());
                if (S._$IsDebugging$_()) return DebugOnCollision.call(t, g);
                if (g) {
                    let e = S._$GetCollisionEngine$_(), i = S._$GetEventSheetManager$_(), t = i._$GetEventStack$_(), s = i._$GetCurrentCondition$_(), r = s._$GetObjectClass$_(), n = s._$GetSavedDataMap$_(), h = s._$GetUnsavedDataMap$_(), o = t._$GetCurrentStackFrame$_(), a = S._$GetTickCount$_(), l = a - 1, u = o._$GetCurrentEvent$_(), c = t._$Push$_(u), f = n.get("collmemory"), d = (f || (f = C33._$New$_(C33._$PairMap$_), 
                    n.set("collmemory", f)), h.get("collisionCreatedDestroyCallback") || (h.set("collisionCreatedDestroyCallback", !0), 
                    S._$Dispatcher$_().addEventListener("instancedestroy", t => CollMemory_RemoveInstance2(f, t.instance))), 
                    r._$GetCurrentSol$_()), p = g._$GetCurrentSol$_(), m = d._$GetInstances$_(), C = null;
                    for (let t = 0; t < m.length; ++t) {
                        const _ = m[t];
                        p._$IsSelectAll$_() ? (e._$GetCollisionCandidates$_(_._$GetWorldInfo$_()._$GetLayer$_(), g, _._$GetWorldInfo$_()._$GetBoundingBox$_(), tempCandidates1), 
                        C = tempCandidates1, e._$AddRegisteredCollisionCandidates$_(_, g, C)) : C = p._$GetInstances$_();
                        for (let t = 0; t < C.length; ++t) {
                            const T = C[t];
                            if (e._$TestOverlap$_(_, T) || e._$CheckRegisteredCollision$_(_, T)) {
                                let t = CollMemory_Get2(f, _, T), e = !1, s = -2;
                                "number" == typeof t && (e = !0, s = t);
                                const y = !e || s < l;
                                if (CollMemory_Add2(f, _, T, a), y) {
                                    const E = u._$GetSolModifiers$_(), A = (i._$PushCopySol$_(E), 
                                    r._$GetCurrentSol$_()), I = g._$GetCurrentSol$_();
                                    if (A._$_SetSelectAll$_(!1), I._$_SetSelectAll$_(!1), 
                                    r === g) {
                                        const M = A._$_GetOwnInstances$_();
                                        C33._$clearArray$_(M), M.push(_), M.push(T), 
                                        r._$ApplySolToContainer$_();
                                    } else {
                                        const w = A._$_GetOwnInstances$_(), v = I._$_GetOwnInstances$_();
                                        C33._$clearArray$_(w), C33._$clearArray$_(v), 
                                        w.push(_), v.push(T), r._$ApplySolToContainer$_(), 
                                        g._$ApplySolToContainer$_();
                                    }
                                    u._$Retrigger$_(o, c), i._$PopSol$_(E);
                                }
                            } else CollMemory_Remove2(f, _, T);
                        }
                        C33._$clearArray$_(tempCandidates1);
                    }
                    t._$Pop$_();
                }
                return !1;
            }, AnySDK._$IsOverlapping$_ = function(t) {
                return t = GetObjectClass2(t), DoOverlapCondition2(GetInst2(this), t, 0, 0);
            }, AnySDK._$IsOverlappingOffset$_ = function(t, e, s) {
                return t = GetObjectClass2(t), DoOverlapCondition2(GetInst2(this), t, e, s);
            }, AnySDK._$OnHierarchyReady$_ = function() {
                return !0;
            }, AnySDK._$HasParent$_ = function() {
                return GetWorldInfo2(this)._$HasParent$_();
            }, AnySDK._$HasChildren$_ = function() {
                return GetWorldInfo2(this)._$HasChildren$_();
            }, AnySDK._$PickParent$_ = function(s, i) {
                const t = GetObjectClass2(this), e = (s = GetObjectClass2(s), t._$GetRuntime$_()), r = this._$GetCurrentSol$_(), n = r._$GetInstances$_();
                if (0 === n.length) return !1;
                let h = s._$GetCurrentSol$_(), o = h._$GetInstances$_();
                if (h._$IsSelectAll$_()) {
                    const u = [ ...e._$instancesPendingCreateForObjectClass$_(s) ];
                    0 < u.length && (o = o.concat(u));
                }
                if (0 === o.length) return !1;
                const a = h._$IsSelectAll$_() ? null : new Set(o), l = new Set();
                for (let t = 0, e = n.length; t < e; ++t) {
                    const c = n[t];
                    if (1 === i) for (const f of c._$parents$_()) f._$BelongsToObjectClass$_(s) && (null === a || a.has(f)) && l.add(f); else {
                        let t;
                        if (0 === i) {
                            if (null === (t = c._$GetParent$_())) continue;
                        } else t = c._$GetTopParent$_();
                        t._$BelongsToObjectClass$_(s) && (null === a || a.has(t)) && l.add(t);
                    }
                }
                return 0 !== l.size && (h._$SetSetPicked$_(l), s._$ApplySolToContainer$_(), 
                !0);
            }, AnySDK._$PickChildren$_ = function(s, i) {
                const t = GetObjectClass2(this), e = (s = GetObjectClass2(s), t._$GetRuntime$_()), r = t._$GetCurrentSol$_(), n = r._$GetInstances$_();
                if (0 === n.length) return !1;
                let h = s._$GetCurrentSol$_(), o = h._$GetInstances$_();
                if (h._$IsSelectAll$_()) {
                    const u = [ ...e._$instancesPendingCreateForObjectClass$_(s) ];
                    0 < u.length && (o = o.concat(u));
                }
                if (0 === o.length) return !1;
                const a = h._$IsSelectAll$_() ? null : new Set(o), l = new Set();
                for (let t = 0, e = n.length; t < e; ++t) {
                    const c = n[t];
                    2 !== i || c._$HasChildren$_() || !c._$BelongsToObjectClass$_(s) || null !== a && !a.has(c) || l.add(c);
                    for (const f of 0 === i ? c.children() : c._$allChildren$_()) 2 === i && f._$HasChildren$_() || f._$BelongsToObjectClass$_(s) && (null === a || a.has(f)) && l.add(f);
                }
                return 0 !== l.size && (h._$SetSetPicked$_(l), s._$ApplySolToContainer$_(), 
                !0);
            }, AnySDK._$PickNthChild$_ = function(s, i, r) {
                const t = GetObjectClass2(this), e = (s = GetObjectClass2(s), t._$GetRuntime$_()), n = t._$GetCurrentSol$_(), h = n._$GetInstances$_();
                if (0 === h.length) return !1;
                let o = s._$GetCurrentSol$_(), a = o._$GetInstances$_();
                if (o._$IsSelectAll$_()) {
                    const c = [ ...e._$instancesPendingCreateForObjectClass$_(s) ];
                    0 < c.length && (a = a.concat(c));
                }
                if (0 === a.length) return !1;
                const l = o._$IsSelectAll$_() ? null : new Set(a), u = [];
                for (let t = 0, e = h.length; t < e; ++t) {
                    const f = h[t];
                    if (0 === i) {
                        const d = f._$GetChildAt$_(r);
                        null !== d && d._$BelongsToObjectClass$_(s) && (null === l || l.has(d)) && u.push(d);
                    } else if (1 === i) for (const p of f.children()) if (p._$BelongsToObjectClass$_(s)) {
                        if (0 === r) {
                            null !== l && !l.has(p) || u.push(p);
                            break;
                        }
                        --r;
                    }
                }
                return 0 !== u.length && (o._$SetArrayPicked$_(u), s._$ApplySolToContainer$_(), 
                !0);
            }, AnySDK._$CompareChildCount$_ = function(t, e, s) {
                const i = GetInst2(this);
                switch (t) {
                  case 0:
                  default:
                    return C33.compare(i._$GetChildCount$_(), e, s);

                  case 1:
                    return C33.compare(i._$GetAllChildCount$_(), e, s);
                }
            }, AnySDK._$AddChild$_ = function(t, e, s, i, r, n, h, o, a, l) {
                t = GetObjectClass2(t);
                const u = GetInst2(this), c = runtime._$GetCurrentAction$_()._$GetObjectClass$_();
                for (const f of t._$allCorrespondingInstances$_(u, c)) {
                    if (!f._$GetPlugin$_()._$SupportsSceneGraph$_()) return;
                    u._$AddChild$_(f, {
                        _$transformX$_: e,
                        _$transformY$_: s,
                        _$transformWidth$_: i,
                        _$transformHeight$_: r,
                        _$transformAngle$_: n,
                        _$transformOpacity$_: h,
                        _$transformZElevation$_: o,
                        _$transformVisibility$_: a,
                        _$destroyWithParent$_: l
                    });
                }
            }, AnySDK._$RemoveChild$_ = function(t) {
                t = GetObjectClass2(t);
                const e = GetInst2(this), s = runtime._$GetCurrentAction$_()._$GetObjectClass$_();
                for (const i of t._$allCorrespondingInstances$_(e, s)) e._$RemoveChild$_(i);
            }, AnySDK._$RemoveFromParent$_ = function() {
                const t = GetInst2(this);
                if (t._$HasParent$_()) {
                    const e = t._$GetParent$_();
                    e._$RemoveChild$_(t);
                }
            }, AnySDK._$ParentUID$_ = function() {
                const t = GetInst2(this)._$GetParent$_();
                return t ? t._$GetUID$_() : -1;
            }, AnySDK._$ChildCount$_ = function() {
                return GetInst2(this)._$GetChildCount$_();
            }, AnySDK._$AllChildCount$_ = function() {
                return GetInst2(this)._$GetAllChildCount$_();
            }, AnySDK._$SetMeshSize$_ = function(t, e) {
                t = Math.floor(t), e = Math.floor(e);
                const s = GetWorldInfo2(this);
                t < 2 || e < 2 || !isFinite(t) || !isFinite(e) ? (s._$ReleaseMesh$_(), 
                s._$SetBboxChanged$_()) : s._$CreateMesh$_(t, e);
            }, AnySDK._$SetMeshPoint$_ = function(t, e, s, i, r, n, h, o) {
                const a = GetWorldInfo2(this), l = a._$SetMeshPoint$_(t, e, {
                    mode: 0 === s ? "absolute" : "relative",
                    x: i,
                    y: r,
                    _$zElevation$_: n,
                    u: h,
                    v: o
                });
                l && a._$SetBboxChanged$_();
            }, AnySDK._$MeshColumns$_ = function() {
                const t = GetWorldInfo2(this);
                return t._$HasMesh$_() ? t._$GetSourceMesh$_()._$GetHSize$_() : 0;
            }, AnySDK._$MeshRows$_ = function() {
                const t = GetWorldInfo2(this);
                return t._$HasMesh$_() ? t._$GetSourceMesh$_()._$GetVSize$_() : 0;
            }, AnySDK._$SetElementVisible$_ = function(t) {
                const e = GetWorldInfo2(this);
                t = 2 === t ? !e._$IsVisible$_() : 0 !== t, e._$IsVisible$_() !== t && e._$SetVisible$_(t);
            }, AnySDK._$SetElementCSSStyle$_ = function(t, e) {
                this instanceof self._$IInstance$_ ? this._$setElementCSSStyle$_(t, e) : this._$SetElementCSSStyle$_(t, e);
            }, AnySDK._$SetElementAttribute$_ = function(t, e) {
                this instanceof self._$IInstance$_ ? this._$setElementAttribute$_(t, "" + e) : this._$SetElementAttribute$_(t, "" + e);
            }, AnySDK._$RemoveElementAttribute$_ = function(t) {
                this instanceof self._$IInstance$_ ? this._$removeElementAttribute$_(t) : this._$RemoveElementAttribute$_(t);
            }, AnySDK._$SetElementFocus$_ = function() {
                this instanceof self._$IInstance$_ ? this._$focusElement$_() : this._$FocusElement$_();
            }, AnySDK._$SetElementBlur$_ = function() {
                this instanceof self._$IInstance$_ ? this._$blurElement$_() : this._$BlurElement$_();
            }, AnySDK._$IsElementFocused$_ = function() {
                return this instanceof self._$IInstance$_ ? this._$isElementFocused$_() : this._$IsElementFocused$_();
            }, AnySDK._$SetElementEnabled$_ = function(t) {
                this instanceof self._$IInstance$_ ? this._setEnabled(0 !== t) : this._$_SetEnabled$_(0 !== t);
            }, AnySDK._$IsElementEnabled$_ = function() {
                return this instanceof self._$IInstance$_ ? this._$_isEnabled$_() : this._$_IsEnabled$_();
            }, SDKv1._$CompareInstanceVar$_ = function(t, e, s) {
                return C33.compare(this._$GetInstance$_()._$GetInstanceVariableValue$_(t), e, s);
            }, SDKv2._$CompareInstanceVar$_ = function(t, e, s) {
                return C33.compare(GetInst_SDKv22(this)._$GetInstanceVariableValue$_(t), e, s);
            }, SDKv1._$IsBoolInstanceVarSet$_ = function(t) {
                return !!this._$GetInstance$_()._$GetInstanceVariableValue$_(t);
            }, SDKv2._$IsBoolInstanceVarSet$_ = function(t) {
                return !!GetInst_SDKv22(this)._$GetInstanceVariableValue$_(t);
            }, AnySDK._$PickInstVarHiLow$_ = function(s, i) {
                const r = GetObjectClass2(this), t = r._$GetCurrentSol$_(), n = t._$GetInstances$_();
                if (!n.length) return !1;
                let h = r._$IsFamily$_(), o = null, a = 0;
                for (let t = 0, e = n.length; t < e; ++t) {
                    const l = n[t], u = h ? l._$GetObjectClass$_()._$GetFamilyInstanceVariableOffset$_(r._$GetFamilyIndex$_()) : 0, c = l._$GetInstanceVariableValue$_(u + i);
                    (null === o || 0 === s && c < a || 1 === s && c > a) && (a = c, 
                    o = l);
                }
                return t._$PickOne$_(o), !0;
            }, AnySDK._$PickByUID$_ = function(t) {
                const e = GetObjectClass2(this);
                return (e._$GetRuntime$_()._$GetCurrentCondition$_()._$IsInverted$_() ? PickByUID_Inverted2 : PickByUID_Normal2)(e, t);
            }, AnySDK._$HasTags$_ = function(t) {
                const e = new Set(C33._$splitStringAndNormalize$_(t)), s = GetInst2(this)._$GetTagsSet$_();
                return e._$isSubsetOf$_(s);
            }, AnySDK._$Tags$_ = function() {
                return GetInst2(this)._$GetTagsString$_();
            }, AnySDK._$TagsCount$_ = function() {
                return GetInst2(this)._$GetTagsSet$_().size;
            }, AnySDK._$TagAt$_ = function(t) {
                return GetInst2(this)._$GetTagAt$_(t);
            }, AnySDK._$ChangeTags$_ = function(t, e) {
                const s = C33._$splitStringAndNormalize$_(e);
                if (0 !== s.length) {
                    const i = GetInst2(this), r = new Set(i._$GetTagsSet$_());
                    if (0 === t) for (const n of s) r.add(n); else if (1 === t) for (const h of s) r.delete(h);
                    i._$SetTagsSet$_(r);
                }
            }, AnySDK._$Destroy$_ = function() {
                runtime._$DestroyInstance$_(GetInst2(this));
            }, AnySDK._$OnCreated$_ = function() {
                return !0;
            }, AnySDK._$OnDestroyed$_ = function() {
                return !0;
            }, SDKv1._$SetInstanceVar$_ = function(t, e) {
                this._$GetInstance$_()._$SetInstanceVariableValue$_(t, e);
            }, SDKv2._$SetInstanceVar$_ = function(t, e) {
                GetInst_SDKv22(this)._$SetInstanceVariableValue$_(t, e);
            }, SDKv1._$AddInstanceVar$_ = function(t, e) {
                const s = this._$GetInstance$_(), i = s._$GetInstanceVariableValue$_(t);
                "number" == typeof i && "number" != typeof e ? e = parseFloat(e) : "string" == typeof i && "string" != typeof e && (e = e.toString()), 
                s._$SetInstanceVariableValue$_(t, i + e);
            }, SDKv2._$AddInstanceVar$_ = function(t, e) {
                const s = GetInst_SDKv22(this), i = s._$GetInstanceVariableValue$_(t);
                "number" == typeof i && "number" != typeof e ? e = parseFloat(e) : "string" == typeof i && "string" != typeof e && (e = e.toString()), 
                s._$SetInstanceVariableValue$_(t, i + e);
            }, SDKv1._$SubInstanceVar$_ = function(t, e) {
                const s = this._$GetInstance$_(), i = s._$GetInstanceVariableValue$_(t);
                "number" == typeof i && ("number" != typeof e && (e = parseFloat(e)), 
                s._$SetInstanceVariableValue$_(t, i - e));
            }, SDKv2._$SubInstanceVar$_ = function(t, e) {
                const s = GetInst_SDKv22(this), i = s._$GetInstanceVariableValue$_(t);
                "number" == typeof i && ("number" != typeof e && (e = parseFloat(e)), 
                s._$SetInstanceVariableValue$_(t, i - e));
            }, SDKv1._$SetBoolInstanceVar$_ = function(t, e) {
                this._$GetInstance$_()._$SetInstanceVariableValue$_(t, e ? 1 : 0);
            }, SDKv2._$SetBoolInstanceVar$_ = function(t, e) {
                GetInst_SDKv22(this)._$SetInstanceVariableValue$_(t, e ? 1 : 0);
            }, SDKv1._$ToggleBoolInstanceVar$_ = function(t) {
                const e = this._$GetInstance$_();
                e._$SetInstanceVariableValue$_(t, 0 === e._$GetInstanceVariableValue$_(t) ? 1 : 0);
            }, SDKv2._$ToggleBoolInstanceVar$_ = function(t) {
                const e = GetInst_SDKv22(this);
                e._$SetInstanceVariableValue$_(t, 0 === e._$GetInstanceVariableValue$_(t) ? 1 : 0);
            }, AnySDK._$LoadFromJsonString$_ = function(t) {
                let e;
                try {
                    e = JSON.parse(t);
                } catch (t) {
                    return void console.error("Failed to load from JSON string: ", t);
                }
                const s = GetInst2(this);
                runtime._$ClearIntancesNeedingAfterLoad$_(), s._$_OnBeforeLoad$_("state"), 
                s._$LoadFromJson$_(e, "state"), runtime._$DoAfterLoad$_("state", {
                    _$setFromJson$_: !0
                });
            }, AnySDK._$AsJSON$_ = function() {
                return JSON.stringify(GetInst2(this)._$SaveToJson$_("state"));
            }, AnySDK._$ObjectTypeName$_ = function() {
                return GetInst2(this)._$GetObjectClass$_()._$GetName$_();
            }, AnySDK._$Count$_ = function() {
                let t = runtime._$GetCurrentEventStackFrame$_()._$GetExpressionObjectClass$_(), e = t._$GetInstanceCount$_();
                for (const s of runtime._$instancesPendingCreateForObjectClass$_(t)) ++e;
                return e;
            }, AnySDK._$PickedCount$_ = function() {
                return runtime._$GetCurrentEventStackFrame$_()._$GetExpressionObjectClass$_()._$GetCurrentSol$_()._$GetInstances$_().length;
            }, SDKv1._$GetIID$_ = function() {
                return this._$GetInstance$_()._$GetIID$_();
            }, SDKv2._$GetIID$_ = function() {
                return GetInst_SDKv22(this)._$GetIID$_();
            }, SDKv1._$GetUID$_ = function() {
                return this._$GetInstance$_()._$GetUID$_();
            }, SDKv2._$GetUID$_ = function() {
                return GetInst_SDKv22(this)._$GetUID$_();
            }, AnySDK._$OnInstanceSignal$_ = function(t) {
                const e = GetInst2(this);
                return t.toLowerCase() === runtime._$GetEventSheetManager$_()._$GetCurrentInstanceSignalTag$_(e);
            }, AnySDK._$InstanceSignal$_ = function(t) {
                const e = GetInst2(this);
                runtime._$GetEventSheetManager$_()._$InstanceSignal$_(e, t);
            }, AnySDK._$InstanceWaitForSignal$_ = function(t) {
                const e = GetObjectClass2(this);
                return runtime._$GetEventSheetManager$_()._$AddScheduledWait$_()._$InitInstanceSignals$_(e._$GetCurrentSol$_()._$GetInstances$_(), t), 
                !0;
            }, AnySDK._$TemplateName$_ = function() {
                return GetInst2(this)._$GetTemplateName$_();
            }, C33._$AddCommonACEs$_ = function(t, e, s) {
                const i = t[1], r = t[3], n = t[4], h = t[5], o = t[6], a = t[7], l = t[8], u = t[10], c = t[11], f = t[12], d = t[13], p = t[14], m = t[15], C = t[16], g = e._$Cnds$_, S = e._$Acts$_, _ = e._$Exps$_, T = Object.assign({}, AnySDK, 2 <= s ? SDKv2 : SDKv1);
                r && (g._$CompareX$_ = T._$CompareX$_, g._$CompareY$_ = T._$CompareY$_, 
                g._$IsOnScreen$_ = T._$IsOnScreen$_, g._$IsOutsideLayout$_ = T._$IsOutsideLayout$_, 
                g._$PickDistance$_ = T._$PickDistance$_, S._$SetX$_ = T._$SetX$_, 
                S._$SetY$_ = T._$SetY$_, S._$SetPos$_ = T._$SetPos$_, S._$SetPosToObject$_ = T._$SetPosToObject$_, 
                S._$MoveForward$_ = T._$MoveForward$_, S._$MoveAtAngle$_ = T._$MoveAtAngle$_, 
                _._$X$_ = T._$GetX$_, _._$Y$_ = T._$GetY$_, _.dt = T._$GetDt$_), 
                n && (g._$CompareWidth$_ = T._$CompareWidth$_, g._$CompareHeight$_ = T._$CompareHeight$_, 
                S._$SetWidth$_ = T._$SetWidth$_, S._$SetHeight$_ = T._$SetHeight$_, 
                S._$SetSize$_ = T._$SetSize$_, _._$Width$_ = T._$GetWidth$_, _._$Height$_ = T._$GetHeight$_, 
                _._$BBoxLeft$_ = T._$GetBboxLeft$_, _._$BBoxTop$_ = T._$GetBboxTop$_, 
                _._$BBoxRight$_ = T._$GetBboxRight$_, _._$BBoxBottom$_ = T._$GetBboxBottom$_, 
                _._$BBoxMidX$_ = T._$GetBboxMidX$_, _._$BBoxMidY$_ = T._$GetBboxMidY$_), 
                h && (g._$AngleWithin$_ = T._$IsAngleWithin$_, g._$IsClockwiseFrom$_ = T._$IsAngleClockwiseFrom$_, 
                g._$IsBetweenAngles$_ = T._$IsBetweenAngles$_, S._$SetAngle$_ = T._$SetAngle$_, 
                S._$RotateClockwise$_ = T._$RotateClockwise$_, S._$RotateCounterclockwise$_ = T._$RotateCounterclockwise$_, 
                S._$RotateTowardAngle$_ = T._$RotateTowardAngle$_, S._$RotateTowardPosition$_ = T._$RotateTowardPosition$_, 
                S._$SetTowardPosition$_ = T._$SetTowardPosition$_, _._$Angle$_ = T.GetAngle), 
                o && (g._$IsVisible$_ = T._$IsVisible$_, g._$CompareOpacity$_ = T._$CompareOpacity$_, 
                S._$SetVisible$_ = T._$SetVisible$_, S._$SetOpacity$_ = T._$SetOpacity$_, 
                S._$SetDefaultColor$_ = T._$SetDefaultColor$_, _.Opacity = T._$GetOpacity$_, 
                _._$ColorValue$_ = T._$GetColor$_), a && (g._$IsOnLayer$_ = T._$IsOnLayer$_, 
                g._$PickTopBottom$_ = T._$PickTopBottom$_, g._$CompareZElevation$_ = T._$CompareZElevation$_, 
                S._$MoveToTop$_ = T._$MoveToTop$_, S._$MoveToBottom$_ = T._$MoveToBottom$_, 
                S._$MoveToLayer$_ = T._$MoveToLayer$_, S._$ZMoveToObject$_ = T._$ZMoveToObject$_, 
                S._$SetZElevation$_ = T._$SetZElevation$_, _._$LayerNumber$_ = T._$LayerNumber$_, 
                _._$LayerName$_ = T._$LayerName$_, _._$ZIndex$_ = T._$ZIndex$_, 
                _._$ZElevation$_ = T._$ZElevation$_, _._$TotalZElevation$_ = T._$TotalZElevation$_), 
                l && (g._$IsEffectEnabled$_ = T._$IsEffectEnabled$_, S._$SetEffectEnabled$_ = T._$SetEffectEnabled$_, 
                S._$SetEffectParam$_ = T._$SetEffectParam$_), d && (g._$OnHierarchyReady$_ = T._$OnHierarchyReady$_, 
                g._$HasParent$_ = T._$HasParent$_, g._$HasChildren$_ = T._$HasChildren$_, 
                g._$PickParent$_ = T._$PickParent$_, g._$PickChildren$_ = T._$PickChildren$_, 
                g._$PickNthChild$_ = T._$PickNthChild$_, g._$CompareChildCount$_ = T._$CompareChildCount$_, 
                S._$AddChild$_ = T._$AddChild$_, S._$RemoveChild$_ = T._$RemoveChild$_, 
                S._$RemoveFromParent$_ = T._$RemoveFromParent$_, _._$ParentUID$_ = T._$ParentUID$_, 
                _._$ChildCount$_ = T._$ChildCount$_, _._$AllChildCount$_ = T._$AllChildCount$_), 
                p && (S._$SetMeshSize$_ = T._$SetMeshSize$_, S._$SetMeshPoint$_ = T._$SetMeshPoint$_, 
                _._$MeshColumns$_ = T._$MeshColumns$_, _._$MeshRows$_ = T._$MeshRows$_), 
                u && (g._$IsVisible$_ = T._$IsVisible$_, S._$SetVisible$_ = T._$SetElementVisible$_, 
                S._$SetCSSStyle$_ = T._$SetElementCSSStyle$_, S._$SetElemAttribute$_ = T._$SetElementAttribute$_, 
                S._$RemoveElemAttribute$_ = T._$RemoveElementAttribute$_), c && (g._$IsFocused$_ = T._$IsElementFocused$_, 
                S._$SetFocus$_ = T._$SetElementFocus$_, S._$SetBlur$_ = T._$SetElementBlur$_), 
                f && (g._$IsEnabled$_ = T._$IsElementEnabled$_, S._$SetEnabled$_ = T._$SetElementEnabled$_), 
                m && (g._$OnCollision$_ = T._$OnCollision$_, g._$IsOverlapping$_ = T._$IsOverlapping$_, 
                g._$IsOverlappingOffset$_ = T._$IsOverlappingOffset$_, e._$FinishCollisionCondition$_ = FinishCollisionCondition2), 
                i || (g._$CompareInstanceVar$_ = T._$CompareInstanceVar$_, g._$IsBoolInstanceVarSet$_ = T._$IsBoolInstanceVarSet$_, 
                g._$PickInstVarHiLow$_ = T._$PickInstVarHiLow$_, g._$PickByUID$_ = T._$PickByUID$_, 
                g._$HasTags$_ = T._$HasTags$_, S._$SetInstanceVar$_ = T._$SetInstanceVar$_, 
                S._$AddInstanceVar$_ = T._$AddInstanceVar$_, S._$SubInstanceVar$_ = T._$SubInstanceVar$_, 
                S._$SetBoolInstanceVar$_ = T._$SetBoolInstanceVar$_, S._$ToggleBoolInstanceVar$_ = T._$ToggleBoolInstanceVar$_, 
                S._$ChangeTags$_ = T._$ChangeTags$_, g._$OnCreated$_ = T._$OnCreated$_, 
                g._$OnDestroyed$_ = T._$OnDestroyed$_, S._$Destroy$_ = T._$Destroy$_, 
                S._$LoadFromJsonString$_ || (S._$LoadFromJsonString$_ = T._$LoadFromJsonString$_), 
                _._$AsJSON$_ || (_._$AsJSON$_ = T._$AsJSON$_), _._$Count$_ = T._$Count$_, 
                _._$PickedCount$_ = T._$PickedCount$_, _._$IID$_ = T._$GetIID$_, 
                _._$UID$_ = T._$GetUID$_, _._$ObjectTypeName$_ = T._$ObjectTypeName$_, 
                _._$Tags$_ = T._$Tags$_, _._$TagsCount$_ = T._$TagsCount$_, _._$TagAt$_ = T._$TagAt$_, 
                g._$OnInstanceSignal$_ = T._$OnInstanceSignal$_, S._$InstanceSignal$_ = T._$InstanceSignal$_, 
                S._$InstanceWaitForSignal$_ = T._$InstanceWaitForSignal$_), C && (_._$TemplateName$_ = T._$TemplateName$_);
            };
        }
        {
            const C33 = self._$C3$_;
            C33._$ScheduledWait$_ = class extends C33._$DefendedBase$_ {
                constructor(t) {
                    super(), this._$_eventSheetManager$_ = t, this._$_type$_ = "", 
                    this._$_time$_ = -1, this._$_signalTag$_ = "", this._$_isSignalled$_ = !1, 
                    this._$_event$_ = null, this._$_actIndex$_ = 0, this._$_solModifiers$_ = [], 
                    this._$_dynamicSolModifiers$_ = null, this._$_sols$_ = new Map(), 
                    this._$_pendingInstances$_ = null, this._$_callingFunctionBlock$_ = null, 
                    this._$_asyncId$_ = -1, this._$_functionParameters$_ = null, 
                    this._$_functionInnerLocalVars$_ = null, this._$_shouldRelease$_ = !1;
                }
                _$Release$_() {
                    this._$_type$_ = "", this._$_time$_ = -1, this._$_signalTag$_ = "", 
                    this._$_event$_ = null, this._$_callingFunctionBlock$_ = null, 
                    this._$_functionParameters$_ = null, this._$_functionInnerLocalVars$_ = null, 
                    this._$_asyncId$_ = -1, C33._$clearArray$_(this._$_solModifiers$_), 
                    this._$_dynamicSolModifiers$_ && (this._$_dynamicSolModifiers$_.clear(), 
                    this._$_dynamicSolModifiers$_ = null);
                    for (const t of this._$_sols$_.values()) t._$Release$_();
                    this._$_sols$_.clear(), this._$_pendingInstances$_ = null;
                }
                _$_Init$_() {
                    const t = this._$_eventSheetManager$_, e = t._$GetRuntime$_()._$GetAllObjectClasses$_(), s = t._$GetCurrentEventStackFrame$_(), i = (this._$_event$_ = s._$GetCurrentEvent$_(), 
                    this._$_actIndex$_ = s._$GetActionIndex$_() + 1, t._$FindFirstFunctionBlockParent$_(this._$_event$_));
                    i && (this._$_callingFunctionBlock$_ = i, this._$_functionParameters$_ = i._$CaptureFunctionParameters$_(), 
                    this._$_functionInnerLocalVars$_ = i._$_GetAllInnerLocalVariables$_().map(t => t._$GetValue$_()), 
                    i._$IsAsync$_()) && (this._$_asyncId$_ = i._$PauseCurrentAsyncFunction$_());
                    for (const n of e) {
                        const h = n._$GetCurrentSol$_();
                        h._$IsSelectAll$_() && !this._$_event$_._$HasSolModifier$_(n) || (this._$_solModifiers$_.push(n), 
                        this._$_sols$_.set(n, C33._$New$_(C33._$SolState$_, h)));
                    }
                    const r = t._$GetDynamicSolModifiersSet$_();
                    this._$_dynamicSolModifiers$_ = 0 < r.size ? r : null;
                }
                _$InitTimer$_(t) {
                    this._$_type$_ = "timer", this._$_Init$_(), this._$_time$_ = this._$_eventSheetManager$_._$GetRuntime$_()._$GetGameTime$_() + t;
                }
                _$InitWallTimer$_(t) {
                    this._$_type$_ = "walltimer", this._$_Init$_(), this._$_time$_ = this._$_eventSheetManager$_._$GetRuntime$_()._$GetWallTime$_() + t;
                }
                _$InitSignal$_(t) {
                    this._$_type$_ = "signal", this._$_Init$_(), this._$_signalTag$_ = t.toLowerCase();
                }
                _$InitInstanceSignals$_(t, e) {
                    this._$_type$_ = "instance-signals", this._$_Init$_(), this._$_signalTag$_ = e.toLowerCase(), 
                    this._$_pendingInstances$_ = new Set(t);
                }
                _$InitPromise$_(t) {
                    this._$_type$_ = "promise", this._$_Init$_(), t.then(() => this._$SetSignalled$_()).catch(t => {
                        console.warn("[C3 runtime] Promise rejected in 'Wait for previous actions to complete': ", t), 
                        this._$SetSignalled$_();
                    });
                }
                _$IsTimer$_() {
                    return "timer" === this._$_type$_;
                }
                _$IsWallTimer$_() {
                    return "walltimer" === this._$_type$_;
                }
                _$IsSignal$_() {
                    return "signal" === this._$_type$_;
                }
                _$IsInstanceSignals$_() {
                    return "instance-signals" === this._$_type$_;
                }
                _$IsPromise$_() {
                    return "promise" === this._$_type$_;
                }
                _$GetSignalTag$_() {
                    return this._$_signalTag$_;
                }
                _$IsSignalled$_() {
                    return this._$_isSignalled$_;
                }
                _$SetSignalled$_() {
                    this._$_isSignalled$_ = !0;
                }
                _$SetInstanceSignalled$_(t) {
                    this._$_pendingInstances$_.delete(t), 0 === this._$_pendingInstances$_.size && this._$SetSignalled$_();
                }
                _$_ShouldRun$_() {
                    return this._$IsTimer$_() ? this._$_time$_ <= this._$_eventSheetManager$_._$GetRuntime$_()._$GetGameTime$_() : this._$IsWallTimer$_() ? this._$_time$_ <= this._$_eventSheetManager$_._$GetRuntime$_()._$GetWallTime$_() : this._$IsSignalled$_();
                }
                _$_RestoreState$_(t) {
                    t._$_Restore$_(this._$_event$_, this._$_actIndex$_);
                    for (const [ s, i ] of this._$_sols$_.entries()) {
                        const r = s._$GetCurrentSol$_();
                        i._$_Restore$_(r);
                    }
                    this._$_dynamicSolModifiers$_ && t._$SetDynamicSolModifiers$_([ ...this._$_dynamicSolModifiers$_ ]);
                    const e = this._$_callingFunctionBlock$_;
                    e && (e._$SetFunctionParameters$_(this._$_functionParameters$_), 
                    e._$_GetAllInnerLocalVariables$_().map((t, e) => t._$SetValue$_(this._$_functionInnerLocalVars$_[e])), 
                    e._$IsAsync$_()) && e._$ResumeAsyncFunction$_(this._$_asyncId$_);
                }
                _$_Run$_(t) {
                    this._$_RestoreState$_(t), this._$_event$_._$_ResumeActionsAndSubEvents$_(t), 
                    this._$_callingFunctionBlock$_ && this._$_callingFunctionBlock$_._$IsAsync$_() && this._$_callingFunctionBlock$_._$MaybeFinishAsyncFunctionCall$_(this._$_asyncId$_), 
                    this._$_eventSheetManager$_._$ClearSol$_(this._$_solModifiers$_), 
                    this._$_shouldRelease$_ = !0;
                }
                async _$_DebugRun$_(t) {
                    this._$_RestoreState$_(t);
                    for (const e of this._$_event$_._$_DebugResumeActionsAndSubEvents$_(t)) await this._$_eventSheetManager$_._$GetRuntime$_()._$DebugBreak$_(e);
                    this._$_callingFunctionBlock$_ && this._$_callingFunctionBlock$_._$IsAsync$_() && this._$_callingFunctionBlock$_._$MaybeFinishAsyncFunctionCall$_(this._$_asyncId$_), 
                    this._$_eventSheetManager$_._$ClearSol$_(this._$_solModifiers$_), 
                    this._$_shouldRelease$_ = !0;
                }
                _$ShouldRelease$_() {
                    return this._$_shouldRelease$_;
                }
                _$RemoveInstances$_(t) {
                    for (const e of this._$_sols$_.values()) e._$RemoveInstances$_(t);
                    if ("instance-signals" === this._$_type$_) {
                        for (const s of t) this._$_pendingInstances$_.delete(s);
                        0 === this._$_pendingInstances$_.size && this._$SetSignalled$_();
                    }
                }
                _$_SaveToJson$_() {
                    const t = {}, e = {
                        wt: this._$_type$_,
                        t: this._$_time$_,
                        st: this._$_signalTag$_,
                        s: this._$_isSignalled$_,
                        ev: this._$_event$_._$GetSID$_(),
                        sm: this._$_solModifiers$_.map(t => t._$GetSID$_()),
                        dsm: this._$_dynamicSolModifiers$_ ? [ ...this._$_dynamicSolModifiers$_ ].map(t => t._$GetSID$_()) : null,
                        sols: t
                    };
                    this._$_event$_._$_HasActionIndex$_(this._$_actIndex$_) && (e.act = this._$_event$_._$GetActionAt$_(this._$_actIndex$_)._$GetSID$_());
                    for (const [ s, i ] of this._$_sols$_) t[s._$GetSID$_().toString()] = i._$_SaveToJson$_();
                    return "instance-signals" === this._$_type$_ && (e.pi = [ ...this._$_pendingInstances$_ ].map(t => t._$GetUID$_())), 
                    e;
                }
                static _$_CreateFromJson$_(t, e) {
                    const s = t._$GetRuntime$_(), i = t._$GetEventBlockBySID$_(e.ev);
                    if (!i) return null;
                    let r = 0;
                    if (e.hasOwnProperty("act")) {
                        const h = t._$GetActionBySID$_(e.act);
                        if (!h) return null;
                        r = h._$GetIndex$_();
                    }
                    const n = C33._$New$_(C33._$ScheduledWait$_, t);
                    n._$_time$_ = e.t, e.hasOwnProperty("wt") ? n._$_type$_ = e.wt : n._$_type$_ = -1 === n._$_time$_ ? "signal" : "timer", 
                    n._$_signalTag$_ = e.st, n._$_isSignalled$_ = e.s, n._$_event$_ = i, 
                    n._$_actIndex$_ = r;
                    for (const o of e.sm) {
                        const a = s._$GetObjectClassBySID$_(o);
                        a && n._$_solModifiers$_.push(a);
                    }
                    if (Array.isArray(e.dsm)) for (const l of e.dsm) {
                        const u = s._$GetObjectClassBySID$_(l);
                        u && (n._$_dynamicSolModifiers$_ || (n._$_dynamicSolModifiers$_ = new Set()), 
                        n._$_dynamicSolModifiers$_.add(u));
                    }
                    for (const [ c, f ] of Object.entries(e.sols)) {
                        const d = parseInt(c, 10), p = s._$GetObjectClassBySID$_(d);
                        if (p) {
                            const m = C33._$New$_(C33._$SolState$_, null);
                            m._$_LoadFromJson$_(t, f), n._$_sols$_.set(p, m);
                        }
                    }
                    if ("instance-signals" === n._$_type$_) {
                        n._$_pendingInstances$_ = new Set();
                        for (const C of e.pi) {
                            const g = s._$GetInstanceByUID$_(C);
                            g && n._$_pendingInstances$_.add(g);
                        }
                    }
                    return n;
                }
            };
        }
        {
            const C33 = self._$C3$_;
            C33._$SolState$_ = class extends C33._$DefendedBase$_ {
                constructor(t) {
                    super(), this._$_objectClass$_ = null, this._$_isSelectAll$_ = !0, 
                    this._$_instances$_ = [], t && (this._$_objectClass$_ = t._$GetObjectClass$_(), 
                    this._$_isSelectAll$_ = t._$IsSelectAll$_(), C33._$shallowAssignArray$_(this._$_instances$_, t._$_GetOwnInstances$_()));
                }
                _$Release$_() {
                    this._$_objectClass$_ = null, C33._$clearArray$_(this._$_instances$_);
                }
                _$_Restore$_(t) {
                    t._$_SetSelectAll$_(this._$_isSelectAll$_), C33._$shallowAssignArray$_(t._$_GetOwnInstances$_(), this._$_instances$_);
                }
                _$RemoveInstances$_(t) {
                    C33._$arrayRemoveAllInSet$_(this._$_instances$_, t);
                }
                _$_SaveToJson$_() {
                    return {
                        sa: this._$_isSelectAll$_,
                        insts: this._$_instances$_.map(t => t._$GetUID$_())
                    };
                }
                _$_LoadFromJson$_(t, e) {
                    const s = t._$GetRuntime$_();
                    this._$_isSelectAll$_ = !!e.sa, C33._$clearArray$_(this._$_instances$_);
                    for (const i of e.insts) {
                        const r = s._$GetInstanceByUID$_(i);
                        r && this._$_instances$_.push(r);
                    }
                }
            };
        }
        {
            let GetNextParamMap2 = function(t, e) {
                let s = t.get(e);
                return s || (s = new Map(), t.set(e, s)), s;
            };
            GetNextParamMap = GetNextParamMap2;
            const C33 = self._$C3$_;
            C33._$SDKPluginBase$_ = class extends C33._$DefendedBase$_ {
                constructor(t) {
                    super(), this._$_runtime$_ = t.runtime, this._$_isSingleGlobal$_ = !!t._$isSingleGlobal$_, 
                    this._$_isWorldType$_ = !!t._$isWorld$_, this._$_isRotatable$_ = !!t._$isRotatable$_, 
                    this._$_mustPredraw$_ = !!t._$mustPredraw$_, this._$_hasEffects$_ = !!t._$hasEffects$_, 
                    this._$_supportsSceneGraph$_ = !!t._$supportsSceneGraph$_, this._$_supportsMesh$_ = !!t._$supportsMesh$_, 
                    this._$_isHTMLElementType$_ = !!t._$isHTMLElementType$_, this._$_is3d$_ = !!t._$is3d$_, 
                    this._$_sdkVersion$_ = t._$sdkVersion$_, this._$_singleGlobalObjectClass$_ = null, 
                    this._$_boundACEMethodCache$_ = new Map(), this._$_boundACEMethodCache_1param$_ = new Map(), 
                    this._$_boundACEMethodCache_2params$_ = new Map(), this._$_boundACEMethodCache_3params$_ = new Map(), 
                    this._$_scriptInterfaceClass$_ = t._$scriptInterfaceClass$_, 
                    this._$_iPlugin$_ = null;
                }
                _$Release$_() {
                    this._$_runtime$_ = null;
                }
                _$GetRuntime$_() {
                    return this._$_runtime$_;
                }
                _$OnCreate$_() {}
                _$GetConstructor$_() {
                    return (2 <= this._$GetSdkVersion$_() ? this._$_iPlugin$_ : this).constructor;
                }
                _$GetSdkVersion$_() {
                    return this._$_sdkVersion$_;
                }
                _$GetScriptInterfaceClass$_(t = !1) {
                    let e = this._$_scriptInterfaceClass$_;
                    return t && "function" != typeof e && 2 <= this._$GetSdkVersion$_() ? globalThis._$ISDKPluginBase$_ : e;
                }
                _$IsSingleGlobal$_() {
                    return this._$_isSingleGlobal$_;
                }
                _$IsWorldType$_() {
                    return this._$_isWorldType$_;
                }
                _$IsHTMLElementType$_() {
                    return this._$_isHTMLElementType$_;
                }
                _$Is3D$_() {
                    return this._$_is3d$_;
                }
                _$IsRotatable$_() {
                    return this._$_isRotatable$_;
                }
                _$MustPreDraw$_() {
                    return this._$_mustPredraw$_;
                }
                _$HasEffects$_() {
                    return this._$_hasEffects$_;
                }
                _$SupportsSceneGraph$_() {
                    return this._$_supportsSceneGraph$_;
                }
                _$SupportsMesh$_() {
                    return this._$_supportsMesh$_;
                }
                _$_GetBoundACEMethod$_(t, e) {
                    if (!e) throw new Error("missing 'this' binding");
                    let s = this._$_boundACEMethodCache$_.get(t);
                    return s || (s = t.bind(e), this._$_boundACEMethodCache$_.set(t, s)), 
                    s;
                }
                _$_GetBoundACEMethod_1param$_(t, e, s) {
                    if (!e) throw new Error("missing 'this' binding");
                    let i = GetNextParamMap2(this._$_boundACEMethodCache_1param$_, t), r = i.get(s);
                    return r || (r = t.bind(e, s), i.set(s, r)), r;
                }
                _$_GetBoundACEMethod_2params$_(t, e, s, i) {
                    if (!e) throw new Error("missing 'this' binding");
                    let r = GetNextParamMap2(this._$_boundACEMethodCache_2params$_, t), n = GetNextParamMap2(r, s), h = n.get(i);
                    return h || (h = t.bind(e, s, i), n.set(i, h)), h;
                }
                _$_GetBoundACEMethod_3params$_(t, e, s, i, r) {
                    if (!e) throw new Error("missing 'this' binding");
                    let n = GetNextParamMap2(this._$_boundACEMethodCache_3params$_, t), h = GetNextParamMap2(n, s), o = GetNextParamMap2(h, i), a = o.get(r);
                    return a || (a = t.bind(e, s, i, r), o.set(r, a)), a;
                }
                _$_SetSingleGlobalObjectClass$_(t) {
                    if (!this._$IsSingleGlobal$_()) throw new Error("must be single-global plugin");
                    this._$_singleGlobalObjectClass$_ = t;
                }
                _$GetSingleGlobalObjectClass$_() {
                    if (this._$IsSingleGlobal$_()) return this._$_singleGlobalObjectClass$_;
                    throw new Error("must be single-global plugin");
                }
                _$GetSingleGlobalInstance$_() {
                    if (this._$IsSingleGlobal$_()) return this._$_singleGlobalObjectClass$_._$GetSingleGlobalInstance$_();
                    throw new Error("must be single-global plugin");
                }
                _$_InitScriptInterface$_() {
                    const t = this._$GetSdkVersion$_(), e = (C33._$AddonManager$_._$_PushInitObject$_(this, t), 
                    this._$GetScriptInterfaceClass$_(!0));
                    if (e) {
                        if (this._$_iPlugin$_ = new e(), !(this._$_iPlugin$_ instanceof self._$IPlugin$_)) throw new TypeError("plugin class must derive from IPlugin");
                    } else this._$_iPlugin$_ = new self._$IPlugin$_();
                    C33._$AddonManager$_._$_PopInitObject$_(t);
                }
                _$GetIPlugin$_() {
                    return this._$_iPlugin$_;
                }
            };
        }
        {
            const C33 = self._$C3$_;
            C33._$SDKDOMPluginBase$_ = class extends C33._$SDKPluginBase$_ {
                constructor(t, e) {
                    super(t), this._$_domComponentId$_ = e, this._$_nextElementId$_ = 0, 
                    this._$_instMap$_ = new Map(), this._$AddElementMessageHandler$_("elem-focused", t => t._$_OnElemFocused$_()), 
                    this._$AddElementMessageHandler$_("elem-blurred", t => {
                        t && t._$_OnElemBlurred$_();
                    });
                }
                _$Release$_() {
                    super._$Release$_();
                }
                _$_AddElement$_(t) {
                    const e = this._$_nextElementId$_++;
                    return this._$_instMap$_.set(e, t), e;
                }
                _$_RemoveElement$_(t) {
                    this._$_instMap$_.delete(t);
                }
                _$AddElementMessageHandler$_(t, s) {
                    this._$_runtime$_._$AddDOMComponentMessageHandler$_(this._$_domComponentId$_, t, t => {
                        const e = this._$_instMap$_.get(t.elementId);
                        s(e, t);
                    });
                }
            };
        }
        {
            const C33 = self._$C3$_;
            C33._$SDKTypeBase$_ = class extends C33._$DefendedBase$_ {
                constructor(t) {
                    super(), this._$_objectClass$_ = t, this._$_runtime$_ = t._$GetRuntime$_(), 
                    this._$_plugin$_ = t._$GetPlugin$_();
                }
                _$Release$_() {
                    this._$_objectClass$_ = null, this._$_runtime$_ = null, this._$_plugin$_ = null;
                }
                _$GetObjectClass$_() {
                    return this._$_objectClass$_;
                }
                _$GetRuntime$_() {
                    return this._$_runtime$_;
                }
                _$GetPlugin$_() {
                    return this._$_plugin$_;
                }
                _$GetImageInfo$_() {
                    return this._$_objectClass$_._$GetImageInfo$_();
                }
                _$OnCreate$_() {}
                _$FinishCondition$_(t) {}
                _$BeforeRunAction$_(t) {}
                _$AfterRunAction$_(t) {}
                _$LoadTextures$_(t) {}
                _$ReleaseTextures$_() {}
                _$OnDynamicTextureLoadComplete$_() {}
                _$PreloadTexturesWithInstances$_(t) {}
                _$LoadTilemapData$_() {}
                _$GetScriptInterfaceClass$_() {
                    return null;
                }
                _$DispatchScriptEvent$_(t, e, s) {
                    const i = C33._$New$_(C33.Event, t, e);
                    i._$objectClass$_ = this, s && Object.assign(i, s), this._$GetObjectClass$_()._$DispatchUserScriptEvent$_(i);
                }
            };
        }
        {
            const C33 = self._$C3$_;
            C33._$SDKInstanceBase$_ = class extends C33._$DefendedBase$_ {
                constructor(t, e) {
                    super(), this._$_inst$_ = t, this._$_domComponentId$_ = e, this._$_wrapperComponentId$_ = null, 
                    this._$_runtime$_ = t._$GetRuntime$_(), this._$_objectClass$_ = this._$_inst$_._$GetObjectClass$_(), 
                    this._$_sdkType$_ = this._$_objectClass$_._$GetSdkType$_(), 
                    this._$_tickFunc$_ = null, this._$_tick2Func$_ = null, this._$_isTicking$_ = !1, 
                    this._$_isTicking2$_ = !1, this._$_disposables$_ = null, this._$_wasReleased$_ = !1;
                }
                _$Release$_() {
                    this._$_wasReleased$_ = !0, this._$_StopTicking$_(), this._$_StopTicking2$_(), 
                    this._$_tickFunc$_ = null, this._$_tick2Func$_ = null, this._$_disposables$_ && (this._$_disposables$_._$Release$_(), 
                    this._$_disposables$_ = null), this._$_inst$_ = null, this._$_runtime$_ = null, 
                    this._$_objectClass$_ = null, this._$_sdkType$_ = null;
                }
                _$WasReleased$_() {
                    return this._$_wasReleased$_;
                }
                _$GetInstance$_() {
                    return this._$_inst$_;
                }
                _$GetRuntime$_() {
                    return this._$_runtime$_;
                }
                _$GetObjectClass$_() {
                    return this._$_objectClass$_;
                }
                _$GetPlugin$_() {
                    return this._$_sdkType$_._$GetPlugin$_();
                }
                _$GetSdkType$_() {
                    return this._$_sdkType$_;
                }
                _$GetScriptInterface$_() {
                    return this._$_inst$_._$GetInterfaceClass$_();
                }
                _$Trigger$_(t) {
                    return this._$_runtime$_._$Trigger$_(t, this._$_inst$_, null);
                }
                _$DebugTrigger$_(t) {
                    return this._$_runtime$_._$DebugTrigger$_(t, this._$_inst$_, null);
                }
                _$TriggerAsync$_(t) {
                    return this._$_runtime$_._$TriggerAsync$_(t, this._$_inst$_, null);
                }
                _$FastTrigger$_(t, e) {
                    return this._$_runtime$_._$FastTrigger$_(t, this._$_inst$_, e);
                }
                _$DebugFastTrigger$_(t, e) {
                    return this._$_runtime$_._$DebugFastTrigger$_(t, this._$_inst$_, e);
                }
                _$ScheduleTriggers$_(t) {
                    return this._$_runtime$_._$ScheduleTriggers$_(t);
                }
                _$AddDOMMessageHandler$_(t, e) {
                    this._$_runtime$_._$AddDOMComponentMessageHandler$_(this._$_domComponentId$_, t, e);
                }
                _$AddDOMMessageHandlers$_(t) {
                    for (const [ e, s ] of t) this._$AddDOMMessageHandler$_(e, s);
                }
                _$PostToDOM$_(t, e) {
                    this._$_runtime$_._$PostComponentMessageToDOM$_(this._$_domComponentId$_, t, e);
                }
                _$PostToDOMAsync$_(t, e) {
                    return this._$_runtime$_._$PostComponentMessageToDOMAsync$_(this._$_domComponentId$_, t, e);
                }
                _$_PostToDOMMaybeSync$_(t, e) {
                    if (!this._$_runtime$_._$IsInWorker$_()) return window.c3_runtimeInterface._OnMessageFromRuntime({
                        type: "event",
                        component: this._$_domComponentId$_,
                        handler: t,
                        data: e,
                        responseId: null
                    });
                    this._$PostToDOM$_(t, e);
                }
                _$SetWrapperExtensionComponentId$_(t) {
                    if (!t) throw new Error("cannot set empty component id");
                    this._$_wrapperComponentId$_ = t;
                }
                _$IsWrapperExtensionAvailable$_() {
                    if (this._$_wrapperComponentId$_) return this._$_runtime$_._$HasWrapperComponentId$_(this._$_wrapperComponentId$_);
                    throw new Error("wrapper extension component id not set");
                }
                _$AddWrapperExtensionMessageHandler$_(t, e) {
                    if (!this._$_wrapperComponentId$_) throw new Error("wrapper extension component id not set");
                    this._$_runtime$_._$AddWrapperExtensionMessageHandler$_(this._$_wrapperComponentId$_, t, e);
                }
                _$AddWrapperExtensionMessageHandlers$_(t) {
                    for (const [ e, s ] of t) this._$AddWrapperExtensionMessageHandler$_(e, s);
                }
                _$SendWrapperExtensionMessage$_(t, e) {
                    if (!this._$_wrapperComponentId$_) throw new Error("wrapper extension component id not set");
                    this._$_runtime$_._$SendWrapperExtensionMessage$_(this._$_wrapperComponentId$_, t, e);
                }
                _$SendWrapperExtensionMessageAsync$_(t, e) {
                    if (this._$_wrapperComponentId$_) return this._$_runtime$_._$SendWrapperExtensionMessageAsync$_(this._$_wrapperComponentId$_, t, e);
                    throw new Error("wrapper extension component id not set");
                }
                _$Tick$_() {}
                _$Tick2$_() {}
                _$_StartTicking$_() {
                    this._$_isTicking$_ || (this._$_tickFunc$_ || (this._$_tickFunc$_ = () => this._$Tick$_()), 
                    this._$_runtime$_._$Dispatcher$_().addEventListener("tick", this._$_tickFunc$_), 
                    this._$_isTicking$_ = !0);
                }
                _$_StopTicking$_() {
                    this._$_isTicking$_ && (this._$_runtime$_._$Dispatcher$_().removeEventListener("tick", this._$_tickFunc$_), 
                    this._$_isTicking$_ = !1);
                }
                _$IsTicking$_() {
                    return this._$_isTicking$_;
                }
                _$_StartTicking2$_() {
                    this._$_isTicking2$_ || (this._$_tick2Func$_ || (this._$_tick2Func$_ = () => this._$Tick2$_()), 
                    this._$_runtime$_._$Dispatcher$_().addEventListener("tick2", this._$_tick2Func$_), 
                    this._$_isTicking2$_ = !0);
                }
                _$_StopTicking2$_() {
                    this._$_isTicking2$_ && (this._$_runtime$_._$Dispatcher$_().removeEventListener("tick2", this._$_tick2Func$_), 
                    this._$_isTicking2$_ = !1);
                }
                _$IsTicking2$_() {
                    return this._$_isTicking2$_;
                }
                _$GetDebuggerProperties$_() {
                    return [];
                }
                _$SaveToJson$_() {
                    return null;
                }
                _$LoadFromJson$_(t) {}
                _$GetPropertyValueByIndex$_(t) {}
                _$SetPropertyValueByIndex$_(t, e) {}
                _$OffsetPropertyValueByIndex$_(t, e, s) {
                    if (0 !== e) {
                        const i = this._$GetPropertyValueByIndex$_(t);
                        if ("number" != typeof i) throw new Error("expected number");
                        this._$SetPropertyValueByIndex$_(t, i + e, s);
                    }
                }
                _$SetPropertyColorOffsetValueByIndex$_(t, e, s, i) {}
                _$CallAction$_(t, ...e) {
                    t.call(this, ...e);
                }
                _$CallExpression$_(t, ...e) {
                    return t.call(this, ...e);
                }
                _$GetScriptInterfaceClass$_() {
                    return null;
                }
                _$DispatchScriptEvent$_(t, e, s) {
                    if (this._$_inst$_._$HasScriptInterface$_()) {
                        const i = this._$GetScriptInterface$_(), r = C33._$New$_(C33.Event, t, e);
                        r.instance = i, s && Object.assign(r, s), i.dispatchEvent(r);
                    }
                }
                _$MustPreDraw$_() {
                    return !1;
                }
            };
        }
        {
            const C33 = self._$C3$_;
            C33._$SDKWorldInstanceBase$_ = class extends C33._$SDKInstanceBase$_ {
                constructor(t, e) {
                    super(t, e), this._$_worldInfo$_ = t._$GetWorldInfo$_(), this._$_renderercontextlost_handler$_ = null, 
                    this._$_renderercontextrestored_handler$_ = null;
                }
                _$Release$_() {
                    if (this._$_renderercontextlost_handler$_) {
                        const t = this._$_runtime$_._$Dispatcher$_();
                        t.removeEventListener("renderercontextlost", this._$_renderercontextlost_handler$_), 
                        t.removeEventListener("renderercontextrestored", this._$_renderercontextrestored_handler$_), 
                        this._$_renderercontextlost_handler$_ = null, this._$_renderercontextrestored_handler$_ = null;
                    }
                    this._$_worldInfo$_ = null, super._$Release$_();
                }
                _$HandleWebGLContextLoss$_() {
                    this._$HandleRendererContextLoss$_();
                }
                _$OnWebGLContextLost$_() {}
                _$OnWebGLContextRestored$_() {}
                _$HandleRendererContextLoss$_() {
                    if (!this._$_renderercontextlost_handler$_) {
                        this._$_renderercontextlost_handler$_ = () => this._$OnRendererContextLost$_(), 
                        this._$_renderercontextrestored_handler$_ = () => this._$OnRendererContextRestored$_();
                        const t = this._$_runtime$_._$Dispatcher$_();
                        t.addEventListener("renderercontextlost", this._$_renderercontextlost_handler$_), 
                        t.addEventListener("renderercontextrestored", this._$_renderercontextrestored_handler$_);
                    }
                }
                _$OnRendererContextLost$_() {
                    this._$OnWebGLContextLost$_();
                }
                _$OnRendererContextRestored$_() {
                    this._$OnWebGLContextRestored$_();
                }
                _$GetWorldInfo$_() {
                    return this._$_worldInfo$_;
                }
                _$IsOriginalSizeKnown$_() {
                    return !1;
                }
                _$GetOriginalWidth$_() {
                    if (!this._$IsOriginalSizeKnown$_()) throw new Error("original size not known");
                    const t = this._$GetCurrentImageInfo$_();
                    if (t) return t._$GetWidth$_();
                }
                _$GetOriginalHeight$_() {
                    if (!this._$IsOriginalSizeKnown$_()) throw new Error("original size not known");
                    const t = this._$GetCurrentImageInfo$_();
                    if (t) return t._$GetHeight$_();
                }
                _$GetCurrentImageInfo$_() {
                    return null;
                }
                _$GetCurrentSurfaceSize$_() {
                    const t = this._$GetCurrentImageInfo$_();
                    if (t) {
                        const e = t._$GetTexture$_();
                        if (e) return [ e._$GetWidth$_(), e._$GetHeight$_() ];
                    }
                    return [ 100, 100 ];
                }
                _$GetCurrentTexRect$_() {
                    const t = this._$GetCurrentImageInfo$_();
                    return t ? t._$GetTexRect$_() : null;
                }
                _$GetCurrentTexQuad$_() {
                    const t = this._$GetCurrentImageInfo$_();
                    return t ? t._$GetTexQuad$_() : null;
                }
                _$IsCurrentTexRotated$_() {
                    const t = this._$GetCurrentImageInfo$_();
                    return !!t && t._$IsRotated$_();
                }
                _$GetImagePoint$_(t) {
                    const e = this._$_inst$_._$GetWorldInfo$_();
                    return [ e._$GetX$_(), e._$GetY$_(), e._$GetTotalZElevation$_() ];
                }
                _$LoadTilemapData$_(t, e, s) {}
                _$TestPointOverlapTile$_(t, e) {}
                _$RendersToOwnZPlane$_() {
                    return !0;
                }
            };
        }
        {
            const C33 = self._$C3$_, tempRect = C33._$New$_(C33.Rect);
            C33._$SDKDOMInstanceBase$_ = class extends C33._$SDKWorldInstanceBase$_ {
                constructor(t, e) {
                    super(t, e), this._$_elementId$_ = this._$GetPlugin$_()._$_AddElement$_(this), 
                    this._$_isElementShowing$_ = !0, this._$_elemHasFocus$_ = !1, 
                    this._$_autoFontSize$_ = !1, this._$_autoFontSizeOffset$_ = -.2, 
                    this._$_lastRect$_ = C33._$New$_(C33.Rect, 0, 0, -1, -1);
                    const s = this._$_runtime$_._$GetCanvasManager$_();
                    this._$_lastWindowWidth$_ = s._$GetLastWidth$_(), this._$_lastWindowHeight$_ = s._$GetLastHeight$_(), 
                    this._$_lastHTMLIndex$_ = -1, this._$_lastHTMLZIndex$_ = -1, 
                    this._$_isPendingUpdateState$_ = !1, this._$_StartTicking$_();
                }
                _$Release$_() {
                    this._$GetPlugin$_()._$_RemoveElement$_(this._$_elementId$_), 
                    this._$PostToDOMElement$_("destroy"), this._$_elementId$_ = -1, 
                    super._$Release$_();
                }
                _$_GetElementInDOMMode$_() {
                    if (this._$_runtime$_._$IsInWorker$_()) throw new Error("not valid in worker mode");
                    return this._$_PostToDOMElementMaybeSync$_("get-element");
                }
                _$PostToDOMElement$_(t, e) {
                    (e = e || {}).elementId = this._$_elementId$_, this._$PostToDOM$_(t, e);
                }
                _$_PostToDOMElementMaybeSync$_(t, e) {
                    return (e = e || {}).elementId = this._$_elementId$_, this._$_PostToDOMMaybeSync$_(t, e);
                }
                _$PostToDOMElementAsync$_(t, e) {
                    return (e = e || {}).elementId = this._$_elementId$_, this._$PostToDOMAsync$_(t, e);
                }
                _$CreateElement$_(t) {
                    t = t || {};
                    const e = this._$GetWorldInfo$_();
                    t.elementId = this._$_elementId$_, t.isVisible = e._$IsVisible$_(), 
                    t.htmlIndex = e._$GetLayer$_()._$GetHTMLIndex$_(), t.htmlZIndex = e._$GetHTMLZIndex$_(), 
                    Object.assign(t, this._$GetElementState$_()), this._$_isElementShowing$_ = !!t.isVisible, 
                    this._$_PostToDOMMaybeSync$_("create", t), this._$_UpdatePosition$_(!0);
                }
                _$SetElementVisible$_(t) {
                    this._$_isElementShowing$_ !== (t = !!t) && (this._$_isElementShowing$_ = t, 
                    this._$PostToDOMElement$_("set-visible", {
                        isVisible: t
                    }));
                }
                _$Tick$_() {
                    this._$_UpdatePosition$_(!1);
                }
                _$_ShouldPreserveElement$_() {
                    const t = this._$_runtime$_._$GetCanvasManager$_()._$GetFullscreenMode$_();
                    return "Android" === C33._$Platform$_._$OS$_ && ("scale-inner" === t || "scale-outer" === t || "crop" === t);
                }
                _$_UpdatePosition$_(u) {
                    if (!this._$GetInstance$_()._$IsDestroyed$_()) {
                        let t = this._$GetWorldInfo$_(), e = t._$GetLayer$_(), s = t._$GetBoundingBox$_(), [ i, r ] = e._$LayerToCanvasCss$_(s._$getLeft$_(), s._$getTop$_()), [ n, h ] = e._$LayerToCanvasCss$_(s._$getRight$_(), s._$getBottom$_()), o = this._$_runtime$_._$GetCanvasManager$_(), a = o._$GetCssWidth$_(), l = o._$GetCssHeight$_();
                        if (t._$IsVisible$_() && e._$IsVisible$_()) if (!this._$_ShouldPreserveElement$_() && (n <= 0 || h <= 0 || a <= i || l <= r)) this._$SetElementVisible$_(!1); else {
                            tempRect.set(i, r, n, h);
                            const c = o._$GetLastWidth$_(), f = o._$GetLastHeight$_(), d = e._$GetHTMLIndex$_(), p = t._$GetHTMLZIndex$_();
                            if (!u && tempRect.equals(this._$_lastRect$_) && this._$_lastWindowWidth$_ === c && this._$_lastWindowHeight$_ === f && this._$_lastHTMLIndex$_ === d && this._$_lastHTMLZIndex$_ === p) this._$SetElementVisible$_(!0); else {
                                this._$_lastRect$_._$copy$_(tempRect), this._$_lastWindowWidth$_ = c, 
                                this._$_lastWindowHeight$_ = f, this._$_lastHTMLIndex$_ = d, 
                                this._$_lastHTMLZIndex$_ = p, this._$SetElementVisible$_(!0);
                                let t = null;
                                this._$_autoFontSize$_ && (t = e._$GetDisplayScale$_() + this._$_autoFontSizeOffset$_), 
                                this._$PostToDOMElement$_("update-position", {
                                    left: Math.round(this._$_lastRect$_._$getLeft$_()),
                                    top: Math.round(this._$_lastRect$_._$getTop$_()),
                                    width: Math.round(this._$_lastRect$_.width()),
                                    height: Math.round(this._$_lastRect$_.height()),
                                    htmlIndex: d,
                                    htmlZIndex: p,
                                    fontSize: t
                                });
                            }
                        } else this._$SetElementVisible$_(!1);
                    }
                }
                _$FocusElement$_() {
                    this._$_PostToDOMElementMaybeSync$_("focus", {
                        focus: !0
                    });
                }
                _$BlurElement$_() {
                    this._$_PostToDOMElementMaybeSync$_("focus", {
                        focus: !1
                    });
                }
                _$_OnElemFocused$_() {
                    this._$_elemHasFocus$_ = !0;
                }
                _$_OnElemBlurred$_() {
                    this._$_elemHasFocus$_ = !1;
                }
                _$IsElementFocused$_() {
                    return this._$_elemHasFocus$_;
                }
                _$SetElementCSSStyle$_(t, e) {
                    this._$PostToDOMElement$_("set-css-style", {
                        prop: C33._$CSSToCamelCase$_(t),
                        val: e
                    });
                }
                _$SetElementAttribute$_(t, e) {
                    this._$PostToDOMElement$_("set-attribute", {
                        name: t,
                        val: e
                    });
                }
                _$RemoveElementAttribute$_(t) {
                    this._$PostToDOMElement$_("remove-attribute", {
                        name: t
                    });
                }
                _$UpdateElementState$_() {
                    this._$_isPendingUpdateState$_ || (this._$_isPendingUpdateState$_ = !0, 
                    Promise.resolve().then(() => {
                        this._$_isPendingUpdateState$_ = !1, this._$PostToDOMElement$_("update-state", this._$GetElementState$_());
                    }));
                }
                _$GetElementState$_() {}
                _$GetElementId$_() {
                    return this._$_elementId$_;
                }
            };
        }
        {
            const C33 = self._$C3$_, IBehavior = self._$IBehavior$_;
            C33._$SDKBehaviorBase$_ = class extends C33._$DefendedBase$_ {
                constructor(t) {
                    super(), this._$_runtime$_ = t.runtime, this._$_myObjectClasses$_ = C33._$New$_(C33._$ArraySet$_), 
                    this._$_myInstances$_ = C33._$New$_(C33._$ArraySet$_), this._$_sdkVersion$_ = t._$sdkVersion$_, 
                    this._$_scriptInterfaceClass$_ = t._$scriptInterfaceClass$_, 
                    this._$_iBehavior$_ = null;
                }
                _$Release$_() {
                    this._$_myInstances$_._$Release$_(), this._$_myObjectClasses$_._$Release$_(), 
                    this._$_runtime$_ = null;
                }
                _$GetRuntime$_() {
                    return this._$_runtime$_;
                }
                _$OnCreate$_() {}
                _$GetSdkVersion$_() {
                    return this._$_sdkVersion$_;
                }
                _$GetScriptInterfaceClass$_(t = !1) {
                    let e = this._$_scriptInterfaceClass$_;
                    return t && "function" != typeof e && 2 <= this._$GetSdkVersion$_() ? globalThis._$ISDKBehaviorBase$_ : e;
                }
                _$_AddObjectClass$_(t) {
                    this._$_myObjectClasses$_._$Add$_(t);
                }
                _$GetObjectClasses$_() {
                    return this._$_myObjectClasses$_._$GetArray$_();
                }
                _$_AddInstance$_(t) {
                    this._$_myInstances$_._$Add$_(t);
                }
                _$_RemoveInstance$_(t) {
                    this._$_myInstances$_._$Delete$_(t);
                }
                _$GetInstances$_() {
                    return this._$_myInstances$_._$GetArray$_();
                }
                _$_InitScriptInterface$_() {
                    const t = this._$GetSdkVersion$_(), e = (C33._$AddonManager$_._$_PushInitObject$_(this, t), 
                    this._$GetScriptInterfaceClass$_(!0));
                    if (e) {
                        if (this._$_iBehavior$_ = new e(), !(this._$_iBehavior$_ instanceof IBehavior)) throw new TypeError("behavior class must derive from IBehavior");
                    } else this._$_iBehavior$_ = new IBehavior();
                    C33._$AddonManager$_._$_PopInitObject$_(t);
                }
                _$GetIBehavior$_() {
                    return this._$_iBehavior$_;
                }
            };
        }
        {
            const C33 = self._$C3$_;
            C33._$SDKBehaviorTypeBase$_ = class extends C33._$DefendedBase$_ {
                constructor(t) {
                    super(), this._$_runtime$_ = t._$GetRuntime$_(), this._$_behaviorType$_ = t, 
                    this._$_objectClass$_ = t._$GetObjectClass$_(), this._$_behavior$_ = t._$GetBehavior$_(), 
                    this._$_behavior$_._$_AddObjectClass$_(this._$_objectClass$_);
                }
                _$Release$_() {
                    this._$_runtime$_ = null, this._$_behaviorType$_ = null, this._$_objectClass$_ = null, 
                    this._$_behavior$_ = null;
                }
                _$OnCreate$_() {}
                _$GetBehaviorType$_() {
                    return this._$_behaviorType$_;
                }
                _$GetObjectClass$_() {
                    return this._$_objectClass$_;
                }
                _$GetRuntime$_() {
                    return this._$_runtime$_;
                }
                _$GetBehavior$_() {
                    return this._$_behavior$_;
                }
            };
        }
        {
            const C33 = self._$C3$_;
            C33._$SDKBehaviorInstanceBase$_ = class extends C33._$DefendedBase$_ {
                constructor(t, e) {
                    super(), this._$_behInst$_ = t, this._$_domComponentId$_ = e, 
                    this._$_inst$_ = t._$GetObjectInstance$_(), this._$_runtime$_ = t._$GetRuntime$_(), 
                    this._$_behaviorType$_ = t._$GetBehaviorType$_(), this._$_sdkType$_ = this._$_behaviorType$_._$GetSdkType$_(), 
                    this._$_isTicking$_ = !1, this._$_isTicking2$_ = !1, this._$_isPostTicking$_ = !1, 
                    this._$_disposables$_ = null;
                }
                _$Release$_() {
                    this._$_StopTicking$_(), this._$_StopTicking2$_(), this._$_StopPostTicking$_(), 
                    this._$_disposables$_ && (this._$_disposables$_._$Release$_(), 
                    this._$_disposables$_ = null), this._$_behInst$_ = null, this._$_inst$_ = null, 
                    this._$_runtime$_ = null, this._$_behaviorType$_ = null, this._$_sdkType$_ = null;
                }
                _$GetBehavior$_() {
                    return this._$_behaviorType$_._$GetBehavior$_();
                }
                _$GetBehaviorInstance$_() {
                    return this._$_behInst$_;
                }
                _$GetObjectInstance$_() {
                    return this._$_inst$_;
                }
                _$GetObjectClass$_() {
                    return this._$_inst$_._$GetObjectClass$_();
                }
                _$GetWorldInfo$_() {
                    return this._$_inst$_._$GetWorldInfo$_();
                }
                _$GetRuntime$_() {
                    return this._$_runtime$_;
                }
                _$GetBehaviorType$_() {
                    return this._$_behaviorType$_;
                }
                _$GetSdkType$_() {
                    return this._$_sdkType$_;
                }
                _$GetScriptInterface$_() {
                    return this._$_behInst$_._$GetScriptInterface$_();
                }
                _$Trigger$_(t) {
                    return this._$_runtime$_._$Trigger$_(t, this._$_inst$_, this._$_behaviorType$_);
                }
                _$DebugTrigger$_(t) {
                    return this._$_runtime$_._$DebugTrigger$_(t, this._$_inst$_, this._$_behaviorType$_);
                }
                _$TriggerAsync$_(t) {
                    return this._$_runtime$_._$TriggerAsync$_(t, this._$_inst$_, this._$_behaviorType$_);
                }
                _$PostCreate$_() {}
                _$Tick$_() {}
                _$Tick2$_() {}
                _$PostTick$_() {}
                _$_StartTicking$_() {
                    this._$_isTicking$_ || (this._$_runtime$_._$_AddBehInstToTick$_(this), 
                    this._$_isTicking$_ = !0);
                }
                _$_StopTicking$_() {
                    this._$_isTicking$_ && (this._$_runtime$_._$_RemoveBehInstToTick$_(this), 
                    this._$_isTicking$_ = !1);
                }
                _$IsTicking$_() {
                    return this._$_isTicking$_;
                }
                _$_StartTicking2$_() {
                    this._$_isTicking2$_ || (this._$_runtime$_._$_AddBehInstToTick2$_(this), 
                    this._$_isTicking2$_ = !0);
                }
                _$_StopTicking2$_() {
                    this._$_isTicking2$_ && (this._$_runtime$_._$_RemoveBehInstToTick2$_(this), 
                    this._$_isTicking2$_ = !1);
                }
                _$IsTicking2$_() {
                    return this._$_isTicking2$_;
                }
                _$_StartPostTicking$_() {
                    this._$_isPostTicking$_ || (this._$_runtime$_._$_AddBehInstToPostTick$_(this), 
                    this._$_isPostTicking$_ = !0);
                }
                _$_StopPostTicking$_() {
                    this._$_isPostTicking$_ && (this._$_runtime$_._$_RemoveBehInstToPostTick$_(this), 
                    this._$_isPostTicking$_ = !1);
                }
                _$IsPostTicking$_() {
                    return this._$_isPostTicking$_;
                }
                _$GetDebuggerProperties$_() {
                    return [];
                }
                _$AddDOMMessageHandler$_(t, e) {
                    this._$_runtime$_._$AddDOMComponentMessageHandler$_(this._$_domComponentId$_, t, e);
                }
                _$OnSpriteFrameChanged$_(t, e) {}
                _$SaveToJson$_() {
                    return null;
                }
                _$LoadFromJson$_(t) {}
                _$GetPropertyValueByIndex$_(t) {}
                _$SetPropertyValueByIndex$_(t, e) {}
                _$OffsetPropertyValueByIndex$_(t, e) {
                    if (0 !== e) {
                        const s = this._$GetPropertyValueByIndex$_(t);
                        if ("number" != typeof s) throw new Error("expected number");
                        this._$SetPropertyValueByIndex$_(t, s + e);
                    }
                }
                _$SetPropertyColorOffsetValueByIndex$_(t, e, s, i) {}
                _$CallAction$_(t, ...e) {
                    t.call(this, ...e);
                }
                _$CallExpression$_(t, ...e) {
                    return t.call(this, ...e);
                }
                _$GetScriptInterfaceClass$_() {
                    return null;
                }
                _$DispatchScriptEvent$_(t, e, s) {
                    if (this._$_behInst$_._$HasScriptInterface$_()) {
                        const i = this._$GetScriptInterface$_(), r = C33._$New$_(C33.Event, t, e);
                        r._$behaviorInstance$_ = i, r.instance = i.instance, s && Object.assign(r, s), 
                        i.dispatchEvent(r);
                    }
                }
            };
        }
        {
            let ValidateInternalAPIToken2 = function(t) {
                if (t !== internalApiToken) throw new Error("invalid internal API token");
            }, C33 = (ValidateInternalAPIToken = ValidateInternalAPIToken2, self._$C3$_), internalApiToken = (C33._$Plugins$_ = {}, 
            C33._$Behaviors$_ = {}, C33._$_GetInternalAPIToken$_()), initObjectStack = [], initObjectStack2 = [], initPropertiesStack = [], originalPushInitObject = null, originalPopInitObject = null, originalGetInitObject = null, originalGetInitObject2 = null, pluginsByCtor = new Map(), behaviorsByCtor = new Map();
            C33._$AddonManager$_ = class extends C33._$DefendedBase$_ {
                constructor(t, e) {
                    super(), this._$_runtime$_ = t, this._$_allPlugins$_ = [], this._$_systemPlugin$_ = null, 
                    this._$_allBehaviors$_ = [], this._$_delayCreateBehaviors$_ = new Map(), 
                    this._$_solidBehavior$_ = null, this._$_jumpthruBehavior$_ = null, 
                    this._$_wrapperComponentIds$_ = new Set(e);
                }
                _$CreatePlugin$_(t) {
                    const e = t[19], s = this._$_runtime$_._$GetObjectReference$_(t[0]);
                    if (!s) throw new Error("missing plugin");
                    C33._$AddCommonACEs$_(t, s, e);
                    const i = 2 <= e ? C33._$SDKPluginBase$_ : s, r = C33._$New$_(i, {
                        runtime: this._$_runtime$_,
                        _$isSingleGlobal$_: t[1],
                        _$isWorld$_: t[2],
                        _$isRotatable$_: t[5],
                        _$hasEffects$_: t[8],
                        _$mustPredraw$_: t[9],
                        _$supportsSceneGraph$_: t[13],
                        _$supportsMesh$_: t[14],
                        _$isHTMLElementType$_: t[17],
                        _$is3d$_: t[18],
                        _$sdkVersion$_: e,
                        _$scriptInterfaceClass$_: 2 <= e ? s : null
                    });
                    r._$OnCreate$_(), this._$_allPlugins$_.push(r), pluginsByCtor.set(s, r);
                }
                _$CreateSystemPlugin$_() {
                    this._$_systemPlugin$_ = C33._$New$_(C33._$Plugins$_._$System$_, {
                        runtime: this._$_runtime$_,
                        _$isSingleGlobal$_: !0
                    }), this._$_systemPlugin$_._$OnCreate$_();
                }
                _$CreateBehavior$_(t) {
                    const s = t[1], i = this._$_runtime$_._$GetObjectReference$_(t[0]);
                    if (!i) throw new Error("missing behavior");
                    this._$_delayCreateBehaviors$_.set(i, () => {
                        const t = 2 <= s ? C33._$SDKBehaviorBase$_ : i, e = C33._$New$_(t, {
                            runtime: this._$_runtime$_,
                            _$sdkVersion$_: s,
                            _$scriptInterfaceClass$_: 2 <= s ? i : null
                        });
                        e._$OnCreate$_(), this._$_allBehaviors$_.push(e), behaviorsByCtor.set(i, e), 
                        !this._$_solidBehavior$_ && C33._$Behaviors$_._$solid$_ && e instanceof C33._$Behaviors$_._$solid$_ ? this._$_solidBehavior$_ = e : !this._$_jumpthruBehavior$_ && C33._$Behaviors$_._$jumpthru$_ && e instanceof C33._$Behaviors$_._$jumpthru$_ && (this._$_jumpthruBehavior$_ = e), 
                        e._$_InitScriptInterface$_();
                    });
                }
                _$_DelayCreateBehavior$_(t) {
                    const e = this._$_delayCreateBehaviors$_.get(t);
                    e && (e(), this._$_delayCreateBehaviors$_.delete(t));
                }
                static _$_PushInitObject$_(t, e = 1) {
                    if (C33._$AddonManager$_._$_PushInitObject$_ !== originalPushInitObject) throw new Error("invalid method");
                    1 === e && initObjectStack.push(t), initObjectStack2.push(t);
                }
                static _$_PopInitObject$_(t = 1) {
                    if (C33._$AddonManager$_._$_PopInitObject$_ !== originalPopInitObject) throw new Error("invalid method");
                    1 === t && initObjectStack.pop(), initObjectStack2.pop();
                }
                static _$_GetInitObject$_() {
                    if (C33._$AddonManager$_._$_GetInitObject$_ !== originalGetInitObject) throw new Error("invalid method");
                    if (0 === initObjectStack.length) throw new Error("no init object set");
                    return initObjectStack.at(-1);
                }
                static _$_GetInitObject2$_(t) {
                    if (C33._$AddonManager$_._$_GetInitObject2$_ !== originalGetInitObject2) throw new Error("invalid method");
                    if (ValidateInternalAPIToken2(t), 0 === initObjectStack2.length) throw new Error("no init object set");
                    return initObjectStack2.at(-1);
                }
                static _$_PushInitProperties$_(t) {
                    initPropertiesStack.push(t);
                }
                static _$_PopInitProperties$_() {
                    initPropertiesStack.pop();
                }
                static _$_GetInitProperties$_() {
                    if (0 === initPropertiesStack.length) throw new Error("no init properties set");
                    return initPropertiesStack.at(-1);
                }
                _$_InitAddonScriptInterfaces$_() {
                    for (const t of this._$_allPlugins$_) t._$_InitScriptInterface$_();
                }
                static _$GetPluginByConstructorFunction$_(t) {
                    return pluginsByCtor.get(t) || null;
                }
                static _$GetBehaviorByConstructorFunction$_(t) {
                    return behaviorsByCtor.get(t) || null;
                }
                _$GetSystemPlugin$_() {
                    return this._$_systemPlugin$_;
                }
                _$GetSolidBehavior$_() {
                    return this._$_solidBehavior$_;
                }
                _$GetJumpthruBehavior$_() {
                    return this._$_jumpthruBehavior$_;
                }
                _$HasWrapperComponentId$_(t) {
                    return this._$_wrapperComponentIds$_.has(t);
                }
            }, originalPushInitObject = C33._$AddonManager$_._$_PushInitObject$_, 
            originalPopInitObject = C33._$AddonManager$_._$_PopInitObject$_, originalGetInitObject = C33._$AddonManager$_._$_GetInitObject$_, 
            originalGetInitObject2 = C33._$AddonManager$_._$_GetInitObject2$_;
        }
        {
            const C33 = self._$C3$_, allImageInfos = new Set();
            C33._$ImageInfo$_ = class extends C33._$DefendedBase$_ {
                constructor() {
                    super(), this._$_generation$_ = 0, this._$_url$_ = "", this._$_size$_ = 0, 
                    this._$_offsetX$_ = 0, this._$_offsetY$_ = 0, this._$_width$_ = 0, 
                    this._$_height$_ = 0, this._$_isRotated$_ = !1, this._$_hasMetaData$_ = !1, 
                    this._$_imageAsset$_ = null, this._$_textureState$_ = "", this._$_rcTex$_ = C33._$New$_(C33.Rect), 
                    this._$_quadTex$_ = C33._$New$_(C33._$Quad$_), this._$_blobUrl$_ = "", 
                    this._$_iImageInfo$_ = new self._$IImageInfo$_(this), allImageInfos.add(this);
                }
                _$Release$_() {
                    this._$ReleaseTexture$_(), this._$_imageAsset$_ && 0 === this._$_imageAsset$_._$GetRefCount$_() && this._$_imageAsset$_._$Release$_(), 
                    this._$_imageAsset$_ = null, allImageInfos.delete(this), this._$ReleaseBlobURL$_();
                }
                static _$OnRendererContextLost$_() {
                    for (const t of allImageInfos) t._$_textureState$_ = "", t._$_rcTex$_.set(0, 0, 0, 0), 
                    t._$_quadTex$_._$setFromRect$_(t._$_rcTex$_);
                }
                _$LoadData$_(t) {
                    this._$_url$_ = t[0], this._$_size$_ = t[1], this._$_offsetX$_ = t[2], 
                    this._$_offsetY$_ = t[3], this._$_width$_ = t[4], this._$_height$_ = t[5], 
                    this._$_isRotated$_ = t[6], this._$_hasMetaData$_ = !0;
                }
                _$LoadDynamicAsset$_(t, e) {
                    if (this._$_imageAsset$_) throw new Error("already loaded asset");
                    this._$_url$_ = e;
                    const s = {};
                    return C33._$IsAbsoluteURL$_(e) && (s._$loadPolicy$_ = "remote"), 
                    this._$LoadAsset$_(t, s), this._$_imageAsset$_._$Load$_();
                }
                _$LoadDynamicBlobAsset$_(t, e) {
                    if (this._$_imageAsset$_) throw new Error("already loaded asset");
                    this._$_url$_ = "", this._$_size$_ = e.size, this._$_imageAsset$_ = C33._$New$_(C33._$ImageAsset$_, t._$GetAssetManager$_(), {
                        blob: e,
                        size: this._$_size$_,
                        _$loadPolicy$_: "local"
                    });
                }
                _$ReplaceWith$_(t) {
                    if (t === this) throw new Error("cannot replace with self");
                    this._$_generation$_++, this._$ReleaseTexture$_(), this._$_url$_ = t._$_url$_, 
                    this._$_size$_ = t._$_size$_, this._$_offsetX$_ = t._$_offsetX$_, 
                    this._$_offsetY$_ = t._$_offsetY$_, this._$_width$_ = t._$_width$_, 
                    this._$_height$_ = t._$_height$_, this._$_isRotated$_ = t._$_isRotated$_, 
                    this._$_hasMetaData$_ = t._$_hasMetaData$_, this._$_imageAsset$_ = t._$_imageAsset$_, 
                    this._$_textureState$_ = t._$_textureState$_, this._$_rcTex$_ = t._$_rcTex$_, 
                    this._$_quadTex$_ = t._$_quadTex$_, this._$ReleaseBlobURL$_();
                }
                _$GetURL$_() {
                    return this._$_url$_;
                }
                _$GetSize$_() {
                    return this._$_size$_;
                }
                _$GetOffsetX$_() {
                    return this._$_offsetX$_;
                }
                _$GetOffsetY$_() {
                    return this._$_offsetY$_;
                }
                _$IsRotated$_() {
                    return this._$_isRotated$_;
                }
                _$GetWidth$_() {
                    return this._$_width$_;
                }
                _$GetHeight$_() {
                    return this._$_height$_;
                }
                _$GetSheetWidth$_() {
                    return this._$_imageAsset$_._$GetWidth$_();
                }
                _$GetSheetHeight$_() {
                    return this._$_imageAsset$_._$GetHeight$_();
                }
                _$LoadAsset$_(t, e) {
                    if (this._$_imageAsset$_) throw new Error("already got asset");
                    e = Object.assign({}, e, {
                        url: this._$GetURL$_(),
                        size: this._$GetSize$_()
                    }), this._$_imageAsset$_ = t._$LoadImage$_(e);
                }
                _$IsLoaded$_() {
                    return this._$_imageAsset$_ && this._$_imageAsset$_._$IsLoaded$_();
                }
                async _$LoadStaticTexture$_(t, e) {
                    if (!this._$_imageAsset$_) throw new Error("no asset");
                    if (this._$_textureState$_) throw new Error("already loaded texture");
                    const s = this._$_generation$_, i = (this._$_textureState$_ = "loading", 
                    await this._$_imageAsset$_._$LoadStaticTexture$_(t, e));
                    if (this._$_generation$_ !== s) return null;
                    if (!i) return this._$_textureState$_ = "", null;
                    this._$_textureState$_ = "loaded", this._$_hasMetaData$_ || (this._$_width$_ = i._$GetWidth$_(), 
                    this._$_height$_ = i._$GetHeight$_(), this._$_hasMetaData$_ = !0);
                    const r = this._$_isRotated$_ ? this._$_height$_ : this._$_width$_, n = this._$_isRotated$_ ? this._$_width$_ : this._$_height$_;
                    return this._$_rcTex$_.set(this._$_offsetX$_, this._$_offsetY$_, this._$_offsetX$_ + r, this._$_offsetY$_ + n), 
                    this._$_rcTex$_._$divide$_(i._$GetWidth$_(), i._$GetHeight$_()), 
                    this._$_quadTex$_._$setFromRect$_(this._$_rcTex$_), this._$_isRotated$_ && this._$_quadTex$_._$rotatePointsAnticlockwise$_(), 
                    i;
                }
                _$ReleaseTexture$_() {
                    this._$_textureState$_ && (this._$_imageAsset$_ && this._$_imageAsset$_._$ReleaseTexture$_(), 
                    this._$_textureState$_ = "", this._$_rcTex$_.set(0, 0, 0, 0), 
                    this._$_quadTex$_._$setFromRect$_(this._$_rcTex$_));
                }
                _$GetTexture$_() {
                    return this._$_imageAsset$_ && "loaded" === this._$_textureState$_ ? this._$_imageAsset$_._$GetTexture$_() : null;
                }
                _$GetTexRect$_() {
                    return this._$_rcTex$_;
                }
                _$GetTexQuad$_() {
                    return this._$_quadTex$_;
                }
                _$GetIImageInfo$_() {
                    return this._$_iImageInfo$_;
                }
                _$GetImageAsset$_() {
                    return this._$_imageAsset$_;
                }
                async _$ExtractImageToCanvas$_(t) {
                    t = t || await this._$_imageAsset$_._$LoadToDrawable$_();
                    const e = C33._$CreateCanvas$_(this._$_width$_, this._$_height$_), s = e.getContext("2d");
                    return this._$_isRotated$_ ? (s.rotate(Math.PI / -2), s.translate(-this._$_height$_, 0), 
                    s.drawImage(t, this._$_offsetX$_, this._$_offsetY$_, this._$_height$_, this._$_width$_, 0, 0, this._$_height$_, this._$_width$_)) : s.drawImage(t, this._$_offsetX$_, this._$_offsetY$_, this._$_width$_, this._$_height$_, 0, 0, this._$_width$_, this._$_height$_), 
                    e;
                }
                async _$ExtractImageToBlobURL$_(t) {
                    if (!this._$_blobUrl$_) {
                        const e = await this._$ExtractImageToCanvas$_(t), s = await C33._$CanvasToBlob$_(e);
                        this._$_blobUrl$_ = URL.createObjectURL(s);
                    }
                    return this._$_blobUrl$_;
                }
                _$ReleaseBlobURL$_() {
                    this._$_blobUrl$_ && (URL.revokeObjectURL(this._$_blobUrl$_), 
                    this._$_blobUrl$_ = "");
                }
            };
        }
        {
            const C33 = self._$C3$_;
            C33._$AnimationInfo$_ = class extends C33._$DefendedBase$_ {
                constructor(t) {
                    super(), this._$_name$_ = t[0], this._$_speed$_ = t[1], this._$_isLooping$_ = !!t[2], 
                    this._$_repeatCount$_ = t[3], this._$_repeatTo$_ = t[4], this._$_isPingPong$_ = !!t[5], 
                    this._$_sid$_ = t[6], this._$_frames$_ = t[7].map(t => C33._$New$_(C33._$AnimationFrameInfo$_, t)), 
                    this._$_iAnimation$_ = new self._$IAnimation$_(this);
                }
                static _$CreateDynamic$_(t, e) {
                    const s = C33._$New$_(C33._$AnimationInfo$_, [ e, 0, !1, 0, 0, !1, Math.floor(1e15 * Math.random()), [] ]);
                    return s._$_frames$_.push(C33._$AnimationFrameInfo$_._$CreateDynamic$_(t)), 
                    s;
                }
                _$Release$_() {
                    for (const t of this._$_frames$_) t._$Release$_();
                    C33._$clearArray$_(this._$_frames$_);
                }
                _$LoadAllAssets$_(t) {
                    for (const e of this._$_frames$_) e._$GetImageInfo$_()._$LoadAsset$_(t);
                }
                _$LoadAllTextures$_(e, s) {
                    return Promise.all(this._$_frames$_.map(t => t._$GetImageInfo$_()._$LoadStaticTexture$_(e, s)));
                }
                _$ReleaseAllTextures$_() {
                    for (const t of this._$_frames$_) t._$GetImageInfo$_()._$ReleaseTexture$_();
                }
                _$GetName$_() {
                    return this._$_name$_;
                }
                _$GetSID$_() {
                    return this._$_sid$_;
                }
                _$GetFrameCount$_() {
                    return this._$_frames$_.length;
                }
                _$GetFrames$_() {
                    return this._$_frames$_;
                }
                _$GetFrameAt$_(t) {
                    if ((t = Math.floor(t)) < 0 || t >= this._$_frames$_.length) throw new RangeError("invalid frame");
                    return this._$_frames$_[t];
                }
                _$InsertFrameAt$_(t, e) {
                    (e = Math.floor(e)) < 0 ? this._$_frames$_.unshift(t) : e >= this._$_frames$_.length ? this._$_frames$_.push(t) : this._$_frames$_.splice(e, 0, t);
                }
                _$RemoveFrameAt$_(t) {
                    if ((t = Math.floor(t)) < 0 || t >= this._$_frames$_.length) throw new RangeError("invalid frame");
                    this._$_frames$_[t]._$Release$_(), this._$_frames$_.splice(t, 1);
                }
                _$GetFrameIndexByTag$_(s) {
                    for (let t = 0, e = this._$_frames$_.length; t < e; ++t) if (C33._$equalsNoCase$_(this._$_frames$_[t]._$GetTag$_(), s)) return t;
                    return -1;
                }
                _$FrameTagOrIndexToIndex$_(t) {
                    if ("string" != typeof t) return t;
                    {
                        const e = this._$GetFrameIndexByTag$_(t);
                        if (-1 === e) throw new Error("cannot find animation frame with tag " + t);
                        return e;
                    }
                }
                _$GetSpeed$_() {
                    return this._$_speed$_;
                }
                _$IsLooping$_() {
                    return this._$_isLooping$_;
                }
                _$GetRepeatCount$_() {
                    return this._$_repeatCount$_;
                }
                _$GetRepeatTo$_() {
                    return this._$_repeatTo$_;
                }
                _$IsPingPong$_() {
                    return this._$_isPingPong$_;
                }
                _$GetIAnimation$_() {
                    return this._$_iAnimation$_;
                }
            };
        }
        {
            const C33 = self._$C3$_, EMPTY_IMAGE_BLOB = (() => {
                const s = atob("iVBORw0KGgoAAAANSUhEUgAAAGQAAABkAQMAAABKLAcXAAAAAXNSR0IArs4c6QAAAANQTFRFAAAAp3o92gAAAAF0Uk5TAEDm2GYAAAATSURBVBgZYxgFo2AUjIJRQFcAAAV4AAHcRQIbAAAAAElFTkSuQmCC"), i = new Uint8Array(s.length);
                for (let t = 0, e = s.length; t < e; ++t) i[t] = s.charCodeAt(t);
                return new Blob([ i ], {
                    type: "image/png"
                });
            })();
            C33._$AnimationFrameInfo$_ = class extends C33._$DefendedBase$_ {
                constructor(t) {
                    super(), this._$_imageInfo$_ = C33._$New$_(C33._$ImageInfo$_), 
                    this._$_imageInfo$_._$LoadData$_(t), this._$_duration$_ = t[7], 
                    this._$_origin$_ = C33._$New$_(C33._$Vector2$_, t[8], t[9]), 
                    this._$_imagePoints$_ = t[10].map(t => C33._$New$_(C33._$ImagePoint$_, this, t)), 
                    this._$_imagePointsByName$_ = new Map();
                    for (const s of this._$_imagePoints$_) this._$_imagePointsByName$_.set(s._$GetName$_().toLowerCase(), s);
                    this._$_collisionPoly$_ = null;
                    const e = t[11];
                    6 <= e.length && (this._$_collisionPoly$_ = C33._$New$_(C33._$CollisionPoly$_, e)), 
                    this._$_tag$_ = t[12] || "", this._$_iAnimationFrame$_ = new self._$IAnimationFrame$_(this);
                }
                static _$CreateDynamic$_(t) {
                    const e = C33._$New$_(C33._$AnimationFrameInfo$_, [ "", 0, 0, 0, 100, 100, !1, 1, 0, 0, [], [], "" ]);
                    return e._$_imageInfo$_._$LoadDynamicBlobAsset$_(t, EMPTY_IMAGE_BLOB), 
                    e;
                }
                _$Release$_() {
                    this._$_collisionPoly$_ && (this._$_collisionPoly$_._$Release$_(), 
                    this._$_collisionPoly$_ = null), this._$_imageInfo$_._$Release$_(), 
                    this._$_imageInfo$_ = null;
                }
                _$GetImageInfo$_() {
                    return this._$_imageInfo$_;
                }
                _$GetDuration$_() {
                    return this._$_duration$_;
                }
                _$GetOriginX$_() {
                    return this._$_origin$_._$getX$_();
                }
                _$GetOriginY$_() {
                    return this._$_origin$_._$getY$_();
                }
                _$GetCollisionPoly$_() {
                    return this._$_collisionPoly$_;
                }
                _$GetImagePointByName$_(t) {
                    return this._$_imagePointsByName$_.get(t.toLowerCase()) || null;
                }
                _$GetImagePointByIndex$_(t) {
                    return (t = Math.floor(t)) < 0 || t >= this._$_imagePoints$_.length ? null : this._$_imagePoints$_[t];
                }
                _$GetImagePointCount$_() {
                    return this._$_imagePoints$_.length;
                }
                _$GetTag$_() {
                    return this._$_tag$_;
                }
                _$GetIAnimationFrame$_() {
                    return this._$_iAnimationFrame$_;
                }
            };
        }
        {
            const C33 = self._$C3$_;
            C33._$ImagePoint$_ = class extends C33._$DefendedBase$_ {
                constructor(t, e) {
                    super(), this._$_afi$_ = t, this._$_name$_ = e[0], this._$_pos$_ = C33._$New$_(C33._$Vector2$_, e[1], e[2]);
                }
                _$Release$_() {}
                _$GetName$_() {
                    return this._$_name$_;
                }
                _$GetX$_() {
                    return this._$_pos$_._$getX$_();
                }
                _$GetY$_() {
                    return this._$_pos$_._$getY$_();
                }
                _$GetVec2$_() {
                    return this._$_pos$_;
                }
            };
        }
        {
            const C33 = self._$C3$_, C3Debugger = self.C3Debugger, IObjectClass = self._$IObjectClass$_, assert = self.assert;
            C33._$ObjectClass$_ = class extends C33._$DefendedBase$_ {
                constructor(e, t, s) {
                    super();
                    const i = e._$GetObjectReference$_(s[1]), [ r, n ] = (this._$_runtime$_ = e, 
                    this._$_plugin$_ = C33._$AddonManager$_._$GetPluginByConstructorFunction$_(i), 
                    this._$_sdkType$_ = null, this._$_instSdkCtor$_ = i.Instance, 
                    this._$_index$_ = t, this._$_sid$_ = s[11], this._$_name$_ = s[0], 
                    this._$_jsPropName$_ = this._$_runtime$_._$GetJsPropName$_(s[14]), 
                    this._$_isGlobal$_ = !!s[9], this._$_isFamily$_ = !!s[2], this._$_isOnLoaderLayout$_ = !!s[10], 
                    this._$_instVars$_ = s[3].map(t => ({
                        sid: t[0],
                        type: t[1],
                        name: t[2],
                        _$jsPropName$_: e._$GetJsPropName$_(t[3])
                    })), this._$_behaviorsCount$_ = s[4], this._$_effectsCount$_ = s[5], 
                    this._$_isWorldType$_ = this._$_plugin$_._$IsWorldType$_(), 
                    this._$_dispatcher$_ = C33._$New$_(C33.Event._$Dispatcher$_), 
                    this._$_effectList$_ = null, e._$GetCollisionEngine$_()._$GetCollisionCellSize$_());
                    if (this._$_collisionGrid$_ = C33._$New$_(C33._$SparseGrid$_, r, n), 
                    this._$_anyCollisionCellChanged$_ = !0, this._$_familyMembers$_ = null, 
                    this._$_familyMembersSet$_ = null, this._$_familyIndex$_ = -1, 
                    this._$_families$_ = null, this._$_familiesSet$_ = null, this._$_familyInstVarMap$_ = null, 
                    this._$_familyBehaviorMap$_ = null, this._$_familyEffectMap$_ = null, 
                    this._$_isInContainer$_ = !1, this._$_container$_ = null, this._$_behaviorTypes$_ = s[8].map(t => C33._$BehaviorType$_._$Create$_(this, t)), 
                    this._$_behaviorTypesIncludingInherited$_ = [], this._$_behaviorsByName$_ = new Map(), 
                    this._$_behaviorNameToIndex$_ = new Map(), this._$_usedBehaviorCtors$_ = new Set(), 
                    this._$_customActionMap$_ = new Map(), this._$_solStack$_ = C33._$New$_(C33._$SolStack$_, this), 
                    this._$_defaultInstanceData$_ = null, this._$_defaultLayerIndex$_ = 0, 
                    this._$_isContained$_ = !1, this._$_container$_ = null, this._$_imageInfo$_ = null, 
                    this._$_animations$_ = null, this._$_animationsByName$_ = null, 
                    this._$_animationsBySid$_ = null, this._$_textureRefCount$_ = 0, 
                    this._$_savedData$_ = new Map(), this._$_unsavedData$_ = new Map(), 
                    this._$_instances$_ = [], this._$_worldInfosByLayer$_ = new Map(), 
                    this._$_iidsStale$_ = !0, this._$_plugin$_._$HasEffects$_() && (this._$_effectList$_ = C33._$New$_(C33._$EffectList$_, this, s[12])), 
                    s[6] && (this._$_imageInfo$_ = C33._$New$_(C33._$ImageInfo$_), 
                    this._$_imageInfo$_._$LoadData$_(s[6])), s[7]) {
                        this._$_animations$_ = s[7].map(t => C33._$New$_(C33._$AnimationInfo$_, t)), 
                        this._$_animationsByName$_ = new Map(), this._$_animationsBySid$_ = new Map();
                        for (const a of this._$_animations$_) this._$_animationsByName$_.set(a._$GetName$_().toLowerCase(), a), 
                        this._$_animationsBySid$_.set(a._$GetSID$_(), a);
                    }
                    this._$_isFamily$_ ? (this._$_familyMembers$_ = [], this._$_familyMembersSet$_ = new Set(), 
                    this._$_familyIndex$_ = this._$_runtime$_._$_GetNextFamilyIndex$_()) : (this._$_families$_ = [], 
                    this._$_familiesSet$_ = new Set(), this._$_familyInstVarMap$_ = [], 
                    this._$_familyBehaviorMap$_ = [], this._$_familyEffectMap$_ = []);
                    const h = this._$_plugin$_._$GetSdkVersion$_();
                    if (h < 2 && (this._$_sdkType$_ = C33._$New$_(i._$Type$_, this, s[15]), 
                    !(this._$_sdkType$_ instanceof C33._$SDKTypeBase$_))) throw new Error("v1 sdk type must derive from SDKTypeBase");
                    this._$_iObjectClass$_ = null, this._$_instanceUserScriptClass$_ = null, 
                    this._$_userScriptDispatcher$_ = C33._$New$_(C33.Event._$Dispatcher$_), 
                    C33._$AddonManager$_._$_PushInitObject$_(this, h);
                    let o;
                    if (o = 2 <= h ? (o = i._$Type$_) || globalThis._$ISDKObjectTypeBase$_ : this._$_sdkType$_._$GetScriptInterfaceClass$_()) {
                        if (this._$_iObjectClass$_ = new o(h < 2 ? this : null), 
                        h < 2 && !(this._$_iObjectClass$_ instanceof IObjectClass)) throw new TypeError("script interface class must derive from IObjectClass");
                        if (2 <= h && !(this._$_iObjectClass$_ instanceof globalThis._$ISDKObjectTypeBase$_)) throw new TypeError("script interface class must derive from ISDKObjectTypeBase");
                    } else this._$_iObjectClass$_ = new IObjectClass();
                    if (C33._$AddonManager$_._$_PopInitObject$_(h), s[13]) {
                        const l = s[13];
                        if (l) {
                            const u = l[0], c = l[1], f = l[2];
                            this._$_sdkType$_._$LoadTilemapData$_(u, c, f);
                        }
                    }
                    this._$_runtime$_._$UsesLoaderLayout$_() && !this._$_isFamily$_ && !this._$_isOnLoaderLayout$_ && this._$_isWorldType$_ || this._$OnCreate$_(), 
                    this._$_plugin$_._$IsSingleGlobal$_() && (this._$_plugin$_._$_SetSingleGlobalObjectClass$_(this), 
                    this._$_CreateSingleGlobalInstance$_(s)), this._$_loadInstancesJson$_ = null;
                }
                static _$Create$_(t, e, s) {
                    return C33._$New$_(C33._$ObjectClass$_, t, e, s);
                }
                _$Release$_() {
                    if (this._$_dispatcher$_._$Release$_(), this._$_dispatcher$_ = null, 
                    this._$_imageInfo$_ && (this._$_imageInfo$_._$Release$_(), this._$_imageInfo$_ = null), 
                    this._$_animations$_) {
                        for (const t of this._$_animations$_) t._$Release$_();
                        C33._$clearArray$_(this._$_animations$_), this._$_animationsByName$_.clear(), 
                        this._$_animationsBySid$_.clear();
                    }
                    this._$_loadInstancesJson$_ = null, this._$_solStack$_._$Release$_(), 
                    this._$_solStack$_ = null, this._$_savedData$_.clear(), this._$_unsavedData$_.clear(), 
                    this._$_container$_ = null, this._$_runtime$_ = null;
                }
                _$_LoadFamily$_(s) {
                    for (let t = 1, e = s.length; t < e; ++t) {
                        const i = this._$_runtime$_._$GetObjectClassByIndex$_(s[t]);
                        this._$_familyMembers$_.push(i), this._$_familyMembersSet$_.add(i), 
                        i._$_families$_.push(this), i._$_familiesSet$_.add(this);
                    }
                }
                _$_SetContainer$_(t) {
                    this._$_isInContainer$_ = !0, this._$_container$_ = t;
                }
                _$IsInContainer$_() {
                    return this._$_isInContainer$_;
                }
                _$GetContainer$_() {
                    return this._$_container$_;
                }
                _$_OnAfterCreate$_() {
                    let t = 0;
                    if (!this._$_isFamily$_) for (const e of this._$_families$_) for (const s of e._$GetBehaviorTypes$_()) {
                        const i = s._$GetName$_().toLowerCase();
                        this._$_behaviorsByName$_.set(i, s), this._$_behaviorNameToIndex$_.set(i, t), 
                        this._$_behaviorTypesIncludingInherited$_.push(s), ++t;
                    }
                    for (const r of this._$GetBehaviorTypes$_()) {
                        const n = r._$GetName$_().toLowerCase();
                        this._$_behaviorsByName$_.set(n, r), this._$_behaviorNameToIndex$_.set(n, t), 
                        this._$_behaviorTypesIncludingInherited$_.push(r), ++t;
                    }
                    for (const h of this._$_behaviorTypesIncludingInherited$_) this._$_usedBehaviorCtors$_.add(h._$GetBehavior$_().constructor);
                    if (!this._$_isFamily$_ && this._$_families$_.length) {
                        let t = this._$_runtime$_._$GetFamilyCount$_(), e = (C33._$extendArray$_(this._$_familyInstVarMap$_, t, 0), 
                        C33._$extendArray$_(this._$_familyBehaviorMap$_, t, 0), 
                        C33._$extendArray$_(this._$_familyEffectMap$_, t, 0), []), s = 0, i = 0, r = 0;
                        for (const o of this._$_families$_) {
                            const a = o._$GetFamilyIndex$_(), l = (this._$_familyInstVarMap$_[a] = s, 
                            s += o._$GetInstanceVariablesCount$_(), this._$_familyBehaviorMap$_[a] = i, 
                            i += o._$GetBehaviorTypesCount$_(), this._$_familyEffectMap$_[a] = r, 
                            r += o._$GetEffectTypesCount$_(), o._$GetEffectList$_());
                            if (l && this._$_effectList$_) for (const u of l._$GetAllEffectTypes$_()) e.push(u._$Clone$_(this._$_effectList$_));
                        }
                        this._$_effectList$_ && this._$_effectList$_._$PrependEffectTypes$_(e);
                    }
                }
                _$_CreateSingleGlobalInstance$_(t) {
                    const e = this._$_runtime$_._$_GetNewUID$_(), s = C33._$New$_(C33.Instance, {
                        runtime: this._$_runtime$_,
                        _$objectType$_: this,
                        uid: e
                    });
                    s._$_CreateSdkInstance$_(t[16], []), this._$_runtime$_._$_MapInstanceByUID$_(e, s), 
                    this._$_instances$_.push(s);
                }
                _$GetSdkType$_() {
                    return this._$_sdkType$_;
                }
                _$IsOnLoaderLayout$_() {
                    return this._$_isOnLoaderLayout$_;
                }
                _$Dispatcher$_() {
                    return this._$_dispatcher$_;
                }
                _$OnCreate$_() {
                    this._$_isFamily$_ || (this._$_sdkType$_ ? this._$_sdkType$_._$OnCreate$_() : this._$_iObjectClass$_._$_onCreate$_());
                }
                _$HasLoadedTextures$_() {
                    return 0 < this._$_textureRefCount$_;
                }
                async _$LoadTextures$_(t) {
                    this._$_isFamily$_ || (this._$_textureRefCount$_++, 1 === this._$_textureRefCount$_ && (this._$_sdkType$_ ? await this._$_sdkType$_._$LoadTextures$_(t) : await this._$_iObjectClass$_._$_loadTextures$_(this._$_runtime$_._$GetCanvasManager$_()._$GetIRenderer$_())));
                }
                _$ReleaseTextures$_() {
                    if (!this._$_isFamily$_) {
                        if (this._$_textureRefCount$_--, this._$_textureRefCount$_ < 0) throw new Error("released textures too many times");
                        0 === this._$_textureRefCount$_ && (this._$_sdkType$_ ? this._$_sdkType$_._$ReleaseTextures$_() : this._$_iObjectClass$_._$_releaseTextures$_(this._$_runtime$_._$GetCanvasManager$_()._$GetIRenderer$_()));
                    }
                }
                _$OnDynamicTextureLoadComplete$_() {
                    if (this._$_isFamily$_) throw new Error("not applicable to family");
                    this._$_sdkType$_ ? this._$_sdkType$_._$OnDynamicTextureLoadComplete$_() : this._$_iObjectClass$_._$_onDynamicTextureLoadComplete$_();
                }
                async _$PreloadTexturesWithInstances$_(t) {
                    this._$_isFamily$_ || (this._$_sdkType$_ ? await this._$_sdkType$_._$PreloadTexturesWithInstances$_(t) : await this._$_iObjectClass$_._$_preloadTexturesWithInstances$_(this._$_runtime$_._$GetCanvasManager$_()._$GetIRenderer$_()));
                }
                _$GetRuntime$_() {
                    return this._$_runtime$_;
                }
                _$GetPlugin$_() {
                    return this._$_plugin$_;
                }
                _$GetInstanceSdkCtor$_() {
                    return this._$_instSdkCtor$_;
                }
                _$GetName$_() {
                    return this._$_name$_;
                }
                _$GetJsPropName$_() {
                    return this._$_jsPropName$_;
                }
                _$GetIndex$_() {
                    return this._$_index$_;
                }
                _$GetSID$_() {
                    return this._$_sid$_;
                }
                _$IsFamily$_() {
                    return this._$_isFamily$_;
                }
                _$IsGlobal$_() {
                    return this._$_isGlobal$_;
                }
                _$IsWorldType$_() {
                    return this._$_isWorldType$_;
                }
                _$GetFamilyIndex$_() {
                    return this._$_familyIndex$_;
                }
                _$GetBehaviorTypes$_() {
                    return this._$_behaviorTypes$_;
                }
                _$GetBehaviorTypesCount$_() {
                    return this._$_behaviorsCount$_;
                }
                _$UsesBehaviorByCtor$_(t) {
                    return t && this._$_usedBehaviorCtors$_.has(t);
                }
                _$GetInstanceVariablesCount$_() {
                    return this._$_instVars$_.length;
                }
                _$GetInstanceVariableSIDs$_() {
                    return this._$_instVars$_.map(t => t.sid);
                }
                _$GetInstanceVariableIndexBySID$_(e) {
                    return this._$_instVars$_.findIndex(t => t.sid === e);
                }
                _$GetInstanceVariableIndexByName$_(e) {
                    return this._$_instVars$_.findIndex(t => t.name === e);
                }
                _$_GetAllInstanceVariableNames$_() {
                    return this._$_instVars$_.map(t => t.name);
                }
                _$_GetAllInstanceVariableJsPropNames$_() {
                    return this._$_instVars$_.map(t => t._$jsPropName$_);
                }
                _$GetInstanceVariableType$_(t) {
                    if ((t = Math.floor(t)) < 0 || t >= this._$_instVars$_.length) throw new RangeError("invalid instance variable index");
                    return this._$_instVars$_[t].type;
                }
                _$GetInstanceVariableName$_(t) {
                    if ((t = Math.floor(t)) < 0 || t >= this._$_instVars$_.length) throw new RangeError("invalid instance variable index");
                    return this._$_instVars$_[t].name;
                }
                _$GetEffectTypesCount$_() {
                    return this._$_effectsCount$_;
                }
                _$GetBehaviorTypesIncludingInherited$_() {
                    return this._$_behaviorTypesIncludingInherited$_;
                }
                _$GetBehaviorTypeByName$_(t) {
                    return this._$_behaviorsByName$_.get(t.toLowerCase()) || null;
                }
                _$GetBehaviorIndexByName$_(t) {
                    const e = this._$_behaviorNameToIndex$_.get(t.toLowerCase());
                    return void 0 === e ? -1 : e;
                }
                _$GetEffectList$_() {
                    return this._$_effectList$_;
                }
                _$HasEffects$_() {
                    return this._$_plugin$_._$HasEffects$_();
                }
                _$UsesEffects$_() {
                    return this._$_effectList$_ && this._$_effectList$_._$HasAnyEffectType$_();
                }
                _$GetSolStack$_() {
                    return this._$_solStack$_;
                }
                _$GetCurrentSol$_() {
                    return this._$_solStack$_._$GetCurrentSol$_();
                }
                _$GetImageInfo$_() {
                    return this._$_imageInfo$_;
                }
                _$SetDefaultInstanceData$_(t) {
                    this._$_defaultInstanceData$_ = t;
                }
                _$GetDefaultInstanceData$_() {
                    return this._$_defaultInstanceData$_;
                }
                _$_SetDefaultLayerIndex$_(t) {
                    this._$_defaultLayerIndex$_ = t;
                }
                _$GetDefaultLayerIndex$_() {
                    return this._$_defaultLayerIndex$_;
                }
                _$GetAnimations$_() {
                    return this._$_animations$_;
                }
                _$GetAnimationCount$_() {
                    return this._$_animations$_.length;
                }
                _$GetFamilies$_() {
                    return this._$_families$_;
                }
                _$BelongsToFamily$_(t) {
                    return this._$_familiesSet$_.has(t);
                }
                _$GetFamilyMembers$_() {
                    return this._$_familyMembers$_;
                }
                _$FamilyHasMember$_(t) {
                    return this._$_familyMembersSet$_.has(t);
                }
                _$GetFamilyBehaviorOffset$_(t) {
                    return this._$_familyBehaviorMap$_[t];
                }
                _$GetFamilyInstanceVariableOffset$_(t) {
                    return this._$_familyInstVarMap$_[t];
                }
                _$AddCustomAction$_(t) {
                    this._$_customActionMap$_.set(t._$GetACEName$_().toLowerCase(), t);
                }
                _$HasOwnCustomActionByName$_(t) {
                    return !!this._$GetOwnCustomActionByName$_(t);
                }
                _$GetOwnCustomActionByName$_(t) {
                    const e = this._$_customActionMap$_.get(t.toLowerCase());
                    return e && e._$IsEnabled$_() ? e : null;
                }
                _$GetAllAnimations$_() {
                    return this._$_animations$_;
                }
                _$GetAnimationByName$_(t) {
                    if (this._$_animations$_) return this._$_animationsByName$_.get(t.toLowerCase()) || null;
                    throw new Error("no animations");
                }
                _$GetAnimationBySID$_(t) {
                    if (this._$_animations$_) return this._$_animationsBySid$_.get(t) || null;
                    throw new Error("no animations");
                }
                _$AddAnimation$_(t) {
                    if (this._$GetAnimationByName$_(t)) throw new Error(`animation name '${t}' already exists`);
                    const e = C33._$AnimationInfo$_._$CreateDynamic$_(this._$GetRuntime$_(), t);
                    return this._$_animations$_.push(e), this._$_animationsByName$_.set(e._$GetName$_().toLowerCase(), e), 
                    this._$_animationsBySid$_.set(e._$GetSID$_(), e), e;
                }
                _$RemoveAnimation$_(t) {
                    const e = this._$GetAnimationByName$_(t);
                    if (!e) throw new Error(`animation name '${t}' does not exist`);
                    if (1 === this._$_animations$_.length) throw new Error("cannot remove last animation");
                    const s = this._$_animations$_.indexOf(e);
                    this._$_animations$_.splice(s, 1), this._$_animationsByName$_.delete(e._$GetName$_().toLowerCase()), 
                    this._$_animationsBySid$_.delete(e._$GetSID$_()), e._$Release$_();
                }
                _$GetFirstAnimation$_() {
                    if (this._$_animations$_) return this._$_animations$_[0];
                    throw new Error("no animations");
                }
                _$GetFirstAnimationFrame$_() {
                    return this._$GetFirstAnimation$_()._$GetFrameAt$_(0);
                }
                _$GetDefaultInstanceSize$_() {
                    if (this._$_animations$_) {
                        const t = this._$GetFirstAnimationFrame$_()._$GetImageInfo$_();
                        return [ t._$GetWidth$_(), t._$GetHeight$_() ];
                    }
                    return this._$_imageInfo$_ ? [ this._$_imageInfo$_._$GetWidth$_(), this._$_imageInfo$_._$GetHeight$_() ] : [ 100, 100 ];
                }
                _$GetSingleGlobalInstance$_() {
                    if (this._$_plugin$_._$IsSingleGlobal$_()) return this._$_instances$_[0];
                    throw new Error("not a single-global plugin");
                }
                _$GetInstances$_() {
                    return this._$_instances$_;
                }
                *instances() {
                    yield* this._$_instances$_;
                }
                *_$instancesIncludingPendingCreate$_() {
                    yield* this._$_instances$_, yield* this._$_runtime$_._$instancesPendingCreateForObjectClass$_(this);
                }
                _$GetInstanceCount$_() {
                    return this._$_instances$_.length;
                }
                _$_AddInstance$_(t) {
                    this._$_instances$_.push(t);
                }
                _$_SetIIDsStale$_() {
                    this._$_iidsStale$_ = !0;
                }
                _$_UpdateIIDs$_() {
                    if (this._$_iidsStale$_ && !this._$_isFamily$_) {
                        let e = this._$_instances$_, s = 0;
                        for (let t = e.length; s < t; ++s) e[s]._$_SetIID$_(s);
                        const t = this._$_runtime$_._$_GetInstancesPendingCreate$_();
                        for (const i of t) i._$GetObjectClass$_() === this && i._$_SetIID$_(s++);
                        this._$_iidsStale$_ = !1;
                    }
                }
                _$GetInstanceByIID$_(t) {
                    const e = this._$_instances$_;
                    if (t < e.length) return e[t];
                    t -= e.length;
                    const s = this._$_runtime$_._$_GetInstancesPendingCreate$_();
                    for (const i of s) if (i._$GetObjectClass$_() === this) {
                        if (0 === t) return i;
                        --t;
                    }
                    return null;
                }
                _$GetFirstPicked$_(t) {
                    if (t && t._$IsInContainer$_() && t._$GetObjectClass$_() !== this) for (const s of t._$siblings$_()) if (s._$GetObjectClass$_() === this) return s;
                    const e = this._$GetCurrentSol$_()._$GetInstances$_();
                    return e.length ? e[0] : null;
                }
                _$GetPairedInstance$_(t) {
                    const e = this._$GetCurrentSol$_()._$GetInstances$_();
                    return 0 < e.length ? e[t._$GetIID$_() % e.length] : null;
                }
                *_$allCorrespondingInstances$_(t, e) {
                    let s = this._$GetCurrentSol$_()._$GetInstances$_(), i = s.length, r = e._$GetCurrentSol$_(), n = e._$GetCurrentSol$_()._$GetInstances$_(), h = n.length, o = t._$GetIID$_(), a = (!e._$IsFamily$_() && r._$IsSelectAll$_() || (o = n.indexOf(t)), 
                    Math.ceil(i / h)), l = i % h, u = 0, c;
                    c = 0 == l || o < l ? (u = o * a, a) : (u = l * a + (o - l) * (a - 1), 
                    a - 1);
                    for (let t = u, e = u + c; t < e; ++t) yield s[t];
                }
                _$FinishCondition$_(t) {
                    this._$_sdkType$_?._$FinishCondition$_(t);
                }
                _$ApplySolToContainer$_() {
                    if (this._$_isInContainer$_ && !this._$_isFamily$_) {
                        this._$_UpdateIIDs$_();
                        const t = this._$GetCurrentSol$_(), e = t._$_GetOwnInstances$_(), s = t._$IsSelectAll$_(), i = this._$_runtime$_._$GetCurrentEventStackFrame$_(), r = i && i._$GetCurrentEvent$_() && i._$GetCurrentEvent$_()._$IsOrBlock$_();
                        for (const n of this._$_container$_._$objectTypes$_()) if (n !== this) {
                            n._$_UpdateIIDs$_();
                            const h = n._$GetCurrentSol$_();
                            if (h._$_SetSelectAll$_(s), !s) {
                                const o = h._$_GetOwnInstances$_();
                                C33._$clearArray$_(o);
                                for (const a of e) o.push(n._$GetInstanceByIID$_(a._$GetIID$_()));
                                if (r) {
                                    const l = t._$_GetOwnElseInstances$_(), u = h._$_GetOwnElseInstances$_();
                                    C33._$clearArray$_(u);
                                    for (const c of l) u.push(n._$GetInstanceByIID$_(c._$GetIID$_()));
                                }
                            }
                        }
                    }
                }
                _$_TruncateContainerSols$_(t, e) {
                    for (const s of this._$GetContainer$_()._$objectTypes$_()) {
                        const i = s._$GetCurrentSol$_();
                        t ? C33._$truncateArray$_(i._$_GetOwnElseInstances$_(), e) : C33._$truncateArray$_(i._$_GetOwnInstances$_(), e);
                    }
                }
                _$_GetCollisionCellGrid$_() {
                    return this._$_collisionGrid$_;
                }
                _$_SetAnyCollisionCellChanged$_(t) {
                    this._$_anyCollisionCellChanged$_ = !!t;
                }
                _$_UpdateAllCollisionCells$_() {
                    if (this._$_anyCollisionCellChanged$_ && this._$_isWorldType$_) {
                        for (const t of this._$_instances$_) t._$GetWorldInfo$_()._$_UpdateCollisionCell$_();
                        for (const e of this._$_runtime$_._$_GetInstancesPendingCreate$_()) e._$GetObjectClass$_() === this && e._$GetWorldInfo$_()._$_UpdateCollisionCell$_();
                        this._$_anyCollisionCellChanged$_ = !1;
                    }
                }
                _$_OnWorldInstanceLayerChanged$_(e, t, s) {
                    if (t) {
                        const i = this._$_worldInfosByLayer$_.get(t);
                        i && (i.delete(e), 0 === i.size) && this._$_worldInfosByLayer$_.delete(t);
                    }
                    if (s) {
                        let t = this._$_worldInfosByLayer$_.get(s);
                        t || (t = new Set(), this._$_worldInfosByLayer$_.set(s, t)), 
                        t.add(e);
                    }
                }
                _$layersHasInstancesOn$_() {
                    if (this._$IsFamily$_()) {
                        const t = new Set();
                        for (const e of this._$_familyMembers$_) for (const s of e._$layersHasInstancesOn$_()) t.add(s);
                        return t.values();
                    }
                    return this._$_worldInfosByLayer$_.keys();
                }
                _$GetSavedDataMap$_() {
                    return this._$_savedData$_ || (this._$_savedData$_ = new Map()), 
                    this._$_savedData$_;
                }
                _$GetUnsavedDataMap$_() {
                    return this._$_unsavedData$_ || (this._$_unsavedData$_ = new Map()), 
                    this._$_unsavedData$_;
                }
                _$HasSolidBehavior$_() {
                    return this._$UsesBehaviorByCtor$_(C33._$Behaviors$_._$solid$_);
                }
                _$HasJumpthruBehavior$_() {
                    return this._$UsesBehaviorByCtor$_(C33._$Behaviors$_._$jumpthru$_);
                }
                _$HasNoSaveBehavior$_() {
                    return this._$UsesBehaviorByCtor$_(C33._$Behaviors$_.NoSave);
                }
                _$HasPersistBehavior$_() {
                    return this._$UsesBehaviorByCtor$_(C33._$Behaviors$_.Persist);
                }
                _$_SaveToJson$_() {
                    const t = {
                        instances: this._$_instances$_.map(t => t._$SaveToJson$_())
                    };
                    return this._$_savedData$_ && this._$_savedData$_.size && (t.ex = C33._$ToSuperJSON$_(this._$_savedData$_)), 
                    t;
                }
                _$_LoadFromJson$_(t, i) {
                    this._$_savedData$_ && (this._$_savedData$_.clear(), this._$_savedData$_ = null);
                    const e = t.ex, r = (e && (this._$_savedData$_ = C33._$FromSuperJSON$_(e)), 
                    this._$_instances$_), n = t.instances;
                    for (let t = 0, e = Math.min(r.length, n.length); t < e; ++t) r[t]._$LoadFromJson$_(n[t]);
                    for (let t = n.length, e = r.length; t < e; ++t) this._$_runtime$_._$DestroyInstance$_(r[t]);
                    for (let s = r.length, t = n.length; s < t; ++s) {
                        let t = n[s], e = null;
                        if (!this._$IsWorldType$_() || (e = this._$_runtime$_._$GetMainRunningLayout$_()._$GetLayerBySID$_(t.w.l))) {
                            const h = this._$_runtime$_._$CreateInstanceFromData$_(this._$_defaultInstanceData$_ || this, e, !1, 0, 0, !0);
                            h._$LoadFromJson$_(t), i && i.add(h);
                        }
                    }
                    this._$_loadInstancesJson$_ = n, this._$_SetIIDsStale$_();
                }
                _$_GetLoadInstancesJson$_() {
                    return this._$_loadInstancesJson$_;
                }
                _$_ClearLoadInstancesJson$_() {
                    this._$_loadInstancesJson$_ = null;
                }
                _$_SetupSceneGraphConnectionsOnChangeOfLayout$_() {
                    for (let t = 0, e = this._$_instances$_; t < e; ++t) this._$_instances$_[t]._$_SetupSceneGraphConnectionsOnChangeOfLayout$_();
                }
                _$GetIObjectClass$_() {
                    return this._$_iObjectClass$_;
                }
                _$UserScriptDispatcher$_() {
                    return this._$_userScriptDispatcher$_;
                }
                _$_GetUserScriptInstanceClass$_() {
                    return this._$_instanceUserScriptClass$_;
                }
                _$_SetUserScriptInstanceClass$_(t) {
                    this._$_instanceUserScriptClass$_ = t;
                }
                _$DispatchUserScriptEvent$_(t) {
                    const e = this._$_runtime$_, s = e._$IsDebug$_() && !e._$GetEventSheetManager$_()._$IsInEventEngine$_();
                    s && C3Debugger.StartMeasuringScriptTime(), this._$_userScriptDispatcher$_.dispatchEvent(t), 
                    s && C3Debugger.AddScriptTime();
                }
            };
        }
        {
            const C33 = self._$C3$_;
            C33._$Container$_ = class extends C33._$DefendedBase$_ {
                constructor(t, e) {
                    super(), this._$_runtime$_ = t, this._$_objectTypes$_ = e;
                    for (const s of this._$_objectTypes$_) s._$_SetContainer$_(this);
                }
                _$Release$_() {
                    this._$_runtime$_ = null;
                }
                _$GetRuntime$_() {
                    return this._$_runtime$_;
                }
                _$GetObjectTypes$_() {
                    return this._$_objectTypes$_;
                }
                _$objectTypes$_() {
                    return this._$_objectTypes$_;
                }
                _$HasAnyWorldType$_() {
                    return this._$_objectTypes$_.some(t => t._$IsWorldType$_());
                }
            };
        }
        {
            let C33 = self._$C3$_, C3Debugger = self.C3Debugger, IInstance = self._$IInstance$_, originalAddonManager = C33._$AddonManager$_, EMPTY_ARRAY = [], nextPuid = 0, savedDataMaps = new WeakMap(), unsavedDataMaps = new WeakMap(), FLAG_DESTROYED = 1, FLAG_TILEMAP = 2, FLAG_MUST_PREDRAW = 4, FLAG_SOLID_ENABLED = 8, FLAG_JUMPTHRU_ENABLED = 16, FLAG_MUST_MITIGATE_Z_FIGHTING = 32, FLAG_IS_DRAWING_WITH_EFFECTS = 64;
            C33.Instance = class extends C33._$DefendedBase$_ {
                constructor(t) {
                    if (C33._$AddonManager$_ !== originalAddonManager) throw new Error("invalid addon manager");
                    super(), this._$_runtime$_ = t.runtime, this._$_objectType$_ = t._$objectType$_, 
                    this._$_worldInfo$_ = null, this._$_sdkInst$_ = null, this._$_iScriptInterface$_ = null, 
                    this._$_iid$_ = 0, this._$_uid$_ = t.uid, this._$_puid$_ = nextPuid++, 
                    this._$_flags$_ = 0, this._$_tagsSet$_ = null;
                    const e = C33._$splitStringAndNormalize$_(t.tags), s = (0 < e.length && (this._$_tagsSet$_ = new Set(e)), 
                    this._$_instVarValues$_ = EMPTY_ARRAY, this._$_behaviorInstances$_ = EMPTY_ARRAY, 
                    this._$_objectType$_._$GetBehaviorTypesIncludingInherited$_()), i = (0 < s.length && (this._$_behaviorInstances$_ = s.map((t, e) => C33._$New$_(C33._$BehaviorInstance$_, {
                        runtime: this._$_runtime$_,
                        _$behaviorType$_: t,
                        instance: this,
                        index: e
                    }))), this._$_siblings$_ = this._$_objectType$_._$IsInContainer$_() ? [] : null, 
                    this._$_timeScale$_ = -1, this._$_dispatcher$_ = null, this._$GetPlugin$_());
                    if (i._$MustPreDraw$_() && (this._$_flags$_ |= FLAG_MUST_PREDRAW), 
                    i._$IsWorldType$_()) if (this._$_worldInfo$_ = C33._$New$_(C33._$WorldInfo$_, this, t._$layer$_), 
                    t._$worldData$_) this._$_worldInfo$_._$Init$_(t._$worldData$_); else {
                        this._$_worldInfo$_._$InitNoData$_();
                        const [ r, n ] = this._$_objectType$_._$GetDefaultInstanceSize$_();
                        this._$_worldInfo$_._$SetSize$_(r, n), this._$GetObjectClass$_()._$UsesEffects$_() && this._$_worldInfo$_._$GetInstanceEffectList$_()._$LoadDefaultEffectParameters$_();
                    }
                    t._$instVarData$_ ? this._$_LoadInstanceVariableData$_(t._$instVarData$_) : this._$_LoadDefaultInstanceVariables$_();
                }
                _$Release$_() {
                    if (this._$_iScriptInterface$_ && (this._$_iScriptInterface$_._$_release$_(), 
                    this._$_iScriptInterface$_ = null), 0 < this._$_behaviorInstances$_.length) {
                        for (const s of this._$_behaviorInstances$_) s._$Release$_();
                        C33._$clearArray$_(this._$_behaviorInstances$_);
                    }
                    this._$_sdkInst$_ && (this._$_sdkInst$_._$Release$_(), this._$_sdkInst$_ = null);
                    const t = savedDataMaps.get(this), e = (t && (t.clear(), savedDataMaps.delete(this)), 
                    unsavedDataMaps.get(this));
                    e && (e.clear(), unsavedDataMaps.delete(this)), this._$_siblings$_ && C33._$clearArray$_(this._$_siblings$_), 
                    this._$_dispatcher$_ && (this._$_dispatcher$_._$Release$_(), 
                    this._$_dispatcher$_ = null), this._$_tagsSet$_ && this._$_tagsSet$_.clear(), 
                    this._$_tagsSet$_ = null, this._$_runtime$_ = null, this._$_objectType$_ = null, 
                    0 < this._$_instVarValues$_.length && C33._$clearArray$_(this._$_instVarValues$_), 
                    this._$_worldInfo$_ && (this._$_worldInfo$_._$Release$_(), this._$_worldInfo$_ = null);
                }
                _$_LoadInstanceVariableData$_(t) {
                    0 < t.length && (this._$_instVarValues$_ = [], C33._$shallowAssignArray$_(this._$_instVarValues$_, t));
                }
                _$_LoadDefaultInstanceVariables$_() {
                    const e = this._$_objectType$_._$GetInstanceVariablesCount$_();
                    if (0 !== e) {
                        this._$_instVarValues$_ = [];
                        const s = [ 0, 0, "" ];
                        for (let t = 0; t < e; ++t) this._$_instVarValues$_.push(s[this._$_objectType$_._$GetInstanceVariableType$_(t)]);
                    }
                }
                _$_CreateSdkInstance$_(t, s) {
                    if (this._$_sdkInst$_) throw new Error("already got sdk instance");
                    for (let t = 0, e = this._$_behaviorInstances$_.length; t < e; ++t) {
                        const i = this._$_behaviorInstances$_[t];
                        i._$_CreateSdkInstance$_(s ? s[t] : null);
                    }
                    const e = this._$GetPlugin$_()._$GetSdkVersion$_();
                    if (e < 2) {
                        if (this._$_sdkInst$_ = C33._$New$_(this._$_objectType$_._$GetInstanceSdkCtor$_(), this, t), 
                        !(this._$_sdkInst$_ instanceof C33._$SDKInstanceBase$_)) throw new Error("sdk type must derive from SDKInstanceBase");
                        !this._$GetPlugin$_()._$IsWorldType$_() && this._$_objectType$_._$_GetUserScriptInstanceClass$_() && this._$GetInterfaceClass$_();
                    } else {
                        const r = this._$GetPlugin$_()._$GetScriptInterfaceClass$_();
                        this._$_InitUserScriptInterface$_(r.Instance, t);
                    }
                }
                _$GetSdkInstance$_() {
                    return this._$_sdkInst$_ ?? this._$_iScriptInterface$_;
                }
                _$GetWorldInfo$_() {
                    return this._$_worldInfo$_;
                }
                _$GetRuntime$_() {
                    return this._$_runtime$_;
                }
                _$GetTimeScale$_() {
                    return this._$_timeScale$_;
                }
                _$GetActiveTimeScale$_() {
                    const t = this._$_timeScale$_;
                    return -1 === t ? this._$GetRuntime$_()._$GetTimeScale$_() : t;
                }
                _$SetTimeScale$_(t) {
                    ((t = +t) < 0 || !isFinite(t)) && (t = 0), this._$_timeScale$_ = t, 
                    this._$GetObjectClass$_()._$UsesEffects$_() && this._$_runtime$_._$_SetTrackingInstanceTime$_(this, !0);
                }
                _$RestoreTimeScale$_() {
                    this._$_timeScale$_ = -1, this._$GetObjectClass$_()._$UsesEffects$_() && this._$_runtime$_._$_SetTrackingInstanceTime$_(this, !1);
                }
                _$GetInstanceGameTime$_() {
                    return this._$_runtime$_._$_GetInstanceGameTime$_(this);
                }
                _$Dispatcher$_() {
                    return this._$_dispatcher$_ || (this._$_dispatcher$_ = C33._$New$_(C33.Event._$Dispatcher$_)), 
                    this._$_dispatcher$_;
                }
                _$Draw$_(t) {
                    this._$_sdkInst$_ ? this._$_sdkInst$_._$Draw$_(t) : this._$_iScriptInterface$_._$_draw$_(this._$_runtime$_._$GetCanvasManager$_()._$GetIRenderer$_());
                }
                _$OnCreate$_(t) {
                    this._$_sdkInst$_._$OnCreate$_(t);
                }
                _$_SetHasTilemap$_() {
                    this._$_flags$_ |= FLAG_TILEMAP;
                }
                _$HasTilemap$_() {
                    return 0 != (this._$_flags$_ & FLAG_TILEMAP);
                }
                _$_MarkDestroyed$_() {
                    this._$_flags$_ |= FLAG_DESTROYED;
                }
                _$IsDestroyed$_() {
                    return 0 != (this._$_flags$_ & FLAG_DESTROYED);
                }
                _$MustPreDraw$_() {
                    return 0 != (this._$_flags$_ & FLAG_MUST_PREDRAW) || this._$_sdkInst$_._$MustPreDraw$_();
                }
                _$SetMustMitigateZFighting$_() {
                    this._$_flags$_ |= FLAG_MUST_MITIGATE_Z_FIGHTING;
                }
                _$MustMitigateZFighting$_() {
                    return 0 != (this._$_flags$_ & FLAG_MUST_MITIGATE_Z_FIGHTING);
                }
                _$_IsSolidEnabled$_() {
                    return 0 != (this._$_flags$_ & FLAG_SOLID_ENABLED);
                }
                _$_SetSolidEnabled$_(t) {
                    t ? this._$_flags$_ |= FLAG_SOLID_ENABLED : this._$_flags$_ &= ~FLAG_SOLID_ENABLED;
                }
                _$_IsJumpthruEnabled$_() {
                    return 0 != (this._$_flags$_ & FLAG_JUMPTHRU_ENABLED);
                }
                _$_SetJumpthruEnabled$_(t) {
                    t ? this._$_flags$_ |= FLAG_JUMPTHRU_ENABLED : this._$_flags$_ &= ~FLAG_JUMPTHRU_ENABLED;
                }
                _$_IsDrawingWithEffects$_() {
                    return 0 != (this._$_flags$_ & FLAG_IS_DRAWING_WITH_EFFECTS);
                }
                _$_SetIsDrawingWithEffects$_(t) {
                    t ? this._$_flags$_ |= FLAG_IS_DRAWING_WITH_EFFECTS : this._$_flags$_ &= ~FLAG_IS_DRAWING_WITH_EFFECTS;
                }
                _$SetFlag$_(t, e) {
                    t <<= 16, e ? this._$_flags$_ |= t : this._$_flags$_ &= ~t;
                }
                _$GetFlag$_(t) {
                    return 0 != (this._$_flags$_ & t << 16);
                }
                _$GetCurrentImageInfo$_() {
                    return this._$_sdkInst$_._$GetCurrentImageInfo$_();
                }
                _$GetCurrentSurfaceSize$_() {
                    return this._$_sdkInst$_._$GetCurrentSurfaceSize$_();
                }
                _$GetCurrentTexRect$_() {
                    return this._$_sdkInst$_._$GetCurrentTexRect$_();
                }
                _$GetCurrentTexQuad$_() {
                    return this._$_sdkInst$_._$GetCurrentTexQuad$_();
                }
                _$IsCurrentTexRotated$_() {
                    return this._$_sdkInst$_._$IsCurrentTexRotated$_();
                }
                _$GetImagePoint$_(t) {
                    return this._$_sdkInst$_._$GetImagePoint$_(t);
                }
                _$GetObjectClass$_() {
                    return this._$_objectType$_;
                }
                _$RendersToOwnZPlane$_() {
                    return this._$_sdkInst$_._$RendersToOwnZPlane$_();
                }
                _$BelongsToObjectClass$_(t) {
                    return t._$IsFamily$_() ? t._$FamilyHasMember$_(this._$GetObjectClass$_()) : this._$GetObjectClass$_() === t;
                }
                _$CollectInstancesToPick$_(r, t, e) {
                    const s = (t, e) => {
                        const s = e || t._$GetObjectClass$_(), i = r.get(s);
                        i ? i.add(t) : r.set(s, new Set([ t ]));
                    };
                    if (s(this, t), this._$IsInContainer$_()) for (const i of this._$siblings$_()) s(i);
                    if (e) for (const n of this._$allChildren$_()) s(n);
                }
                _$VerifySupportsSceneGraph$_() {
                    if (!this._$GetPlugin$_()._$SupportsSceneGraph$_()) throw new Error("object does not support scene graph");
                }
                _$HasParent$_() {
                    return null !== this._$GetParent$_();
                }
                _$GetParent$_() {
                    const t = this._$GetWorldInfo$_();
                    if (!t) return null;
                    const e = t._$GetParent$_();
                    return e ? e._$GetInstance$_() : null;
                }
                _$GetTopParent$_() {
                    const t = this._$GetWorldInfo$_();
                    if (!t) return null;
                    const e = t._$GetTopParent$_();
                    return e ? e._$GetInstance$_() : null;
                }
                *_$parents$_() {
                    const t = this._$GetWorldInfo$_();
                    if (t) for (const e of t._$parents$_()) yield e._$GetInstance$_();
                }
                _$HasChild$_(t) {
                    if (t) for (const e of this.children()) if (e === t) return !0;
                    return !1;
                }
                _$HasChildren$_() {
                    const t = this._$GetWorldInfo$_();
                    return !!t && t._$HasChildren$_();
                }
                _$GetChildrenOfObjectClass$_(t) {
                    const e = this._$GetWorldInfo$_();
                    if (!e) return [];
                    const s = t._$GetName$_();
                    return e._$GetChildren$_().map(t => t._$GetInstance$_()).filter(t => t._$GetObjectClass$_()._$GetName$_() === s);
                }
                _$GetChildren$_() {
                    const t = this._$GetWorldInfo$_();
                    return t ? t._$GetChildren$_().map(t => t._$GetInstance$_()) : [];
                }
                *children() {
                    const t = this._$GetWorldInfo$_();
                    if (t) for (const e of t.children()) yield e._$GetInstance$_();
                }
                *_$allChildren$_() {
                    const t = this._$GetWorldInfo$_();
                    if (t) for (const e of t._$allChildren$_()) yield e._$GetInstance$_();
                }
                _$GetChildCount$_() {
                    const t = this._$GetWorldInfo$_();
                    return t ? t._$GetChildCount$_() : 0;
                }
                _$GetParentCount$_() {
                    return [ ...this._$parents$_() ].length;
                }
                _$GetAllChildCount$_() {
                    const t = this._$GetWorldInfo$_();
                    return t ? t._$GetAllChildCount$_() : 0;
                }
                _$GetChildAt$_(t) {
                    const e = this._$GetWorldInfo$_();
                    if (!e) return null;
                    const s = e._$GetChildAt$_(t);
                    return s ? s._$GetInstance$_() : null;
                }
                _$GetIndexInParent$_() {
                    const t = this._$GetWorldInfo$_();
                    if (!t) return NaN;
                    const e = t._$GetParent$_();
                    return e ? e._$GetChildIndex$_(t) : NaN;
                }
                _$HasChildWithUID$_(t) {
                    for (const e of this._$GetWorldInfo$_()._$GetChildren$_()) if (e._$GetInstance$_()._$GetUID$_() === t) return !0;
                    return !1;
                }
                _$AddChild$_(t, e) {
                    this._$VerifySupportsSceneGraph$_(), t._$VerifySupportsSceneGraph$_(), 
                    this._$GetWorldInfo$_()._$AddChild$_(t._$GetWorldInfo$_(), e || {});
                }
                _$RemoveChild$_(t) {
                    const e = this._$GetWorldInfo$_();
                    e && e._$RemoveChild$_(t._$GetWorldInfo$_());
                }
                _$GetDestroyWithParent$_() {
                    const t = this._$GetWorldInfo$_();
                    return !!t && t._$GetDestroyWithParent$_();
                }
                _$SetupInitialSceneGraphConnections$_() {
                    const t = this._$GetWorldInfo$_();
                    if (t) {
                        const e = t._$GetSceneGraphChildrenExportData$_();
                        if (e) for (const s of e) {
                            const i = this._$_runtime$_._$GetInstanceByUID$_(s[2]);
                            if (i) {
                                const r = s[3];
                                this._$AddChild$_(i, {
                                    _$transformX$_: !!(r >> 0 & 1),
                                    _$transformY$_: !!(r >> 1 & 1),
                                    _$transformWidth$_: !!(r >> 2 & 1),
                                    _$transformHeight$_: !!(r >> 3 & 1),
                                    _$transformAngle$_: !!(r >> 4 & 1),
                                    _$destroyWithParent$_: !!(r >> 5 & 1),
                                    _$transformZElevation$_: !!(r >> 6 & 1),
                                    _$transformOpacity$_: !!(r >> 7 & 1),
                                    _$transformVisibility$_: !!(r >> 8 & 1)
                                });
                            }
                        }
                    }
                }
                _$SetupPersistedSceneGraphConnections$_(t, e) {
                    const s = t.get(this);
                    if (s) for (const i of s.sceneGraphJson.children) {
                        const r = e.get(i.index);
                        if (r) {
                            const n = i.flags;
                            this._$AddChild$_(r, {
                                _$transformX$_: !!(n >> 0 & 1),
                                _$transformY$_: !!(n >> 1 & 1),
                                _$transformWidth$_: !!(n >> 2 & 1),
                                _$transformHeight$_: !!(n >> 3 & 1),
                                _$transformAngle$_: !!(n >> 4 & 1),
                                _$destroyWithParent$_: !!(n >> 5 & 1),
                                _$transformZElevation$_: !!(n >> 6 & 1),
                                _$transformOpacity$_: !!(n >> 7 & 1),
                                _$transformVisibility$_: !!(n >> 8 & 1)
                            });
                        }
                    }
                }
                _$GetTemplateName$_() {
                    const t = this._$_runtime$_._$GetTemplateManager$_();
                    return t ? t._$GetInstanceTemplateName$_(this) : "";
                }
                _$IsInContainer$_() {
                    return null !== this._$_siblings$_;
                }
                _$_AddSibling$_(t) {
                    this._$_siblings$_.push(t);
                }
                _$GetSiblings$_() {
                    return this._$_siblings$_;
                }
                _$HasSibling$_(t) {
                    return !!this._$GetSibling$_(t);
                }
                _$GetSibling$_(t) {
                    const e = this._$siblings$_();
                    if (null === e || 0 === e.length) return !1;
                    for (const s of e) if (s._$GetObjectClass$_() === t) return s;
                    return null;
                }
                _$siblings$_() {
                    return this._$_siblings$_;
                }
                _$SetSiblingsSinglePicked$_() {
                    for (const t of this._$siblings$_()) t._$GetObjectClass$_()._$GetCurrentSol$_()._$SetSinglePicked$_(t);
                }
                _$_PushSiblingsToSolInstances$_() {
                    for (const t of this._$siblings$_()) t._$GetObjectClass$_()._$GetCurrentSol$_()._$_PushInstance$_(t);
                }
                _$_SetSiblingsToSolInstancesIndex$_(t) {
                    for (const e of this._$siblings$_()) e._$GetObjectClass$_()._$GetCurrentSol$_()._$_GetOwnInstances$_()[t] = e;
                }
                _$_PushSiblingsToSolElseInstances$_() {
                    for (const t of this._$siblings$_()) t._$GetObjectClass$_()._$GetCurrentSol$_()._$_PushElseInstance$_(t);
                }
                _$_SetSiblingsToSolElseInstancesIndex$_(t) {
                    for (const e of this._$siblings$_()) e._$GetObjectClass$_()._$GetCurrentSol$_()._$_GetOwnElseInstances$_()[t] = e;
                }
                _$GetPlugin$_() {
                    return this._$_objectType$_._$GetPlugin$_();
                }
                _$_SetIID$_(t) {
                    this._$_iid$_ = t;
                }
                _$GetIID$_() {
                    return this._$_objectType$_._$_UpdateIIDs$_(), this._$_iid$_;
                }
                _$GetUID$_() {
                    return this._$_uid$_;
                }
                _$GetPUID$_() {
                    return this._$_puid$_;
                }
                _$_SetTagsSetFromJson$_(t) {
                    t ? this._$SetTagsSet$_(new Set(t)) : this._$_tagsSet$_ = null;
                }
                _$SetTagsSet$_(t) {
                    if (0 === t.size) this._$_tagsSet$_ = null; else {
                        this._$_tagsSet$_ ? this._$_tagsSet$_.clear() : this._$_tagsSet$_ = new Set();
                        for (const e of t) this._$_tagsSet$_.add(e);
                    }
                }
                _$GetTagsSet$_() {
                    return this._$_tagsSet$_ ?? new Set();
                }
                _$GetTagsString$_() {
                    return Array.from(this._$GetTagsSet$_()).join(" ");
                }
                _$GetTagAt$_(t) {
                    t = Math.floor(t);
                    for (const e of this._$GetTagsSet$_()) {
                        if (0 === t) return e;
                        --t;
                    }
                    return "";
                }
                _$GetBehaviorInstances$_() {
                    return this._$_behaviorInstances$_;
                }
                _$GetBehaviorInstanceFromCtor$_(t) {
                    if (t) for (const e of this._$_behaviorInstances$_) if (e._$GetBehavior$_() instanceof t) return e;
                    return null;
                }
                _$GetBehaviorSdkInstanceFromCtor$_(t) {
                    if (!t) return null;
                    const e = this._$GetBehaviorInstanceFromCtor$_(t);
                    return e ? e._$GetSdkInstance$_() : null;
                }
                _$GetBehaviorIndexBySID$_(s) {
                    const i = this._$_behaviorInstances$_;
                    for (let t = 0, e = i.length; t < e; ++t) if (i[t]._$GetBehaviorType$_()._$GetSID$_() === s) return t;
                    return -1;
                }
                _$GetAllInstanceVariableValues$_() {
                    return this._$_instVarValues$_;
                }
                _$_GetAllInstanceVariableNames$_() {
                    return this._$_objectType$_._$_GetAllInstanceVariableNames$_();
                }
                _$GetInstanceVariableCount$_() {
                    return this._$_instVarValues$_.length;
                }
                _$GetInstanceVariableValue$_(t) {
                    const e = this._$_instVarValues$_;
                    if ((t |= 0) < 0 || t >= e.length) throw new RangeError("invalid instance variable");
                    return e[t];
                }
                _$_GetInstanceVariableValueUnchecked$_(t) {
                    return this._$_instVarValues$_[t];
                }
                _$_GetInstanceVariableTypedValue$_(t) {
                    const e = this._$_instVarValues$_[t];
                    return 0 === this._$_objectType$_._$GetInstanceVariableType$_(t) ? !!e : e;
                }
                _$SetInstanceVariableValue$_(t, e) {
                    const s = this._$_instVarValues$_;
                    if ((t |= 0) < 0 || t >= s.length) throw new RangeError("invalid instance variable");
                    const i = this._$_objectType$_._$GetInstanceVariableType$_(t);
                    switch (i) {
                      case 0:
                        s[t] = e ? 1 : 0;
                        break;

                      case 1:
                        s[t] = "number" == typeof e ? e : parseFloat(e);
                        break;

                      case 2:
                        s[t] = "string" == typeof e ? e : e.toString();
                        break;

                      default:
                        throw new Error("unknown instance variable type");
                    }
                }
                _$SetInstanceVariableOffset$_(t, e) {
                    if (0 !== e) {
                        const s = this._$_instVarValues$_;
                        if ((t |= 0) < 0 || t >= s.length) throw new RangeError("invalid instance variable");
                        const i = s[t];
                        if ("number" != typeof i) throw "boolean" == typeof i ? new Error("can not set offset of boolean variable") : "string" == typeof i ? new Error("can not set offset of string variable") : new Error("unknown instance variable type");
                        s[t] += "number" == typeof e ? e : parseFloat(e);
                    }
                }
                _$GetSavedDataMap$_() {
                    let t = savedDataMaps.get(this);
                    return t || (t = new Map(), savedDataMaps.set(this, t)), t;
                }
                _$GetUnsavedDataMap$_() {
                    let t = unsavedDataMaps.get(this);
                    return t || (t = new Map(), unsavedDataMaps.set(this, t)), t;
                }
                _$_HasAnyCreateDestroyHandler$_(t) {
                    const e = this._$GetObjectClass$_();
                    if (e._$UserScriptDispatcher$_()._$HasAnyHandlerFor$_(t)) return !0;
                    for (const s of e._$GetFamilies$_()) if (s._$UserScriptDispatcher$_()._$HasAnyHandlerFor$_(t)) return !0;
                    return !!this._$_runtime$_._$UserScriptDispatcher$_()._$HasAnyHandlerFor$_(t);
                }
                _$_TriggerOnCreatedOnSelfAndRelated$_() {
                    const t = new Set(), e = (t.add(this), this._$GetWorldInfo$_());
                    if (e && e._$HasChildren$_()) for (const s of this._$allChildren$_()) if (t.add(s), 
                    s._$IsInContainer$_()) for (const i of s._$siblings$_()) t.add(i);
                    if (this._$IsInContainer$_()) for (const r of this._$siblings$_()) t.add(r);
                    for (const n of t.values()) n._$_TriggerOnCreated$_();
                    this._$_OnHierarchyReady$_();
                }
                _$_OnCreatedCommon$_() {
                    this._$_objectType$_._$_GetUserScriptInstanceClass$_() && this._$GetInterfaceClass$_();
                    for (const t of this._$_behaviorInstances$_) t._$PostCreate$_();
                }
                _$_OnCreatedForLoadingSavegame$_() {
                    this._$_OnCreatedCommon$_();
                }
                _$_TriggerOnCreated$_() {
                    if (this._$_OnCreatedCommon$_(), this._$_HasAnyCreateDestroyHandler$_("instancecreate")) {
                        const t = this._$GetObjectClass$_(), e = new C33.Event("instancecreate");
                        e.instance = this._$GetInterfaceClass$_(), t._$DispatchUserScriptEvent$_(e);
                        for (const s of t._$GetFamilies$_()) s._$DispatchUserScriptEvent$_(e);
                        this._$_runtime$_._$DispatchUserScriptEvent$_(e);
                    }
                    this._$_runtime$_._$Trigger$_(this._$GetPlugin$_()._$GetConstructor$_()._$Cnds$_._$OnCreated$_, this, null);
                }
                _$_OnHierarchyReady$_() {
                    if (this._$GetPlugin$_()._$SupportsSceneGraph$_()) {
                        if (this._$DispatchUserScriptEvent$_(new C33.Event("hierarchyready")), 
                        this._$_HasAnyCreateDestroyHandler$_("hierarchyready")) {
                            const t = this._$GetObjectClass$_(), e = new C33.Event("hierarchyready");
                            e.instance = this._$GetInterfaceClass$_(), t._$DispatchUserScriptEvent$_(e);
                            for (const s of t._$GetFamilies$_()) s._$DispatchUserScriptEvent$_(e);
                            this._$_runtime$_._$DispatchUserScriptEvent$_(e);
                        }
                        this._$_runtime$_._$Trigger$_(this._$GetPlugin$_()._$GetConstructor$_()._$Cnds$_._$OnHierarchyReady$_, this, null);
                    }
                }
                _$_TriggerOnDestroyed$_() {
                    this._$_runtime$_._$Trigger$_(this._$GetPlugin$_()._$GetConstructor$_()._$Cnds$_._$OnDestroyed$_, this, null);
                }
                _$_FireDestroyedScriptEvents$_(t) {
                    if (this._$_iScriptInterface$_) {
                        const e = new C33.Event("destroy");
                        e._$isEndingLayout$_ = t, this._$DispatchUserScriptEvent$_(e);
                    }
                    if (this._$_HasAnyCreateDestroyHandler$_("instancedestroy")) {
                        const s = this._$GetObjectClass$_(), i = new C33.Event("instancedestroy");
                        i.instance = this._$GetInterfaceClass$_(), i._$isEndingLayout$_ = t, 
                        s._$DispatchUserScriptEvent$_(i);
                        for (const r of s._$GetFamilies$_()) r._$DispatchUserScriptEvent$_(i);
                        this._$_runtime$_._$DispatchUserScriptEvent$_(i);
                    }
                }
                _$_GetDebuggerProperties$_() {
                    return this._$_sdkInst$_ ? this._$_sdkInst$_._$GetDebuggerProperties$_() : this._$_iScriptInterface$_._$_getDebuggerProperties$_();
                }
                _$SaveToJson$_(t = "full", e = null) {
                    const s = {}, i = ("full" === t ? s.uid = this._$GetUID$_() : s.c3 = !0, 
                    this._$GetTagsSet$_());
                    if (0 < i.size && (s.tags = Array.from(i)), "visual-state" !== t) {
                        const n = savedDataMaps.get(this);
                        if (n && n.size && (s.ex = C33._$ToSuperJSON$_(n)), -1 !== this._$GetTimeScale$_() && (s.mts = this._$GetTimeScale$_()), 
                        0 < this._$_objectType$_._$GetInstanceVariablesCount$_()) {
                            const h = {}, o = this._$_objectType$_._$GetInstanceVariableSIDs$_();
                            for (let t = 0, e = this._$_instVarValues$_.length; t < e; ++t) h[o[t].toString()] = this._$_instVarValues$_[t];
                            s.ivs = h;
                        }
                        if (this._$_behaviorInstances$_.length) {
                            const a = {};
                            for (const l of this._$_behaviorInstances$_) {
                                const u = l._$SaveToJson$_(t);
                                u && (a[l._$GetBehaviorType$_()._$GetSID$_().toString()] = u);
                            }
                            s.behs = a;
                        }
                    }
                    this._$_worldInfo$_ && (s.w = this._$_worldInfo$_._$_SaveToJson$_(t, e));
                    const r = this._$_sdkInst$_ ? this._$_sdkInst$_._$SaveToJson$_() : this._$_iScriptInterface$_._$_saveToJson$_();
                    return r && (s.data = r), s;
                }
                _$_OnBeforeLoad$_(t = "full", e) {
                    this._$_worldInfo$_ && this._$_worldInfo$_._$_OnBeforeLoad$_(t);
                }
                _$_OnAfterLoad$_(t, e = "full", s = null) {
                    this._$_worldInfo$_ && this._$_worldInfo$_._$_OnAfterLoad$_(t, e, s);
                }
                _$_OnAfterLoad2$_(t, e = "full", s = null) {
                    this._$_worldInfo$_ && this._$_worldInfo$_._$_OnAfterLoad2$_(t, e, s);
                }
                _$_SetupSceneGraphConnectionsOnChangeOfLayout$_() {
                    this._$GetPlugin$_()._$IsWorldType$_() && this._$_worldInfo$_._$_SetupSceneGraphConnectionsOnChangeOfLayout$_();
                }
                _$LoadFromJson$_(e, t = "full", s) {
                    if ("full" === t) this._$_uid$_ = e.uid; else if (!e.c3) return;
                    if (this._$_SetTagsSetFromJson$_(e.tags), "visual-state" !== t) {
                        let t = savedDataMaps.get(this);
                        t && (t.clear(), savedDataMaps.delete(this));
                        const r = e.ex, n = (r && (t = C33._$FromSuperJSON$_(r), 
                        savedDataMaps.set(this, t)), this._$_timeScale$_ = e.hasOwnProperty("mts") ? e.mts : -1, 
                        e.ivs);
                        if (n) for (const [ h, o ] of Object.entries(n)) {
                            const a = parseInt(h, 10), l = this._$_objectType$_._$GetInstanceVariableIndexBySID$_(a);
                            if (!(l < 0 || l >= this._$_instVarValues$_.length)) {
                                let t = o;
                                null === t && (t = NaN), this._$_instVarValues$_[l] = t;
                            }
                        }
                    }
                    if (this._$GetPlugin$_()._$IsWorldType$_()) {
                        const u = e.w;
                        if (u) {
                            const c = u.l;
                            if (this._$_worldInfo$_._$GetLayer$_()._$GetSID$_() !== c) {
                                const f = this._$_worldInfo$_._$GetLayer$_(), d = f._$GetLayout$_()._$GetLayerBySID$_(c);
                                d ? (this._$_worldInfo$_._$_SetLayer$_(d), f._$_RemoveInstance$_(this, !0), 
                                d._$_AddInstance$_(this, !0), d._$SetZIndicesChanged$_(this), 
                                this._$_worldInfo$_._$SetBboxChanged$_()) : "full" === t && this._$_runtime$_._$DestroyInstance$_(this);
                            }
                            this._$_worldInfo$_._$_LoadFromJson$_(u, t);
                        }
                    }
                    if ("visual-state" !== t) {
                        const p = e.behs;
                        if (p) for (const [ m, C ] of Object.entries(p)) {
                            const g = parseInt(m, 10), S = this._$GetBehaviorIndexBySID$_(g);
                            S < 0 || S >= this._$_behaviorInstances$_.length || this._$_behaviorInstances$_[S]._$LoadFromJson$_(C, t);
                        }
                    }
                    const i = e.data;
                    i && (this._$_sdkInst$_ ? this._$_sdkInst$_._$LoadFromJson$_(i, t) : this._$_iScriptInterface$_._$_loadFromJson$_(i));
                }
                _$GetInterfaceClass$_() {
                    return this._$_iScriptInterface$_ || this._$_InitUserScriptInterface$_();
                }
                _$HasScriptInterface$_() {
                    return !!this._$_iScriptInterface$_;
                }
                _$_InitUserScriptInterface$_(t, e) {
                    const s = this._$_worldInfo$_ ? t ? self._$ISDKWorldInstanceBase$_ : self._$IWorldInstance$_ : t ? self._$ISDKInstanceBase$_ : self._$IInstance$_, i = t || this._$_sdkInst$_._$GetScriptInterfaceClass$_(), r = this._$_objectType$_._$_GetUserScriptInstanceClass$_(), n = r || i || s, h = this._$GetPlugin$_()._$GetSdkVersion$_();
                    if (C33._$AddonManager$_._$_PushInitObject$_(this, h), C33._$AddonManager$_._$_PushInitProperties$_(e), 
                    this._$_iScriptInterface$_ = new n(), C33._$AddonManager$_._$_PopInitProperties$_(), 
                    C33._$AddonManager$_._$_PopInitObject$_(h), i && !(this._$_iScriptInterface$_ instanceof s)) throw new TypeError(`script interface class '${i.name}' does not extend the right base class '${s.name}'`);
                    if (r) {
                        const o = i || s;
                        if (!(this._$_iScriptInterface$_ instanceof o)) throw new TypeError(`setInstanceClass(): class '${r.name}' does not extend the right base class - check it extends the right class, e.g. globalThis.InstanceType.MyObjectName`);
                    }
                    return this._$_iScriptInterface$_;
                }
                _$_GetInstVarsScriptDescriptor$_(t) {
                    if (0 !== this._$_instVarValues$_.length) {
                        const s = {}, i = this._$_objectType$_._$_GetAllInstanceVariableJsPropNames$_();
                        for (let t = 0, e = i.length; t < e; ++t) s[i[t]] = {
                            configurable: !1,
                            enumerable: !0,
                            get: C33.Instance.prototype._$_GetInstanceVariableTypedValue$_.bind(this, t),
                            set: C33.Instance.prototype._$SetInstanceVariableValue$_.bind(this, t)
                        };
                        const e = Object.create(Object.prototype, s);
                        t._$instVars$_ = {
                            value: e,
                            writable: !1
                        };
                    }
                }
                _$_GetBehaviorsScriptDescriptor$_(t) {
                    const e = this._$_behaviorInstances$_;
                    if (0 !== e.length) {
                        const s = {};
                        for (const r of e) s[r._$GetBehaviorType$_()._$GetJsPropName$_()] = {
                            value: r._$GetScriptInterface$_(),
                            writable: !1
                        };
                        const i = Object.create(Object.prototype, s);
                        t._$behaviors$_ = {
                            value: i,
                            writable: !1
                        };
                    }
                }
                _$DispatchUserScriptEvent$_(t) {
                    if (this._$HasScriptInterface$_()) {
                        const e = this._$GetInterfaceClass$_(), s = (t.instance = e, 
                        this._$_runtime$_), i = s._$IsDebug$_() && !s._$GetEventSheetManager$_()._$IsInEventEngine$_();
                        i && C3Debugger.StartMeasuringScriptTime(), e.dispatchEvent(t), 
                        i && C3Debugger.AddScriptTime();
                    }
                }
            };
        }
        {
            const C33 = self._$C3$_;
            C33._$SceneGraphInfo$_ = class extends C33._$DefendedBase$_ {
                constructor(i) {
                    super(), this._$_owner$_ = i, this._$_parent$_ = null, this._$_children$_ = [], 
                    this._$_startWidth$_ = i._$GetWidth$_(), this._$_startHeight$_ = i._$GetHeight$_(), 
                    this._$_startScaleX$_ = 1, this._$_startScaleY$_ = 1, this._$_parentStartAngle$_ = 0, 
                    this._$_ownOpacity$_ = 1, this._$_startOpacity$_ = i._$GetOpacity$_(), 
                    this._$_tmpSceneGraphChildren$_ = null, this._$_tmpSceneGraphChildrenIndexes$_ = null, 
                    this._$_indexInParent$_ = NaN, this._$_originalSizeKnown$_ = !1, 
                    this._$_originalWidth$_ = NaN, this._$_originalHeight$_ = NaN, 
                    this._$_on_instance_create$_ = t => {
                        if (t.instance === this._$_parent$_._$GetInstance$_()) {
                            const e = i._$GetRuntime$_(), s = (e._$Dispatcher$_().removeEventListener("instancecreate", this._$_on_instance_create$_), 
                            this._$_parent$_._$GetInstance$_()._$GetSdkInstance$_());
                            this._$_originalSizeKnown$_ = !!s._$IsOriginalSizeKnown$_(), 
                            this._$_originalWidth$_ = this._$_originalSizeKnown$_ ? s._$GetOriginalWidth$_() : NaN, 
                            this._$_originalHeight$_ = this._$_originalSizeKnown$_ ? s._$GetOriginalHeight$_() : NaN;
                        }
                    };
                }
                _$Release$_() {
                    this._$_parent$_ = null, this._$_tmpSceneGraphChildren$_ = null, 
                    this._$_tmpSceneGraphChildrenIndexes$_ = null, this._$_indexInParent$_ = NaN, 
                    this._$_originalSizeKnown$_ = !1, this._$_originalWidth$_ = NaN, 
                    this._$_originalHeight$_ = NaN, C33._$clearArray$_(this._$_children$_);
                }
                _$SetParent$_(t) {
                    if (this._$_ownOpacity$_ = this._$_owner$_._$GetOpacity$_(), 
                    this._$_startOpacity$_ = this._$_ownOpacity$_, this._$_parent$_ = t, 
                    this._$_parentStartAngle$_ = t ? t.GetAngle() : 0, this._$_parent$_) {
                        const e = this._$_owner$_, s = e._$GetRuntime$_(), i = this._$_parent$_._$GetInstance$_()._$GetPlugin$_()._$GetSdkVersion$_();
                        if (i < 2) {
                            const r = this._$_parent$_._$GetInstance$_()._$GetSdkInstance$_();
                            r ? (this._$_originalSizeKnown$_ = !!r._$IsOriginalSizeKnown$_(), 
                            this._$_originalWidth$_ = this._$_originalSizeKnown$_ ? r._$GetOriginalWidth$_() : NaN, 
                            this._$_originalHeight$_ = this._$_originalSizeKnown$_ ? r._$GetOriginalHeight$_() : NaN) : this._$_parent$_._$GetInstance$_()._$IsDestroyed$_() || s._$Dispatcher$_().addEventListener("instancecreate", this._$_on_instance_create$_);
                        } else this._$_originalSizeKnown$_ = !1, this._$_originalWidth$_ = NaN, 
                        this._$_originalHeight$_ = NaN;
                    } else this._$_originalSizeKnown$_ = !1, this._$_originalWidth$_ = NaN, 
                    this._$_originalHeight$_ = NaN;
                }
                _$GetParent$_() {
                    return this._$_parent$_;
                }
                _$HasChildren$_() {
                    return 0 < this._$_children$_.length;
                }
                _$GetChildren$_() {
                    return this._$_children$_;
                }
                _$_MaybeSortChildren$_() {
                    this._$HasChildren$_() && 1 !== this._$_children$_.length && (this._$_tmpSceneGraphChildrenIndexes$_ ? this._$_children$_.sort((t, e) => {
                        const s = this._$_tmpSceneGraphChildrenIndexes$_.get(t._$GetInstance$_()), i = this._$_tmpSceneGraphChildrenIndexes$_.get(e._$GetInstance$_());
                        return C33._$IsFiniteNumber$_(s) && C33._$IsFiniteNumber$_(i) ? s - i : 0;
                    }) : this._$_children$_.sort((t, e) => {
                        const s = t._$_GetSceneGraphInfo$_()._$_GetIndexInParent$_(), i = e._$_GetSceneGraphInfo$_()._$_GetIndexInParent$_();
                        return C33._$IsFiniteNumber$_(s) && C33._$IsFiniteNumber$_(i) ? s - i : 0;
                    }));
                }
                _$_GetIndexInParent$_() {
                    return this._$_indexInParent$_;
                }
                _$GetStartScaleX$_() {
                    return this._$_startScaleX$_;
                }
                _$SetStartScaleX$_(t) {
                    this._$_startScaleX$_ = t;
                }
                _$GetStartScaleY$_() {
                    return this._$_startScaleY$_;
                }
                _$SetStartScaleY$_(t) {
                    this._$_startScaleY$_ = t;
                }
                _$GetStartOpacity$_() {
                    return this._$_startOpacity$_;
                }
                _$GetOwnOpacity$_() {
                    return this._$_ownOpacity$_;
                }
                _$SetOwnOpacity$_(t) {
                    this._$_ownOpacity$_ = t;
                }
                _$_GetStartWidth$_() {
                    return 0 === this._$_startWidth$_ ? Number.EPSILON : this._$_startWidth$_;
                }
                _$_GetStartHeight$_() {
                    return 0 === this._$_startHeight$_ ? Number.EPSILON : this._$_startHeight$_;
                }
                _$GetParentScaleX$_() {
                    if (this._$_owner$_._$GetTransformWithParentWidth$_()) {
                        let t = this._$_parent$_, e = t._$GetWidth$_(), s = t._$_GetSceneGraphInfo$_()._$_GetStartWidth$_();
                        return 0 === e && (e = Number.EPSILON), s === Number.EPSILON && e === Number.EPSILON ? 1 : s === Number.EPSILON && e !== Number.EPSILON && this._$_originalSizeKnown$_ ? 1 + e / this._$_originalWidth$_ : e / s;
                    }
                    return 1;
                }
                _$GetParentScaleY$_() {
                    if (this._$_owner$_._$GetTransformWithParentHeight$_()) {
                        let t = this._$_parent$_, e = t._$GetHeight$_(), s = t._$_GetSceneGraphInfo$_()._$_GetStartHeight$_();
                        return 0 === e && (e = Number.EPSILON), s === Number.EPSILON && e === Number.EPSILON ? 1 : s === Number.EPSILON && e !== Number.EPSILON && this._$_originalSizeKnown$_ ? 1 + e / this._$_originalHeight$_ : e / s;
                    }
                    return 1;
                }
                _$GetParentStartAngle$_() {
                    return 0;
                }
                _$_SaveToJsonProperties$_() {
                    return {
                        sw: this._$_startWidth$_,
                        sh: this._$_startHeight$_,
                        sx: this._$_startScaleX$_,
                        sy: this._$_startScaleY$_,
                        psa: this._$_parentStartAngle$_,
                        oo: this._$_ownOpacity$_,
                        so: this._$_startOpacity$_,
                        pi: this._$_owner$_._$GetInstance$_()._$GetIndexInParent$_()
                    };
                }
                _$_SaveToJson$_(t, e = null) {
                    const s = this._$_SaveToJsonProperties$_();
                    return e && e.selfOnly ? Object.assign(s, {
                        p: null,
                        c: []
                    }) : Object.assign(s, {
                        p: this._$_GetParentJson$_(t),
                        c: this._$_GetChildrenJson$_(t)
                    });
                }
                _$_GetFlagsString$_(t) {
                    let e = "";
                    return t._$GetTransformWithParentX$_() && (e += "x"), t._$GetTransformWithParentY$_() && (e += "y"), 
                    t._$GetTransformWithParentWidth$_() && (e += "w"), t._$GetTransformWithParentHeight$_() && (e += "h"), 
                    t._$GetTransformWithParentAngle$_() && (e += "a"), t._$GetTransformWithParentZElevation$_() && (e += "z"), 
                    t._$GetDestroyWithParent$_() && (e += "d"), t._$GetTransformWithParentOpacity$_() && (e += "o"), 
                    t._$GetTransformWithParentVisibility$_() && (e += "v"), e;
                }
                _$_GetParentJson$_(t) {
                    return this._$_parent$_ && this._$_parent$_._$GetInstance$_() && !this._$_parent$_._$GetInstance$_()._$IsDestroyed$_() ? this._$_GetInstanceJson$_(this._$_parent$_, this._$_owner$_, t) : null;
                }
                _$_GetChildrenJson$_(e) {
                    return this._$_children$_.map(t => this._$_GetInstanceJson$_(t, t, e)).filter(t => t);
                }
                _$_GetInstanceJson$_(t, e, s) {
                    const i = t._$GetInstance$_();
                    if (i && i._$IsDestroyed$_()) return null;
                    const r = {};
                    return r.uid = i._$GetUID$_(), r.f = this._$_GetFlagsString$_(e), 
                    r.offsets = e._$_SaveSceneGraphPropertiesToJson$_(), r.data = C33._$SceneGraphInfo$_._$GetSceneGraphInstanceDataFromInstance$_(i), 
                    r.oci = i._$GetObjectClass$_()._$GetIndex$_(), "state" === s ? (r.inst = i._$SaveToJson$_("full", {
                        selfOnly: !0
                    }), r.instIndex = NaN) : (r.instIndex = i._$GetObjectClass$_()._$GetInstances$_().indexOf(i), 
                    r.inst = null), r;
                }
                _$_LoadFromJson$_(t) {
                    this._$_startWidth$_ = t.sw, this._$_startHeight$_ = t.sh, this._$_startScaleX$_ = t.sx, 
                    this._$_startScaleY$_ = t.sy, this._$_parentStartAngle$_ = t.psa, 
                    this._$_ownOpacity$_ = t.oo, this._$_startOpacity$_ = t.so, 
                    this._$_indexInParent$_ = C33._$IsFiniteNumber$_(t.pi) ? t.pi : NaN;
                }
                _$_SetTmpSceneGraphChildren$_(t, e) {
                    if (!t && !e && this._$_tmpSceneGraphChildren$_) for (const s of this._$_tmpSceneGraphChildren$_) s._$IsDestroyed$_() || s._$HasParent$_() || s._$GetRuntime$_()._$DestroyInstance$_(s);
                    this._$_tmpSceneGraphChildren$_ = t, this._$_tmpSceneGraphChildrenIndexes$_ = e;
                }
                _$_OnAfterLoad$_(t, e) {
                    const s = this._$_owner$_, i = s._$GetRuntime$_(), r = new Set();
                    if (t.p && !this._$_parent$_) {
                        const o = t.p.uid, a = i._$GetInstanceByUID$_(o);
                        if (e?._$setFromJson$_, a) {
                            const l = a._$GetWorldInfo$_();
                            if (a._$HasChild$_(s._$GetInstance$_())) this._$_parent$_ = l; else {
                                a._$HasChildWithUID$_(s._$GetInstance$_()._$GetUID$_()) ? i._$DestroyInstance$_(s._$GetInstance$_()) : a._$AddChild$_(s._$GetInstance$_(), this._$_GetFlagsObj$_(t.p.f)), 
                                r.has(s) || (s._$_LoadSceneGraphPropertiesFromJson$_(t.p.offsets), 
                                this._$_LoadInstancePropertiesFromJson$_(a, t.p, e)), 
                                r.add(s);
                                const u = a._$GetWorldInfo$_();
                                u._$_GetSceneGraphInfo$_()._$_MaybeSortChildren$_();
                            }
                        } else if (C33._$IsFiniteNumber$_(t.p.oci)) {
                            const c = i._$GetObjectClassByIndex$_(t.p.oci), f = (i._$GetSystemPlugin$_(), 
                            i._$CreateInstance$_(c, s._$GetLayer$_(), 0, 0, !0));
                            if (e?._$setFromJson$_, f) {
                                const d = this._$_GetInstanceData$_(t.p, i), p = (d && f._$LoadFromJson$_(d), 
                                f._$GetWorldInfo$_()), m = (p._$GetLayer$_()._$SortAndAddInstancesByZIndex$_(f), 
                                f._$AddChild$_(s._$GetInstance$_(), this._$_GetFlagsObj$_(t.p.f)), 
                                f._$GetWorldInfo$_());
                                m._$_GetSceneGraphInfo$_()._$_MaybeSortChildren$_();
                            }
                        }
                    }
                    const n = [];
                    for (const C of t.c) {
                        const g = C.uid, S = i._$GetInstanceByUID$_(g);
                        S && n.push(S);
                    }
                    let h = 0;
                    for (const _ of t.c) {
                        const T = _.uid, y = i._$GetInstanceByUID$_(T);
                        if (e?._$setFromJson$_, y) {
                            if (this._$_tmpSceneGraphChildren$_) {
                                if (this._$_tmpSceneGraphChildren$_.includes(y)) {
                                    const M = y;
                                    if (M._$GetObjectClass$_() !== y._$GetObjectClass$_()) {
                                        h++;
                                        continue;
                                    }
                                    if (M._$IsDestroyed$_()) {
                                        h++;
                                        continue;
                                    }
                                    const w = t.c[h];
                                    if (!e?._$setFromJson$_ && this._$_HasAllChildrenOfType$_(M, n, s)) {
                                        this._$_UpdateInstance$_(h, w, s, r, e), 
                                        h++;
                                        continue;
                                    }
                                    if (M._$HasParent$_() && M._$GetParent$_() !== s._$GetInstance$_()) {
                                        const v = this._$_CreateNewChildInstance$_(w, e);
                                        this._$_AddAndSetChildInstance$_(v, w, r, e), 
                                        h++;
                                        continue;
                                    }
                                    this._$_AddAndSetChildInstance$_(M._$GetWorldInfo$_(), w, r, e, !0), 
                                    h++;
                                    continue;
                                }
                                if (this._$_tmpSceneGraphChildren$_[h]) {
                                    const R = this._$_tmpSceneGraphChildren$_[h];
                                    if (R._$GetObjectClass$_() !== y._$GetObjectClass$_()) {
                                        h++;
                                        continue;
                                    }
                                    if (R._$IsDestroyed$_()) {
                                        h++;
                                        continue;
                                    }
                                    const b = t.c[h];
                                    if (!e?._$setFromJson$_ && this._$_HasAllChildrenOfType$_(R, n, s)) {
                                        this._$_UpdateInstance$_(h, b, s, r, e), 
                                        h++;
                                        continue;
                                    }
                                    if (R._$HasParent$_() && R._$GetParent$_() !== s._$GetInstance$_()) {
                                        const G = this._$_CreateNewChildInstance$_(b, e);
                                        this._$_AddAndSetChildInstance$_(G, b, r, e), 
                                        h++;
                                        continue;
                                    }
                                    this._$_AddAndSetChildInstance$_(R._$GetWorldInfo$_(), b, r, e, !0), 
                                    h++;
                                    continue;
                                }
                            }
                            const E = y._$GetObjectClass$_(), A = this._$_GetInstancesOfObjectClassCount$_(n, E), I = s._$GetInstance$_()._$GetChildrenOfObjectClass$_(E).length;
                            if (A === I) {
                                const x = s._$GetInstance$_()._$GetChildAt$_(h);
                                if (x) {
                                    const P = x._$GetWorldInfo$_();
                                    P && (r.has(P) || (P._$_LoadSceneGraphPropertiesFromJson$_(_.offsets), 
                                    this._$_LoadInstancePropertiesFromJson$_(x, _, e)), 
                                    r.add(P));
                                }
                                h++;
                                continue;
                            }
                            if (y._$HasParent$_() && y._$GetParent$_() !== s._$GetInstance$_()) {
                                const O = this._$_CreateNewChildInstance$_(_, e);
                                this._$_AddAndSetChildInstance$_(O, _, r, e), h++;
                                continue;
                            }
                            this._$_AddAndSetChildInstance$_(y._$GetWorldInfo$_(), _, r, e);
                        } else if (this._$_tmpSceneGraphChildren$_ && this._$_tmpSceneGraphChildren$_[h]) {
                            const D = this._$_tmpSceneGraphChildren$_[h], N = i._$GetObjectClassByIndex$_(this._$_GetObjectClassIndex$_(_));
                            if (D._$GetObjectClass$_() !== N) {
                                h++;
                                continue;
                            }
                            if (D._$IsDestroyed$_()) {
                                h++;
                                continue;
                            }
                            const L = t.c[h];
                            if (!e?._$setFromJson$_ && this._$_HasAllChildrenOfType$_(D, n, s)) {
                                this._$_UpdateInstance$_(h, L, s, r, e), h++;
                                continue;
                            }
                            if (D._$HasParent$_() && D._$GetParent$_() !== s._$GetInstance$_()) {
                                const F = this._$_CreateNewChildInstance$_(L, e);
                                this._$_AddAndSetChildInstance$_(F, L, r, e), h++;
                                continue;
                            }
                            this._$_AddAndSetChildInstance$_(D._$GetWorldInfo$_(), L, r, e);
                        } else {
                            const B = this._$_CreateNewChildInstance$_(_, e);
                            this._$_AddAndSetChildInstance$_(B, _, r, e);
                        }
                        h++;
                    }
                }
                _$_HasAllChildrenOfType$_(t, e, s) {
                    const i = t._$GetObjectClass$_(), r = this._$_GetInstancesOfObjectClassCount$_(e, i), n = s._$GetInstance$_()._$GetChildrenOfObjectClass$_(i).length;
                    return r === n;
                }
                _$_UpdateInstance$_(t, e, s, i, r) {
                    const n = s._$GetInstance$_()._$GetChildAt$_(t, e);
                    if (n) {
                        const h = n._$GetWorldInfo$_();
                        h && (i.has(h) || (h._$_LoadSceneGraphPropertiesFromJson$_(e.offsets), 
                        this._$_LoadInstancePropertiesFromJson$_(n, e, r)), i.add(h));
                    }
                }
                _$_GetFlagsObj$_(t) {
                    const e = {};
                    return e._$transformX$_ = t.includes("x"), e._$transformY$_ = t.includes("y"), 
                    e._$transformWidth$_ = t.includes("w"), e._$transformHeight$_ = t.includes("h"), 
                    e._$transformAngle$_ = t.includes("a"), e._$transformZElevation$_ = t.includes("z"), 
                    e._$destroyWithParent$_ = t.includes("d"), e._$transformOpacity$_ = t.includes("o"), 
                    e._$transformVisibility$_ = t.includes("v"), e;
                }
                _$_GetObjectClassIndex$_(t) {
                    return C33._$IsFiniteNumber$_(t.oci) ? t.oci : t[1];
                }
                _$_CreateNewChildInstance$_(i, r) {
                    if (C33._$IsFiniteNumber$_(i.oci)) {
                        let t = this._$_owner$_, e = t._$GetRuntime$_(), s;
                        if (i.data) s = e._$CreateInstanceFromData$_(i.data, t._$GetLayer$_(), !1, 0, 0, !1, !0); else {
                            const n = e._$GetObjectClassByIndex$_(i.oci);
                            s = e._$CreateInstance$_(n, t._$GetLayer$_(), 0, 0, !0);
                        }
                        if (r?._$setFromJson$_, s) {
                            const h = this._$_GetInstanceData$_(i, e), o = (h && s._$LoadFromJson$_(h), 
                            s._$GetWorldInfo$_());
                            return o._$GetLayer$_()._$SortAndAddInstancesByZIndex$_(s, !0), 
                            o;
                        }
                    }
                }
                _$_AddAndSetChildInstance$_(t, e, s, i, r = !0) {
                    const n = this._$_owner$_, h = n._$AddChild$_(t, this._$_GetFlagsObj$_(e.f));
                    h && r && (s.has(t) || (t._$_LoadSceneGraphPropertiesFromJson$_(e.offsets), 
                    this._$_LoadInstancePropertiesFromJson$_(t._$GetInstance$_(), e, i)), 
                    s.add(t)), this._$_MaybeSortChildren$_();
                }
                _$_LoadInstancePropertiesFromJson$_(t, e, s) {
                    let i = this._$_GetInstanceData$_(e, this._$_owner$_._$GetRuntime$_());
                    i && ((i = JSON.parse(JSON.stringify(i))).w = null, t._$LoadFromJson$_(i));
                }
                _$_GetInstancesOfObjectClassCount$_(t, e) {
                    return t.filter(t => t._$GetObjectClass$_()._$GetName$_() === e._$GetName$_()).length;
                }
                _$_GetInstanceData$_(t, e) {
                    if (C33._$IsFiniteNumber$_(t.instIndex)) {
                        const s = e._$GetObjectClassByIndex$_(t.oci), i = s._$_GetLoadInstancesJson$_();
                        return i ? i[t.instIndex] : null;
                    }
                    return C33._$IsString$_(t.inst) ? JSON.parse(t.inst) : t.inst || void 0;
                }
                static _$GetSceneGraphInstanceDataFromInstance$_(t) {
                    let e = t._$GetWorldInfo$_()._$GetLayer$_()._$GetInitialInstanceData$_(t._$GetUID$_());
                    if (!e) return null;
                    e = JSON.parse(JSON.stringify(e));
                    const s = [];
                    for (const i of [ ...t._$GetChildren$_() ]) {
                        const r = i._$GetWorldInfo$_();
                        s.push([ r._$GetLayout$_()._$GetSID$_(), r._$GetLayer$_()._$GetIndex$_(), i._$GetUID$_(), C33._$SceneGraphInfo$_._$_GetFlagsNumber$_(r), i._$GetObjectClass$_()._$IsInContainer$_() ? 1 : 0, r._$GetZIndex$_(), C33._$SceneGraphInfo$_._$GetSceneGraphInstanceDataFromInstance$_(i) ]);
                    }
                    return C33._$IsArray$_(e[0][14]) ? e[0][14][1] = s : (e[0][14] = [], 
                    e[0][14][0] = C33._$SceneGraphInfo$_._$_GetDefaultFlagsNumber$_(), 
                    e[0][14][1] = s, e[0][14][2] = t._$GetWorldInfo$_()._$GetZIndex$_()), 
                    e;
                }
                static _$_GetFlagsNumber$_(t) {
                    let e = 0;
                    return (e |= Number(t._$GetTransformWithParentVisibility$_()) << 8) | Number(t._$GetTransformWithParentOpacity$_()) << 7 | Number(t._$GetTransformWithParentZElevation$_()) << 6 | Number(t._$GetDestroyWithParent$_()) << 5 | Number(t._$GetTransformWithParentAngle$_()) << 4 | Number(t._$GetTransformWithParentHeight$_()) << 3 | Number(t._$GetTransformWithParentWidth$_()) << 2 | Number(t._$GetTransformWithParentY$_()) << 1 | Number(t._$GetTransformWithParentX$_()) << 0;
                }
                static _$_GetDefaultFlagsNumber$_(t) {
                    let e = 0;
                    return e, 511;
                }
            };
        }
        {
            let C33 = self._$C3$_, glMatrix = self._$glMatrix$_, vec32 = glMatrix._$vec3$_, vec42 = glMatrix._$vec4$_, tempRect = C33._$New$_(C33.Rect), tempQuad = C33._$New$_(C33._$Quad$_), bboxChangeEvent = C33._$New$_(C33.Event, "bboxchange", !1), tempColor = C33._$New$_(C33._$Color$_, 0, 0, 0, 0), tempCollisionPoly = C33._$New$_(C33._$CollisionPoly$_), DEFAULT_COLOR = C33._$New$_(C33._$Color$_, 1, 1, 1, 1), DEFAULT_RENDER_CELLS = C33._$New$_(C33.Rect, 0, 0, -1, -1), DEFAULT_COLLISION_CELLS = C33._$New$_(C33.Rect, 0, 0, -1, -1), VALID_SET_MESH_POINT_MODES = new Set([ "absolute", "relative" ]), EMPTY_ARRAY = [], enableUpdateRendererStateGroup = !0, FLAG_IS_VISIBLE = 1, FLAG_BBOX_CHANGED = 2, FLAG_ENABLE_BBOX_CHANGED_EVENT = 4, FLAG_COLLISION_ENABLED = 8, FLAG_COLLISION_CELL_CHANGED = 16, FLAG_SOLID_FILTER_INCLUSIVE = 32, FLAG_HAS_ANY_ACTIVE_EFFECT = 64, FLAG_IS_ROTATABLE = 128, FLAG_DESTROYED = 256, FLAG_DESTROY_WITH_PARENT = 512, FLAG_TRANSFORM_WITH_PARENT_X = 1024, FLAG_TRANSFORM_WITH_PARENT_Y = 2048, FLAG_TRANSFORM_WITH_PARENT_W = 4096, FLAG_TRANSFORM_WITH_PARENT_H = 8192, FLAG_TRANSFORM_WITH_PARENT_A = 16384, FLAG_TRANSFORM_WITH_PARENT_Z_ELEVATION = 32768, FLAG_TRANSFORM_WITH_PARENT_OPACITY = 1 << 22, FLAG_TRANSFORM_WITH_PARENT_VISIBILITY = 1 << 23, MASK_ALL_SCENE_GRAPH_FLAGS = FLAG_DESTROY_WITH_PARENT | FLAG_TRANSFORM_WITH_PARENT_X | FLAG_TRANSFORM_WITH_PARENT_Y | FLAG_TRANSFORM_WITH_PARENT_W | FLAG_TRANSFORM_WITH_PARENT_H | FLAG_TRANSFORM_WITH_PARENT_A | FLAG_TRANSFORM_WITH_PARENT_Z_ELEVATION | FLAG_TRANSFORM_WITH_PARENT_OPACITY | FLAG_TRANSFORM_WITH_PARENT_VISIBILITY, FLAG_MESH_CHANGED = 65536, FLAG_PHYSICS_BODY_CHANGED = 1 << 17, FLAG_SIN_COS_ANGLE_CHANGED = 1 << 18, FLAG_USE_POINTS_SHADER_PROGRAM = 1 << 19, FLAG_DRAW_BACK_FACE_ONLY = 1 << 20, FLAG_DRAW_NON_BACK_FACES_ONLY = 1 << 21, FLAG_BLEND_MODE_BIT_OFFSET = 26, FLAG_BLEND_MODE_MASK = 31 << FLAG_BLEND_MODE_BIT_OFFSET, sceneGraphExportDataMap = new WeakMap(), sceneGraphZIndexMap = new WeakMap();
            C33._$WorldInfo$_ = class extends C33._$DefendedBase$_ {
                constructor(t, e) {
                    super(), this._$_inst$_ = t, this._$_objectClass$_ = t._$GetObjectClass$_(), 
                    this._$_runtime$_ = t._$GetRuntime$_(), this._$_layer$_ = e, 
                    this._$_objectClass$_._$_OnWorldInstanceLayerChanged$_(this, null, e), 
                    this._$_zIndex$_ = -1, this._$_htmlZIndex$_ = -1, this._$_flags$_ = FLAG_IS_VISIBLE | FLAG_BBOX_CHANGED | FLAG_COLLISION_ENABLED | FLAG_COLLISION_CELL_CHANGED | FLAG_MESH_CHANGED | FLAG_PHYSICS_BODY_CHANGED, 
                    this._$_objectClass$_._$GetPlugin$_()._$IsRotatable$_() && (this._$_flags$_ |= FLAG_IS_ROTATABLE), 
                    this._$_x$_ = NaN, this._$_y$_ = NaN, this._$_zElevation$_ = NaN, 
                    this._$_w$_ = NaN, this._$_h$_ = NaN, this._$_depth$_ = NaN, 
                    this._$_a$_ = NaN, this._$_sinA$_ = NaN, this._$_cosA$_ = NaN, 
                    this._$_ox$_ = NaN, this._$_oy$_ = NaN, this._$_boundingBox$_ = C33._$New$_(C33.Rect), 
                    this._$_boundingQuad$_ = C33._$New$_(C33._$Quad$_), this._$_collisionCells$_ = DEFAULT_COLLISION_CELLS, 
                    this._$_renderCells$_ = DEFAULT_RENDER_CELLS, this._$_sourceCollisionPoly$_ = null, 
                    this._$_transformedPolyInfo$_ = null, this._$_solidFilterTags$_ = null, 
                    this._$_color$_ = DEFAULT_COLOR, this._$_colorPremultiplied$_ = DEFAULT_COLOR, 
                    this._$_stateGroup$_ = null, this._$_instanceEffectList$_ = null, 
                    this._$_inst$_._$GetObjectClass$_()._$UsesEffects$_() && (this._$_instanceEffectList$_ = C33._$New$_(C33._$InstanceEffectList$_, this._$_inst$_, this)), 
                    this._$_sceneGraphInfo$_ = null, this._$_tmpSceneGraphChildren$_ = null, 
                    this._$_tmpSceneGraphChildrenIndexes$_ = null, this._$_tmpHierarchyPosition$_ = -1, 
                    this._$_meshInfo$_ = null;
                }
                _$_MarkDestroyed$_() {
                    this._$_flags$_ |= FLAG_DESTROYED;
                }
                _$Release$_() {
                    if (this._$_objectClass$_._$_OnWorldInstanceLayerChanged$_(this, this._$_layer$_, null), 
                    this._$_stateGroup$_ && (this._$_runtime$_._$GetRenderer$_()._$ReleaseStateGroup$_(this._$_stateGroup$_), 
                    this._$_stateGroup$_ = null), this._$_sourceCollisionPoly$_ = null, 
                    this._$_transformedPolyInfo$_ && (this._$_transformedPolyInfo$_._$poly$_._$Release$_(), 
                    this._$_transformedPolyInfo$_ = null), this._$_solidFilterTags$_ && (this._$_solidFilterTags$_.clear(), 
                    this._$_solidFilterTags$_ = null), this._$ReleaseMesh$_(), this._$_instanceEffectList$_ && this._$_instanceEffectList$_._$Release$_(), 
                    this._$HasParent$_() && this._$GetParent$_()._$RemoveChild$_(this), 
                    this._$HasChildren$_()) {
                        const t = [ ...this._$GetChildren$_() ];
                        for (const e of t) this._$RemoveChild$_(e);
                    }
                    this._$_ReleaseSceneGraphInfo$_(), this._$_ReleaseTmpSceneGraphInfo$_(), 
                    sceneGraphExportDataMap.delete(this), sceneGraphZIndexMap.delete(this), 
                    this._$_inst$_ = null, this._$_objectClass$_ = null, this._$_runtime$_ = null, 
                    this._$_layer$_ = null;
                }
                _$Init$_(t) {
                    if (enableUpdateRendererStateGroup = !1, this._$SetXY$_(t[0], t[1]), 
                    this._$SetZElevation$_(t[2]), this._$SetSize$_(t[3], t[4]), 
                    this._$_depth$_ = 0, this._$IsRotatable$_() ? this._$SetAngle$_(t[6]) : this._$_a$_ = 0, 
                    tempColor._$setFromJSON$_(t[7]), this._$_SetColor$_(tempColor), 
                    this._$SetOriginX$_(t[8]), this._$SetOriginY$_(t[9]), this._$SetBlendMode$_(t[10]), 
                    this._$_instanceEffectList$_ && this._$_instanceEffectList$_._$_LoadEffectParameters$_(t[12]), 
                    t[14] && sceneGraphExportDataMap.set(this, {
                        _$childrenData$_: t[14][1],
                        _$zIndexData$_: t[14][2]
                    }), t[15]) {
                        const e = t[15], i = (this._$CreateMesh$_(e[0], e[1]), this._$GetSourceMesh$_()), r = e[2];
                        for (let s = 0, t = r.length; s < t; ++s) {
                            const n = r[s];
                            for (let t = 0, e = n.length; t < e; ++t) {
                                const h = n[t], o = i._$GetMeshPointAt$_(t, s);
                                o._$SetX$_(h[0]), o._$SetY$_(h[1]), o._$SetZElevation$_(h[2]), 
                                o._$SetU$_(h[3]), o._$SetV$_(h[4]);
                            }
                        }
                    }
                    if (t[16]) {
                        const s = t[16][0], a = t[16][1], l = !!a, u = !l, c = this._$_runtime$_._$GetTemplateManager$_();
                        l && c && c._$MapInstanceToTemplateName$_(this._$GetInstance$_(), a), 
                        u && c && c._$MapInstanceToTemplateName$_(this._$GetInstance$_(), s);
                    }
                    enableUpdateRendererStateGroup = !0, this._$_UpdateRendererStateGroup$_();
                }
                _$InitNoData$_() {
                    this._$_x$_ = 0, this._$_y$_ = 0, this._$_zElevation$_ = 0, 
                    this._$_w$_ = 0, this._$_h$_ = 0, this._$_depth$_ = 0, this._$_a$_ = 0, 
                    this._$_sinA$_ = 0, this._$_cosA$_ = 1, this._$_ox$_ = 0, this._$_oy$_ = 0, 
                    this._$_UpdateRendererStateGroup$_();
                }
                _$GetRuntime$_() {
                    return this._$_runtime$_;
                }
                _$GetObjectClass$_() {
                    return this._$_objectClass$_;
                }
                _$GetInstance$_() {
                    return this._$_inst$_;
                }
                _$_GetParentOffsetAngle$_() {
                    return this._$GetTransformWithParentAngle$_() ? this._$_MaybeReflectAngleForMirrorFlip$_(this._$GetParent$_()._$_GetAngleNoReflect$_() - this._$_sceneGraphInfo$_._$GetParentStartAngle$_()) : 0;
                }
                _$SetX$_(t) {
                    if (t = +t, this._$GetTransformWithParentX$_()) {
                        const e = this._$_sceneGraphInfo$_, s = t - this._$GetX$_(), i = -this._$_GetParentOffsetAngle$_();
                        0 == i ? this._$_x$_ += s / e._$GetParentScaleX$_() : (this._$_x$_ += Math.cos(i) * s / e._$GetParentScaleX$_(), 
                        this._$GetTransformWithParentY$_() && (this._$_y$_ += Math.sin(i) * s / e._$GetParentScaleY$_()));
                    } else this._$_x$_ = t;
                }
                _$OffsetX$_(t, e = !1) {
                    t = +t, !e && this._$GetTransformWithParentX$_() ? this._$SetX$_(this._$GetX$_() + t) : this._$_x$_ += t;
                }
                _$GetX$_() {
                    if (this._$GetTransformWithParentX$_()) {
                        let t = this._$_x$_, e = this._$_sceneGraphInfo$_, s = this._$GetParent$_(), i = this._$_GetParentOffsetAngle$_();
                        return 0 === i ? t *= e._$GetParentScaleX$_() : (t = t * e._$GetParentScaleX$_() * Math.cos(i), 
                        this._$GetTransformWithParentY$_() && (t -= this._$_y$_ * e._$GetParentScaleY$_() * Math.sin(i))), 
                        s._$GetX$_() + t;
                    }
                    return this._$_x$_;
                }
                _$SetY$_(t) {
                    if (t = +t, this._$GetTransformWithParentY$_()) {
                        const e = this._$_sceneGraphInfo$_, s = t - this._$GetY$_(), i = -this._$_GetParentOffsetAngle$_();
                        0 == i ? this._$_y$_ += s / e._$GetParentScaleY$_() : (this._$GetTransformWithParentX$_() && (this._$_x$_ -= Math.sin(i) * s / e._$GetParentScaleX$_()), 
                        this._$_y$_ += Math.cos(i) * s / e._$GetParentScaleY$_());
                    } else this._$_y$_ = t;
                }
                _$OffsetY$_(t, e = !1) {
                    t = +t, !e && this._$GetTransformWithParentY$_() ? this._$SetY$_(this._$GetY$_() + t) : this._$_y$_ += t;
                }
                _$GetY$_() {
                    if (this._$GetTransformWithParentY$_()) {
                        let t = this._$_y$_, e = this._$_sceneGraphInfo$_, s = this._$GetParent$_(), i = this._$_GetParentOffsetAngle$_();
                        return 0 === i ? t *= e._$GetParentScaleY$_() : (t = t * e._$GetParentScaleY$_() * Math.cos(i), 
                        this._$GetTransformWithParentX$_() && (t += this._$_x$_ * e._$GetParentScaleX$_() * Math.sin(i))), 
                        s._$GetY$_() + t;
                    }
                    return this._$_y$_;
                }
                _$SetXY$_(t, e) {
                    if (t = +t, e = +e, this._$GetTransformWithParentXOrY$_()) {
                        const s = this._$GetTransformWithParentX$_(), i = this._$GetTransformWithParentY$_(), r = this._$_sceneGraphInfo$_, n = t - this._$GetX$_(), h = e - this._$GetY$_(), o = -this._$_GetParentOffsetAngle$_();
                        if (0 == o) s ? this._$_x$_ += n / r._$GetParentScaleX$_() : this._$_x$_ = t, 
                        i ? this._$_y$_ += h / r._$GetParentScaleY$_() : this._$_y$_ = e; else {
                            const a = Math.sin(o), l = Math.cos(o);
                            s ? this._$_x$_ += i ? (l * n - a * h) / r._$GetParentScaleX$_() : l * n / r._$GetParentScaleX$_() : this._$_x$_ = t, 
                            i ? this._$_y$_ += s ? (a * n + l * h) / r._$GetParentScaleY$_() : l * h / r._$GetParentScaleY$_() : this._$_y$_ = e;
                        }
                    } else this._$_x$_ = t, this._$_y$_ = e;
                }
                _$GetXY$_() {
                    return [ this._$GetX$_(), this._$GetY$_() ];
                }
                _$OffsetXY$_(t, e) {
                    t = +t, e = +e, this._$GetTransformWithParentXOrY$_() ? this._$SetXY$_(this._$GetX$_() + t, this._$GetY$_() + e) : (this._$_x$_ += t, 
                    this._$_y$_ += e);
                }
                _$EqualsXY$_(t, e) {
                    return this._$GetX$_() === t && this._$GetY$_() === e;
                }
                _$SetZElevation$_(t) {
                    if (t = +t, this._$GetTransformWithParentZElevation$_() && (t -= this._$GetParent$_()._$GetZElevation$_()), 
                    this._$_zElevation$_ !== t) {
                        this._$_zElevation$_ = t, this._$_UpdateZElevation$_();
                        const e = this._$GetLayer$_();
                        0 !== this._$_zElevation$_ && e._$_SetAnyInstanceZElevated$_(), 
                        e._$SetZIndicesChanged$_(this);
                    }
                }
                _$_UpdateZElevation$_() {
                    if (this._$_UpdateRendererStateGroup$_(), this._$HasChildren$_()) {
                        const s = this._$GetChildren$_();
                        for (let t = 0, e = s.length; t < e; t++) {
                            const i = s[t];
                            i._$GetTransformWithParentZElevation$_() && i._$_UpdateZElevation$_();
                        }
                    }
                }
                _$OffsetZElevation$_(t) {
                    this._$SetZElevation$_(this._$GetZElevation$_() + t);
                }
                _$GetZElevation$_() {
                    return this._$GetTransformWithParentZElevation$_() ? this._$GetParent$_()._$GetZElevation$_() + this._$_zElevation$_ : this._$_zElevation$_;
                }
                _$GetTotalZElevation$_() {
                    return this._$GetLayer$_()._$GetZElevation$_() + this._$GetZElevation$_();
                }
                _$IsOriginalSizeKnown$_() {
                    const t = this._$GetInstance$_()._$GetPlugin$_()._$GetSdkVersion$_();
                    return t < 2 && this._$GetInstance$_()._$GetSdkInstance$_()._$IsOriginalSizeKnown$_();
                }
                _$SetWidth$_(t) {
                    if (t = +t, this._$GetTransformWithParentWidth$_()) {
                        const e = this._$GetWidth$_();
                        0 === e ? this._$_w$_ = Number.EPSILON : this._$_w$_ *= t / e;
                    } else this._$_w$_ = t;
                    this._$_MarkSinCosAngleChanged$_();
                }
                _$OffsetWidth$_(t, e) {
                    t = +t, !e && this._$GetTransformWithParentWidth$_() ? this._$SetWidth$_(this._$GetWidth$_() + t) : this._$_w$_ += t, 
                    this._$_MarkSinCosAngleChanged$_();
                }
                _$GetWidth$_() {
                    if (this._$GetTransformWithParentWidth$_()) {
                        const t = this._$GetParent$_(), e = t._$GetWidth$_(), s = t._$_GetSceneGraphInfo$_()._$_GetStartWidth$_();
                        return s === Number.EPSILON ? (this._$_GetSceneGraphInfo$_()._$_GetStartWidth$_() + e) * this._$_w$_ : e * this._$_w$_;
                    }
                    return this._$_w$_;
                }
                _$SetHeight$_(t) {
                    if (t = +t, this._$GetTransformWithParentHeight$_()) {
                        const e = this._$GetHeight$_();
                        0 === e ? this._$_h$_ = Number.EPSILON : this._$_h$_ *= t / e;
                    } else this._$_h$_ = t;
                    this._$_MarkSinCosAngleChanged$_();
                }
                _$OffsetHeight$_(t, e) {
                    t = +t, !e && this._$GetTransformWithParentHeight$_() ? this._$SetHeight$_(this._$GetHeight$_() + t) : this._$_h$_ += t, 
                    this._$_MarkSinCosAngleChanged$_();
                }
                _$GetHeight$_() {
                    if (this._$GetTransformWithParentHeight$_()) {
                        const t = this._$GetParent$_(), e = t._$GetHeight$_(), s = t._$_GetSceneGraphInfo$_()._$_GetStartHeight$_();
                        return s === Number.EPSILON ? (this._$_GetSceneGraphInfo$_()._$_GetStartHeight$_() + e) * this._$_h$_ : e * this._$_h$_;
                    }
                    return this._$_h$_;
                }
                _$SetSize$_(t, e) {
                    if (t = +t, e = +e, this._$GetTransformWithParentWidth$_()) {
                        const s = this._$GetWidth$_();
                        0 === s ? this._$_w$_ = Number.EPSILON : this._$_w$_ *= t / s;
                    } else this._$_w$_ = t;
                    if (this._$GetTransformWithParentHeight$_()) {
                        const i = this._$GetHeight$_();
                        0 === i ? this._$_h$_ = Number.EPSILON : this._$_h$_ *= e / i;
                    } else this._$_h$_ = e;
                    this._$_MarkSinCosAngleChanged$_();
                }
                _$GetSize$_() {
                    return [ this._$GetWidth$_(), this._$GetHeight$_() ];
                }
                _$GetDepth$_() {
                    return this._$_depth$_;
                }
                _$SetDepth$_(t) {
                    if (t < 0) throw new RangeError("invalid depth");
                    this._$_depth$_ = t;
                }
                _$GetSceneGraphScale$_() {
                    if (this._$HasParent$_()) {
                        const t = this._$_sceneGraphInfo$_;
                        return Math.min(t._$GetParentScaleX$_(), t._$GetParentScaleY$_());
                    }
                    return 1;
                }
                _$IsRotatable$_() {
                    return 0 != (this._$_flags$_ & FLAG_IS_ROTATABLE);
                }
                _$SetAngle$_(t) {
                    t = +t, this._$IsRotatable$_() && (this._$GetTransformWithParentAngle$_() && (t -= this._$GetParent$_().GetAngle()), 
                    t = C33._$clampAngle$_(t), this._$_a$_ !== t) && (this._$_a$_ = t, 
                    this._$_MarkSinCosAngleChanged$_());
                }
                _$OffsetAngle$_(t) {
                    0 != (t = +t) && this._$IsRotatable$_() && (this._$_a$_ = C33._$clampAngle$_(this._$_a$_ + t), 
                    this._$_MarkSinCosAngleChanged$_());
                }
                _$_MarkSinCosAngleChanged$_() {
                    if (this._$_flags$_ |= FLAG_SIN_COS_ANGLE_CHANGED, this._$HasChildren$_()) {
                        const s = this._$GetChildren$_();
                        for (let t = 0, e = s.length; t < e; t++) s[t]._$_MarkSinCosAngleChanged$_();
                    }
                }
                GetAngle() {
                    return this._$GetTransformWithParentAngle$_() && this._$IsRotatable$_() ? this._$_MaybeReflectAngleForMirrorFlip$_(C33._$clampAngle$_(this._$GetParent$_()._$_GetAngleNoReflect$_() + this._$_a$_)) : this._$_a$_;
                }
                _$_GetAngleNoReflect$_() {
                    return this._$GetTransformWithParentAngle$_() && this._$IsRotatable$_() ? C33._$clampAngle$_(this._$GetParent$_()._$_GetAngleNoReflect$_() + this._$_a$_) : this._$_a$_;
                }
                _$_MaybeReflectAngleForMirrorFlip$_(t) {
                    return this._$GetTransformWithParentWidth$_() && this._$GetTopParent$_()._$GetWidth$_() < 0 && (t = C33._$clampAngle$_(C33._$angleReflect$_(t, this._$GetTopParent$_().GetAngle() + Math.PI))), 
                    this._$GetTransformWithParentHeight$_() && this._$GetTopParent$_()._$GetHeight$_() < 0 ? C33._$angleReflect$_(t, this._$GetTopParent$_().GetAngle()) : t;
                }
                _$_NeedsReflectAngleForMirrorOrFlip$_() {
                    const t = this._$GetParent$_();
                    return !!(this._$GetTransformWithParentWidth$_() && t._$GetWidth$_() < 0) || !!(this._$GetTransformWithParentHeight$_() && t._$GetHeight$_() < 0);
                }
                _$_NeedsReflectAngleForMirrorAndFlip$_() {
                    const t = this._$GetParent$_();
                    return !!(this._$GetTransformWithParentWidth$_() && t._$GetWidth$_() < 0 && this._$GetTransformWithParentHeight$_() && t._$GetHeight$_() < 0);
                }
                _$_MaybeUpdateSinCosAngle$_() {
                    const t = this._$_flags$_;
                    if (0 != (t & FLAG_SIN_COS_ANGLE_CHANGED)) {
                        const e = this.GetAngle();
                        this._$_sinA$_ = Math.sin(e), this._$_cosA$_ = Math.cos(e), 
                        this._$_flags$_ = t & ~FLAG_SIN_COS_ANGLE_CHANGED;
                    }
                }
                _$GetSinAngle$_() {
                    return this._$_MaybeUpdateSinCosAngle$_(), this._$_sinA$_;
                }
                _$GetCosAngle$_() {
                    return this._$_MaybeUpdateSinCosAngle$_(), this._$_cosA$_;
                }
                _$SetOriginX$_(t) {
                    this._$_ox$_ = +t;
                }
                _$OffsetOriginX$_(t) {
                    this._$_ox$_ += +t;
                }
                _$GetOriginX$_() {
                    return this._$_ox$_;
                }
                _$SetOriginY$_(t) {
                    this._$_oy$_ = +t;
                }
                _$OffsetOriginY$_(t) {
                    this._$_oy$_ += +t;
                }
                _$GetOriginY$_() {
                    return this._$_oy$_;
                }
                _$_SetColor$_(t) {
                    this._$_color$_.equals(t) || (this._$_color$_ === DEFAULT_COLOR ? (this._$_color$_ = C33._$New$_(C33._$Color$_, t), 
                    this._$_colorPremultiplied$_ = C33._$New$_(C33._$Color$_, t), 
                    this._$_colorPremultiplied$_._$premultiply$_()) : t._$equalsRgba$_(1, 1, 1, 1) ? (this._$_color$_ = DEFAULT_COLOR, 
                    this._$_colorPremultiplied$_ = DEFAULT_COLOR) : (this._$_color$_.set(t), 
                    this._$_colorPremultiplied$_.set(t), this._$_colorPremultiplied$_._$premultiply$_()), 
                    this._$_UpdateRendererStateGroup$_());
                }
                _$SetOpacity$_(t) {
                    if (t = C33._$clamp$_(+t, 0, 1), this._$GetTransformWithParentOpacity$_()) {
                        if (this._$_GetSceneGraphInfo$_()._$GetOwnOpacity$_() === t) return;
                        this._$_GetSceneGraphInfo$_()._$SetOwnOpacity$_(t), t = this._$GetOpacity$_();
                    } else if (this._$_color$_.a === t) return;
                    this._$_SetColorWithOpacity$_(t);
                }
                _$_SetOpacityOfChildren$_() {
                    if (this._$HasChildren$_()) {
                        const s = this._$GetChildren$_();
                        for (let t = 0, e = s.length; t < e; t++) {
                            const i = s[t];
                            i._$_SetColorWithOpacity$_(i._$GetOpacity$_());
                        }
                    }
                }
                _$_SetColorWithOpacity$_(t) {
                    tempColor._$copyRgb$_(this._$_color$_), tempColor.a = t, this._$_SetColor$_(tempColor), 
                    this._$_SetOpacityOfChildren$_();
                }
                _$OffsetOpacity$_(t) {
                    this._$GetTransformWithParentOpacity$_() ? this._$SetOpacity$_(this._$_GetSceneGraphInfo$_()._$GetOwnOpacity$_() + t) : this._$SetOpacity$_(this._$GetOpacity$_() + t);
                }
                _$GetOpacity$_() {
                    return this._$GetTransformWithParentOpacity$_() ? this._$GetParent$_()._$GetOpacity$_() * this._$_GetSceneGraphInfo$_()._$GetOwnOpacity$_() : this._$_color$_.a;
                }
                _$SetUnpremultipliedColor$_(t) {
                    this._$_color$_._$equalsIgnoringAlpha$_(t) || (tempColor._$copyRgb$_(t), 
                    tempColor.a = this._$GetOpacity$_(), this._$_SetColor$_(tempColor));
                }
                _$SetUnpremultipliedColorRGB$_(t, e, s) {
                    tempColor._$setRgb$_(t, e, s), this._$SetUnpremultipliedColor$_(tempColor);
                }
                _$OffsetUnpremultipliedColorRGB$_(t, e, s) {
                    0 === t && 0 === e && 0 === s || (tempColor._$copyRgb$_(this._$_color$_), 
                    tempColor.r += t, tempColor.g += e, tempColor.b += s, this._$SetUnpremultipliedColor$_(tempColor));
                }
                _$GetUnpremultipliedColor$_() {
                    return this._$_color$_;
                }
                _$GetPremultipliedColor$_() {
                    return this._$_colorPremultiplied$_;
                }
                _$GetDestroyWithParent$_() {
                    return 0 != (this._$_flags$_ & FLAG_DESTROY_WITH_PARENT);
                }
                _$SetDestroyWithParent$_(t) {
                    this._$_SetFlag$_(FLAG_DESTROY_WITH_PARENT, t);
                }
                _$GetTransformWithParentX$_() {
                    return 0 != (this._$_flags$_ & FLAG_TRANSFORM_WITH_PARENT_X);
                }
                _$SetTransformWithParentX$_(t) {
                    this._$_SetFlag$_(FLAG_TRANSFORM_WITH_PARENT_X, t);
                }
                _$GetTransformWithParentY$_() {
                    return 0 != (this._$_flags$_ & FLAG_TRANSFORM_WITH_PARENT_Y);
                }
                _$GetTransformWithParentXOrY$_() {
                    return 0 != (this._$_flags$_ & (FLAG_TRANSFORM_WITH_PARENT_X | FLAG_TRANSFORM_WITH_PARENT_Y));
                }
                _$SetTransformWithParentY$_(t) {
                    this._$_SetFlag$_(FLAG_TRANSFORM_WITH_PARENT_Y, t);
                }
                _$GetTransformWithParentWidth$_() {
                    return 0 != (this._$_flags$_ & FLAG_TRANSFORM_WITH_PARENT_W);
                }
                _$SetTransformWithParentWidth$_(t) {
                    this._$_SetFlag$_(FLAG_TRANSFORM_WITH_PARENT_W, t);
                }
                _$GetTransformWithParentHeight$_() {
                    return 0 != (this._$_flags$_ & FLAG_TRANSFORM_WITH_PARENT_H);
                }
                _$SetTransformWithParentHeight$_(t) {
                    this._$_SetFlag$_(FLAG_TRANSFORM_WITH_PARENT_H, t);
                }
                _$GetTransformWithParentAngle$_() {
                    return 0 != (this._$_flags$_ & FLAG_TRANSFORM_WITH_PARENT_A);
                }
                _$SetTransformWithParentAngle$_(t) {
                    this._$_SetFlag$_(FLAG_TRANSFORM_WITH_PARENT_A, t);
                }
                _$GetTransformWithParentZElevation$_() {
                    return 0 != (this._$_flags$_ & FLAG_TRANSFORM_WITH_PARENT_Z_ELEVATION);
                }
                _$SetTransformWithParentZElevation$_(t) {
                    this._$_SetFlag$_(FLAG_TRANSFORM_WITH_PARENT_Z_ELEVATION, t);
                }
                _$GetTransformWithParentOpacity$_() {
                    return 0 != (this._$_flags$_ & FLAG_TRANSFORM_WITH_PARENT_OPACITY);
                }
                _$SetTransformWithParentOpacity$_(t) {
                    this._$_SetFlag$_(FLAG_TRANSFORM_WITH_PARENT_OPACITY, t);
                }
                _$GetTransformWithParentVisibility$_() {
                    return 0 != (this._$_flags$_ & FLAG_TRANSFORM_WITH_PARENT_VISIBILITY);
                }
                _$SetTransformWithParentVisibility$_(t) {
                    this._$_SetFlag$_(FLAG_TRANSFORM_WITH_PARENT_VISIBILITY, t);
                }
                _$_ClearAllSceneGraphFlags$_() {
                    this._$_flags$_ &= ~MASK_ALL_SCENE_GRAPH_FLAGS;
                }
                _$AddChild$_(t, e) {
                    if (t === this) return !1;
                    if (t._$HasParent$_()) return !1;
                    if (this._$_HasChildRecursive$_(t)) return !1;
                    if (this._$_HasAnyParent$_(t)) return !1;
                    const s = t._$GetX$_(), i = t._$GetY$_(), r = t._$GetWidth$_(), n = t._$GetHeight$_(), h = t.GetAngle(), o = t._$GetZElevation$_(), a = t._$GetOpacity$_(), l = (t._$_SetParent$_(this), 
                    t._$SetTransformWithParentX$_(e._$transformX$_), t._$SetTransformWithParentY$_(e._$transformY$_), 
                    t._$SetTransformWithParentWidth$_(e._$transformWidth$_), t._$SetTransformWithParentHeight$_(e._$transformHeight$_), 
                    t._$SetTransformWithParentAngle$_(e._$transformAngle$_), t._$SetTransformWithParentZElevation$_(e._$transformZElevation$_), 
                    t._$SetTransformWithParentOpacity$_(e._$transformOpacity$_), 
                    t._$SetTransformWithParentVisibility$_(e._$transformVisibility$_), 
                    t._$SetDestroyWithParent$_(e._$destroyWithParent$_), s - this._$GetX$_()), u = i - this._$GetY$_(), c = -this.GetAngle(), f = Math.cos(c), d = Math.sin(c);
                    if (e._$transformX$_ && (e._$transformAngle$_ ? t._$_x$_ = l * f - u * d : t._$_x$_ = l, 
                    e._$transformWidth$_)) {
                        const p = this._$GetWidth$_() / this._$_sceneGraphInfo$_._$_GetStartWidth$_();
                        0 != p && (t._$_x$_ /= p);
                    }
                    if (e._$transformY$_ && (e._$transformAngle$_ ? t._$_y$_ = l * d + u * f : t._$_y$_ = u, 
                    e._$transformHeight$_)) {
                        const m = this._$GetHeight$_() / this._$_sceneGraphInfo$_._$_GetStartHeight$_();
                        0 != m && (t._$_y$_ /= m);
                    }
                    if (e._$transformWidth$_) {
                        const C = this._$GetWidth$_();
                        0 === C || C === Number.EPSILON ? (t._$_w$_ = 1, t._$_sceneGraphInfo$_._$SetStartScaleX$_(1)) : (t._$_w$_ = r / this._$GetWidth$_(), 
                        t._$_sceneGraphInfo$_._$SetStartScaleX$_(t._$_w$_));
                    }
                    if (e._$transformHeight$_) {
                        const g = this._$GetHeight$_();
                        0 === g || g === Number.EPSILON ? (t._$_h$_ = 1, t._$_sceneGraphInfo$_._$SetStartScaleY$_(1)) : (t._$_h$_ = n / this._$GetHeight$_(), 
                        t._$_sceneGraphInfo$_._$SetStartScaleY$_(t._$_h$_));
                    }
                    return e._$transformAngle$_ && (t._$_a$_ = h - this.GetAngle()), 
                    e._$transformZElevation$_ && (t._$_zElevation$_ = o - this._$GetZElevation$_()), 
                    e._$transformOpacity$_ && t._$_sceneGraphInfo$_._$SetOwnOpacity$_(a), 
                    e._$transformVisibility$_ && t._$SetVisible$_(this._$IsVisible$_()), 
                    this._$_AddChildToSceneGraphInfo$_(t), this._$SetBboxChanged$_(), 
                    this._$_SetOpacityOfChildren$_(), !0;
                }
                _$RemoveChild$_(t) {
                    if (t._$GetParent$_() === this) {
                        const e = t._$GetX$_(), s = t._$GetY$_(), i = t._$GetWidth$_(), r = t._$GetHeight$_(), n = t.GetAngle(), h = t._$GetZElevation$_(), o = t._$GetOpacity$_();
                        t._$_SetParent$_(null), t._$_ClearAllSceneGraphFlags$_(), 
                        t._$SetXY$_(e, s), t._$SetSize$_(i, r), t._$SetAngle$_(n), 
                        t._$SetZElevation$_(h), t._$SetOpacity$_(o), this._$_RemoveChildFromSceneGraphInfo$_(t), 
                        this._$SetBboxChanged$_();
                    }
                }
                _$GetTmpHierarchyPosition$_() {
                    return this._$_tmpHierarchyPosition$_;
                }
                _$_ResetAllSceneGraphState$_() {
                    this._$_BuildTmpSceneGraphData$_();
                    const t = [ ...this.children() ];
                    for (const s of t) this._$RemoveChild$_(s);
                    const e = this._$GetParent$_();
                    e && e._$RemoveChild$_(this), this._$_ClearAllSceneGraphFlags$_();
                }
                _$_BuildTmpSceneGraphData$_() {
                    if (this._$_SetTmpHierarchyPosition$_(), !this._$_tmpSceneGraphChildren$_) {
                        const e = [ ...this.children() ];
                        e.length && (this._$_tmpSceneGraphChildren$_ = [], this._$_tmpSceneGraphChildrenIndexes$_ = new WeakMap());
                        let t = 0;
                        for (const s of e) {
                            const i = s._$GetInstance$_();
                            this._$_tmpSceneGraphChildren$_.push(i), this._$_tmpSceneGraphChildrenIndexes$_.set(i, t), 
                            t++;
                        }
                    }
                    const t = this._$GetParent$_();
                    t && t._$_BuildTmpSceneGraphData$_();
                }
                _$_SetTmpHierarchyPosition$_() {
                    if (-1 === this._$_tmpHierarchyPosition$_) {
                        const t = [ ...this._$parents$_() ];
                        this._$_tmpHierarchyPosition$_ = t.length;
                        for (const s of t) s._$_SetTmpHierarchyPosition$_();
                        const e = [ ...this.children() ];
                        for (const i of e) i._$_SetTmpHierarchyPosition$_();
                    }
                }
                _$_ReleaseTmpSceneGraphInfo$_() {
                    this._$_tmpSceneGraphChildren$_ && (this._$_tmpSceneGraphChildren$_.length = 0), 
                    this._$_tmpSceneGraphChildren$_ = null, this._$_tmpSceneGraphChildrenIndexes$_ = null;
                    const t = this._$GetParent$_();
                    t && t._$_ReleaseTmpSceneGraphInfo$_(), this._$_tmpHierarchyPosition$_ = -1;
                }
                _$HasParent$_() {
                    return null !== this._$GetParent$_();
                }
                _$GetParent$_() {
                    const t = this._$_sceneGraphInfo$_;
                    return null !== t ? t._$GetParent$_() : null;
                }
                _$GetTopParent$_() {
                    let t = this;
                    for (;t._$HasParent$_(); ) t = t._$GetParent$_();
                    return t;
                }
                *_$parents$_() {
                    let t = this._$GetParent$_();
                    for (;t; ) yield t, t = t._$GetParent$_();
                }
                _$HasChild$_(t) {
                    return this._$GetChildren$_().includes(t);
                }
                _$HasChildren$_() {
                    const t = this._$_sceneGraphInfo$_;
                    return null !== t && t._$HasChildren$_();
                }
                _$GetChildren$_() {
                    const t = this._$_sceneGraphInfo$_;
                    return null !== t ? t._$GetChildren$_() : EMPTY_ARRAY;
                }
                children() {
                    return this._$GetChildren$_();
                }
                *_$allChildren$_() {
                    for (const t of this.children()) yield t, yield* t._$allChildren$_();
                }
                _$GetChildCount$_() {
                    return this._$GetChildren$_().length;
                }
                _$GetAllChildCount$_() {
                    return [ ...this._$allChildren$_() ].length;
                }
                _$GetChildAt$_(t) {
                    const e = this._$GetChildren$_();
                    return (t = Math.floor(+t)) < 0 || t >= e.length ? null : e[t];
                }
                _$GetChildIndex$_(e) {
                    if (e) {
                        const s = this._$GetChildren$_();
                        if (s) for (let t = 0; t < s.length; t++) if (e === s[t]) return t;
                    }
                    return NaN;
                }
                _$_CreateSceneGraphInfo$_(t) {
                    this._$_sceneGraphInfo$_ || (this._$_sceneGraphInfo$_ = C33._$New$_(C33._$SceneGraphInfo$_, this)), 
                    t && this._$_sceneGraphInfo$_._$SetParent$_(t);
                }
                _$_GetSceneGraphInfo$_() {
                    return this._$_sceneGraphInfo$_;
                }
                _$_ReleaseSceneGraphInfo$_() {
                    this._$_sceneGraphInfo$_ && (this._$_sceneGraphInfo$_._$Release$_(), 
                    this._$_sceneGraphInfo$_ = null);
                }
                _$_SetParent$_(t) {
                    t ? (t._$_CreateSceneGraphInfo$_(null), this._$_CreateSceneGraphInfo$_(t)) : (this._$_sceneGraphInfo$_ && this._$_sceneGraphInfo$_._$SetParent$_(null), 
                    this._$HasChildren$_() || this._$_ReleaseSceneGraphInfo$_());
                }
                _$_HasAnyParent$_(t) {
                    if (!this._$HasParent$_()) return !1;
                    const e = this._$GetParent$_();
                    return e === t || e._$_HasAnyParent$_(t);
                }
                _$_HasChildRecursive$_(t) {
                    if (this._$HasChild$_(t)) return !0;
                    for (const e of this._$GetChildren$_()) if (e._$_HasChildRecursive$_(t)) return !0;
                    return !1;
                }
                _$_AddChildToSceneGraphInfo$_(t) {
                    this._$_sceneGraphInfo$_._$GetChildren$_().push(t);
                }
                _$_RemoveChildFromSceneGraphInfo$_(t) {
                    const e = this._$_sceneGraphInfo$_._$GetChildren$_(), s = e.indexOf(t);
                    -1 !== s && e.splice(s, 1), 0 !== e.length || this._$HasParent$_() || this._$_ReleaseSceneGraphInfo$_(), 
                    t._$HasChildren$_() || t._$_ReleaseSceneGraphInfo$_();
                }
                _$GetSceneGraphChildrenExportData$_() {
                    const t = sceneGraphExportDataMap.get(this);
                    return t ? t._$childrenData$_ : null;
                }
                _$GetSceneGraphZIndexExportData$_() {
                    const t = sceneGraphExportDataMap.get(this);
                    return t ? t._$zIndexData$_ : NaN;
                }
                _$GetSceneGraphZIndex$_() {
                    const t = sceneGraphZIndexMap.get(this);
                    return C33._$IsFiniteNumber$_(t) ? t : NaN;
                }
                _$SetSceneGraphZIndex$_(t) {
                    sceneGraphZIndexMap.set(this, t);
                }
                _$SetUsePointsShaderProgram$_() {
                    this._$_SetFlag$_(FLAG_USE_POINTS_SHADER_PROGRAM, !0), this._$_UpdateRendererStateGroup$_();
                }
                _$_UpdateRendererStateGroup$_() {
                    if (enableUpdateRendererStateGroup) {
                        const e = this._$_runtime$_._$GetRenderer$_();
                        this._$_stateGroup$_ && e._$ReleaseStateGroup$_(this._$_stateGroup$_);
                        let t;
                        t = 0 != (this._$_flags$_ & FLAG_USE_POINTS_SHADER_PROGRAM) ? e._$GetPointsRenderingProgram$_() || "<point>" : e._$GetTextureFillShaderProgram$_() || "<default>", 
                        this._$_stateGroup$_ = e._$AcquireStateGroup$_(t, this._$GetBlendMode$_(), this._$_colorPremultiplied$_, this._$GetZElevation$_());
                    }
                }
                _$GetRendererStateGroup$_() {
                    return this._$_stateGroup$_;
                }
                _$HasDefaultColor$_() {
                    return this._$_color$_ === DEFAULT_COLOR;
                }
                _$SetBlendMode$_(t) {
                    if ((t |= 0) < 0 || 31 < t) throw new RangeError("invalid blend mode");
                    this._$GetBlendMode$_() !== t && (this._$_flags$_ = this._$_flags$_ & ~FLAG_BLEND_MODE_MASK | t << FLAG_BLEND_MODE_BIT_OFFSET, 
                    this._$_UpdateRendererStateGroup$_());
                }
                _$GetBlendMode$_() {
                    return (this._$_flags$_ & FLAG_BLEND_MODE_MASK) >> FLAG_BLEND_MODE_BIT_OFFSET;
                }
                _$_SetLayer$_(t, e) {
                    const s = e && this._$_layer$_ !== t;
                    s && this._$_RemoveFromRenderCells$_(), this._$_objectClass$_._$_OnWorldInstanceLayerChanged$_(this, this._$_layer$_, t), 
                    this._$_layer$_ = t, s && this._$_UpdateRenderCell$_(), 0 !== this._$GetZElevation$_() && this._$_layer$_._$_SetAnyInstanceZElevated$_();
                }
                _$GetLayer$_() {
                    return this._$_layer$_;
                }
                _$GetLayout$_() {
                    return this._$GetLayer$_()._$GetLayout$_();
                }
                _$_SetZIndex$_(t) {
                    this._$_zIndex$_ = 0 | t;
                }
                _$GetZIndex$_() {
                    return this._$_layer$_._$_UpdateZIndices$_(), this._$_zIndex$_;
                }
                _$_SetHTMLZIndex$_(t) {
                    this._$_htmlZIndex$_ = 0 | t;
                }
                _$GetHTMLZIndex$_() {
                    return this._$_layer$_._$_UpdateHTMLZIndices$_(), this._$_htmlZIndex$_;
                }
                _$_GetLastCachedZIndex$_() {
                    return this._$_zIndex$_;
                }
                _$_SetFlag$_(t, e) {
                    e ? this._$_flags$_ |= t : this._$_flags$_ &= ~t;
                }
                _$IsVisible$_() {
                    return 0 != (this._$_flags$_ & FLAG_IS_VISIBLE);
                }
                _$SetVisible$_(t) {
                    if (this._$_SetFlag$_(FLAG_IS_VISIBLE, t), this._$HasChildren$_()) for (const e of this._$GetChildren$_()) e._$GetTransformWithParentVisibility$_() && e._$SetVisible$_(t);
                }
                _$IsCollisionEnabled$_() {
                    return 0 != (this._$_flags$_ & FLAG_COLLISION_ENABLED);
                }
                _$SetCollisionEnabled$_(t) {
                    t = !!t, this._$IsCollisionEnabled$_() !== t && (this._$_SetFlag$_(FLAG_COLLISION_ENABLED, t), 
                    t ? this._$SetBboxChanged$_() : this._$_RemoveFromCollisionCells$_());
                }
                _$SetSolidCollisionFilter$_(t, e) {
                    if (this._$_SetFlag$_(FLAG_SOLID_FILTER_INCLUSIVE, t), this._$_solidFilterTags$_ && this._$_solidFilterTags$_.clear(), 
                    e.trim()) {
                        this._$_solidFilterTags$_ || (this._$_solidFilterTags$_ = new Set());
                        for (const s of e.split(" ")) s && this._$_solidFilterTags$_.add(s.toLowerCase());
                    } else this._$_solidFilterTags$_ = null;
                }
                _$IsSolidCollisionAllowed$_(t) {
                    const e = 0 != (this._$_flags$_ & FLAG_SOLID_FILTER_INCLUSIVE), s = this._$_solidFilterTags$_;
                    if (t && s) for (const i of s) if (t.has(i)) return e;
                    return !e;
                }
                _$SetBboxChanged$_() {
                    if (this._$_flags$_ |= FLAG_BBOX_CHANGED | FLAG_COLLISION_CELL_CHANGED | FLAG_MESH_CHANGED, 
                    this._$_objectClass$_._$_SetAnyCollisionCellChanged$_(!0), this._$_runtime$_._$UpdateRender$_(), 
                    this._$_layer$_._$UsesRenderCells$_() && (this._$CalculateBbox$_(this._$_boundingBox$_, this._$_boundingQuad$_, !0), 
                    this._$_flags$_ &= ~FLAG_BBOX_CHANGED, this._$_UpdateRenderCell$_()), 
                    0 != (this._$_flags$_ & FLAG_ENABLE_BBOX_CHANGED_EVENT) && this._$_inst$_._$Dispatcher$_().dispatchEvent(bboxChangeEvent), 
                    null !== this._$_sceneGraphInfo$_) {
                        const s = this._$_sceneGraphInfo$_._$GetChildren$_();
                        for (let t = 0, e = s.length; t < e; ++t) s[t]._$SetBboxChanged$_();
                    }
                }
                _$CalculateBbox$_(t, e, s) {
                    const i = this._$GetX$_(), r = this._$GetY$_(), n = this._$GetWidth$_(), h = this._$GetHeight$_(), o = this.GetAngle();
                    t._$setWH$_(i - this._$_ox$_ * n, r - this._$_oy$_ * h, n, h), 
                    s && this._$HasMesh$_() && this._$_ExpandBboxForMesh$_(t), 0 === o ? e._$setFromRect$_(t) : (t.offset(-i, -r), 
                    e._$setFromRotatedRectPrecalc$_(t, this._$GetSinAngle$_(), this._$GetCosAngle$_()), 
                    e.offset(i, r), e._$getBoundingBox$_(t)), t.normalize();
                }
                _$_UpdateBbox$_() {
                    const t = this._$_flags$_;
                    0 != (t & FLAG_BBOX_CHANGED) && (this._$CalculateBbox$_(this._$_boundingBox$_, this._$_boundingQuad$_, !0), 
                    this._$_flags$_ = t & ~FLAG_BBOX_CHANGED);
                }
                _$GetBoundingBox$_() {
                    return this._$_UpdateBbox$_(), this._$_boundingBox$_;
                }
                _$GetBoundingQuad$_() {
                    return this._$_UpdateBbox$_(), this._$_boundingQuad$_;
                }
                _$PixelRoundQuad$_(t) {
                    const e = this._$GetX$_(), s = this._$GetY$_(), i = Math.round(e) - e, r = Math.round(s) - s;
                    return 0 == i && 0 == r ? t : (tempQuad._$copy$_(t), tempQuad.offset(i, r), 
                    tempQuad);
                }
                _$OverwriteBoundingBox$_(t) {
                    this._$_boundingBox$_._$copy$_(t), this._$_boundingQuad$_._$setFromRect$_(this._$_boundingBox$_), 
                    this._$_flags$_ &= ~FLAG_BBOX_CHANGED, this._$_UpdateCollisionCell$_(), 
                    this._$_UpdateRenderCell$_();
                }
                _$SetBboxChangeEventEnabled$_(t) {
                    this._$_SetFlag$_(FLAG_ENABLE_BBOX_CHANGED_EVENT, t);
                }
                _$IsBboxChangeEventEnabled$_() {
                    return 0 != (this._$_flags$_ & FLAG_ENABLE_BBOX_CHANGED_EVENT);
                }
                _$IsInViewport$_(t, e, s) {
                    return e && 0 !== this._$GetDepth$_() ? this._$IsInViewport3D$_(this._$GetLayer$_()._$_GetViewFrustum$_()) : 0 === this._$GetZElevation$_() || s ? t._$intersectsRect$_(this._$GetBoundingBox$_()) : this._$_IsInViewport_ZElevated$_();
                }
                _$_IsInViewport_ZElevated$_() {
                    const t = this._$GetLayer$_(), e = this._$GetTotalZElevation$_();
                    return !(e >= t._$Get2DCameraZ$_()) && (t._$GetViewportForZ$_(e, tempRect), 
                    tempRect._$intersectsRect$_(this._$GetBoundingBox$_()));
                }
                _$IsInViewport3D$_(t) {
                    const e = this._$GetBoundingBox$_(), s = e._$getLeft$_(), i = e._$getRight$_(), r = e._$getTop$_(), n = e._$getBottom$_(), h = this._$GetTotalZElevation$_(), o = h + this._$GetDepth$_();
                    return t._$ContainsAABB$_(s, r, h, i, n, o);
                }
                _$IsInViewport2$_() {
                    const t = this._$GetLayer$_();
                    if (t._$Has3DCamera$_()) return this._$IsInViewport3D$_(t._$_GetViewFrustum$_());
                    {
                        const e = t._$GetLayout$_();
                        return this._$IsInViewport$_(t._$GetViewport$_(), e._$HasVanishingPointOutsideViewport$_(), e._$IsOrthographicProjection$_());
                    }
                }
                _$_SetDrawBackFaceOnly$_(t) {
                    this._$_SetFlag$_(FLAG_DRAW_BACK_FACE_ONLY, t);
                }
                _$_SetDrawNonBackFacesOnly$_(t) {
                    this._$_SetFlag$_(FLAG_DRAW_NON_BACK_FACES_ONLY, t);
                }
                _$IsDrawBackFaceOnly$_() {
                    return 0 != (this._$_flags$_ & FLAG_DRAW_BACK_FACE_ONLY);
                }
                _$IsDrawNonBackFacesOnly$_() {
                    return 0 != (this._$_flags$_ & FLAG_DRAW_NON_BACK_FACES_ONLY);
                }
                _$SetSourceCollisionPoly$_(t) {
                    this._$_sourceCollisionPoly$_ = t, this._$_DiscardTransformedCollisionPoly$_(), 
                    this._$HasMesh$_() && (this._$_meshInfo$_._$meshPoly$_ = null);
                }
                _$GetSourceCollisionPoly$_() {
                    return this._$_sourceCollisionPoly$_;
                }
                _$HasOwnCollisionPoly$_() {
                    return null !== this._$_sourceCollisionPoly$_ || this._$HasMesh$_();
                }
                _$GetTransformedCollisionPoly$_() {
                    return this._$_GetCustomTransformedCollisionPolyPrecalc$_(this._$GetWidth$_(), this._$GetHeight$_(), this.GetAngle(), this._$GetSinAngle$_(), this._$GetCosAngle$_());
                }
                _$GetCustomTransformedCollisionPoly$_(t, e, s) {
                    let i = 0, r = 1;
                    return 0 !== s && (i = Math.sin(s), r = Math.cos(s)), this._$_GetCustomTransformedCollisionPolyPrecalc$_(t, e, s, i, r);
                }
                _$_GetCustomTransformedCollisionPolyPrecalc$_(r, n, t, h, o) {
                    let e = this._$_transformedPolyInfo$_;
                    null === e && (e = {
                        _$poly$_: C33._$New$_(C33._$CollisionPoly$_),
                        width: NaN,
                        height: NaN,
                        angle: NaN
                    }, this._$_transformedPolyInfo$_ = e);
                    const a = e._$poly$_;
                    if (e.width !== r || e.height !== n || e.angle !== t) {
                        const l = this._$_sourceCollisionPoly$_;
                        if (this._$HasMesh$_()) {
                            let t = this._$GetOriginX$_(), e = this._$GetOriginY$_(), s = this._$GetSourceMesh$_(), i = this._$_meshInfo$_._$meshPoly$_;
                            i || (l ? (tempCollisionPoly._$copy$_(l), tempCollisionPoly.offset(t, e)) : tempCollisionPoly._$setDefaultPoints$_(), 
                            i = s._$InsertPolyMeshVertices$_(tempCollisionPoly), 
                            this._$_meshInfo$_._$meshPoly$_ = i), s._$TransformCollisionPoly$_(i, a), 
                            a.offset(-t, -e), a._$transformPrecalc$_(r, n, h, o);
                        } else l ? (a._$copy$_(l), a._$transformPrecalc$_(r, n, h, o)) : a._$setFromQuad$_(this._$GetBoundingQuad$_(), -this._$GetX$_(), -this._$GetY$_());
                        e.width = r, e.height = n, e.angle = t;
                    }
                    return a;
                }
                _$_DiscardTransformedCollisionPoly$_() {
                    this._$SetPhysicsBodyChanged$_(!0);
                    const t = this._$_transformedPolyInfo$_;
                    null !== t && (t.width = NaN);
                }
                _$CreateMesh$_(t, e) {
                    if (t = Math.floor(t), e = Math.floor(e), !this._$GetInstance$_()._$GetPlugin$_()._$SupportsMesh$_()) throw new Error("object does not support mesh");
                    this._$ReleaseMesh$_(), this._$_meshInfo$_ = {
                        _$sourceMesh$_: C33._$New$_(C33._$Gfx$_._$Mesh$_, t, e),
                        _$transformedMesh$_: C33._$New$_(C33._$Gfx$_._$Mesh$_, t, e),
                        _$meshPoly$_: null
                    };
                }
                _$HasMesh$_() {
                    return null !== this._$_meshInfo$_;
                }
                _$GetSourceMesh$_() {
                    if (this._$HasMesh$_()) return this._$_meshInfo$_._$sourceMesh$_;
                    throw new Error("no mesh");
                }
                _$GetTransformedMesh$_() {
                    if (this._$HasMesh$_()) return this._$_meshInfo$_._$transformedMesh$_;
                    throw new Error("no mesh");
                }
                _$SetMeshChanged$_(t) {
                    this._$_SetFlag$_(FLAG_MESH_CHANGED, t);
                }
                _$IsMeshChanged$_() {
                    return 0 != (this._$_flags$_ & FLAG_MESH_CHANGED);
                }
                _$SetPhysicsBodyChanged$_(t) {
                    this._$_SetFlag$_(FLAG_PHYSICS_BODY_CHANGED, t);
                }
                _$IsPhysicsBodyChanged$_() {
                    return 0 != (this._$_flags$_ & FLAG_PHYSICS_BODY_CHANGED);
                }
                _$_ExpandBboxForMesh$_(t) {
                    const e = this._$_meshInfo$_._$sourceMesh$_, s = Math.min(e._$GetMinX$_(), 0), i = Math.min(e._$GetMinY$_(), 0), r = Math.max(e._$GetMaxX$_(), 1), n = Math.max(e._$GetMaxY$_(), 1), h = t.width(), o = t.height();
                    t.offsetLeft(s * h), t.offsetTop(i * o), t._$offsetRight$_((r - 1) * h), 
                    t._$offsetBottom$_((n - 1) * o), this._$_depth$_ = e._$GetMaxZ$_();
                }
                _$ReleaseMesh$_() {
                    this._$_meshInfo$_ && (this._$_meshInfo$_._$sourceMesh$_._$Release$_(), 
                    this._$_meshInfo$_._$transformedMesh$_._$Release$_(), this._$_meshInfo$_ = null, 
                    this._$_DiscardTransformedCollisionPoly$_());
                }
                _$SetMeshPoint$_(t, e, s) {
                    t = Math.floor(t), e = Math.floor(e);
                    const i = s.mode || "absolute";
                    if (!VALID_SET_MESH_POINT_MODES.has(i)) throw new Error("invalid mode");
                    let r = "relative" === i, n = s.x, h = s.y, o = s._$zElevation$_, a = "number" == typeof s.u ? s.u : r ? 0 : -1, l = "number" == typeof s.v ? s.v : r ? 0 : -1;
                    if (!this._$HasMesh$_()) return !1;
                    const u = this._$GetSourceMesh$_(), c = u._$GetMeshPointAt$_(t, e);
                    if (null === c) return !1;
                    let f = !1;
                    return "number" == typeof o && c._$GetZElevation$_() !== o && (c._$SetZElevation$_(o), 
                    f = !0), r && (n += t / (u._$GetHSize$_() - 1), h += e / (u._$GetVSize$_() - 1)), 
                    a = -1 !== a || r ? (r && (a += t / (u._$GetHSize$_() - 1)), 
                    C33._$clamp$_(a, 0, 1)) : c._$GetU$_(), l = -1 !== l || r ? (r && (l += e / (u._$GetVSize$_() - 1)), 
                    C33._$clamp$_(l, 0, 1)) : c._$GetV$_(), c._$GetX$_() === n && c._$GetY$_() === h && c._$GetU$_() === a && c._$GetV$_() === l ? f : (c._$SetX$_(n), 
                    c._$SetY$_(h), c._$SetU$_(a), c._$SetV$_(l), this._$_DiscardTransformedCollisionPoly$_(), 
                    !0);
                }
                _$HasTilemap$_() {
                    return this._$_inst$_._$HasTilemap$_();
                }
                _$ContainsPoint$_(t, e) {
                    return !!this._$GetBoundingBox$_()._$containsPoint$_(t, e) && !!this._$GetBoundingQuad$_()._$containsPoint$_(t, e) && (this._$HasTilemap$_() ? this._$_inst$_._$GetSdkInstance$_()._$TestPointOverlapTile$_(t, e) : !this._$HasOwnCollisionPoly$_() || this._$GetTransformedCollisionPoly$_()._$containsPoint$_(t - this._$GetX$_(), e - this._$GetY$_()));
                }
                _$_IsCollisionCellChanged$_() {
                    return 0 != (this._$_flags$_ & FLAG_COLLISION_CELL_CHANGED);
                }
                _$_UpdateCollisionCell$_() {
                    if (this._$_IsCollisionCellChanged$_() && this._$IsCollisionEnabled$_() && 0 == (this._$_flags$_ & FLAG_DESTROYED)) {
                        const t = this._$GetBoundingBox$_(), e = this._$_objectClass$_._$_GetCollisionCellGrid$_(), s = this._$_collisionCells$_;
                        if (tempRect.set(e._$XToCell$_(t._$getLeft$_()), e._$YToCell$_(t._$getTop$_()), e._$XToCell$_(t._$getRight$_()), e._$YToCell$_(t._$getBottom$_())), 
                        !s.equals(tempRect)) {
                            const i = this._$_inst$_;
                            s === DEFAULT_COLLISION_CELLS ? (e._$Update$_(i, null, tempRect), 
                            this._$_collisionCells$_ = C33._$New$_(C33.Rect, tempRect)) : (e._$Update$_(i, s, tempRect), 
                            s._$copy$_(tempRect)), this._$_flags$_ &= ~FLAG_COLLISION_CELL_CHANGED;
                        }
                    }
                }
                _$_SetCollisionCellChanged$_() {
                    this._$_flags$_ |= FLAG_COLLISION_CELL_CHANGED;
                }
                _$_RemoveFromCollisionCells$_() {
                    const t = this._$_collisionCells$_;
                    t !== DEFAULT_COLLISION_CELLS && (this._$_objectClass$_._$_GetCollisionCellGrid$_()._$Update$_(this._$_inst$_, t, null), 
                    this._$_collisionCells$_ = DEFAULT_COLLISION_CELLS);
                }
                _$_UpdateRenderCell$_() {
                    const t = this._$GetLayer$_();
                    if (t._$UsesRenderCells$_() && 0 == (this._$_flags$_ & FLAG_DESTROYED)) {
                        const e = t._$GetRenderGrid$_(), s = this._$GetBoundingBox$_(), i = this._$_renderCells$_;
                        if (tempRect.set(e._$XToCell$_(s._$getLeft$_()), e._$YToCell$_(s._$getTop$_()), e._$XToCell$_(s._$getRight$_()), e._$YToCell$_(s._$getBottom$_())), 
                        !i.equals(tempRect)) {
                            const r = this._$_inst$_;
                            i === DEFAULT_RENDER_CELLS ? (e._$Update$_(r, null, tempRect), 
                            this._$_renderCells$_ = C33._$New$_(C33.Rect, tempRect)) : (e._$Update$_(r, i, tempRect), 
                            i._$copy$_(tempRect)), t._$SetRenderListStale$_();
                        }
                    }
                }
                _$_RemoveFromRenderCells$_() {
                    const t = this._$_renderCells$_;
                    t !== DEFAULT_RENDER_CELLS && (this._$GetLayer$_()._$GetRenderGrid$_()._$Update$_(this._$_inst$_, t, null), 
                    this._$_renderCells$_ = DEFAULT_RENDER_CELLS);
                }
                _$GetRenderCellRange$_() {
                    return this._$_renderCells$_;
                }
                _$ZOrderMoveToTop$_() {
                    const t = this._$_inst$_, e = this._$_layer$_, s = e._$_GetInstances$_();
                    s.length && s.at(-1) === t || (e._$_RemoveInstance$_(t, !1), 
                    e._$_AddInstance$_(t, !1), this._$_runtime$_._$UpdateRender$_());
                }
                _$ZOrderMoveToBottom$_() {
                    const t = this._$_inst$_, e = this._$_layer$_, s = e._$_GetInstances$_();
                    s.length && s[0] === t || (e._$_RemoveInstance$_(t, !1), e._$_PrependInstance$_(t, !1), 
                    this._$_runtime$_._$UpdateRender$_());
                }
                _$ZOrderMoveToLayer$_(t) {
                    const e = this._$_inst$_, s = this._$_layer$_;
                    if (s._$GetLayout$_() !== t._$GetLayout$_()) throw new Error("layer from different layout");
                    t !== s && (s._$_RemoveInstance$_(e, !0), this._$_SetLayer$_(t), 
                    t._$_AddInstance$_(e, !0), this._$_runtime$_._$UpdateRender$_());
                }
                _$ZOrderMoveAdjacentToInstance$_(t, e) {
                    let s = this._$_inst$_, i = !1, r = this._$_layer$_;
                    if (t._$GetUID$_() !== s._$GetUID$_()) {
                        const n = t._$GetWorldInfo$_();
                        if (!n) throw new Error("expected world instance");
                        const h = n._$GetLayer$_(), o = (r._$GetIndex$_() !== h._$GetIndex$_() && (r._$_RemoveInstance$_(s, !0), 
                        this._$_SetLayer$_(h), h._$_AddInstance$_(s, !0), i = !0), 
                        h._$MoveInstanceAdjacent$_(s, t, !!e));
                        (i || o) && this._$_runtime$_._$UpdateRender$_();
                    }
                }
                _$GetInstanceEffectList$_() {
                    return this._$_instanceEffectList$_;
                }
                _$_SetHasAnyActiveEffect$_(t) {
                    this._$_SetFlag$_(FLAG_HAS_ANY_ACTIVE_EFFECT, t);
                }
                _$HasAnyActiveEffect$_() {
                    return 0 != (this._$_flags$_ & FLAG_HAS_ANY_ACTIVE_EFFECT);
                }
                _$_SaveToJson$_(t, e = null) {
                    const s = {
                        x: this._$GetX$_(),
                        y: this._$GetY$_(),
                        w: this._$GetWidth$_(),
                        h: this._$GetHeight$_(),
                        l: this._$GetLayer$_()._$GetSID$_(),
                        zi: this._$GetZIndex$_()
                    }, i = (0 !== this._$GetZElevation$_() && (s.ze = this._$GetZElevation$_()), 
                    0 !== this.GetAngle() && (s.a = this._$_GetAngleNoReflect$_()), 
                    this._$HasDefaultColor$_() || (s.c = this._$_color$_.toJSON()), 
                    .5 !== this._$GetOriginX$_() && (s.oX = this._$GetOriginX$_()), 
                    .5 !== this._$GetOriginY$_() && (s.oY = this._$GetOriginY$_()), 
                    0 !== this._$GetBlendMode$_() && (s.bm = this._$GetBlendMode$_()), 
                    this._$IsVisible$_() || (s.v = this._$IsVisible$_()), this._$IsCollisionEnabled$_() || (s.ce = this._$IsCollisionEnabled$_()), 
                    this._$IsBboxChangeEventEnabled$_() && (s.be = this._$IsBboxChangeEventEnabled$_()), 
                    this._$_instanceEffectList$_ && (s.fx = this._$_instanceEffectList$_._$_SaveToJson$_()), 
                    0 != (this._$_flags$_ & FLAG_SOLID_FILTER_INCLUSIVE));
                    return i && (s.sfi = i), this._$_solidFilterTags$_ && (s.sft = [ ...this._$_solidFilterTags$_ ].join(" ")), 
                    this._$_sceneGraphInfo$_ && "visual-state" !== t && (s.sgi = this._$_sceneGraphInfo$_._$_SaveToJson$_(t, e), 
                    sceneGraphExportDataMap.has(this)) && (s.sgcd = sceneGraphExportDataMap.get(this)._$childrenData$_, 
                    s.sgzid = sceneGraphExportDataMap.get(this)._$zIndexData$_), 
                    this._$HasMesh$_() && (s.mesh = this._$GetSourceMesh$_()._$SaveToJson$_()), 
                    s;
                }
                _$_SaveSceneGraphPropertiesToJson$_() {
                    return {
                        x: this._$_x$_,
                        y: this._$_y$_,
                        z: this._$_zElevation$_,
                        w: this._$_w$_,
                        h: this._$_h$_,
                        a: this._$_a$_,
                        sgi: this._$_GetSceneGraphInfo$_() ? this._$_GetSceneGraphInfo$_()._$_SaveToJsonProperties$_() : null
                    };
                }
                _$_LoadSceneGraphPropertiesFromJson$_(t) {
                    t && (this._$_x$_ = t.x, this._$_y$_ = t.y, this._$_zElevation$_ = t.z, 
                    this._$_w$_ = t.w, this._$_h$_ = t.h, this._$_a$_ = t.a, t.sgi && this._$_GetSceneGraphInfo$_() && this._$_GetSceneGraphInfo$_()._$_LoadFromJson$_(t.sgi), 
                    this._$_MarkSinCosAngleChanged$_(), this._$SetBboxChanged$_());
                }
                _$_SetupSceneGraphConnectionsOnChangeOfLayout$_() {
                    this._$_ReleaseTmpSceneGraphInfo$_(), this._$_ResetAllSceneGraphState$_(), 
                    this._$_CreateSceneGraphInfo$_(null), this._$_sceneGraphInfo$_ && this._$_sceneGraphInfo$_._$_SetTmpSceneGraphChildren$_(this._$_tmpSceneGraphChildren$_, this._$_tmpSceneGraphChildrenIndexes$_);
                }
                _$_OnBeforeLoad$_(t) {
                    "visual-state" !== t && this._$_ResetAllSceneGraphState$_();
                }
                _$_OnAfterLoad$_(t, e = "full", s = null) {
                    t.hasOwnProperty("sgi") && "visual-state" !== e && 0 == (this._$_flags$_ & FLAG_DESTROYED) && this._$_sceneGraphInfo$_._$_OnAfterLoad$_(t.sgi, s);
                }
                _$_OnAfterLoad2$_(t, e = "full", s) {
                    t.hasOwnProperty("sgi") && "visual-state" !== e && 0 == (this._$_flags$_ & FLAG_DESTROYED) && (this._$_sceneGraphInfo$_._$_SetTmpSceneGraphChildren$_(null, null), 
                    this._$_ReleaseTmpSceneGraphInfo$_(), this._$SetBboxChanged$_());
                }
                _$_LoadFromJson$_(t, e) {
                    if (enableUpdateRendererStateGroup = !1, this._$SetX$_(t.x), 
                    this._$SetY$_(t.y), this._$SetWidth$_(t.w), this._$SetHeight$_(t.h), 
                    this._$_SetZIndex$_(t.zi), this._$SetZElevation$_(t.hasOwnProperty("ze") ? t.ze : 0), 
                    this._$SetAngle$_(t.hasOwnProperty("a") ? t.a : 0), t.hasOwnProperty("c") ? tempColor._$setFromJSON$_(t.c) : t.hasOwnProperty("o") ? (tempColor._$copyRgb$_(this._$_color$_), 
                    tempColor.a = t.o) : tempColor._$setRgba$_(1, 1, 1, 1), this._$_SetColor$_(tempColor), 
                    this._$SetOriginX$_(t.hasOwnProperty("oX") ? t.oX : .5), this._$SetOriginY$_(t.hasOwnProperty("oY") ? t.oY : .5), 
                    this._$SetBlendMode$_(t.hasOwnProperty("bm") ? t.bm : 0), this._$SetVisible$_(!t.hasOwnProperty("v") || t.v), 
                    this._$SetCollisionEnabled$_(!t.hasOwnProperty("ce") || t.ce), 
                    this._$SetBboxChangeEventEnabled$_(!!t.hasOwnProperty("be") && t.be), 
                    this._$SetSolidCollisionFilter$_(!!t.hasOwnProperty("sfi") && t.sfi, t.hasOwnProperty("sft") ? t.sft : ""), 
                    this._$_instanceEffectList$_ && t.hasOwnProperty("fx") && this._$_instanceEffectList$_._$_LoadFromJson$_(t.fx), 
                    !t.hasOwnProperty("sgi") && "visual-state" !== e && this._$_tmpSceneGraphChildren$_) for (const s of this._$_tmpSceneGraphChildren$_) s._$IsDestroyed$_() || this._$_runtime$_._$DestroyInstance$_(s);
                    if (t.hasOwnProperty("sgi") && "visual-state" !== e) {
                        this._$_CreateSceneGraphInfo$_(null);
                        const i = this._$_sceneGraphInfo$_, r = t.sgi;
                        i._$_LoadFromJson$_(r), i._$_SetTmpSceneGraphChildren$_(this._$_tmpSceneGraphChildren$_, this._$_tmpSceneGraphChildrenIndexes$_), 
                        t.sgcd && C33._$IsFiniteNumber$_(t.sgzid) && sceneGraphExportDataMap.set(this, {
                            _$childrenData$_: t.sgcd,
                            _$zIndexData$_: t.sgzid
                        });
                    }
                    if (t.hasOwnProperty("mesh")) {
                        const n = t.mesh;
                        this._$CreateMesh$_(n.cols, n.rows), this._$GetSourceMesh$_()._$LoadFromJson$_(n);
                    } else this._$ReleaseMesh$_();
                    this._$SetBboxChanged$_(), enableUpdateRendererStateGroup = !0, 
                    this._$_UpdateRendererStateGroup$_(), "visual-state" !== e && this._$_runtime$_._$AddInstanceNeedingAfterLoad$_(this._$GetInstance$_(), t);
                }
            };
        }
        {
            const C33 = self._$C3$_;
            C33._$BehaviorType$_ = class extends C33._$DefendedBase$_ {
                constructor(t, e) {
                    super();
                    const s = t._$GetRuntime$_(), i = s._$GetObjectReference$_(e[1]), r = (s._$GetAddonManager$_()._$_DelayCreateBehavior$_(i), 
                    this._$_runtime$_ = s, this._$_objectClass$_ = t, this._$_behavior$_ = C33._$AddonManager$_._$GetBehaviorByConstructorFunction$_(i), 
                    this._$_sdkType$_ = null, this._$_iBehaviorType$_ = null, this._$_instSdkCtor$_ = i.Instance, 
                    this._$_sid$_ = e[2], this._$_name$_ = e[0], this._$_jsPropName$_ = this._$_runtime$_._$GetJsPropName$_(e[3]), 
                    this._$_behavior$_._$GetSdkVersion$_());
                    if (r < 2 && (this._$_sdkType$_ = C33._$New$_(i._$Type$_, this), 
                    !(this._$_sdkType$_ instanceof C33._$SDKBehaviorTypeBase$_))) throw new Error("v1 sdk type must derive from SDKBehaviorBase");
                    if (C33._$AddonManager$_._$_PushInitObject$_(this, r), 2 <= r) {
                        const n = i._$Type$_ ?? globalThis._$ISDKBehaviorTypeBase$_;
                        if (this._$_iBehaviorType$_ = new n(), !(this._$_iBehaviorType$_ instanceof globalThis._$ISDKBehaviorTypeBase$_)) throw new Error("script interface class must derive from ISDKBehaviorTypeBase");
                    } else this._$_iBehaviorType$_ = new globalThis._$IBehaviorType$_();
                    C33._$AddonManager$_._$_PopInitObject$_(r), this._$OnCreate$_();
                }
                static _$Create$_(t, e) {
                    return C33._$New$_(C33._$BehaviorType$_, t, e);
                }
                _$Release$_() {
                    this._$_runtime$_ = null, this._$_behavior$_ = null, this._$_sdkType$_ && (this._$_sdkType$_._$Release$_(), 
                    this._$_sdkType$_ = null), this._$_instSdkCtor$_ = null;
                }
                _$GetSdkType$_() {
                    return this._$_sdkType$_;
                }
                _$OnCreate$_() {
                    this._$_sdkType$_ ? this._$_sdkType$_._$OnCreate$_() : this._$_iBehaviorType$_ && this._$_iBehaviorType$_._$_onCreate$_();
                }
                _$GetRuntime$_() {
                    return this._$_runtime$_;
                }
                _$GetObjectClass$_() {
                    return this._$_objectClass$_;
                }
                _$GetBehavior$_() {
                    return this._$_behavior$_;
                }
                _$GetInstanceSdkCtor$_() {
                    return this._$_instSdkCtor$_;
                }
                _$GetName$_() {
                    return this._$_name$_;
                }
                _$GetSID$_() {
                    return this._$_sid$_;
                }
                _$GetIBehaviorType$_() {
                    return this._$_iBehaviorType$_;
                }
                _$GetJsPropName$_() {
                    return this._$_jsPropName$_;
                }
            };
        }
        {
            const C33 = self._$C3$_, IBehaviorInstance = self._$IBehaviorInstance$_;
            C33._$BehaviorInstance$_ = class extends C33._$DefendedBase$_ {
                constructor(t) {
                    super(), this._$_runtime$_ = t.runtime, this._$_behaviorType$_ = t._$behaviorType$_, 
                    this._$_behavior$_ = this._$_behaviorType$_._$GetBehavior$_(), 
                    this._$_inst$_ = t.instance, this._$_index$_ = t.index, this._$_sdkInst$_ = null, 
                    this._$_iScriptInterface$_ = null, this._$_behavior$_._$_AddInstance$_(this._$_inst$_);
                }
                _$Release$_() {
                    this._$_iScriptInterface$_ && (this._$_iScriptInterface$_._$_release$_(), 
                    this._$_iScriptInterface$_ = null), this._$_behavior$_._$_RemoveInstance$_(this._$_inst$_), 
                    this._$_sdkInst$_ && (this._$_sdkInst$_._$Release$_(), this._$_sdkInst$_ = null), 
                    this._$_runtime$_ = null, this._$_behaviorType$_ = null, this._$_behavior$_ = null, 
                    this._$_inst$_ = null;
                }
                _$_CreateSdkInstance$_(t) {
                    if (this._$_sdkInst$_) throw new Error("already got sdk instance");
                    const e = this._$GetBehavior$_()._$GetSdkVersion$_();
                    if (e < 2) {
                        if (this._$_sdkInst$_ = C33._$New$_(this._$_behaviorType$_._$GetInstanceSdkCtor$_(), this, t), 
                        !(this._$_sdkInst$_ instanceof C33._$SDKBehaviorInstanceBase$_)) throw new Error("v1 sdk type must derive from SDKBehaviorInstanceBase");
                    } else {
                        const s = this._$GetBehavior$_()._$GetScriptInterfaceClass$_();
                        this._$_InitScriptInterface$_(s.Instance, t);
                    }
                }
                _$GetSdkInstance$_() {
                    return this._$_sdkInst$_ ?? this._$_iScriptInterface$_;
                }
                _$GetObjectInstance$_() {
                    return this._$_inst$_;
                }
                _$GetRuntime$_() {
                    return this._$_runtime$_;
                }
                _$GetBehaviorType$_() {
                    return this._$_behaviorType$_;
                }
                _$GetBehavior$_() {
                    return this._$_behavior$_;
                }
                _$_GetIndex$_() {
                    return this._$_index$_;
                }
                _$PostCreate$_() {
                    this._$_sdkInst$_ ? this._$_sdkInst$_._$PostCreate$_() : this._$_iScriptInterface$_._$_postCreate$_();
                }
                _$OnSpriteFrameChanged$_(t, e) {
                    this._$_sdkInst$_ && this._$_sdkInst$_._$OnSpriteFrameChanged$_(t, e);
                }
                _$_GetDebuggerProperties$_() {
                    return this._$_sdkInst$_ ? this._$_sdkInst$_._$GetDebuggerProperties$_() : this._$_iScriptInterface$_._$_getDebuggerProperties$_();
                }
                _$SaveToJson$_(t = "full") {
                    return this._$_sdkInst$_ ? this._$_sdkInst$_._$SaveToJson$_(t) : this._$_iScriptInterface$_._$_saveToJson$_(t);
                }
                _$LoadFromJson$_(t, e = "full") {
                    if (this._$_sdkInst$_) return this._$_sdkInst$_._$LoadFromJson$_(t, e);
                    this._$_iScriptInterface$_._$_loadFromJson$_(t, e);
                }
                static _$SortByTickSequence$_(t, e, s) {
                    let i = globalThis._$ISDKBehaviorInstanceBase$_, r, n;
                    r = e instanceof i ? t._$_UnwrapScriptInterface$_(e) : e._$GetBehaviorInstance$_(), 
                    n = s instanceof i ? t._$_UnwrapScriptInterface$_(s) : s._$GetBehaviorInstance$_();
                    const h = r._$GetObjectInstance$_(), o = n._$GetObjectInstance$_(), a = h._$GetObjectClass$_()._$GetIndex$_(), l = o._$GetObjectClass$_()._$GetIndex$_();
                    if (a !== l) return a - l;
                    const u = h._$GetPUID$_(), c = o._$GetPUID$_();
                    return u !== c ? u - c : r._$_GetIndex$_() - n._$_GetIndex$_();
                }
                _$_InitScriptInterface$_(t, e) {
                    const s = IBehaviorInstance, i = t ?? this._$_sdkInst$_._$GetScriptInterfaceClass$_(), r = i || s, n = this._$GetBehavior$_()._$GetSdkVersion$_();
                    if (C33._$AddonManager$_._$_PushInitObject$_(this, n), C33._$AddonManager$_._$_PushInitProperties$_(e), 
                    this._$_iScriptInterface$_ = new r(), C33._$AddonManager$_._$_PopInitProperties$_(), 
                    C33._$AddonManager$_._$_PopInitObject$_(n), !i || this._$_iScriptInterface$_ instanceof s) return this._$_iScriptInterface$_;
                    throw new TypeError(`script interface class '${i.name}' does not extend the right base class '${s.name}'`);
                }
                _$GetScriptInterface$_() {
                    return this._$_iScriptInterface$_ || this._$_InitScriptInterface$_();
                }
                _$HasScriptInterface$_() {
                    return !!this._$_iScriptInterface$_;
                }
            };
        }
        {
            const C33 = self._$C3$_;
            C33._$EffectList$_ = class extends C33._$DefendedBase$_ {
                constructor(t, e) {
                    super(), this._$_owner$_ = t, this._$_allEffectTypes$_ = [], 
                    this._$_activeEffectTypes$_ = [], this._$_effectTypesByName$_ = new Map(), 
                    this._$_effectParams$_ = [], this._$_effectParamBuffers$_ = [], 
                    this._$_allInstanceEffectLists$_ = new Set(), this._$_preservesOpaqueness$_ = !0;
                    for (const s of e) {
                        const i = C33._$New$_(C33._$EffectType$_, this, s, this._$_allEffectTypes$_.length);
                        this._$_allEffectTypes$_.push(i), this._$_effectTypesByName$_.set(i._$GetName$_().toLowerCase(), i), 
                        3 <= s.length && this._$_effectParams$_.push(this._$_LoadSingleEffectParameters$_(i, s[2]));
                    }
                    this._$GetRuntime$_()._$_AddEffectList$_(this);
                }
                _$Release$_() {
                    this._$GetRuntime$_()._$_RemoveEffectList$_(this);
                    for (const t of this._$_effectParamBuffers$_) t._$Release$_();
                    C33._$clearArray$_(this._$_effectParamBuffers$_), C33._$clearArray$_(this._$_allEffectTypes$_), 
                    C33._$clearArray$_(this._$_activeEffectTypes$_), this._$_effectTypesByName$_.clear(), 
                    C33._$clearArray$_(this._$_effectParams$_), this._$_owner$_ = null;
                }
                _$_AddInstanceEffectList$_(t) {
                    this._$_allInstanceEffectLists$_.add(t);
                }
                _$_RemoveInstanceEffectList$_(t) {
                    this._$_allInstanceEffectLists$_.delete(t);
                }
                _$_InitRenderer$_(t) {
                    t._$IsWebGPU$_() && (this._$_effectParamBuffers$_ = this._$_allEffectTypes$_.map(t => {
                        const e = t._$GetShaderProgram$_();
                        return 0 < e._$GetCustomParametersByteSize$_() ? C33._$New$_(C33._$Gfx$_._$WebGPUEffectCustomParamsBuffer$_, e) : null;
                    }), this._$_UpdateAllEffectParamBuffers$_());
                    for (const e of this._$_allInstanceEffectLists$_) e._$_InitRenderer$_(t);
                }
                _$PrependEffectTypes$_(t) {
                    if (t.length) {
                        this._$_allEffectTypes$_ = t.concat(this._$_allEffectTypes$_);
                        for (const e of t) this._$_effectTypesByName$_.set(e._$GetName$_().toLowerCase(), e);
                        for (let t = 0, e = this._$_allEffectTypes$_.length; t < e; ++t) this._$_allEffectTypes$_[t]._$_SetIndex$_(t);
                    }
                }
                _$_LoadSingleEffectParameters$_(t, e) {
                    t._$SetActive$_(e[0]);
                    const s = e.slice(1);
                    for (let t = 0, e = s.length; t < e; ++t) {
                        const i = s[t];
                        if (Array.isArray(i)) {
                            const r = C33._$New$_(C33._$Color$_);
                            r._$setFromJSON$_(i), s[t] = r;
                        }
                    }
                    return s;
                }
                _$GetOwner$_() {
                    return this._$_owner$_;
                }
                _$GetRuntime$_() {
                    return this._$_owner$_._$GetRuntime$_();
                }
                _$UpdateActiveEffects$_() {
                    C33._$clearArray$_(this._$_activeEffectTypes$_);
                    let t = !0;
                    for (const e of this._$_allEffectTypes$_) e._$IsActive$_() && (this._$_activeEffectTypes$_.push(e), 
                    e._$GetShaderProgram$_()._$PreservesOpaqueness$_() || (t = !1));
                    this._$_preservesOpaqueness$_ = t;
                }
                _$GetAllEffectTypes$_() {
                    return this._$_allEffectTypes$_;
                }
                _$HasAnyEffectType$_() {
                    return 0 < this._$_allEffectTypes$_.length;
                }
                _$GetEffectTypeByName$_(t) {
                    return this._$_effectTypesByName$_.get(t.toLowerCase()) || null;
                }
                _$GetEffectTypeByIndex$_(t) {
                    if ((t = Math.floor(+t)) < 0 || t >= this._$_allEffectTypes$_.length) throw new RangeError("invalid effect type index");
                    return this._$_allEffectTypes$_[t];
                }
                _$IsEffectIndexActive$_(t) {
                    return this._$GetEffectTypeByIndex$_(t)._$IsActive$_();
                }
                _$SetEffectIndexActive$_(t, e) {
                    this._$GetEffectTypeByIndex$_(t)._$SetActive$_(e);
                }
                _$GetActiveEffectTypes$_() {
                    return this._$_activeEffectTypes$_;
                }
                _$HasAnyActiveEffect$_() {
                    return 0 < this._$_activeEffectTypes$_.length;
                }
                _$PreservesOpaqueness$_() {
                    return this._$_preservesOpaqueness$_;
                }
                _$GetEffectParametersForIndex$_(t) {
                    return this._$_effectParams$_[t];
                }
                _$_GetEffectChainShaderParametersForIndex$_(t) {
                    return (t < this._$_effectParamBuffers$_.length ? this._$_effectParamBuffers$_ : this._$_effectParams$_)[t];
                }
                _$GetEffectParameter$_(t, e) {
                    if (t < 0 || t >= this._$_effectParams$_.length) return null;
                    const s = this._$_effectParams$_[t];
                    return e < 0 || e >= s.length ? null : s[e];
                }
                _$SetEffectParameter$_(t, e, s) {
                    if (t < 0 || t >= this._$_effectParams$_.length) return !1;
                    const i = this._$_effectParams$_[t];
                    if (e < 0 || e >= i.length) return !1;
                    const r = i[e];
                    if (r instanceof C33._$Color$_) {
                        if (r._$equalsIgnoringAlpha$_(s)) return !1;
                        r._$copyRgb$_(s);
                    } else {
                        if (r === s) return !1;
                        i[e] = s;
                    }
                    return t < this._$_effectParamBuffers$_.length && this._$_effectParamBuffers$_[t]._$SetParameterValue$_(e, s), 
                    !0;
                }
                _$_UpdateAllEffectParamBuffers$_() {
                    const s = this._$_effectParams$_, i = this._$_effectParamBuffers$_;
                    for (let t = 0, e = Math.min(s.length, i.length); t < e; ++t) {
                        const r = i[t], n = s[t];
                        for (let t = 0, e = n.length; t < e; ++t) r._$SetParameterValue$_(t, n[t]);
                    }
                }
                static _$SaveFxParamToJson$_(t) {
                    return t && t instanceof C33._$Color$_ ? {
                        t: "color",
                        v: t.toJSON()
                    } : t;
                }
                static _$LoadFxParamFromJson$_(t) {
                    if (null === t) return NaN;
                    if ("object" != typeof t) return t;
                    {
                        const e = t.t;
                        if ("color" !== e) throw new Error("invalid effect parameter type");
                        {
                            const s = C33._$New$_(C33._$Color$_);
                            return s._$setFromJSON$_(t.v), s;
                        }
                    }
                }
                static _$SaveFxParamsToJson$_(t) {
                    return t.map(C33._$EffectList$_._$SaveFxParamToJson$_);
                }
                static _$LoadFxParamsFromJson$_(t) {
                    return t.map(C33._$EffectList$_._$LoadFxParamFromJson$_);
                }
                _$SaveToJson$_() {
                    return this._$_allEffectTypes$_.map(t => ({
                        name: t._$GetName$_(),
                        active: t._$IsActive$_(),
                        params: C33._$EffectList$_._$SaveFxParamsToJson$_(this._$_effectParams$_[t._$GetIndex$_()])
                    }));
                }
                _$LoadFromJson$_(t) {
                    for (const e of t) {
                        const s = this._$GetEffectTypeByName$_(e.name);
                        s && (s._$SetActive$_(e.active), this._$_effectParams$_[s._$GetIndex$_()] = C33._$EffectList$_._$LoadFxParamsFromJson$_(e.params));
                    }
                    this._$UpdateActiveEffects$_(), this._$_UpdateAllEffectParamBuffers$_();
                }
            };
        }
        {
            const C33 = self._$C3$_;
            C33._$EffectType$_ = class extends C33._$DefendedBase$_ {
                constructor(t, e, s) {
                    super(), this._$_effectList$_ = t, this._$_id$_ = e[0], this._$_name$_ = e[1], 
                    this._$_index$_ = s, this._$_shaderProgram$_ = null, this._$_isActive$_ = !0;
                }
                _$Release$_() {
                    this._$_effectList$_ = null, this._$_shaderProgram$_ = null;
                }
                _$Clone$_(t) {
                    const e = C33._$New$_(C33._$EffectType$_, t, [ this._$_id$_, this._$_name$_ ], -1);
                    return e._$_shaderProgram$_ = this._$_shaderProgram$_, e._$_isActive$_ = this._$_isActive$_, 
                    e;
                }
                _$_InitRenderer$_(t) {
                    const e = t._$GetShaderProgramByName$_(this._$_id$_);
                    if (!e) throw new Error("failed to find shader program '" + this._$_id$_ + "'");
                    this._$_shaderProgram$_ = e;
                }
                _$GetEffectList$_() {
                    return this._$_effectList$_;
                }
                _$GetName$_() {
                    return this._$_name$_;
                }
                _$_SetIndex$_(t) {
                    this._$_index$_ = t;
                }
                _$GetIndex$_() {
                    return this._$_index$_;
                }
                _$GetOwner$_() {
                    return this._$_effectList$_._$GetOwner$_();
                }
                _$GetRuntime$_() {
                    return this._$_effectList$_._$GetRuntime$_();
                }
                _$SetActive$_(t) {
                    this._$_isActive$_ = !!t;
                }
                _$IsActive$_() {
                    return this._$_isActive$_;
                }
                _$GetShaderProgram$_() {
                    return this._$_shaderProgram$_;
                }
                _$GetDefaultParameterValues$_() {
                    const s = [];
                    for (let t = 0, e = this._$_shaderProgram$_._$GetParameterCount$_(); t < e; ++t) {
                        const i = this._$_shaderProgram$_._$GetParameterType$_(t);
                        if ("float" === i || "percent" === i) s.push(0); else {
                            if ("color" !== i) throw new TypeError("unknown effect parameter type");
                            s.push(C33._$New$_(C33._$Color$_, 1, 1, 1, 1));
                        }
                    }
                    return s;
                }
            };
        }
        {
            const C33 = self._$C3$_;
            C33._$InstanceEffectList$_ = class extends C33._$DefendedBase$_ {
                constructor(t, e) {
                    super(), this._$_inst$_ = t, this._$_wi$_ = e, this._$_effectList$_ = t._$GetObjectClass$_()._$GetEffectList$_(), 
                    this._$_needsRebuildSteps$_ = !0, this._$_wasDefaultColor$_ = !0, 
                    this._$_was3D$_ = !1, this._$_wasRotatedOrNegativeSize$_ = !1, 
                    this._$_wasTexRotated$_ = !1, this._$_wasMustPreDraw$_ = !1, 
                    this._$_effectChain$_ = C33._$New$_(C33._$Gfx$_._$EffectChain$_, t._$GetRuntime$_()._$GetCanvasManager$_()._$GetEffectChainManager$_(), {
                        _$drawContent$_: (t, e) => {
                            const s = e._$GetContentObject$_(), i = s._$GetWorldInfo$_();
                            t._$SetColor$_(i._$GetPremultipliedColor$_()), t._$SetCurrentZ$_(i._$GetTotalZElevation$_()), 
                            s._$Draw$_(t), t._$SetCurrentZ$_(0);
                        },
                        _$getSourceTextureInfo$_: t => {
                            const e = t._$GetCurrentTexRect$_(), [ s, i ] = t._$GetCurrentSurfaceSize$_();
                            return {
                                _$srcTexRect$_: e,
                                _$srcWidth$_: s,
                                _$srcHeight$_: i
                            };
                        },
                        _$getShaderParameters$_: t => this._$_GetEffectChainShaderParametersForIndex$_(t)
                    }), this._$_activeEffectFlags$_ = [], this._$_activeEffectTypes$_ = [], 
                    this._$_preservesOpaqueness$_ = !0, this._$_effectParams$_ = [], 
                    this._$_effectParamBuffers$_ = [], this._$_InitRenderer$_(t._$GetRuntime$_()._$GetRenderer$_());
                    for (let t = 0, e = this._$_effectList$_._$GetAllEffectTypes$_().length; t < e; ++t) this._$_activeEffectFlags$_.push(!0);
                    this._$UpdateActiveEffects$_(), this._$_effectList$_._$_AddInstanceEffectList$_(this);
                }
                _$Release$_() {
                    this._$_effectList$_._$_RemoveInstanceEffectList$_(this);
                    for (const t of this._$_effectParamBuffers$_) t && t._$Release$_();
                    C33._$clearArray$_(this._$_effectParamBuffers$_), this._$_effectChain$_._$Release$_(), 
                    this._$_effectChain$_ = null, C33._$clearArray$_(this._$_activeEffectFlags$_), 
                    C33._$clearArray$_(this._$_activeEffectTypes$_), C33._$clearArray$_(this._$_effectParams$_), 
                    this._$_inst$_ = null, this._$_effectList$_ = null;
                }
                _$_InitRenderer$_(t) {
                    t._$IsWebGPU$_() && (this._$_effectParamBuffers$_ = this._$_effectList$_._$GetAllEffectTypes$_().map(t => {
                        const e = t._$GetShaderProgram$_();
                        return 0 < e._$GetCustomParametersByteSize$_() ? C33._$New$_(C33._$Gfx$_._$WebGPUEffectCustomParamsBuffer$_, e) : null;
                    }));
                }
                _$_LoadEffectParameters$_(t) {
                    let e = 0;
                    for (const s of t) this._$_effectParams$_.push(this._$_LoadSingleEffectParameters$_(e, s)), 
                    ++e;
                    this._$_UpdateAllEffectParamBuffers$_(), this._$UpdateActiveEffects$_();
                }
                _$_LoadSingleEffectParameters$_(t, e) {
                    this._$_activeEffectFlags$_[t] = e[0];
                    const s = e.slice(1);
                    for (let t = 0, e = s.length; t < e; ++t) {
                        const i = s[t];
                        if (Array.isArray(i)) {
                            const r = C33._$New$_(C33._$Color$_);
                            r._$setFromJSON$_(i), s[t] = r;
                        }
                    }
                    return s;
                }
                _$LoadDefaultEffectParameters$_() {
                    for (const t of this._$_effectList$_._$GetAllEffectTypes$_()) this._$_effectParams$_.push(t._$GetDefaultParameterValues$_());
                    this._$_UpdateAllEffectParamBuffers$_();
                }
                _$GetOwner$_() {
                    return this._$_owner$_;
                }
                _$GetEffectList$_() {
                    return this._$_effectList$_;
                }
                _$GetEffectChain$_() {
                    return this._$_MaybeRebuildEffectChainSteps$_(), this._$_effectChain$_;
                }
                _$GetRuntime$_() {
                    return this._$_inst$_._$GetRuntime$_();
                }
                _$UpdateActiveEffects$_() {
                    C33._$clearArray$_(this._$_activeEffectTypes$_);
                    let t = this._$_wi$_, s = this._$_effectList$_._$GetAllEffectTypes$_(), i = this._$_activeEffectTypes$_, r = this._$_activeEffectFlags$_, n = !0;
                    for (let t = 0, e = s.length; t < e; ++t) if (r[t]) {
                        const h = s[t];
                        i.push(h), h._$GetShaderProgram$_()._$PreservesOpaqueness$_() || (n = !1);
                    }
                    this._$_preservesOpaqueness$_ = n, t._$_SetHasAnyActiveEffect$_(!!i.length), 
                    this._$_needsRebuildSteps$_ = !0;
                }
                _$_MaybeRebuildEffectChainSteps$_() {
                    const t = this._$_inst$_, e = this._$_wi$_, s = e._$HasDefaultColor$_(), i = t._$GetPlugin$_()._$Is3D$_(), r = 0 !== e.GetAngle() || 0 !== e._$GetLayer$_().GetAngle() || e._$GetWidth$_() < 0 || e._$GetHeight$_() < 0, n = t._$IsCurrentTexRotated$_(), h = t._$MustPreDraw$_();
                    (this._$_needsRebuildSteps$_ || s !== this._$_wasDefaultColor$_ || i !== this._$_was3D$_ || r !== this._$_wasRotatedOrNegativeSize$_ || n !== this._$_wasTexRotated$_ || h !== this._$_wasMustPreDraw$_ || this._$_effectChain$_._$NeedsRebuild$_()) && (this._$_effectChain$_._$BuildSteps$_(this._$_activeEffectTypes$_.map(t => t._$GetShaderProgram$_()), {
                        _$indexMap$_: this._$_activeEffectTypes$_.map(t => t._$GetIndex$_()),
                        _$forcePreDraw$_: !s || h,
                        _$is3D$_: i,
                        _$isSourceTextureRotated$_: n,
                        _$isRotatedOrNegativeSizeInstance$_: r
                    }), this._$_needsRebuildSteps$_ = !1, this._$_wasDefaultColor$_ = s, 
                    this._$_was3D$_ = i, this._$_wasRotatedOrNegativeSize$_ = r, 
                    this._$_wasTexRotated$_ = n, this._$_wasMustPreDraw$_ = h);
                }
                _$GetActiveEffectTypes$_() {
                    return this._$_activeEffectTypes$_;
                }
                _$GetEffectParametersForIndex$_(t) {
                    return this._$_effectParams$_[t];
                }
                _$_GetEffectChainShaderParametersForIndex$_(t) {
                    return (t < this._$_effectParamBuffers$_.length ? this._$_effectParamBuffers$_ : this._$_effectParams$_)[t];
                }
                _$GetEffectParameter$_(t, e) {
                    if (t < 0 || t >= this._$_effectParams$_.length) return null;
                    const s = this._$_effectParams$_[t];
                    return e < 0 || e >= s.length ? null : s[e];
                }
                _$SetEffectParameter$_(t, e, s) {
                    if (t < 0 || t >= this._$_effectParams$_.length) return !1;
                    const i = this._$_effectParams$_[t];
                    if (e < 0 || e >= i.length) return !1;
                    const r = i[e];
                    if (r instanceof C33._$Color$_) {
                        if (r._$equalsIgnoringAlpha$_(s)) return !1;
                        r._$copyRgb$_(s);
                    } else {
                        if (r === s) return !1;
                        i[e] = s;
                    }
                    return t < this._$_effectParamBuffers$_.length && this._$_effectParamBuffers$_[t]._$SetParameterValue$_(e, s), 
                    !0;
                }
                _$_UpdateAllEffectParamBuffers$_() {
                    const s = this._$_effectParams$_, i = this._$_effectParamBuffers$_;
                    for (let t = 0, e = i.length; t < e; ++t) {
                        const r = i[t], n = s[t];
                        for (let t = 0, e = n.length; t < e; ++t) r._$SetParameterValue$_(t, n[t]);
                    }
                }
                _$PreservesOpaqueness$_() {
                    return this._$_preservesOpaqueness$_;
                }
                _$HasAnyActiveBackgroundBlendingEffect$_() {
                    return this._$_activeEffectTypes$_.some(t => t._$GetShaderProgram$_()._$BlendsBackground$_());
                }
                _$IsEffectIndexActive$_(t) {
                    return this._$_activeEffectFlags$_[t];
                }
                _$SetEffectIndexActive$_(t, e) {
                    this._$_activeEffectFlags$_[t] = !!e;
                }
                _$GetAllEffectTypes$_() {
                    return this._$_effectList$_._$GetAllEffectTypes$_();
                }
                _$_SaveToJson$_() {
                    return this._$_effectList$_._$GetAllEffectTypes$_().map(t => ({
                        name: t._$GetName$_(),
                        active: this._$_activeEffectFlags$_[t._$GetIndex$_()],
                        params: C33._$EffectList$_._$SaveFxParamsToJson$_(this._$_effectParams$_[t._$GetIndex$_()])
                    }));
                }
                _$_LoadFromJson$_(t) {
                    for (const e of t) {
                        const s = this._$_effectList$_._$GetEffectTypeByName$_(e.name);
                        s && (this._$_activeEffectFlags$_[s._$GetIndex$_()] = e.active, 
                        this._$_effectParams$_[s._$GetIndex$_()] = C33._$EffectList$_._$LoadFxParamsFromJson$_(e.params));
                    }
                    this._$UpdateActiveEffects$_(), this._$_UpdateAllEffectParamBuffers$_();
                }
            };
        }
        {
            let C33 = self._$C3$_, tempCandidates = [], tileCollRectCandidates = [], tempJumpthruRet = [], tempPolyA = C33._$New$_(C33._$CollisionPoly$_), tempPolyB = C33._$New$_(C33._$CollisionPoly$_), tempQuad = C33._$New$_(C33._$Quad$_), tempRect = C33._$New$_(C33.Rect), tempRect2 = C33._$New$_(C33.Rect), tempPolyC = null, tempRect3 = null, tempQuadB = null;
            C33._$CollisionEngine$_ = class extends C33._$DefendedBase$_ {
                constructor(t) {
                    super(), this._$_runtime$_ = t, this._$_collisionCellWidth$_ = 0, 
                    this._$_collisionCellHeight$_ = 0, this._$_registeredCollisions$_ = [], 
                    this._$_collisionCheckCount$_ = 0, this._$_collisionCheckSec$_ = 0, 
                    this._$_polyCheckCount$_ = 0, this._$_polyCheckSec$_ = 0, this._$_iCollisionEngine$_ = new self._$ICollisionEngine$_(this);
                }
                _$Release$_() {
                    this._$_runtime$_ = null;
                }
                _$GetRuntime$_() {
                    return this._$_runtime$_;
                }
                _$GetICollisionEngine$_() {
                    return this._$_iCollisionEngine$_;
                }
                _$_Update1sStats$_() {
                    this._$_collisionCheckSec$_ = this._$_collisionCheckCount$_, 
                    this._$_collisionCheckCount$_ = 0, this._$_polyCheckSec$_ = this._$_polyCheckCount$_, 
                    this._$_polyCheckCount$_ = 0;
                }
                _$Get1secCollisionChecks$_() {
                    return this._$_collisionCheckSec$_;
                }
                _$Get1secPolyChecks$_() {
                    return this._$_polyCheckSec$_;
                }
                _$RegisterCollision$_(t, e) {
                    const s = t._$GetWorldInfo$_(), i = e._$GetWorldInfo$_();
                    s && i && s._$IsCollisionEnabled$_() && i._$IsCollisionEnabled$_() && this._$_registeredCollisions$_.push([ t, e ]);
                }
                _$AddRegisteredCollisionCandidates$_(e, s, i) {
                    for (const [ r, n ] of this._$_registeredCollisions$_) {
                        let t = null;
                        if (e === r) t = n; else {
                            if (e !== n) continue;
                            t = r;
                        }
                        t._$BelongsToObjectClass$_(s) && !i.includes(t) && i.push(t);
                    }
                }
                _$CheckRegisteredCollision$_(t, e) {
                    if (this._$_registeredCollisions$_.length) for (const [ s, i ] of this._$_registeredCollisions$_) if (t === s && e === i || t === i && e === s) return !0;
                    return !1;
                }
                _$ClearRegisteredCollisions$_() {
                    C33._$clearArray$_(this._$_registeredCollisions$_);
                }
                _$TestOverlap$_(t, e) {
                    if (!t || !e || t === e) return !1;
                    const s = t._$GetWorldInfo$_(), i = e._$GetWorldInfo$_();
                    if (!s._$IsCollisionEnabled$_() || !i._$IsCollisionEnabled$_()) return !1;
                    this._$_collisionCheckCount$_++;
                    const r = s._$GetLayer$_(), n = i._$GetLayer$_(), h = r._$IsTransformCompatibleWith$_(n);
                    return h ? this._$_TestOverlap_SameLayers$_(s, i) : this._$_TestOverlap_DifferentLayers$_(s, i);
                }
                _$_TestOverlap_SameLayers$_(t, e) {
                    if (!t._$GetBoundingBox$_()._$intersectsRect$_(e._$GetBoundingBox$_())) return !1;
                    if (this._$_polyCheckCount$_++, !t._$GetBoundingQuad$_()._$intersectsQuad$_(e._$GetBoundingQuad$_())) return !1;
                    if (t._$HasTilemap$_() && e._$HasTilemap$_()) return !1;
                    if (t._$HasTilemap$_()) return this._$TestTilemapOverlap$_(t, e);
                    if (e._$HasTilemap$_()) return this._$TestTilemapOverlap$_(e, t);
                    if (!t._$HasOwnCollisionPoly$_() && !e._$HasOwnCollisionPoly$_()) return !0;
                    const s = t._$GetTransformedCollisionPoly$_(), i = e._$GetTransformedCollisionPoly$_();
                    return s._$intersectsPoly$_(i, e._$GetX$_() - t._$GetX$_(), e._$GetY$_() - t._$GetY$_());
                }
                _$_TestOverlap_DifferentLayers$_(s, i) {
                    const t = s._$HasTilemap$_(), e = i._$HasTilemap$_();
                    if (t && !e) return this._$TestTilemapOverlapDifferentLayers$_(s, i);
                    if (e && !t) return this._$TestTilemapOverlapDifferentLayers$_(i, s);
                    if (e || t) return !1;
                    {
                        const r = s._$GetLayer$_(), n = i._$GetLayer$_(), h = (tempPolyA._$copy$_(s._$GetTransformedCollisionPoly$_()), 
                        tempPolyB._$copy$_(i._$GetTransformedCollisionPoly$_()), 
                        tempPolyA._$pointsArr$_());
                        for (let t = 0, e = h.length; t < e; t += 2) {
                            const a = t + 1, l = h[t], u = h[a], [ c, f ] = r._$LayerToCanvasCss$_(l + s._$GetX$_(), u + s._$GetY$_());
                            h[t] = c, h[a] = f;
                        }
                        const o = tempPolyB._$pointsArr$_();
                        for (let t = 0, e = o.length; t < e; t += 2) {
                            const d = t + 1, p = o[t], m = o[d], [ C, g ] = n._$LayerToCanvasCss$_(p + i._$GetX$_(), m + i._$GetY$_());
                            o[t] = C, o[d] = g;
                        }
                        return tempPolyA._$setBboxChanged$_(), tempPolyB._$setBboxChanged$_(), 
                        this._$_polyCheckCount$_++, tempPolyA._$intersectsPoly$_(tempPolyB, 0, 0);
                    }
                }
                _$TestTilemapOverlapDifferentLayers$_(t, e) {
                    const s = t._$GetLayer$_(), i = e._$GetLayer$_(), r = (tempPolyC = tempPolyC || C33._$New$_(C33._$CollisionPoly$_), 
                    tempRect3 = tempRect3 || C33._$New$_(C33.Rect), tempQuadB = tempQuadB || C33._$New$_(C33._$Quad$_), 
                    e._$GetX$_()), n = e._$GetY$_(), [ h, o ] = i._$LayerToCanvasCss$_(r, n), [ a, l ] = s._$CanvasCssToLayer$_(h, o), u = a - r, c = l - n;
                    if (tempRect3._$copy$_(e._$GetBoundingBox$_()), tempRect3.offset(u, c), 
                    !t._$GetBoundingBox$_()._$intersectsRect$_(tempRect3)) return !1;
                    if (tempQuadB._$copy$_(e._$GetBoundingQuad$_()), tempQuadB.offset(u, c), 
                    this._$_polyCheckCount$_++, !t._$GetBoundingQuad$_()._$intersectsQuad$_(tempQuadB)) return !1;
                    tempPolyC._$copy$_(e._$GetTransformedCollisionPoly$_());
                    const f = tempPolyC._$pointsArr$_();
                    for (let t = 0, e = f.length; t < e; t += 2) {
                        const d = t + 1;
                        f[t] += u, f[d] += c;
                    }
                    return tempPolyC._$setBboxChanged$_(), this._$TestTilemapOverlap$_(t, e, a, l, tempPolyC, tempRect3, tempQuadB);
                }
                _$TestTilemapOverlap$_(t, i, e, s, r, n, h) {
                    const o = void 0 !== n ? n : i._$GetBoundingBox$_(), a = t._$GetX$_(), l = t._$GetY$_(), u = t._$GetInstance$_()._$GetSdkInstance$_(), c = void 0 !== e ? e : i._$GetX$_(), f = void 0 !== s ? s : i._$GetY$_(), d = i._$HasOwnCollisionPoly$_(), p = void 0 !== h ? h : i._$GetBoundingQuad$_(), m = tileCollRectCandidates;
                    u._$GetCollisionRectCandidates$_(o, m);
                    for (let t = 0, e = m.length; t < e; ++t) {
                        const C = m[t], g = C._$GetRect$_();
                        if (this._$_collisionCheckCount$_++, o._$intersectsRectOffset$_(g, a, l) && (tempQuad._$setFromRect$_(g), 
                        tempQuad.offset(a, l), tempQuad._$intersectsQuad$_(p))) if (d) {
                            let t = void 0 !== r ? r : i._$GetTransformedCollisionPoly$_(), e = c, s = f;
                            void 0 !== r && (e = i._$GetX$_(), s = i._$GetY$_());
                            const S = C._$GetPoly$_();
                            if (S) {
                                if (this._$_polyCheckCount$_++, S._$intersectsPoly$_(t, e - (a + g._$getLeft$_()), s - (l + g._$getTop$_()))) return C33._$clearArray$_(m), 
                                !0;
                            } else if (tempPolyA._$setFromQuad$_(tempQuad, 0, 0), 
                            tempPolyA._$intersectsPoly$_(t, e, s)) return C33._$clearArray$_(m), 
                            !0;
                        } else {
                            const _ = C._$GetPoly$_();
                            if (!_) return C33._$clearArray$_(m), !0;
                            if (tempPolyA._$setFromQuad$_(p, 0, 0), _._$intersectsPoly$_(tempPolyA, -(a + g._$getLeft$_()), -(l + g._$getTop$_()))) return C33._$clearArray$_(m), 
                            !0;
                        }
                    }
                    return C33._$clearArray$_(m), !1;
                }
                _$TestAndSelectCanvasPointOverlap$_(t, o, a) {
                    const l = t._$GetCurrentSol$_(), e = this._$_runtime$_._$GetCurrentEvent$_();
                    if (!e) throw new Error("cannot call outside event");
                    const u = e._$IsOrBlock$_(), s = new Map(), c = t => {
                        let e = s.get(t);
                        return void 0 === e && (e = t._$IsSelfAndParentsInteractive$_(), 
                        s.set(t, e)), e;
                    };
                    if (l._$IsSelectAll$_()) {
                        a || (l._$_SetSelectAll$_(!1), C33._$clearArray$_(l._$_GetOwnInstances$_())), 
                        u && C33._$clearArray$_(l._$_GetOwnElseInstances$_());
                        for (const i of t._$GetInstances$_()) {
                            let r = i._$GetWorldInfo$_(), n = r._$GetLayer$_();
                            if (!(!c(n) || !r._$IsInViewport2$_()) && o.some(([ t, e ]) => {
                                const [ s, i ] = n._$CanvasCssToLayer$_(t, e, r._$GetTotalZElevation$_());
                                return r._$ContainsPoint$_(s, i);
                            })) {
                                if (a) return !1;
                                l._$_PushInstance$_(i);
                            } else u && l._$_PushElseInstance$_(i);
                        }
                    } else {
                        let s, i = !1, h = (!u || e._$IsFirstConditionOfType$_(this._$_runtime$_._$GetCurrentCondition$_()) || this._$_runtime$_._$IsCurrentConditionFirst$_() && !l._$_GetOwnElseInstances$_().length && l._$_GetOwnInstances$_().length ? s = l._$_GetOwnInstances$_() : (s = l._$_GetOwnElseInstances$_(), 
                        i = !0), 0);
                        for (let e = 0, t = s.length; e < t; ++e) {
                            let t = s[e], r = t._$GetWorldInfo$_(), n = r._$GetLayer$_();
                            if (!(!c(n) || !r._$IsInViewport2$_()) && o.some(([ t, e ]) => {
                                const [ s, i ] = n._$CanvasCssToLayer$_(t, e, r._$GetTotalZElevation$_());
                                return r._$ContainsPoint$_(s, i);
                            })) {
                                if (a) return !1;
                                i ? l._$_PushInstance$_(t) : s[h++] = t;
                            } else i ? s[h++] = t : u && l._$_PushElseInstance$_(t);
                        }
                        a || (s.length = h);
                    }
                    return t._$ApplySolToContainer$_(), s.clear(), !!a || l._$HasAnyInstances$_();
                }
                _$_ObjectClassCanUseCollisionCells$_(t, e) {
                    if (t) for (const s of e._$layersHasInstancesOn$_()) if (!t._$IsTransformCompatibleWith$_(s)) return !1;
                    return !0;
                }
                _$GetCollisionCandidates$_(t, e, s, i) {
                    if (e._$IsFamily$_()) for (const r of e._$GetFamilyMembers$_()) this._$_ObjectClassCanUseCollisionCells$_(t, r) ? (r._$_UpdateAllCollisionCells$_(), 
                    r._$_GetCollisionCellGrid$_()._$QueryRange$_(s, i)) : C33._$appendArray$_(i, r._$GetInstances$_()); else this._$_ObjectClassCanUseCollisionCells$_(t, e) ? (e._$_UpdateAllCollisionCells$_(), 
                    e._$_GetCollisionCellGrid$_()._$QueryRange$_(s, i)) : C33._$appendArray$_(i, e._$GetInstances$_());
                }
                _$GetObjectClassesCollisionCandidates$_(t, e, s, i) {
                    for (const r of e) this._$GetCollisionCandidates$_(t, r, s, i);
                }
                _$GetSolidCollisionCandidates$_(t, e, s) {
                    const i = this._$_runtime$_._$GetSolidBehavior$_();
                    i && this._$GetObjectClassesCollisionCandidates$_(t, i._$GetObjectClasses$_(), e, s);
                }
                _$GetJumpthruCollisionCandidates$_(t, e, s) {
                    const i = this._$_runtime$_._$GetJumpthruBehavior$_();
                    i && this._$GetObjectClassesCollisionCandidates$_(t, i._$GetObjectClasses$_(), e, s);
                }
                _$IsSolidCollisionAllowed$_(t, e) {
                    return t._$_IsSolidEnabled$_() && (!e || e._$GetWorldInfo$_()._$IsSolidCollisionAllowed$_(t._$GetSavedDataMap$_().get("solidTags")));
                }
                _$TestOverlapSolid$_(t) {
                    const e = t._$GetWorldInfo$_();
                    this._$GetSolidCollisionCandidates$_(e._$GetLayer$_(), e._$GetBoundingBox$_(), tempCandidates);
                    for (const s of tempCandidates) if (this._$IsSolidCollisionAllowed$_(s, t) && this._$TestOverlap$_(t, s)) return C33._$clearArray$_(tempCandidates), 
                    s;
                    return C33._$clearArray$_(tempCandidates), null;
                }
                _$TestRectOverlapSolid$_(t, e) {
                    this._$GetSolidCollisionCandidates$_(null, t, tempCandidates);
                    for (const s of tempCandidates) if (this._$IsSolidCollisionAllowed$_(s, e) && this._$TestRectOverlap$_(t, s)) return C33._$clearArray$_(tempCandidates), 
                    s;
                    return C33._$clearArray$_(tempCandidates), null;
                }
                _$TestOverlapJumpthru$_(t, e) {
                    let s = null;
                    e && (s = tempJumpthruRet, C33._$clearArray$_(s));
                    const i = t._$GetWorldInfo$_();
                    this._$GetJumpthruCollisionCandidates$_(i._$GetLayer$_(), i._$GetBoundingBox$_(), tempCandidates);
                    for (const r of tempCandidates) if (r._$_IsJumpthruEnabled$_() && this._$TestOverlap$_(t, r)) {
                        if (!e) return C33._$clearArray$_(tempCandidates), r;
                        s.push(r);
                    }
                    return C33._$clearArray$_(tempCandidates), s;
                }
                _$PushOut$_(e, s, i, r, n) {
                    r = r || 50;
                    const h = e._$GetWorldInfo$_(), o = h._$GetX$_(), a = h._$GetY$_();
                    for (let t = 0; t < r; ++t) if (h._$SetXY$_(o + s * t, a + i * t), 
                    h._$SetBboxChanged$_(), !this._$TestOverlap$_(e, n)) return !0;
                    return h._$SetXY$_(o, a), h._$SetBboxChanged$_(), !1;
                }
                _$PushOutSolid$_(e, s, i, r, n, h) {
                    r = r || 50;
                    let o = e._$GetWorldInfo$_(), a = o._$GetX$_(), l = o._$GetY$_(), u = null, c = null;
                    for (let t = 0; t < r; ++t) if (o._$SetXY$_(a + s * t, l + i * t), 
                    o._$SetBboxChanged$_(), !this._$TestOverlap$_(e, u)) if (u = this._$TestOverlapSolid$_(e)) c = u; else if (n && (u = h ? this._$TestOverlap$_(e, h) ? h : null : this._$TestOverlapJumpthru$_(e)) && (c = u), 
                    !u) return c && this._$PushInFractional$_(e, s, i, c, 16, !0), 
                    !0;
                    return o._$SetXY$_(a, l), o._$SetBboxChanged$_(), !1;
                }
                _$PushOutSolidAxis$_(s, i, r, t) {
                    t = t || 50;
                    let n = s._$GetWorldInfo$_(), h = n._$GetX$_(), o = n._$GetY$_(), a = null, l = null;
                    for (let e = 0; e < t; ++e) for (let t = 0; t < 2; ++t) {
                        const u = 2 * t - 1;
                        if (n._$SetXY$_(h + i * e * u, o + r * e * u), n._$SetBboxChanged$_(), 
                        !this._$TestOverlap$_(s, a)) {
                            if (!(a = this._$TestOverlapSolid$_(s))) return l && this._$PushInFractional$_(s, i * u, r * u, l, 16, !0), 
                            !0;
                            l = a;
                        }
                    }
                    return n._$SetXY$_(h, o), n._$SetBboxChanged$_(), !1;
                }
                _$PushInFractional$_(t, e, s, i, r, n) {
                    let h = 2, o = !1, a = !1, l = t._$GetWorldInfo$_(), u = l._$GetX$_(), c = l._$GetY$_();
                    for (;h <= r; ) {
                        const f = 1 / h;
                        h *= 2, l._$OffsetXY$_(e * f * (o ? 1 : -1), s * f * (o ? 1 : -1)), 
                        l._$SetBboxChanged$_(), this._$TestOverlap$_(t, i) || n && this._$TestOverlapSolid$_(t) ? (o = !0, 
                        a = !0) : (o = !1, a = !1, u = l._$GetX$_(), c = l._$GetY$_());
                    }
                    a && (l._$SetXY$_(u, c), l._$SetBboxChanged$_());
                }
                _$PushOutSolidNearest$_(s, t = 100) {
                    let i = 0, r = s._$GetWorldInfo$_(), n = r._$GetX$_(), h = r._$GetY$_(), o = 0, a = this._$TestOverlapSolid$_(s);
                    if (!a) return !0;
                    for (;i <= t; ) {
                        let t = 0, e = 0;
                        switch (o) {
                          case 0:
                            t = 0, e = -1, i++;
                            break;

                          case 1:
                            t = 1, e = -1;
                            break;

                          case 2:
                            t = 1, e = 0;
                            break;

                          case 3:
                            t = 1, e = 1;
                            break;

                          case 4:
                            t = 0, e = 1;
                            break;

                          case 5:
                            t = -1, e = 1;
                            break;

                          case 6:
                            t = -1, e = 0;
                            break;

                          case 7:
                            t = -1, e = -1;
                        }
                        if (o = (o + 1) % 8, r._$SetXY$_(Math.floor(n + t * i), Math.floor(h + e * i)), 
                        r._$SetBboxChanged$_(), !this._$TestOverlap$_(s, a) && !(a = this._$TestOverlapSolid$_(s))) return !0;
                    }
                    return r._$SetXY$_(n, h), r._$SetBboxChanged$_(), !1;
                }
                _$CalculateBounceAngle$_(t, e, s, i) {
                    const r = t._$GetWorldInfo$_(), n = r._$GetX$_(), h = r._$GetY$_(), o = Math.max(10, C33._$distanceTo$_(e, s, n, h)), a = C33._$angleTo$_(e, s, n, h), l = i || this._$TestOverlapSolid$_(t);
                    if (!l) return C33._$clampAngle$_(a + Math.PI);
                    let u = l, c = 0, f = 0, d = C33._$toRadians$_(5), p;
                    for (p = 1; p < 36; ++p) {
                        const I = a - p * d;
                        if (r._$SetXY$_(e + Math.cos(I) * o, s + Math.sin(I) * o), 
                        r._$SetBboxChanged$_(), !this._$TestOverlap$_(t, u) && !(u = i ? null : this._$TestOverlapSolid$_(t))) {
                            c = I;
                            break;
                        }
                    }
                    for (36 === p && (c = C33._$clampAngle$_(a + Math.PI)), u = l, 
                    p = 1; p < 36; ++p) {
                        const M = a + p * d;
                        if (r._$SetXY$_(e + Math.cos(M) * o, s + Math.sin(M) * o), 
                        r._$SetBboxChanged$_(), !this._$TestOverlap$_(t, u) && !(u = i ? null : this._$TestOverlapSolid$_(t))) {
                            f = M;
                            break;
                        }
                    }
                    if (36 === p && (f = C33._$clampAngle$_(a + Math.PI)), r._$SetXY$_(n, h), 
                    r._$SetBboxChanged$_(), f === c) return f;
                    let m = C33._$angleDiff$_(f, c) / 2, C;
                    C = C33._$angleClockwise$_(f, c) ? C33._$clampAngle$_(c + m + Math.PI) : C33._$clampAngle$_(f + m);
                    const g = Math.cos(a), S = Math.sin(a), _ = Math.cos(C), T = Math.sin(C), y = g * _ + S * T, E = g - 2 * y * _, A = S - 2 * y * T;
                    return C33._$angleTo$_(0, 0, E, A);
                }
                _$TestSegmentOverlap$_(t, e, s, i, r) {
                    if (!r) return !1;
                    const n = r._$GetWorldInfo$_();
                    if (!n._$IsCollisionEnabled$_()) return !1;
                    if (this._$_collisionCheckCount$_++, tempRect.set(Math.min(t, s), Math.min(e, i), Math.max(t, s), Math.max(e, i)), 
                    !n._$GetBoundingBox$_()._$intersectsRect$_(tempRect)) return !1;
                    if (r._$HasTilemap$_()) return this._$_TestSegmentOverlapTilemap$_(t, e, s, i, r, n);
                    if (this._$_polyCheckCount$_++, !n._$GetBoundingQuad$_()._$intersectsSegment$_(t, e, s, i)) return !1;
                    if (!n._$HasOwnCollisionPoly$_()) return !0;
                    const h = n._$GetTransformedCollisionPoly$_();
                    return h._$intersectsSegment$_(n._$GetX$_(), n._$GetY$_(), t, e, s, i);
                }
                _$_TestSegmentOverlapTilemap$_(s, i, r, n, t, e) {
                    const h = e._$GetX$_(), o = e._$GetY$_(), a = t._$GetSdkInstance$_(), l = tileCollRectCandidates;
                    tempRect2.set(s, i, r, n), tempRect2.normalize(), a._$GetCollisionRectCandidates$_(tempRect2, l);
                    for (let t = 0, e = l.length; t < e; ++t) {
                        const u = l[t], c = u._$GetRect$_();
                        if (this._$_collisionCheckCount$_++, tempRect._$intersectsRectOffset$_(c, h, o) && (tempQuad._$setFromRect$_(c), 
                        tempQuad.offset(h, o), tempQuad._$intersectsSegment$_(s, i, r, n))) {
                            const f = u._$GetPoly$_();
                            if (!f) return C33._$clearArray$_(l), !0;
                            if (this._$_polyCheckCount$_++, f._$intersectsSegment$_(h + c._$getLeft$_(), o + c._$getTop$_(), s, i, r, n)) return C33._$clearArray$_(l), 
                            !0;
                        }
                    }
                    return C33._$clearArray$_(l), !1;
                }
                _$TestRectOverlap$_(t, e) {
                    if (!e) return !1;
                    const s = e._$GetWorldInfo$_();
                    if (!s._$IsCollisionEnabled$_()) return !1;
                    if (this._$_collisionCheckCount$_++, !s._$GetBoundingBox$_()._$intersectsRect$_(t)) return !1;
                    if (e._$HasTilemap$_()) return this._$_TestRectOverlapTilemap$_(t, e, s);
                    if (this._$_polyCheckCount$_++, tempQuad._$setFromRect$_(t), 
                    !s._$GetBoundingQuad$_()._$intersectsQuad$_(tempQuad)) return !1;
                    if (!s._$HasOwnCollisionPoly$_()) return !0;
                    const i = tempPolyA, r = (i._$setFromRect$_(t, s._$GetX$_(), s._$GetY$_()), 
                    s._$GetTransformedCollisionPoly$_());
                    return i._$intersectsPoly$_(r, 0, 0);
                }
                _$_TestRectOverlapTilemap$_(s, t, e) {
                    const i = e._$GetX$_(), r = e._$GetY$_(), n = t._$GetSdkInstance$_(), h = tileCollRectCandidates;
                    n._$GetCollisionRectCandidates$_(s, h);
                    for (let t = 0, e = h.length; t < e; ++t) {
                        const o = h[t], a = o._$GetRect$_();
                        if (this._$_collisionCheckCount$_++, s._$intersectsRectOffset$_(a, i, r)) {
                            const l = o._$GetPoly$_();
                            if (!l) return C33._$clearArray$_(h), !0;
                            if (this._$_polyCheckCount$_++, tempPolyA._$setFromRect$_(s, 0, 0), 
                            l._$intersectsPoly$_(tempPolyA, -(i + a._$getLeft$_()), -(r + a._$getTop$_()))) return C33._$clearArray$_(h), 
                            !0;
                        }
                    }
                    return C33._$clearArray$_(h), !1;
                }
                _$TestRayIntersectsInstance$_(t, e) {
                    if (t) {
                        const s = t._$GetWorldInfo$_();
                        s._$IsCollisionEnabled$_() && (this._$_collisionCheckCount$_++, 
                        s._$GetBoundingBox$_()._$intersectsRect$_(e.rect)) && (t._$HasTilemap$_() ? this._$_TestRayIntersectsTilemap$_(t, s, e) : (this._$_polyCheckCount$_++, 
                        s._$HasOwnCollisionPoly$_() ? e._$TestInstancePoly$_(t, s._$GetX$_(), s._$GetY$_(), s._$GetTransformedCollisionPoly$_()) : e._$TestInstanceQuad$_(t, s._$GetBoundingQuad$_())));
                    }
                }
                _$_TestRayIntersectsTilemap$_(s, i, r) {
                    const n = i._$GetX$_(), h = i._$GetY$_(), o = tileCollRectCandidates;
                    s._$GetSdkInstance$_()._$GetCollisionRectCandidates$_(r.rect, o);
                    for (let t = 0, e = o.length; t < e; t++) {
                        const a = o[t], l = a._$GetRect$_();
                        if (this._$_collisionCheckCount$_++, r.rect._$intersectsRectOffset$_(l, n, h)) {
                            const u = a._$GetPoly$_();
                            this._$_polyCheckCount$_++, u ? r._$TestInstancePoly$_(s, n + l._$getLeft$_(), h + l._$getTop$_(), u) : r._$TestInstanceRect$_(s, i._$GetX$_(), i._$GetY$_(), l);
                        }
                    }
                    C33._$clearArray$_(o);
                }
                _$SetCollisionCellSize$_(t, e) {
                    if (t !== this._$_collisionCellWidth$_ || e !== this._$_collisionCellHeight$_) {
                        this._$_collisionCellWidth$_ = t, this._$_collisionCellHeight$_ = e;
                        const s = this._$_runtime$_._$GetAllObjectClasses$_();
                        for (const i of s) if (i._$IsWorldType$_()) {
                            for (const r of i._$instancesIncludingPendingCreate$_()) r._$GetWorldInfo$_()._$_RemoveFromCollisionCells$_();
                            i._$_GetCollisionCellGrid$_()._$SetCellSize$_(t, e), 
                            i._$_SetAnyCollisionCellChanged$_();
                            for (const n of i._$instancesIncludingPendingCreate$_()) {
                                const h = n._$GetWorldInfo$_();
                                h._$_SetCollisionCellChanged$_(), h._$_UpdateCollisionCell$_();
                            }
                        }
                    }
                }
                _$GetCollisionCellSize$_() {
                    return [ this._$_collisionCellWidth$_, this._$_collisionCellHeight$_ ];
                }
                _$_InitCollisionCellSize$_(t, e) {
                    this._$_collisionCellWidth$_ = t, this._$_collisionCellHeight$_ = e;
                }
            };
        }
        {
            const C33 = self._$C3$_;
            C33._$SparseGrid$_ = class extends C33._$DefendedBase$_ {
                constructor(t, e) {
                    super(), this._$_cellWidth$_ = t, this._$_cellHeight$_ = e, 
                    this._$_cells$_ = C33._$New$_(C33._$PairMap$_);
                }
                _$Release$_() {
                    this._$_cells$_._$Release$_(), this._$_cells$_ = null;
                }
                _$SetCellSize$_(t, e) {
                    if (!this._$_cells$_._$IsEmpty$_()) throw new Error("grid not empty");
                    this._$_cellWidth$_ = t, this._$_cellHeight$_ = e;
                }
                _$GetCell$_(t, e, s) {
                    let i = this._$_cells$_._$Get$_(t, e);
                    return i || (s ? (i = C33._$New$_(C33._$GridCell$_, this, t, e), 
                    this._$_cells$_.Set(t, e, i), i) : null);
                }
                _$XToCell$_(t) {
                    const e = Math.floor(t / this._$_cellWidth$_);
                    return isFinite(e) ? e : 0;
                }
                _$YToCell$_(t) {
                    const e = Math.floor(t / this._$_cellHeight$_);
                    return isFinite(e) ? e : 0;
                }
                _$Update$_(i, r, n) {
                    if (r) for (let s = r._$getLeft$_(), t = r._$getRight$_(); s <= t; ++s) for (let t = r._$getTop$_(), e = r._$getBottom$_(); t <= e; ++t) if (!n || !n._$containsPoint$_(s, t)) {
                        const h = this._$GetCell$_(s, t, !1);
                        h && (h._$Remove$_(i), h._$IsEmpty$_()) && this._$_cells$_._$Delete$_(s, t);
                    }
                    if (n) for (let s = n._$getLeft$_(), t = n._$getRight$_(); s <= t; ++s) for (let t = n._$getTop$_(), e = n._$getBottom$_(); t <= e; ++t) r && r._$containsPoint$_(s, t) || this._$GetCell$_(s, t, !0)._$Insert$_(i);
                }
                _$QueryRange$_(t, e) {
                    let s = this._$XToCell$_(t._$getLeft$_()), i = this._$YToCell$_(t._$getTop$_()), r = this._$XToCell$_(t._$getRight$_()), n = this._$YToCell$_(t._$getBottom$_());
                    if (isFinite(r) && isFinite(n)) for (;s <= r; ++s) for (let t = i; t <= n; ++t) {
                        const h = this._$GetCell$_(s, t, !1);
                        h && h._$Dump$_(e);
                    }
                }
            };
        }
        {
            const C33 = self._$C3$_;
            C33._$GridCell$_ = class extends C33._$DefendedBase$_ {
                constructor(t, e, s) {
                    super(), this._$_grid$_ = t, this._$_x$_ = e, this._$_y$_ = s, 
                    this._$_instances$_ = C33._$New$_(C33._$ArraySet$_);
                }
                _$Release$_() {
                    this._$_instances$_._$Release$_(), this._$_instances$_ = null, 
                    this._$_grid$_ = null;
                }
                _$IsEmpty$_() {
                    return this._$_instances$_._$IsEmpty$_();
                }
                _$Insert$_(t) {
                    this._$_instances$_._$Add$_(t);
                }
                _$Remove$_(t) {
                    this._$_instances$_._$Delete$_(t);
                }
                _$Dump$_(t) {
                    C33._$appendArray$_(t, this._$_instances$_._$GetArray$_());
                }
            };
        }
        {
            const C33 = self._$C3$_, PADDING = 1e-6, NO_HIT = 2;
            C33._$Ray$_ = class {
                constructor() {
                    this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.dx = 0, 
                    this.dy = 0, this.rect = new C33.Rect(), this._$hitFraction$_ = NO_HIT, 
                    this._$hitUid$_ = null, this._$hitNormal$_ = 0, this._$hitNormalDx$_ = 0, 
                    this._$hitNormalDy$_ = 0, this._$hitX$_ = 0, this._$hitY$_ = 0, 
                    this._$distance$_ = 0, this._$normalX$_ = 1, this._$normalY$_ = 0, 
                    this._$reflectionX$_ = 1, this._$reflectionY$_ = 0;
                }
                _$DidCollide$_() {
                    return this._$hitFraction$_ < 1 + PADDING;
                }
                _$Reset$_() {
                    this._$hitFraction$_ = NO_HIT;
                }
                Set(t, e, s, i) {
                    return this.x1 = t, this.y1 = e, this.x2 = s, this.y2 = i, this.dx = s - t, 
                    this.dy = i - e, this.rect.set(t, e, s, i), this.rect.normalize(), 
                    this._$hitFraction$_ = NO_HIT, this._$hitUid$_ = null, this._$hitNormal$_ = 0, 
                    this._$hitNormalDx$_ = 0, this._$hitNormalDy$_ = 0, this._$hitX$_ = 0, 
                    this._$hitY$_ = 0, this._$distance$_ = 0, this._$normalX$_ = 1, 
                    this._$normalY$_ = 0, this._$reflectionX$_ = 1, this._$reflectionY$_ = 0, 
                    this;
                }
                _$Complete$_() {
                    if (!1 !== this._$DidCollide$_()) {
                        const t = this.dx * this._$hitFraction$_, e = this.dy * this._$hitFraction$_, s = C33._$hypot2DFast$_(t, e), i = t / s, r = e / s, n = (this._$distance$_ = s - PADDING, 
                        this._$hitX$_ = this.x1 + i * this._$distance$_, this._$hitY$_ = this.y1 + r * this._$distance$_, 
                        this._$hitNormal$_ = Math.atan2(this._$hitNormalDy$_, this._$hitNormalDx$_) + Math.PI / 2, 
                        this._$normalX$_ = Math.cos(this._$hitNormal$_), this._$normalY$_ = Math.sin(this._$hitNormal$_), 
                        i * this._$normalX$_ + r * this._$normalY$_);
                        if (this._$reflectionX$_ = i - 2 * this._$normalX$_ * n, 
                        this._$reflectionY$_ = r - 2 * this._$normalY$_ * n, 0 < n) {
                            const h = Math.PI;
                            this._$hitNormal$_ = C33._$clampAngle$_(this._$hitNormal$_ + h), 
                            this._$normalX$_ = -this._$normalX$_, this._$normalY$_ = -this._$normalY$_;
                        }
                    }
                }
                _$TestInstanceSegment$_(t, e, s, i, r) {
                    const n = C33._$rayIntersect$_(this.x1, this.y1, this.x2, this.y2, e, s, i, r);
                    0 <= n && n < this._$hitFraction$_ && (this._$hitFraction$_ = n, 
                    this._$hitUid$_ = t._$GetUID$_(), this._$hitNormalDx$_ = e - i, 
                    this._$hitNormalDy$_ = s - r);
                }
                _$TestInstanceRect$_(t, e, s, i) {
                    const r = e + i._$getLeft$_(), n = e + i._$getRight$_(), h = s + i._$getTop$_(), o = s + i._$getBottom$_();
                    this._$TestInstanceSegment$_(t, r, h, n, h), this._$TestInstanceSegment$_(t, n, h, n, o), 
                    this._$TestInstanceSegment$_(t, n, o, r, o), this._$TestInstanceSegment$_(t, r, o, r, h);
                }
                _$TestInstanceQuad$_(t, e) {
                    const s = e._$getTlx$_(), i = e._$getTly$_(), r = e._$getTrx$_(), n = e._$getTry$_(), h = e._$getBrx$_(), o = e._$getBry$_(), a = e._$getBlx$_(), l = e._$getBly$_();
                    this._$TestInstanceSegment$_(t, s, i, r, n), this._$TestInstanceSegment$_(t, r, n, h, o), 
                    this._$TestInstanceSegment$_(t, h, o, a, l), this._$TestInstanceSegment$_(t, a, l, s, i);
                }
                _$TestInstancePoly$_(s, i, r, t) {
                    const n = t._$pointsArr$_();
                    for (let t = 0, e = n.length; t < e; t += 2) {
                        const h = (t + 2) % e, o = n[t] + i, a = n[t + 1] + r, l = n[h] + i, u = n[1 + h] + r;
                        this._$TestInstanceSegment$_(s, o, a, l, u);
                    }
                }
            };
        }
        {
            const C33 = self._$C3$_, VALID_FULLSCREEN_MODES = new Set([ "off", "crop", "scale-inner", "scale-outer", "letterbox-scale", "letterbox-integer-scale" ]), VALID_FULLSCREEN_SCALING_QUALITIES = new Set([ "high", "low" ]), glMatrix = self._$glMatrix$_, mat42 = glMatrix._$mat4$_, vec32 = glMatrix._$vec3$_, tempProjection = mat42.create(), PERCENTTEXT_WIDTH = 300, PERCENTTEXT_HEIGHT = 200, PROGRESSBAR_WIDTH = 120, PROGRESSBAR_HEIGHT = 8, tempQuad = C33._$New$_(C33._$Quad$_), tempRect = C33._$New$_(C33.Rect), SPLASH_MIN_DISPLAY_TIME = 3e3, SPLASH_AFTER_FADEOUT_WAIT_TIME = 200, SPLASH_FADE_DURATION = 300;
            C33._$CanvasManager$_ = class extends C33._$DefendedBase$_ {
                constructor(t) {
                    super(), this._$_runtime$_ = t, this._$_canvasLayers$_ = [], 
                    this._$_isWebGPUEnabled$_ = !1, this._$_webglRenderer$_ = null, 
                    this._$_webgpuRenderer$_ = null, this._$_iRenderer$_ = null, 
                    this._$_gpuPreference$_ = "high-performance", this._$_isLimitedToWebGL1$_ = !1, 
                    this._$_multitexturingMode$_ = "auto", this._$_windowInnerWidth$_ = 0, 
                    this._$_windowInnerHeight$_ = 0, this._$_cssDisplayMode$_ = "", 
                    this._$_canvasCssWidth$_ = 0, this._$_canvasCssHeight$_ = 0, 
                    this._$_canvasDeviceWidth$_ = 0, this._$_canvasDeviceHeight$_ = 0, 
                    this._$_canvasCssOffsetX$_ = 0, this._$_canvasCssOffsetY$_ = 0, 
                    this._$_zAxisScale$_ = "normalized", this._$_initFieldOfView$_ = 0, 
                    this._$_zNear$_ = 1, this._$_zFar$_ = 1e4, this._$_enableMipmaps$_ = !0, 
                    this._$_textureAnisotropy$_ = 0, this._$_drawWidth$_ = 0, this._$_drawHeight$_ = 0, 
                    this._$_fullscreenMode$_ = "letterbox-scale", this._$_documentFullscreenMode$_ = "letterbox-scale", 
                    this._$_deviceTransformOffX$_ = 0, this._$_deviceTransformOffY$_ = 0, 
                    this._$_defaultProjectionMatrix$_ = mat42.create(), this._$_wantFullscreenScalingQuality$_ = "high", 
                    this._$_fullscreenScalingQuality$_ = this._$_wantFullscreenScalingQuality$_, 
                    this._$_isDocumentFullscreen$_ = !1, this._$_availableAdditionalRenderTargets$_ = [], 
                    this._$_usedAdditionalRenderTargets$_ = new Set(), this._$_shaderData$_ = self.C3_Shaders, 
                    this._$_effectChainManager$_ = C33._$New$_(C33._$Gfx$_._$EffectChainManager$_, {
                        _$getDrawSize$_: () => [ this._$GetDrawWidth$_(), this._$GetDrawHeight$_() ],
                        _$getRenderTarget$_: () => this._$GetEffectCompositorRenderTarget$_(),
                        _$releaseRenderTarget$_: t => this._$ReleaseEffectCompositorRenderTarget$_(t),
                        getTime: () => this._$GetRuntime$_()._$GetGameTime$_(),
                        _$redraw$_: () => this._$GetRuntime$_()._$UpdateRender$_()
                    }), this._$_gpuTimeStartFrame$_ = 0, this._$_gpuTimeEndFrame$_ = 0, 
                    this._$_gpuLastUtilisation$_ = NaN, this._$_gpuFrameTimingsBuffer$_ = null, 
                    this._$_layersGpuProfile$_ = new Map(), this._$_gpuCurUtilisation$_ = NaN, 
                    this._$_webgpuFrameTimings$_ = new Map(), this._$_snapshotFormat$_ = "", 
                    this._$_snapshotQuality$_ = 1, this._$_snapshotArea$_ = C33._$New$_(C33.Rect), 
                    this._$_snapshotUrl$_ = "", this._$_snapshotPromise$_ = null, 
                    this._$_snapshotResolve$_ = null, this._$_isPastingToDrawingCanvas$_ = 0, 
                    this._$_loaderStartTime$_ = 0, this._$_rafId$_ = -1, this._$_loadingProgress$_ = 0, 
                    this._$_loadingprogress_handler$_ = t => this._$_loadingProgress$_ = t.progress, 
                    this._$_percentText$_ = null, this._$_splashTextures$_ = {
                        _$logo$_: null,
                        _$powered$_: null,
                        _$website$_: null
                    }, this._$_splashFrameNumber$_ = 0, this._$_splashFadeInFinishTime$_ = 0, 
                    this._$_splashFadeOutStartTime$_ = 0, this._$_splashState$_ = "fade-in", 
                    this._$_splashDoneResolve$_ = null, this._$_splashDonePromise$_ = new Promise(t => this._$_splashDoneResolve$_ = t);
                }
                _$_SetGPUPowerPreference$_(t) {
                    this._$_gpuPreference$_ = t;
                }
                _$_SetWebGPUEnabled$_(t) {
                    this._$_isWebGPUEnabled$_ = !!t;
                }
                _$_SetZAxisScale$_(t) {
                    this._$_zAxisScale$_ = t;
                }
                _$GetZAxisScale$_() {
                    return this._$_zAxisScale$_;
                }
                _$_SetInitFieldOfView$_(t) {
                    this._$_initFieldOfView$_ = t;
                }
                _$_SetZDistances$_(t, e) {
                    this._$_zNear$_ = t, this._$_zFar$_ = e;
                }
                _$_SetLimitedToWebGL1$_(t) {
                    this._$_isLimitedToWebGL1$_ = !!t;
                }
                _$_SetMultitexturingMode$_(t) {
                    this._$_multitexturingMode$_ = t;
                }
                async _$CreateCanvas$_(t) {
                    let e = t.canvas, s = (this._$_canvasLayers$_.push({
                        canvas: e,
                        _$ctx$_: null
                    }), this._$_runtime$_._$AddDOMComponentMessageHandler$_("runtime", "window-resize", t => this._$_OnWindowResize$_(t)), 
                    this._$_runtime$_._$AddDOMComponentMessageHandler$_("runtime", "fullscreenchange", t => this._$_OnFullscreenChange$_(t)), 
                    this._$_runtime$_._$AddDOMComponentMessageHandler$_("runtime", "fullscreenerror", t => this._$_OnFullscreenError$_(t)), 
                    e.addEventListener("webglcontextlost", t => this._$_OnWebGLContextLost$_(t)), 
                    e.addEventListener("webglcontextrestored", t => this._$_OnWebGLContextRestored$_(t)), 
                    this._$_isDocumentFullscreen$_ = !!t.isFullscreen, this._$_cssDisplayMode$_ = t.cssDisplayMode, 
                    navigator.gpu && this._$_isWebGPUEnabled$_), i = !1;
                    if (s) try {
                        await this._$_InitWebGPUContext$_(!0);
                    } catch (t) {
                        this._$_MaybeLogRendererError$_("WebGPU", t), this._$_webgpuRenderer$_ = null;
                    }
                    if (!this._$GetRenderer$_()) try {
                        await this._$_InitWebGLContext$_(!0);
                    } catch (t) {
                        this._$_MaybeLogRendererError$_("WebGL", t), this._$_webglRenderer$_ = null;
                    }
                    if (this._$GetRenderer$_() || (i = !0), !this._$GetRenderer$_() && s) try {
                        await this._$_InitWebGPUContext$_(!1);
                    } catch (t) {
                        this._$_MaybeLogRendererError$_("WebGPU", t), this._$_webgpuRenderer$_ = null;
                    }
                    if (!this._$GetRenderer$_()) try {
                        await this._$_InitWebGLContext$_(!1);
                    } catch (t) {
                        this._$_MaybeLogRendererError$_("WebGL", t), this._$_webglRenderer$_ = null;
                    }
                    const r = this._$GetRenderer$_();
                    if (!r) throw new Error("failed to acquire a renderer - check WebGL or WebGPU is supported");
                    r._$SetHasMajorPerformanceCaveat$_(i), this._$_webgpuRenderer$_ && (this._$_webgpuRenderer$_._$ondevicelost$_ = () => this._$_OnWebGPUDeviceLost$_(), 
                    this._$_webgpuRenderer$_._$ondevicerestored$_ = () => this._$_OnWebGPUDeviceRestored$_()), 
                    "normalized" === this._$_zAxisScale$_ ? r._$SetZAxisScaleNormalized$_() : (r._$SetZAxisScaleRegular$_(), 
                    r._$SetFovY$_(this._$_initFieldOfView$_)), this._$SetSize$_(t.windowInnerWidth, t.windowInnerHeight, !0), 
                    await this._$_InitRenderer$_();
                }
                _$_MaybeLogRendererError$_(t, e) {
                    e && "string" == typeof e.message && e.message.startsWith("renderer-unavailable") || console.error(`Error creating ${t} renderer: `, e);
                }
                async _$_InitWebGPUContext$_(t) {
                    let e = {
                        _$nearZ$_: this._$_zNear$_,
                        _$farZ$_: this._$_zFar$_
                    }, s = !0;
                    "no" === this._$_multitexturingMode$_ ? s = !1 : "auto" === this._$_multitexturingMode$_ && (s = C33._$Platform$_._$IsDesktop$_);
                    const i = {
                        powerPreference: this._$_gpuPreference$_,
                        depth: this._$_runtime$_._$Uses3DFeatures$_(),
                        failIfMajorPerformanceCaveat: t,
                        _$usesBackgroundBlending$_: this._$_runtime$_._$UsesAnyBackgroundBlending$_(),
                        _$canSampleBackbuffer$_: this._$_runtime$_._$UsesAnyCrossSampling$_(),
                        _$canSampleDepth$_: this._$_runtime$_._$UsesAnyDepthSampling$_(),
                        _$isMultiTexturingAllowed$_: s
                    };
                    this._$_webgpuRenderer$_ = C33._$New$_(C33._$Gfx$_._$WebGPURenderer$_, e), 
                    await this._$_webgpuRenderer$_._$Create$_(this._$_canvasLayers$_[0].canvas, i);
                }
                async _$_InitWebGLContext$_(t) {
                    const e = {
                        alpha: !0,
                        powerPreference: this._$_gpuPreference$_,
                        _$enableGpuProfiling$_: "xbox-uwp-webview2" !== this._$_runtime$_._$GetExportType$_(),
                        depth: this._$_runtime$_._$Uses3DFeatures$_(),
                        _$canSampleDepth$_: this._$_runtime$_._$UsesAnyDepthSampling$_(),
                        failIfMajorPerformanceCaveat: t,
                        _$nearZ$_: this._$_zNear$_,
                        _$farZ$_: this._$_zFar$_
                    };
                    this._$_isLimitedToWebGL1$_ && (e._$maxWebGLVersion$_ = 1), 
                    this._$_webglRenderer$_ = C33._$New$_(C33._$Gfx$_._$WebGLRenderer$_, this._$_canvasLayers$_[0].canvas, e), 
                    await this._$_webglRenderer$_._$InitState$_();
                }
                async _$_InitWebGPU$_() {
                    if (this._$_shaderData$_) {
                        const t = [];
                        for (const [ e, s ] of Object.entries(this._$_shaderData$_)) {
                            s.src = s.wgsl;
                            const i = C33._$Gfx$_._$WebGPUShaderProgram$_._$GetDefaultVertexShaderSource$_();
                            t.push(this._$_webgpuRenderer$_._$CreateShaderProgram$_(Object.assign({
                                _$vertexSrc$_: i,
                                name: e
                            }, s)));
                        }
                        await Promise.all(t);
                    }
                }
                async _$_InitWebGL$_() {
                    if (this._$_shaderData$_) {
                        const e = [];
                        for (const [ s, i ] of Object.entries(this._$_shaderData$_)) {
                            let t;
                            if (i.glslWebGL2 && 2 <= this._$_webglRenderer$_._$GetWebGLVersionNumber$_()) i.src = i.glslWebGL2, 
                            t = C33._$Gfx$_._$WebGLShaderProgram$_._$GetDefaultVertexShaderSource_WebGL2$_(); else {
                                if (!i.glsl) throw new Error(`shader '${s}' does not support WebGL 1`);
                                i.src = i.glsl, t = C33._$Gfx$_._$WebGLShaderProgram$_._$GetDefaultVertexShaderSource$_();
                            }
                            e.push(this._$_webglRenderer$_._$CreateShaderProgram$_(Object.assign({
                                _$vertexSrc$_: t,
                                name: s
                            }, i)));
                        }
                        await Promise.all(e), this._$_webglRenderer$_._$ResetLastProgram$_(), 
                        this._$_webglRenderer$_._$SetTextureFillMode$_();
                    }
                    this._$_webglRenderer$_._$SupportsGPUProfiling$_() && (this._$_gpuFrameTimingsBuffer$_ = C33._$New$_(C33._$Gfx$_._$WebGLQueryResultBuffer$_, this._$_webglRenderer$_));
                }
                async _$_InitRenderer$_() {
                    this._$_webgpuRenderer$_ ? await this._$_InitWebGPU$_() : this._$_webglRenderer$_ && await this._$_InitWebGL$_();
                    const t = this._$GetRenderer$_();
                    t._$SetMipmapsEnabled$_(this._$_enableMipmaps$_), t._$SupportsGPUProfiling$_() && (this._$_gpuLastUtilisation$_ = 0);
                    for (const e of this._$_runtime$_._$_GetAllEffectLists$_()) {
                        for (const s of e._$GetAllEffectTypes$_()) s._$_InitRenderer$_(t);
                        e._$_InitRenderer$_(t), e._$UpdateActiveEffects$_();
                    }
                    this._$_iRenderer$_ = new self._$IRenderer$_(this._$_runtime$_, t);
                }
                _$Release$_() {
                    this._$_runtime$_ = null, this._$_webglRenderer$_ = null, this._$_canvasLayers$_.length = 0;
                }
                _$IsInWorker$_() {
                    return this._$_runtime$_._$IsInWorker$_();
                }
                _$_OnWindowResize$_(t) {
                    const e = this._$_runtime$_;
                    if (!e._$IsExportToVideo$_()) {
                        const s = t.devicePixelRatio, i = (this._$IsInWorker$_() && (self.devicePixelRatio = s), 
                        e._$_SetDevicePixelRatio$_(s), this._$_isDocumentFullscreen$_ = !!t.isFullscreen, 
                        this._$_cssDisplayMode$_ = t.cssDisplayMode, this._$SetSize$_(t.innerWidth, t.innerHeight), 
                        e._$UpdateRender$_(), new C33.Event("window-resize")), r = (i.data = t, 
                        e._$Dispatcher$_()._$dispatchEventAndWaitAsyncSequential$_(i), 
                        new C33.Event("resize"));
                        r._$cssWidth$_ = this._$GetCssWidth$_(), r._$cssHeight$_ = this._$GetCssHeight$_(), 
                        r._$deviceWidth$_ = this._$GetDeviceWidth$_(), r._$deviceHeight$_ = this._$GetDeviceHeight$_(), 
                        e._$DispatchUserScriptEvent$_(r), e._$IsDebug$_() && (e._$HitBreakpoint$_() || self.C3Debugger.IsDebuggerPaused()) && e._$Render$_();
                    }
                }
                _$_OnFullscreenChange$_(t) {
                    this._$_isDocumentFullscreen$_ = !!t.isFullscreen, this._$SetSize$_(t.innerWidth, t.innerHeight, !0), 
                    this._$_runtime$_._$UpdateRender$_();
                }
                _$_OnFullscreenError$_(t) {
                    this._$_isDocumentFullscreen$_ = !!t.isFullscreen, this._$SetSize$_(t.innerWidth, t.innerHeight, !0), 
                    this._$_runtime$_._$UpdateRender$_();
                }
                _$SetSize$_(t, e, s = !1) {
                    if (t = Math.floor(t), e = Math.floor(e), t <= 0 || e <= 0) throw new Error("invalid size");
                    if (this._$_windowInnerWidth$_ !== t || this._$_windowInnerHeight$_ !== e || s) {
                        this._$_windowInnerWidth$_ = t, this._$_windowInnerHeight$_ = e;
                        const i = this._$GetCurrentFullscreenMode$_();
                        "letterbox-scale" === i ? this._$_CalculateLetterboxScale$_(t, e) : "letterbox-integer-scale" === i ? this._$_CalculateLetterboxIntegerScale$_(t, e) : "off" === i ? this._$_CalculateFixedSizeCanvas$_(t, e) : this._$_CalculateFullsizeCanvas$_(t, e), 
                        this._$_UpdateFullscreenScalingQuality$_(i);
                        for (const {
                            canvas: h
                        } of this._$_canvasLayers$_) h.width = this._$_canvasDeviceWidth$_, 
                        h.height = this._$_canvasDeviceHeight$_;
                        this._$_runtime$_._$PostComponentMessageToDOM$_("canvas", "update-size", {
                            marginLeft: this._$_canvasCssOffsetX$_,
                            marginTop: this._$_canvasCssOffsetY$_,
                            styleWidth: this._$_canvasCssWidth$_,
                            styleHeight: this._$_canvasCssHeight$_,
                            displayScale: this._$GetDisplayScale$_()
                        });
                        const r = this._$GetRenderer$_();
                        r._$SetSize$_(this._$_canvasDeviceWidth$_, this._$_canvasDeviceHeight$_, !0);
                        for (const o of this._$_availableAdditionalRenderTargets$_) r._$DeleteRenderTarget$_(o);
                        C33._$clearArray$_(this._$_availableAdditionalRenderTargets$_), 
                        this._$UpdateDefaultProjectionMatrix$_();
                        const n = this._$_runtime$_._$GetLayoutManager$_();
                        n._$SetAllLayerProjectionChanged$_(), n._$SetAllLayerMVChanged$_();
                    }
                }
                _$UpdateDefaultProjectionMatrix$_() {
                    this._$GetRenderer$_()._$CalculatePerspectiveMatrix$_(this._$_defaultProjectionMatrix$_, this._$GetDrawWidth$_() / this._$GetDrawHeight$_());
                }
                _$GetDefaultProjectionMatrix$_() {
                    return this._$_defaultProjectionMatrix$_;
                }
                _$_CalculateLetterboxScale$_(t, e) {
                    const s = this._$_runtime$_._$GetDevicePixelRatio$_(), i = this._$_runtime$_._$GetOriginalViewportWidth$_(), r = this._$_runtime$_._$GetOriginalViewportHeight$_(), n = i / r, h = t / e;
                    if (n < h) {
                        const o = e * n;
                        this._$_canvasCssWidth$_ = Math.round(o), this._$_canvasCssHeight$_ = e, 
                        this._$_canvasCssOffsetX$_ = Math.floor((t - this._$_canvasCssWidth$_) / 2), 
                        this._$_canvasCssOffsetY$_ = 0;
                    } else {
                        const a = t / n;
                        this._$_canvasCssWidth$_ = t, this._$_canvasCssHeight$_ = Math.round(a), 
                        this._$_canvasCssOffsetX$_ = 0, this._$_canvasCssOffsetY$_ = Math.floor((e - this._$_canvasCssHeight$_) / 2);
                    }
                    this._$_canvasDeviceWidth$_ = Math.round(this._$_canvasCssWidth$_ * s), 
                    this._$_canvasDeviceHeight$_ = Math.round(this._$_canvasCssHeight$_ * s), 
                    this._$_runtime$_._$SetViewportSize$_(i, r);
                }
                _$_CalculateLetterboxIntegerScale$_(t, e) {
                    let s = this._$_runtime$_._$GetDevicePixelRatio$_(), i = (1 !== s && (t += 1, 
                    e += 1), this._$_runtime$_._$GetOriginalViewportWidth$_()), r = this._$_runtime$_._$GetOriginalViewportHeight$_(), n = i / r, h = t / e, o;
                    if (n < h) {
                        const a = e * n;
                        o = a * s / i;
                    } else {
                        const l = t / n;
                        o = l * s / r;
                    }
                    1 < o ? o = Math.floor(o) : o < 1 && (o = 1 / Math.ceil(1 / o)), 
                    this._$_canvasDeviceWidth$_ = Math.round(i * o), this._$_canvasDeviceHeight$_ = Math.round(r * o), 
                    this._$_canvasCssWidth$_ = this._$_canvasDeviceWidth$_ / s, 
                    this._$_canvasCssHeight$_ = this._$_canvasDeviceHeight$_ / s, 
                    this._$_canvasCssOffsetX$_ = Math.max(Math.floor((t - this._$_canvasCssWidth$_) / 2), 0), 
                    this._$_canvasCssOffsetY$_ = Math.max(Math.floor((e - this._$_canvasCssHeight$_) / 2), 0), 
                    this._$_runtime$_._$SetViewportSize$_(i, r);
                }
                _$_CalculateFullsizeCanvas$_(t, e) {
                    const s = this._$_runtime$_._$GetDevicePixelRatio$_(), i = (this._$_canvasCssWidth$_ = t, 
                    this._$_canvasCssHeight$_ = e, this._$_canvasDeviceWidth$_ = Math.round(this._$_canvasCssWidth$_ * s), 
                    this._$_canvasDeviceHeight$_ = Math.round(this._$_canvasCssHeight$_ * s), 
                    this._$_canvasCssOffsetX$_ = 0, this._$_canvasCssOffsetY$_ = 0, 
                    this._$GetDisplayScale$_());
                    this._$_runtime$_._$SetViewportSize$_(this._$_canvasCssWidth$_ / i, this._$_canvasCssHeight$_ / i);
                }
                _$_CalculateFixedSizeCanvas$_(t, e) {
                    const s = this._$_runtime$_._$GetDevicePixelRatio$_();
                    this._$_canvasCssWidth$_ = this._$_runtime$_._$GetViewportWidth$_(), 
                    this._$_canvasCssHeight$_ = this._$_runtime$_._$GetViewportHeight$_(), 
                    this._$_canvasDeviceWidth$_ = Math.round(this._$_canvasCssWidth$_ * s), 
                    this._$_canvasDeviceHeight$_ = Math.round(this._$_canvasCssHeight$_ * s), 
                    this._$IsDocumentFullscreen$_() ? (this._$_canvasCssOffsetX$_ = Math.floor((t - this._$_canvasCssWidth$_) / 2), 
                    this._$_canvasCssOffsetY$_ = Math.floor((e - this._$_canvasCssHeight$_) / 2)) : (this._$_canvasCssOffsetX$_ = 0, 
                    this._$_canvasCssOffsetY$_ = 0), this._$_runtime$_._$SetViewportSize$_(this._$_runtime$_._$GetViewportWidth$_(), this._$_runtime$_._$GetViewportHeight$_());
                }
                _$_UpdateFullscreenScalingQuality$_(s) {
                    if ("high" === this._$_wantFullscreenScalingQuality$_) this._$_drawWidth$_ = this._$_canvasDeviceWidth$_, 
                    this._$_drawHeight$_ = this._$_canvasDeviceHeight$_, this._$_fullscreenScalingQuality$_ = "high"; else {
                        let t, e;
                        if (e = "off" === this._$GetCurrentFullscreenMode$_() ? (t = this._$_runtime$_._$GetViewportWidth$_(), 
                        this._$_runtime$_._$GetViewportHeight$_()) : (t = this._$_runtime$_._$GetOriginalViewportWidth$_(), 
                        this._$_runtime$_._$GetOriginalViewportHeight$_()), this._$_canvasDeviceWidth$_ < t || this._$_canvasDeviceHeight$_ < e) this._$_drawWidth$_ = this._$_canvasDeviceWidth$_, 
                        this._$_drawHeight$_ = this._$_canvasDeviceHeight$_, this._$_fullscreenScalingQuality$_ = "high"; else if (this._$_drawWidth$_ = t, 
                        this._$_drawHeight$_ = e, this._$_fullscreenScalingQuality$_ = "low", 
                        "scale-inner" === s) {
                            const i = t / e, r = this._$_windowInnerWidth$_ / this._$_windowInnerHeight$_;
                            r < i ? this._$_drawWidth$_ = this._$_drawHeight$_ * r : i < r && (this._$_drawHeight$_ = this._$_drawWidth$_ / r);
                        } else if ("scale-outer" === s) {
                            const n = t / e, h = this._$_windowInnerWidth$_ / this._$_windowInnerHeight$_;
                            n < h ? this._$_drawWidth$_ = this._$_drawHeight$_ * h : h < n && (this._$_drawHeight$_ = this._$_drawWidth$_ / h);
                        }
                    }
                }
                _$GetRuntime$_() {
                    return this._$_runtime$_;
                }
                _$GetMainCanvas$_() {
                    return this._$_canvasLayers$_[0].canvas;
                }
                _$GetEffectChainManager$_() {
                    return this._$_effectChainManager$_;
                }
                _$IsDocumentFullscreen$_() {
                    return this._$_isDocumentFullscreen$_;
                }
                _$GetCssDisplayMode$_() {
                    return this._$_cssDisplayMode$_;
                }
                _$SetFullscreenMode$_(t) {
                    if (!VALID_FULLSCREEN_MODES.has(t)) throw new Error("invalid fullscreen mode");
                    this._$_fullscreenMode$_ = t;
                    const e = this._$_runtime$_._$GetLayoutManager$_();
                    e._$SetAllLayerProjectionChanged$_(), e._$SetAllLayerMVChanged$_();
                }
                _$GetFullscreenMode$_() {
                    return this._$_fullscreenMode$_;
                }
                _$SetDocumentFullscreenMode$_(t) {
                    if (!VALID_FULLSCREEN_MODES.has(t)) throw new Error("invalid fullscreen mode");
                    this._$_documentFullscreenMode$_ = t;
                    const e = this._$_runtime$_._$GetLayoutManager$_();
                    e._$SetAllLayerProjectionChanged$_(), e._$SetAllLayerMVChanged$_();
                }
                _$GetDocumentFullscreenMode$_() {
                    return this._$_documentFullscreenMode$_;
                }
                _$GetCurrentFullscreenMode$_() {
                    return this._$IsDocumentFullscreen$_() ? this._$GetDocumentFullscreenMode$_() : this._$GetFullscreenMode$_();
                }
                _$SetFullscreenScalingQuality$_(t) {
                    if (!VALID_FULLSCREEN_SCALING_QUALITIES.has(t)) throw new Error("invalid fullscreen scaling quality");
                    this._$_wantFullscreenScalingQuality$_ = t, this._$_runtime$_._$GetLayoutManager$_()._$SetAllLayerProjectionChanged$_();
                }
                _$GetSetFullscreenScalingQuality$_() {
                    return this._$_wantFullscreenScalingQuality$_;
                }
                _$GetCurrentFullscreenScalingQuality$_() {
                    return this._$_fullscreenScalingQuality$_;
                }
                static _$_FullscreenModeNumberToString$_(t) {
                    switch (t) {
                      case 0:
                        return "off";

                      case 1:
                        return "crop";

                      case 2:
                        return "scale-inner";

                      case 3:
                        return "scale-outer";

                      case 4:
                        return "letterbox-scale";

                      case 5:
                        return "letterbox-integer-scale";

                      default:
                        throw new Error("invalid fullscreen mode");
                    }
                }
                _$GetLastWidth$_() {
                    return this._$_windowInnerWidth$_;
                }
                _$GetLastHeight$_() {
                    return this._$_windowInnerHeight$_;
                }
                _$GetDrawWidth$_() {
                    return this._$_drawWidth$_;
                }
                _$GetDrawHeight$_() {
                    return this._$_drawHeight$_;
                }
                _$SetMipmapsEnabled$_(t) {
                    this._$_enableMipmaps$_ = !!t;
                }
                _$_SetTextureAnisotropy$_(t) {
                    this._$_textureAnisotropy$_ = t;
                }
                _$GetTextureAnisotropy$_() {
                    return this._$_textureAnisotropy$_;
                }
                _$IsRendererContextLost$_() {
                    return this._$GetRenderer$_()._$IsContextLost$_();
                }
                _$_OnWebGLContextLost$_(t) {
                    console.log("[Construct] WebGL context lost"), t.preventDefault(), 
                    this._$_availableAdditionalRenderTargets$_ = [], this._$_usedAdditionalRenderTargets$_.clear(), 
                    this._$_effectChainManager$_._$OnContextLost$_(), this._$_webglRenderer$_._$OnContextLost$_(), 
                    this._$_runtime$_._$_OnRendererContextLost$_();
                }
                _$_OnWebGPUDeviceLost$_() {
                    console.log("[Construct] WebGPU device lost"), this._$_availableAdditionalRenderTargets$_ = [], 
                    this._$_usedAdditionalRenderTargets$_.clear(), this._$_effectChainManager$_._$OnContextLost$_(), 
                    this._$_runtime$_._$_OnRendererContextLost$_();
                }
                async _$_OnWebGLContextRestored$_(t) {
                    await this._$_webglRenderer$_._$OnContextRestored$_(), await this._$_InitRenderer$_(), 
                    await this._$_runtime$_._$_OnRendererContextRestored$_(), console.log("[Construct] WebGL context restored");
                }
                async _$_OnWebGPUDeviceRestored$_() {
                    await this._$_InitRenderer$_(), await this._$_runtime$_._$_OnRendererContextRestored$_(), 
                    console.log("[Construct] WebGPU device restored");
                }
                _$GetWebGLRenderer$_() {
                    return this._$_webglRenderer$_;
                }
                _$GetWebGPURenderer$_() {
                    return this._$_webgpuRenderer$_;
                }
                _$GetRenderer$_() {
                    return this._$_webgpuRenderer$_ || this._$_webglRenderer$_;
                }
                _$GetIRenderer$_() {
                    return this._$_iRenderer$_;
                }
                _$GetRendererString$_() {
                    let t = "";
                    return t = this._$_runtime$_._$GetWebGPURenderer$_() ? "webgpu" : "webgl" + this._$_runtime$_._$GetWebGLRenderer$_()._$GetWebGLVersionNumber$_(), 
                    this._$_runtime$_._$GetRenderer$_()._$HasMajorPerformanceCaveat$_() && (t += "-software"), 
                    t;
                }
                _$GetRendererDetailString$_() {
                    return this._$_runtime$_._$GetWebGPURenderer$_() ? this._$_runtime$_._$GetWebGPURenderer$_()._$GetAdapterInfoString$_() : this._$_runtime$_._$GetWebGLRenderer$_()._$GetUnmaskedRenderer$_();
                }
                _$GetRenderScale$_() {
                    return "low" === this._$_fullscreenScalingQuality$_ ? 1 / this._$_runtime$_._$GetDevicePixelRatio$_() : this._$GetDisplayScale$_();
                }
                _$GetDisplayScale$_() {
                    const t = this._$GetCurrentFullscreenMode$_();
                    if ("off" === t || "crop" === t) return 1;
                    const e = this._$_runtime$_._$GetOriginalViewportWidth$_(), s = this._$_runtime$_._$GetOriginalViewportHeight$_(), i = e / s, r = this._$_canvasDeviceWidth$_ / this._$_canvasDeviceHeight$_;
                    return "scale-inner" !== t && i < r || "scale-inner" === t && r < i ? this._$_canvasCssHeight$_ / s : this._$_canvasCssWidth$_ / e;
                }
                _$GetEffectLayerScaleParam$_() {
                    return "low" === this._$GetCurrentFullscreenScalingQuality$_() ? 1 : this._$GetDisplayScale$_();
                }
                _$GetEffectDevicePixelRatioParam$_() {
                    return "low" === this._$GetCurrentFullscreenScalingQuality$_() ? 1 : this._$_runtime$_._$GetDevicePixelRatio$_();
                }
                _$SetDeviceTransformOffset$_(t, e) {
                    this._$_deviceTransformOffX$_ = t, this._$_deviceTransformOffY$_ = e;
                }
                _$SetDeviceTransform$_(e, s, i, t = !0) {
                    s = s || this._$_drawWidth$_, i = i || this._$_drawHeight$_;
                    const r = s / 2 + this._$_deviceTransformOffX$_, n = i / 2 + this._$_deviceTransformOffY$_;
                    if (t) {
                        let t = this._$GetDefaultProjectionMatrix$_();
                        s === this._$_drawWidth$_ && i === this._$_drawHeight$_ || (e._$CalculatePerspectiveMatrix$_(tempProjection, s / i), 
                        t = tempProjection), e._$SetProjectionMatrix$_(t);
                    }
                    const h = e._$CalculateLookAtModelView2$_(r, n, e._$GetDefaultCameraZ$_(i), r, n, 0, i);
                    e._$SetModelViewMatrix$_(h);
                }
                _$SetCssTransform$_(t, e = !0) {
                    const s = this._$GetCssWidth$_(), i = this._$GetCssHeight$_(), r = s / 2, n = i / 2, h = (e && t._$SetProjectionMatrix$_(this._$GetDefaultProjectionMatrix$_()), 
                    t._$CalculateLookAtModelView2$_(r, n, t._$GetDefaultCameraZ$_(i), r, n, 0, i));
                    t._$SetModelViewMatrix$_(h);
                }
                _$GetDeviceWidth$_() {
                    return this._$_canvasDeviceWidth$_;
                }
                _$GetDeviceHeight$_() {
                    return this._$_canvasDeviceHeight$_;
                }
                _$GetCssWidth$_() {
                    return this._$_canvasCssWidth$_;
                }
                _$GetCssHeight$_() {
                    return this._$_canvasCssHeight$_;
                }
                _$GetCanvasClientX$_() {
                    return this._$_canvasCssOffsetX$_;
                }
                _$GetCanvasClientY$_() {
                    return this._$_canvasCssOffsetY$_;
                }
                _$GetHTMLLayerCount$_() {
                    return this._$_canvasLayers$_.length;
                }
                _$_CanUseImageBitmapRenderingContext$_() {
                    return "undefined" != typeof OffscreenCanvas && this._$GetMainCanvas$_() instanceof OffscreenCanvas && ("Chromium" !== C33._$Platform$_._$BrowserEngine$_ || 124 <= C33._$Platform$_._$BrowserVersionNumber$_);
                }
                async _$SetHTMLLayerCount$_(i, r = !1) {
                    if (i < 1) throw new Error("invalid HTML layer count");
                    if (this._$_canvasLayers$_.length !== i) {
                        let t = this._$_runtime$_._$GetLayoutManager$_()._$GetMainRunningLayout$_(), e = {
                            count: i,
                            layersDomState: t._$_GetRootLayers$_().filter(t => t._$IsHTMLElementsLayer$_()).map(t => t._$_GetHTMLLayerDOMState$_()),
                            immediate: r,
                            marginLeft: this._$_canvasCssOffsetX$_,
                            marginTop: this._$_canvasCssOffsetY$_,
                            styleWidth: this._$_canvasCssWidth$_,
                            styleHeight: this._$_canvasCssHeight$_
                        }, s;
                        if (s = this._$IsInWorker$_() ? await this._$_runtime$_._$PostComponentMessageToDOMAsync$_("canvas", "set-html-layer-count", e) : self.c3_runtimeInterface._OnSetHTMLLayerCount(e), 
                        i < this._$_canvasLayers$_.length) this._$_canvasLayers$_.length = i; else for (const n of s.addedCanvases) {
                            n.width = this._$_canvasDeviceWidth$_, n.height = this._$_canvasDeviceHeight$_;
                            const h = this._$_CanUseImageBitmapRenderingContext$_() ? "bitmaprenderer" : "2d", o = n.getContext(h);
                            if (!o) throw new Error(`failed to acquire '${h}' canvas context`);
                            this._$_canvasLayers$_.push({
                                canvas: n,
                                _$ctx$_: o
                            });
                        }
                        this._$_runtime$_._$UpdateRender$_();
                    }
                }
                _$BlitMainCanvasToHTMLLayerCanvas$_(t) {
                    if (!(t >= this._$_canvasLayers$_.length)) {
                        const e = this._$GetMainCanvas$_(), s = this._$_canvasLayers$_[t]._$ctx$_;
                        this._$_CanUseImageBitmapRenderingContext$_() ? s.transferFromImageBitmap(e.transferToImageBitmap()) : (s.globalCompositeOperation = "copy", 
                        s.drawImage(e, 0, 0));
                    }
                }
                _$GetAdditionalRenderTarget$_(e) {
                    e.depth = this._$_runtime$_._$Uses3DFeatures$_();
                    let t = this._$_availableAdditionalRenderTargets$_, s = t.findIndex(t => t._$IsCompatibleWithOptions$_(e)), i;
                    return -1 !== s ? (i = t[s], t.splice(s, 1)) : i = this._$GetRenderer$_()._$CreateRenderTarget$_(e), 
                    this._$_usedAdditionalRenderTargets$_.add(i), i;
                }
                _$ReleaseAdditionalRenderTarget$_(t) {
                    if (!this._$_usedAdditionalRenderTargets$_.has(t)) throw new Error("render target not in use");
                    this._$_usedAdditionalRenderTargets$_.delete(t), this._$_availableAdditionalRenderTargets$_.push(t);
                }
                _$GetEffectCompositorRenderTarget$_() {
                    const t = {
                        _$sampling$_: this._$_runtime$_._$GetSampling$_()
                    };
                    return "low" === this._$GetCurrentFullscreenScalingQuality$_() && (t.width = this._$GetDrawWidth$_(), 
                    t.height = this._$GetDrawHeight$_()), this._$GetAdditionalRenderTarget$_(t);
                }
                _$ReleaseEffectCompositorRenderTarget$_(t) {
                    this._$ReleaseAdditionalRenderTarget$_(t);
                }
                *_$activeLayersGpuProfiles$_() {
                    for (const t of this._$_runtime$_._$GetLayoutManager$_()._$runningLayouts$_()) for (const e of t._$GetLayers$_()) {
                        const s = this._$_layersGpuProfile$_.get(e);
                        s && (yield s);
                    }
                }
                _$GetLayerTimingsBuffer$_(t) {
                    if (!this._$GetRenderer$_()._$SupportsGPUProfiling$_()) return null;
                    let e = this._$_layersGpuProfile$_.get(t);
                    return e || (e = {
                        _$layer$_: t,
                        name: t._$GetName$_(),
                        _$timingsBuffer$_: C33._$New$_(C33._$Gfx$_._$WebGLQueryResultBuffer$_, this._$_webglRenderer$_),
                        _$curUtilisation$_: 0,
                        _$lastTotalUtilisation$_: 0,
                        _$lastSelfUtilisation$_: 0
                    }, this._$_layersGpuProfile$_.set(t, e)), e._$timingsBuffer$_;
                }
                _$_Update1sFrameRange$_() {
                    const t = this._$GetRenderer$_();
                    if (t._$SupportsGPUProfiling$_() && 0 === this._$_gpuTimeEndFrame$_) {
                        this._$_gpuTimeEndFrame$_ = t._$GetFrameNumber$_(), this._$_gpuCurUtilisation$_ = NaN;
                        for (const e of this._$activeLayersGpuProfiles$_()) e._$curUtilisation$_ = NaN;
                    }
                }
                _$_UpdateTick$_() {
                    this._$_webglRenderer$_ && this._$_webglRenderer$_._$SupportsGPUProfiling$_() && this._$_UpdateTick_WebGL$_(), 
                    this._$_webgpuRenderer$_ && this._$_webgpuRenderer$_._$SupportsGPUProfiling$_() && this._$_UpdateTick_WebGPU$_();
                }
                _$_UpdateTick_WebGL$_() {
                    if (isNaN(this._$_gpuCurUtilisation$_) && (this._$_gpuCurUtilisation$_ = this._$_gpuFrameTimingsBuffer$_._$GetFrameRangeResultSum$_(this._$_gpuTimeStartFrame$_, this._$_gpuTimeEndFrame$_), 
                    !isNaN(this._$_gpuCurUtilisation$_))) {
                        if (this._$_runtime$_._$IsDebug$_()) for (const t of this._$activeLayersGpuProfiles$_()) if (t._$curUtilisation$_ = t._$timingsBuffer$_._$GetFrameRangeResultSum$_(this._$_gpuTimeStartFrame$_, this._$_gpuTimeEndFrame$_), 
                        isNaN(t._$curUtilisation$_)) return;
                        if (this._$_gpuFrameTimingsBuffer$_._$DeleteAllBeforeFrameNumber$_(this._$_gpuTimeEndFrame$_), 
                        this._$_gpuLastUtilisation$_ = Math.min(this._$_gpuCurUtilisation$_, 1), 
                        this._$_runtime$_._$IsDebug$_()) {
                            const s = new Map();
                            for (const r of this._$activeLayersGpuProfiles$_()) r._$timingsBuffer$_._$DeleteAllBeforeFrameNumber$_(this._$_gpuTimeEndFrame$_), 
                            r._$lastTotalUtilisation$_ = Math.min(r._$curUtilisation$_, 1), 
                            s.set(r._$layer$_, r._$lastTotalUtilisation$_);
                            for (const n of this._$activeLayersGpuProfiles$_()) {
                                const h = n._$layer$_, o = s.get(h) || 0, a = o - h._$GetSubLayers$_().reduce((t, e) => t + (s.get(e) || 0), 0);
                                n._$lastSelfUtilisation$_ = C33._$clamp$_(a, 0, 1);
                            }
                            const e = this._$_runtime$_._$GetMainRunningLayout$_(), i = this._$_gpuLastUtilisation$_ - e._$_GetRootLayers$_().reduce((t, e) => t + (s.get(e) || 0), 0);
                            self.C3Debugger.UpdateGPUProfile(C33._$clamp$_(i, 0, 1), this._$_gpuLastUtilisation$_, [ ...this._$activeLayersGpuProfiles$_() ]);
                        }
                        this._$_gpuTimeStartFrame$_ = this._$_gpuTimeEndFrame$_, 
                        this._$_gpuTimeEndFrame$_ = 0;
                    }
                }
                _$GetGPUFrameTimingsBuffer$_() {
                    return this._$_gpuFrameTimingsBuffer$_;
                }
                _$_UpdateTick_WebGPU$_() {
                    if (0 !== this._$_gpuTimeEndFrame$_) {
                        for (let t = this._$_gpuTimeStartFrame$_; t < this._$_gpuTimeEndFrame$_; ++t) {
                            const s = this._$_webgpuFrameTimings$_.get(t);
                            if (s && !s._$HasResult$_()) return;
                        }
                        let t = this._$_runtime$_._$GetMainRunningLayout$_(), h = C33._$MakeFilledArray$_(t._$GetLayerCount$_() + 1, 0), e = 0;
                        for (let t = this._$_gpuTimeStartFrame$_; t < this._$_gpuTimeEndFrame$_; ++t) {
                            const o = this._$_webgpuFrameTimings$_.get(t);
                            if (o) {
                                let s = o._$GetResult$_(), i = BigInt(0), r = BigInt(0), n = BigInt(0);
                                for (let t = 0, e = Math.min(h.length, s.length / 2); t < e; ++t) {
                                    const u = s[2 * t], c = s[2 * t + 1], f = (u !== n && (i === n || u < i) && (i = u), 
                                    c > r && (r = c), c - u), d = Number(f) / 1e9;
                                    h[t] += d;
                                }
                                const a = r - i, l = Number(a) / 1e9;
                                e += l;
                            }
                        }
                        if (this._$_gpuLastUtilisation$_ = C33._$clamp$_(e, 0, 1), 
                        this._$_runtime$_._$IsDebug$_()) {
                            const i = t._$GetLayers$_(), r = new Map();
                            for (let t = 0, e = Math.min(i.length, h.length - 1); t < e; ++t) {
                                const C = h[t + 1];
                                r.set(i[t], C);
                            }
                            const n = [], p = new Map();
                            for (const [ g, S ] of r) {
                                const _ = [ ...g._$selfAndAllSubLayers$_() ].reduce((t, e) => t + (r.get(e) || 0), 0);
                                p.set(g, _), n.push({
                                    name: g._$GetName$_(),
                                    _$lastSelfUtilisation$_: C33._$clamp$_(S, 0, 1),
                                    _$lastTotalUtilisation$_: C33._$clamp$_(_, 0, 1)
                                });
                            }
                            const m = this._$_gpuLastUtilisation$_ - t._$_GetRootLayers$_().reduce((t, e) => t + (p.get(e) || 0), 0);
                            self.C3Debugger.UpdateGPUProfile(C33._$clamp$_(m, 0, 1), this._$_gpuLastUtilisation$_, n);
                        }
                        for (let t = this._$_gpuTimeStartFrame$_; t < this._$_gpuTimeEndFrame$_; ++t) this._$_webgpuFrameTimings$_.delete(t);
                        this._$_gpuTimeStartFrame$_ = this._$_gpuTimeEndFrame$_, 
                        this._$_gpuTimeEndFrame$_ = 0;
                    }
                }
                _$_AddWebGPUFrameTiming$_(t) {
                    this._$_webgpuFrameTimings$_.set(this._$_webgpuRenderer$_._$GetFrameNumber$_(), t);
                }
                _$GetGPUUtilisation$_() {
                    return this._$_gpuLastUtilisation$_;
                }
                _$SnapshotCanvas$_(t, e, s, i, r, n) {
                    return this._$_snapshotFormat$_ = t, this._$_snapshotQuality$_ = e, 
                    this._$_snapshotArea$_._$setWH$_(s, i, r, n), this._$_snapshotPromise$_ || (this._$_snapshotPromise$_ = new Promise(t => {
                        this._$_snapshotResolve$_ = t;
                    })), this._$_snapshotPromise$_;
                }
                _$_MaybeTakeSnapshot$_() {
                    if (this._$_snapshotFormat$_) {
                        let t = this._$GetMainCanvas$_(), e = this._$_snapshotArea$_, s = C33._$clamp$_(Math.floor(e._$getLeft$_()), 0, t.width), i = C33._$clamp$_(Math.floor(e._$getTop$_()), 0, t.height), r = e.width(), n = (r = 0 === r ? t.width - s : C33._$clamp$_(Math.floor(r), 0, t.width - s), 
                        e.height());
                        if (n = 0 === n ? t.height - i : C33._$clamp$_(Math.floor(n), 0, t.height - i), 
                        (0 !== s || 0 !== i || r !== t.width || n !== t.height) && 0 < r && 0 < n) {
                            const h = C33._$CreateCanvas$_(r, n), o = h.getContext("2d");
                            o.drawImage(t, s, i, r, n, 0, 0, r, n), t = h;
                        }
                        C33._$CanvasToBlob$_(t, this._$_snapshotFormat$_, this._$_snapshotQuality$_).then(t => {
                            this._$_snapshotUrl$_ && URL.revokeObjectURL(this._$_snapshotUrl$_), 
                            this._$_snapshotUrl$_ = URL.createObjectURL(t), this._$_snapshotPromise$_ = null, 
                            this._$_snapshotResolve$_(this._$_snapshotUrl$_);
                        }), this._$_snapshotFormat$_ = "", this._$_snapshotQuality$_ = 1;
                    }
                }
                _$GetCanvasSnapshotUrl$_() {
                    return this._$_snapshotUrl$_;
                }
                _$SetIsPastingToDrawingCanvas$_(t) {
                    t ? this._$_isPastingToDrawingCanvas$_++ : this._$_isPastingToDrawingCanvas$_--;
                }
                _$IsPastingToDrawingCanvas$_() {
                    return 0 < this._$_isPastingToDrawingCanvas$_;
                }
                _$InitLoadingScreen$_(t) {
                    const e = this._$GetRenderer$_();
                    if (2 === t) this._$_percentText$_ = C33._$New$_(C33._$Gfx$_._$RendererText$_, this._$GetRenderer$_()), 
                    this._$_percentText$_._$SetFontName$_("Arial"), this._$_percentText$_._$SetFontSize$_(16), 
                    this._$_percentText$_._$SetHorizontalAlignment$_("center"), 
                    this._$_percentText$_._$SetVerticalAlignment$_("center"), this._$_percentText$_._$SetSize$_(PERCENTTEXT_WIDTH, PERCENTTEXT_HEIGHT); else if (0 === t) {
                        const s = this._$_runtime$_._$GetLoadingLogoAsset$_();
                        s && s._$LoadStaticTexture$_(e).catch(t => console.warn("[C3 runtime] Failed to create texture for loading logo: ", t));
                    } else 4 === t && (this._$_LoadSvgSplashImage$_("splash-images/splash-logo.svg").then(t => {
                        "done" === this._$_splashState$_ ? e._$DeleteTexture$_(t) : this._$_splashTextures$_._$logo$_ = t;
                    }).catch(t => console.warn("Failed to load splash image: ", t)), 
                    this._$_LoadBitmapSplashImage$_("splash-images/splash-poweredby-512.png").then(t => {
                        "done" === this._$_splashState$_ ? e._$DeleteTexture$_(t) : this._$_splashTextures$_._$powered$_ = t;
                    }).catch(t => console.warn("Failed to load splash image: ", t)), 
                    this._$_LoadBitmapSplashImage$_("splash-images/splash-website-512.png").then(t => {
                        "done" === this._$_splashState$_ ? e._$DeleteTexture$_(t) : this._$_splashTextures$_._$website$_ = t;
                    }).catch(t => console.warn("Failed to load splash image: ", t)));
                }
                async _$_LoadSvgSplashImage$_(t) {
                    t = new URL(t, this._$_runtime$_._$GetRuntimeBaseURL$_()).toString();
                    const e = await C33._$FetchBlob$_(t), s = await this._$_runtime$_._$RasterSvgImage$_(e, 2048, 2048);
                    return this._$GetRenderer$_()._$CreateStaticTextureAsync$_(s, {
                        _$mipMapQuality$_: "high"
                    });
                }
                async _$_LoadBitmapSplashImage$_(t) {
                    t = new URL(t, this._$_runtime$_._$GetRuntimeBaseURL$_()).toString();
                    const e = await C33._$FetchBlob$_(t);
                    return this._$GetRenderer$_()._$CreateStaticTextureAsync$_(e, {
                        _$mipMapQuality$_: "high"
                    });
                }
                _$HideCordovaSplashScreen$_() {
                    this._$_runtime$_._$PostComponentMessageToDOM$_("runtime", "hide-cordova-splash");
                }
                _$StartLoadingScreen$_() {
                    this._$_loaderStartTime$_ = Date.now(), this._$_runtime$_._$Dispatcher$_().addEventListener("loadingprogress", this._$_loadingprogress_handler$_), 
                    this._$_rafId$_ = requestAnimationFrame(() => this._$_DrawLoadingScreen$_());
                    const t = this._$_runtime$_._$GetLoaderStyle$_();
                    3 !== t && this._$HideCordovaSplashScreen$_();
                }
                async _$EndLoadingScreen$_() {
                    const t = this._$GetRenderer$_(), e = (this._$_loadingProgress$_ = 1, 
                    this._$_runtime$_._$GetLoaderStyle$_());
                    4 === e && await this._$_splashDonePromise$_, this._$_splashDoneResolve$_ = null, 
                    this._$_splashDonePromise$_ = null, -1 !== this._$_rafId$_ && (cancelAnimationFrame(this._$_rafId$_), 
                    this._$_rafId$_ = -1), this._$_runtime$_._$Dispatcher$_().removeEventListener("loadingprogress", this._$_loadingprogress_handler$_), 
                    this._$_loadingprogress_handler$_ = null, this._$_percentText$_ && (this._$_percentText$_._$Release$_(), 
                    this._$_percentText$_ = null), this._$_runtime$_._$ReleaseLoadingLogoAsset$_(), 
                    t._$Start$_(), this._$_splashTextures$_._$logo$_ && (t._$DeleteTexture$_(this._$_splashTextures$_._$logo$_), 
                    this._$_splashTextures$_._$logo$_ = null), this._$_splashTextures$_._$powered$_ && (t._$DeleteTexture$_(this._$_splashTextures$_._$powered$_), 
                    this._$_splashTextures$_._$powered$_ = null), this._$_splashTextures$_._$website$_ && (t._$DeleteTexture$_(this._$_splashTextures$_._$website$_), 
                    this._$_splashTextures$_._$website$_ = null), t._$ClearRgba$_(0, 0, 0, 0), 
                    t._$Finish$_(), this._$_splashState$_ = "done", this._$_gpuTimeStartFrame$_ = t._$GetFrameNumber$_(), 
                    3 === e && this._$HideCordovaSplashScreen$_();
                }
                _$_DrawLoadingScreen$_() {
                    if (-1 !== this._$_rafId$_) {
                        const t = this._$GetRenderer$_(), e = (t._$Start$_(), this._$_rafId$_ = -1, 
                        this._$_runtime$_._$GetAssetManager$_()._$HasHadErrorLoading$_()), s = this._$_runtime$_._$GetLoaderStyle$_();
                        if (3 !== s && (this._$SetCssTransform$_(t), t._$ClearRgba$_(0, 0, 0, 0), 
                        t._$ResetColor$_(), t._$SetTextureFillMode$_(), t._$SetTexture$_(null)), 
                        0 === s) this._$_DrawProgressBarAndLogoLoadingScreen$_(e); else if (1 === s) this._$_DrawProgressBarLoadingScreen$_(e, PROGRESSBAR_WIDTH, 0); else if (2 === s) this._$_DrawPercentTextLoadingScreen$_(e); else if (3 === s) C33._$noop$_(); else {
                            if (4 !== s) throw new Error("invalid loader style");
                            this._$_DrawSplashLoadingScreen$_(e);
                        }
                        t._$Finish$_(), this._$_rafId$_ = requestAnimationFrame(() => this._$_DrawLoadingScreen$_());
                    }
                }
                _$_DrawPercentTextLoadingScreen$_(t) {
                    t ? this._$_percentText$_._$SetColorRgb$_(1, 0, 0) : this._$_percentText$_._$SetColorRgb$_(.6, .6, .6), 
                    this._$_percentText$_._$SetText$_(Math.round(100 * this._$_loadingProgress$_) + "%");
                    const e = this._$_canvasCssWidth$_ / 2, s = this._$_canvasCssHeight$_ / 2, i = PERCENTTEXT_WIDTH / 2, r = PERCENTTEXT_HEIGHT / 2, n = (tempQuad._$setRect$_(e - i, s - r, e + i, s + r), 
                    this._$GetRenderer$_());
                    n._$SetTexture$_(this._$_percentText$_._$GetTexture$_()), n._$Quad3$_(tempQuad, this._$_percentText$_._$GetTexRect$_());
                }
                _$_DrawProgressBarLoadingScreen$_(t, e, s) {
                    const i = this._$GetRenderer$_(), r = PROGRESSBAR_HEIGHT, n = (i._$SetColorFillMode$_(), 
                    t ? i._$SetColorRgba$_(1, 0, 0, 1) : i._$SetColorRgba$_(.118, .565, 1, 1), 
                    this._$_canvasCssWidth$_ / 2), h = this._$_canvasCssHeight$_ / 2, o = e / 2, a = r / 2;
                    tempRect._$setWH$_(n - o, h - a + s, Math.floor(e * this._$_loadingProgress$_), r), 
                    i.Rect(tempRect), tempRect._$setWH$_(n - o, h - a + s, e, r), 
                    tempRect.offset(-.5, -.5), tempRect._$inflate$_(.5, .5), i._$SetColorRgba$_(0, 0, 0, 1), 
                    i._$LineRect2$_(tempRect), tempRect._$inflate$_(1, 1), i._$SetColorRgba$_(1, 1, 1, 1), 
                    i._$LineRect2$_(tempRect);
                }
                _$_DrawProgressBarAndLogoLoadingScreen$_(t) {
                    const e = this._$GetRenderer$_(), s = this._$_runtime$_._$GetLoadingLogoAsset$_();
                    if (s) {
                        const i = s._$GetTexture$_();
                        if (i) {
                            const r = i._$GetWidth$_(), n = i._$GetHeight$_(), h = this._$_canvasCssWidth$_ / 2, o = this._$_canvasCssHeight$_ / 2, a = r / 2, l = n / 2;
                            tempQuad._$setRect$_(h - a, o - l, h + a, o + l), e._$SetTexture$_(i), 
                            e._$Quad$_(tempQuad), this._$_DrawProgressBarLoadingScreen$_(t, r, 16 + l);
                        } else this._$_DrawProgressBarLoadingScreen$_(t, PROGRESSBAR_WIDTH, 0);
                    } else this._$_DrawProgressBarLoadingScreen$_(t, PROGRESSBAR_WIDTH, 0);
                }
                _$_DrawSplashLoadingScreen$_(t) {
                    let e = this._$GetRenderer$_(), s = this._$_splashTextures$_._$logo$_, i = this._$_splashTextures$_._$powered$_, r = this._$_splashTextures$_._$website$_, n = Date.now(), h = (0 === this._$_splashFrameNumber$_ && (this._$_loaderStartTime$_ = n), 
                    this._$_runtime$_._$IsPreview$_() || this._$_runtime$_._$IsFBInstantAvailable$_() && !this._$_runtime$_._$IsCordova$_()), o = h ? 0 : SPLASH_AFTER_FADEOUT_WAIT_TIME, a = h ? 0 : SPLASH_MIN_DISPLAY_TIME, l = 1, u = ("fade-in" === this._$_splashState$_ ? l = Math.min((n - this._$_loaderStartTime$_) / SPLASH_FADE_DURATION, 1) : "fade-out" === this._$_splashState$_ && (l = Math.max(1 - (n - this._$_splashFadeOutStartTime$_) / SPLASH_FADE_DURATION, 0)), 
                    e._$SetColorFillMode$_(), e._$SetColorRgba$_(.231 * l, .251 * l, .271 * l, l), 
                    tempRect.set(0, 0, this._$_canvasCssWidth$_, this._$_canvasCssHeight$_), 
                    e.Rect(tempRect), Math.ceil(this._$_canvasCssWidth$_)), c = Math.ceil(this._$_canvasCssHeight$_), f, d;
                    256 < this._$_canvasCssHeight$_ ? (e._$SetColorRgba$_(.302 * l, .334 * l, .365 * l, l), 
                    f = u, d = Math.max(.005 * c, 2), tempRect._$setWH$_(0, .8 * c - d / 2, f, d), 
                    e.Rect(tempRect), t ? e._$SetColorRgba$_(l, 0, 0, l) : e._$SetColorRgba$_(.161 * l, .953 * l, .816 * l, l), 
                    f = u * this._$_loadingProgress$_, tempRect._$setWH$_(.5 * u - f / 2, .8 * c - d / 2, f, d), 
                    e.Rect(tempRect), e._$SetColorRgba$_(l, l, l, l), e._$SetTextureFillMode$_(), 
                    i && (f = 1.5 * C33._$clamp$_(.22 * c, 105, .6 * u), d = f / 8, 
                    tempRect._$setWH$_(.5 * u - f / 2, .2 * c - d / 2, f, d), e._$SetTexture$_(i), 
                    e.Rect(tempRect)), s && (f = Math.min(.395 * c, .95 * u), d = f, 
                    tempRect._$setWH$_(.5 * u - f / 2, .485 * c - d / 2, f, d), 
                    e._$SetTexture$_(s), e.Rect(tempRect)), r && (f = 1.5 * C33._$clamp$_(.22 * c, 105, .6 * u), 
                    d = f / 8, tempRect._$setWH$_(.5 * u - f / 2, .868 * c - d / 2, f, d), 
                    e._$SetTexture$_(r), e.Rect(tempRect))) : (e._$SetColorRgba$_(.302 * l, .334 * l, .365 * l, l), 
                    f = u, d = Math.max(.005 * c, 2), tempRect._$setWH$_(0, .85 * c - d / 2, f, d), 
                    e.Rect(tempRect), t ? e._$SetColorRgba$_(l, 0, 0, l) : e._$SetColorRgba$_(.161 * l, .953 * l, .816 * l, l), 
                    f = u * this._$_loadingProgress$_, tempRect._$setWH$_(.5 * u - f / 2, .85 * c - d / 2, f, d), 
                    e.Rect(tempRect), e._$SetColorRgba$_(l, l, l, l), e._$SetTextureFillMode$_(), 
                    s && (f = .55 * c, d = f, tempRect._$setWH$_(.5 * u - f / 2, .45 * c - d / 2, f, d), 
                    e._$SetTexture$_(s), e.Rect(tempRect))), this._$_splashFrameNumber$_++, 
                    "fade-in" === this._$_splashState$_ && n - this._$_loaderStartTime$_ >= SPLASH_FADE_DURATION && 2 <= this._$_splashFrameNumber$_ && (this._$_splashState$_ = "wait", 
                    this._$_splashFadeInFinishTime$_ = n), "wait" === this._$_splashState$_ && n - this._$_splashFadeInFinishTime$_ >= a && 1 <= this._$_loadingProgress$_ && (this._$_splashState$_ = "fade-out", 
                    this._$_splashFadeOutStartTime$_ = n), ("fade-out" === this._$_splashState$_ && n - this._$_splashFadeOutStartTime$_ >= SPLASH_FADE_DURATION + o || h && 1 <= this._$_loadingProgress$_ && n - this._$_loaderStartTime$_ < 500) && this._$_splashDoneResolve$_();
                }
            };
        }
        {
            let C33 = self._$C3$_, C3Debugger = self.C3Debugger, assert = self.assert, DEFAULT_RUNTIME_OPTS = {
                messagePort: null,
                runtimeBaseUrl: "",
                headless: !1,
                hasDom: !0,
                isInWorker: !1,
                useAudio: !0,
                exportType: ""
            }, ife = !0;
            C33._$Runtime$_ = class extends C33._$DefendedBase$_ {
                constructor(t) {
                    t = Object.assign({}, DEFAULT_RUNTIME_OPTS, t), super(), this._$_messagePort$_ = t.messagePort, 
                    this._$_runtimeBaseUrl$_ = t.runtimeBaseUrl, this._$_previewUrl$_ = t.previewUrl, 
                    this._$_isHeadless$_ = !!t.headless, this._$_hasDom$_ = !!t.hasDom, 
                    this._$_isInWorker$_ = !!t.isInWorker, ife = t.ife, this._$_useAudio$_ = !!t.useAudio, 
                    this._$_exportType$_ = t.exportType, this._$_isNWjs$_ = t.isNWjs, 
                    this._$_isiOSCordova$_ = !!t.isiOSCordova, this._$_isiOSWebView$_ = !!t.isiOSWebView, 
                    this._$_isWindowsWebView2$_ = !!t.isWindowsWebView2, this._$_isAnyWebView2Wrapper$_ = !!t.isAnyWebView2Wrapper, 
                    this._$_isFBInstantAvailable$_ = !!t.isFBInstantAvailable, this._$_isDebug$_ = !("preview" !== this._$_exportType$_ || !t.isDebug), 
                    this._$_breakpointsEnabled$_ = this._$_isDebug$_, this._$_isDebugging$_ = this._$_isDebug$_, 
                    this._$_debuggingDisabled$_ = 0, this._$_additionalLoadPromises$_ = [], 
                    this._$_additionalCreatePromises$_ = [], this._$_isUsingCreatePromises$_ = !1, 
                    this._$_projectName$_ = "", this._$_projectVersion$_ = "", this._$_projectUniqueId$_ = "", 
                    this._$_appId$_ = "", this._$_exportTimestamp$_ = 0, this._$_originalViewportWidth$_ = 0, 
                    this._$_originalViewportHeight$_ = 0, this._$_devicePixelRatio$_ = self.devicePixelRatio, 
                    this._$_parallaxXorigin$_ = 0, this._$_parallaxYorigin$_ = 0, 
                    this._$_viewportWidth$_ = 0, this._$_viewportHeight$_ = 0, this._$_loaderStyle$_ = 0, 
                    this._$_usesLoaderLayout$_ = !1, this._$_isLoading$_ = !0, this._$_usesAnyBackgroundBlending$_ = !1, 
                    this._$_usesAnyCrossSampling$_ = !1, this._$_usesAnyDepthSampling$_ = !1, 
                    this._$_loadingLogoAsset$_ = null, this._$_assetManager$_ = C33._$New$_(C33._$AssetManager$_, this, t), 
                    this._$_layoutManager$_ = C33._$New$_(C33._$LayoutManager$_, this), 
                    this._$_eventSheetManager$_ = C33._$New$_(C33._$EventSheetManager$_, this), 
                    this._$_addonManager$_ = C33._$New$_(C33._$AddonManager$_, this, t.wrapperComponentIds), 
                    this._$_collisionEngine$_ = C33._$New$_(C33._$CollisionEngine$_, this), 
                    this._$_timelineManager$_ = C33._$New$_(C33._$TimelineManager$_, this), 
                    this._$_transitionManager$_ = C33._$New$_(C33._$TransitionManager$_, this), 
                    this._$_templateManager$_ = C33._$New$_(C33._$TemplateManager$_, this), 
                    this._$_flowchartManager$_ = C33._$New$_(C33._$FlowchartManager$_, this), 
                    this._$_textIconManager$_ = C33._$New$_(C33._$TextIconManager$_, {
                        _$getIconSetMeta$_: t => this._$_GetTextIconSetMeta$_(t),
                        _$getIconSetContent$_: t => this._$_GetTextIconSetContent$_(t)
                    }), this._$_iconChangeHandlers$_ = new Map(), this._$_allObjectClasses$_ = [], 
                    this._$_objectClassesByName$_ = new Map(), this._$_objectClassesBySid$_ = new Map(), 
                    this._$_familyCount$_ = 0, this._$_allContainers$_ = [], this._$_allEffectLists$_ = new Set(), 
                    this._$_currentLayoutStack$_ = [], this._$_instancesPendingCreate$_ = [], 
                    this._$_instancesPendingDestroy$_ = new Map(), this._$_hasPendingInstances$_ = !1, 
                    this._$_isFlushingPendingInstances$_ = !1, this._$_objectCount$_ = 0, 
                    this._$_nextUid$_ = 0, this._$_instancesByUid$_ = new Map(), 
                    this._$_instancesPendingRelease$_ = new Set(), this._$_instancesPendingReleaseAffectedObjectClasses$_ = new Set(), 
                    this._$_objectReferenceTable$_ = [], this._$_jsPropNameTable$_ = [], 
                    this._$_canvasManager$_ = null, this._$_uses3dFeatures$_ = !1, 
                    this._$_framerateMode$_ = "vsync", this._$_sampling$_ = "trilinear", 
                    this._$_isPixelRoundingEnabled$_ = !1, this._$_needRender$_ = !0, 
                    this._$_pauseOnBlur$_ = !1, this._$_isPausedOnBlur$_ = !1, this._$_exportToVideo$_ = null, 
                    this._$_tickCallbacks$_ = {
                        _$normal$_: t => {
                            this._$_rafId$_ = -1, this._$_ruafId$_ = -1, this._$Tick$_(t);
                        },
                        _$tickOnly$_: t => {
                            this._$_ruafId$_ = -1, this._$Tick$_(t, !1, "skip-render");
                        },
                        _$renderOnly$_: () => {
                            this._$_rafId$_ = -1, this._$Render$_();
                        }
                    }, this._$_rafId$_ = -1, this._$_ruafId$_ = -1, this._$_tickCount$_ = 0, 
                    this._$_tickCountNoSave$_ = 0, this._$_hasStarted$_ = !1, this._$_isInTick$_ = !1, 
                    this._$_hasStartedTicking$_ = !1, this._$_isLayoutFirstTick$_ = !0, 
                    this._$_isAutoSuspendEnabled$_ = !0, this._$_isPageVisibilitySuspended$_ = !1, 
                    this._$_suspendCount$_ = 0, this._$_scheduleTriggersThrottle$_ = new C33._$PromiseThrottle$_(1), 
                    this._$_randomNumberCallback$_ = () => Math.random(), this._$_startTime$_ = 0, 
                    this._$_lastTickTime$_ = 0, this._$_dtRaw$_ = 0, this._$_dt1$_ = 0, 
                    this._$_dt$_ = 0, this._$_timeScale$_ = 1, this._$_maxDt$_ = 1 / 30, 
                    this._$_minDt$_ = 0, this._$_gameTime$_ = C33._$New$_(C33._$KahanSum$_), 
                    this._$_gameTimeRaw$_ = C33._$New$_(C33._$KahanSum$_), this._$_wallTime$_ = C33._$New$_(C33._$KahanSum$_), 
                    this._$_instanceTimes$_ = new Map(), this._$_fpsFrameCount$_ = -1, 
                    this._$_fpsLastTime$_ = 0, this._$_fps$_ = 0, this._$_tpsTickCount$_ = -1, 
                    this._$_tps$_ = 0, this._$_mainThreadTimeCounter$_ = 0, this._$_mainThreadTime$_ = 0, 
                    this._$_isLoadingState$_ = !1, this._$_saveToSlotName$_ = "", 
                    this._$_saveToJsonString$_ = !1, this._$_loadFromSlotName$_ = "", 
                    this._$_loadFromJson$_ = null, this._$_lastSaveJson$_ = "", 
                    this._$_projectStorage$_ = null, this._$_savegamesStorage$_ = null, 
                    this._$_dispatcher$_ = C33._$New$_(C33.Event._$Dispatcher$_), 
                    this._$_domEventHandlers$_ = new Map(), this._$_pendingResponsePromises$_ = new Map(), 
                    this._$_nextDomResponseId$_ = 0, this._$_didRequestDeviceOrientationEvent$_ = !1, 
                    this._$_didRequestDeviceMotionEvent$_ = !1, this._$_isReadyToHandleEvents$_ = !1, 
                    this._$_waitingToHandleEvents$_ = [], this._$_eventObjects$_ = {
                        pretick: C33._$New$_(C33.Event, "pretick", !1),
                        tick: C33._$New$_(C33.Event, "tick", !1),
                        tick2: C33._$New$_(C33.Event, "tick2", !1),
                        instancecreate: C33._$New$_(C33.Event, "instancecreate", !1),
                        instancedestroy: C33._$New$_(C33.Event, "instancedestroy", !1),
                        beforelayoutchange: C33._$New$_(C33.Event, "beforelayoutchange", !1),
                        layoutchange: C33._$New$_(C33.Event, "layoutchange", !1)
                    }, this._$_eventObjects$_.instancecreate.instance = null, this._$_eventObjects$_.instancedestroy.instance = null, 
                    this._$_userScriptDispatcher$_ = C33._$New$_(C33.Event._$Dispatcher$_), 
                    this._$_userScriptEventObjects$_ = null;
                    const e = (t, e) => C33._$BehaviorInstance$_._$SortByTickSequence$_(this, t, e);
                    this._$_behInstsToTick$_ = C33._$New$_(C33._$RedBlackSet$_, e), 
                    this._$_behInstsToPostTick$_ = C33._$New$_(C33._$RedBlackSet$_, e), 
                    this._$_behInstsToTick2$_ = C33._$New$_(C33._$RedBlackSet$_, e), 
                    this._$_jobScheduler$_ = C33._$New$_(C33._$JobSchedulerRuntime$_, this, t.jobScheduler), 
                    t.canvas && (this._$_canvasManager$_ = C33._$New$_(C33._$CanvasManager$_, this)), 
                    this._$_messagePort$_.onmessage = t => this._OnMessageFromDOM(t.data), 
                    this._$AddDOMComponentMessageHandler$_("runtime", "visibilitychange", t => this._$_OnVisibilityChange$_(t)), 
                    this._$AddDOMComponentMessageHandler$_("runtime", "wrapper-extension-message", t => this._$_OnWrapperExtensionMessage$_(t)), 
                    this._$AddDOMComponentMessageHandler$_("runtime", "get-remote-preview-status-info", () => this._$_GetRemotePreviewStatusInfo$_()), 
                    this._$AddDOMComponentMessageHandler$_("runtime", "js-invoke-function", t => this._$_InvokeFunctionFromJS$_(t)), 
                    this._$AddDOMComponentMessageHandler$_("runtime", "go-to-last-error-script", self.goToLastErrorScript), 
                    this._$AddDOMComponentMessageHandler$_("runtime", "offline-audio-render-completed", t => this._$_OnOfflineAudioRenderCompleted$_(t)), 
                    this._$_dispatcher$_.addEventListener("window-blur", t => this._$_OnWindowBlur$_(t)), 
                    this._$_dispatcher$_.addEventListener("window-focus", () => this._$_OnWindowFocus$_()), 
                    this._$_timelineManager$_._$AddRuntimeListeners$_(), this._$_templateManager$_._$AddRuntimeListeners$_(), 
                    this._$_iRuntime$_ = null, this._$_interfaceMap$_ = new WeakMap(), 
                    this._$_commonScriptInterfaces$_ = {
                        keyboard: null,
                        _$mouse$_: null,
                        _$touch$_: null,
                        _$timelineController$_: null
                    }, this._$_instancesNeedingAfterLoadMap$_ = new WeakMap(), this._$_instancesNeedingAfterLoadArray$_ = [];
                }
                static _$Create$_(t) {
                    return C33._$New$_(C33._$Runtime$_, t);
                }
                _$Release$_() {
                    C33._$clearArray$_(this._$_allObjectClasses$_), this._$_objectClassesByName$_.clear(), 
                    this._$_objectClassesBySid$_.clear(), this._$_layoutManager$_._$Release$_(), 
                    this._$_layoutManager$_ = null, this._$_eventSheetManager$_._$Release$_(), 
                    this._$_eventSheetManager$_ = null, this._$_addonManager$_._$Release$_(), 
                    this._$_addonManager$_ = null, this._$_assetManager$_._$Release$_(), 
                    this._$_assetManager$_ = null, this._$_collisionEngine$_._$Release$_(), 
                    this._$_collisionEngine$_ = null, this._$_timelineManager$_._$Release$_(), 
                    this._$_timelineManager$_ = null, this._$_transitionManager$_._$Release$_(), 
                    this._$_transitionManager$_ = null, this._$_templateManager$_._$Release$_(), 
                    this._$_templateManager$_ = null, this._$_flowchartManager$_._$Release$_(), 
                    this._$_flowchartManager$_ = null, this._$_textIconManager$_._$Release$_(), 
                    this._$_textIconManager$_ = null, this._$_canvasManager$_ && (this._$_canvasManager$_._$Release$_(), 
                    this._$_canvasManager$_ = null), this._$_dispatcher$_._$Release$_(), 
                    this._$_dispatcher$_ = null, this._$_tickEvent$_ = null;
                }
                ["_OnMessageFromDOM"](t) {
                    const e = t.type;
                    if ("event" === e) this._$_OnEventFromDOM$_(t); else {
                        if ("result" !== e) throw new Error(`unknown message '${e}'`);
                        this._$_OnResultFromDOM$_(t);
                    }
                }
                _$_OnEventFromDOM$_(t) {
                    if (this._$_isReadyToHandleEvents$_) {
                        const e = t.component, s = t.handler, i = t.data, r = t.dispatchOpts, n = !(!r || !r.dispatchRuntimeEvent), h = !(!r || !r.dispatchUserScriptEvent), o = t.responseId;
                        if ("runtime" === e) {
                            if (n) {
                                const l = new C33.Event(s);
                                l.data = i, this._$_dispatcher$_._$dispatchEventAndWaitAsyncSequential$_(l);
                            }
                            if (h) {
                                const u = new C33.Event(s, !0);
                                for (const [ c, f ] of Object.entries(i)) u[c] = f;
                                this._$DispatchUserScriptEvent$_(u);
                            }
                        }
                        const a = this._$_domEventHandlers$_.get(e);
                        if (a) {
                            const d = a.get(s);
                            if (d) {
                                let t = null;
                                try {
                                    t = d(i);
                                } catch (t) {
                                    return console.error(`Exception in '${e}' handler '${s}':`, t), 
                                    void (null !== o && this._$_PostResultToDOM$_(o, !1, "" + t));
                                }
                                null !== o && (t && t.then ? t.then(t => this._$_PostResultToDOM$_(o, !0, t)).catch(t => {
                                    console.error(`Rejection from '${e}' handler '${s}':`, t), 
                                    this._$_PostResultToDOM$_(o, !1, "" + t);
                                }) : this._$_PostResultToDOM$_(o, !0, t));
                            } else n || h || console.warn(`[Runtime] No DOM handler '${s}' for component '${e}'`);
                        } else n || h || console.warn(`[Runtime] No DOM event handlers for component '${e}'`);
                    } else this._$_waitingToHandleEvents$_.push(t);
                }
                _$_PostResultToDOM$_(t, e, s) {
                    this._$_messagePort$_.postMessage({
                        type: "result",
                        responseId: t,
                        isOk: e,
                        result: s
                    });
                }
                _$_OnResultFromDOM$_(t) {
                    const e = t.responseId, s = t.isOk, i = t.result, r = this._$_pendingResponsePromises$_.get(e);
                    s ? r.resolve(i) : r.reject(i), this._$_pendingResponsePromises$_.delete(e);
                }
                _$AddDOMComponentMessageHandler$_(t, e, s) {
                    let i = this._$_domEventHandlers$_.get(t);
                    if (i || (i = new Map(), this._$_domEventHandlers$_.set(t, i)), 
                    i.has(e)) throw new Error(`[Runtime] Component '${t}' already has handler '${e}'`);
                    i.set(e, s);
                }
                _$PostComponentMessageToDOM$_(t, e, s, i) {
                    this._$_messagePort$_.postMessage({
                        type: "event",
                        component: t,
                        handler: e,
                        data: s,
                        responseId: null
                    }, i);
                }
                _$PostComponentMessageToDOMAsync$_(t, e, s, i) {
                    const r = this._$_nextDomResponseId$_++, n = new Promise((t, e) => {
                        this._$_pendingResponsePromises$_.set(r, {
                            resolve: t,
                            reject: e
                        });
                    });
                    return this._$_messagePort$_.postMessage({
                        type: "event",
                        component: t,
                        handler: e,
                        data: s,
                        responseId: r
                    }, i), n;
                }
                _$SendWrapperExtensionMessage$_(t, e, s, i = -1) {
                    this._$PostComponentMessageToDOM$_("runtime", "send-wrapper-extension-message", {
                        componentId: t,
                        messageId: e,
                        params: s,
                        asyncId: i
                    });
                }
                _$SendWrapperExtensionMessageAsync$_(t, e, s) {
                    const i = this._$_nextDomResponseId$_++, r = new Promise((t, e) => {
                        this._$_pendingResponsePromises$_.set(i, {
                            resolve: t,
                            reject: e
                        });
                    });
                    return this._$SendWrapperExtensionMessage$_(t, e, s, i), r;
                }
                _$_OnWrapperExtensionMessage$_(t) {
                    if (-1 !== t.asyncId) {
                        const e = t.asyncId, s = this._$_pendingResponsePromises$_.get(e);
                        s.resolve(t.params), this._$_pendingResponsePromises$_.delete(e);
                    } else this._$_OnEventFromDOM$_({
                        component: "wrapper-extension:" + t.componentId,
                        handler: t.messageId,
                        data: t.params,
                        responseId: null
                    });
                }
                _$AddWrapperExtensionMessageHandler$_(t, e, s) {
                    this._$AddDOMComponentMessageHandler$_("wrapper-extension:" + t, e, s);
                }
                _$HasWrapperComponentId$_(t) {
                    return this._$_addonManager$_._$HasWrapperComponentId$_(t);
                }
                _$PostToDebugger$_(t) {
                    if (!this._$IsDebug$_()) throw new Error("not in debug mode");
                    this._$PostComponentMessageToDOM$_("runtime", "post-to-debugger", t);
                }
                async _$Init$_(t) {
                    C33._$CommonACES_SetRuntime$_(this), this._$IsDebug$_() ? await C3Debugger._$Init$_(this) : self.C3Debugger && self.C3Debugger.InitPreview(this);
                    const e = await this._$_assetManager$_._$FetchJson$_("data.json");
                    if (await this._$_LoadDataJson$_(e), await this._$_InitialiseCanvas$_(t), 
                    this._$IsPreview$_() || console.info("%cMade with Construct, the game and animation creation tool. Visit: https://www.construct.net", "font-weight: bold"), 
                    this._$GetWebGLRenderer$_()) {
                        const s = this._$GetWebGLRenderer$_();
                        console.info(`[C3 runtime] Hosted in ${this._$IsInWorker$_() ? "worker" : "DOM"}, rendering with WebGL ${s._$GetWebGLVersionNumber$_()} [${s._$GetUnmaskedRenderer$_()}]`);
                    } else this._$GetWebGPURenderer$_() && console.info(`[C3 runtime] Hosted in ${this._$IsInWorker$_() ? "worker" : "DOM"}, rendering with WebGPU [${this._$GetWebGPURenderer$_()._$GetAdapterInfoString$_()}]`);
                    this._$GetRenderer$_()._$HasMajorPerformanceCaveat$_() && console.warn("[C3 runtime] The renderer indicates a major performance caveat. Software rendering may be in use. This can result in significantly degraded performance."), 
                    this._$_isReadyToHandleEvents$_ = !0;
                    for (const i of this._$_waitingToHandleEvents$_) this._$_OnEventFromDOM$_(i);
                    C33._$clearArray$_(this._$_waitingToHandleEvents$_), this._$_canvasManager$_ && this._$_canvasManager$_._$StartLoadingScreen$_();
                    for (const r of t.runOnStartupFunctions) this._$_additionalLoadPromises$_.push(this._$_RunOnStartupFunction$_(r));
                    if (await Promise.all([ this._$_assetManager$_._$WaitForAllToLoad$_(), ...this._$_additionalLoadPromises$_ ]), 
                    C33._$clearArray$_(this._$_additionalLoadPromises$_), !this._$_assetManager$_._$HasHadErrorLoading$_()) return this._$_canvasManager$_ && await this._$_canvasManager$_._$EndLoadingScreen$_(), 
                    await this._$_dispatcher$_._$dispatchEventAndWaitAsync$_(new C33.Event("beforeruntimestart")), 
                    await this._$Start$_(), this._$_messagePort$_.postMessage({
                        type: "runtime-ready"
                    }), this;
                    this._$_canvasManager$_ && this._$_canvasManager$_._$HideCordovaSplashScreen$_();
                }
                async _$_RunOnStartupFunction$_(t) {
                    try {
                        await t(this._$_iRuntime$_);
                    } catch (t) {
                        console.error("[C3 runtime] Error in runOnStartup function: ", t);
                    }
                }
                async _$_LoadDataJson$_(t) {
                    const e = t.project, s = (this._$_projectName$_ = e[0], this._$_projectVersion$_ = e[16], 
                    this._$_projectUniqueId$_ = e[31], this._$_appId$_ = e[38], 
                    this._$_exportTimestamp$_ = e[36], e[39] || "loading-logo.png"), i = (this._$_isPixelRoundingEnabled$_ = !!e[9], 
                    this._$_originalViewportWidth$_ = this._$_viewportWidth$_ = e[10], 
                    this._$_originalViewportHeight$_ = this._$_viewportHeight$_ = e[11], 
                    this._$_collisionEngine$_._$_InitCollisionCellSize$_(this._$_originalViewportWidth$_, this._$_originalViewportHeight$_), 
                    this._$_parallaxXorigin$_ = this._$_originalViewportWidth$_ / 2, 
                    this._$_parallaxYorigin$_ = this._$_originalViewportHeight$_ / 2, 
                    this._$_framerateMode$_ = e[37], this._$_uses3dFeatures$_ = !!e[40], 
                    this._$_sampling$_ = e[14], this._$_usesAnyBackgroundBlending$_ = e[15], 
                    this._$_usesAnyCrossSampling$_ = e[42], this._$_usesAnyDepthSampling$_ = e[17], 
                    this._$_usesLoaderLayout$_ = !!e[18], this._$_loaderStyle$_ = e[19], 
                    this._$_nextUid$_ = e[21], this._$_pauseOnBlur$_ = e[22], this._$_assetManager$_);
                    if (i._$_SetFileStructure$_(e[45]), i._$_SetAudioFiles$_(e[7], e[25]), 
                    i._$_SetMediaSubfolder$_(e[8]), i._$_SetFontsSubfolder$_(e[32]), 
                    i._$_SetIconsSubfolder$_(e[28]), i._$_SetWebFonts$_(e[29]), 
                    0 === this._$_loaderStyle$_) {
                        let t;
                        (t = "flat" === i._$GetFileStructure$_() ? i._$GetIconsSubfolder$_() + s : s) && (this._$_loadingLogoAsset$_ = i._$LoadImage$_({
                            url: t
                        }));
                    }
                    this._$_canvasManager$_ && (this._$_canvasManager$_._$SetFullscreenMode$_(C33._$CanvasManager$_._$_FullscreenModeNumberToString$_(e[12])), 
                    this._$_canvasManager$_._$SetFullscreenScalingQuality$_(e[23] ? "high" : "low"), 
                    this._$_canvasManager$_._$SetMipmapsEnabled$_(0 !== e[24]), 
                    this._$_canvasManager$_._$_SetGPUPowerPreference$_(e[34]), this._$_canvasManager$_._$_SetTextureAnisotropy$_(e[41]), 
                    this._$_canvasManager$_._$_SetWebGPUEnabled$_(e[13]), this._$_canvasManager$_._$_SetZAxisScale$_(e[30]), 
                    this._$_canvasManager$_._$_SetZDistances$_(e[46], e[47]), this._$_canvasManager$_._$_SetInitFieldOfView$_(e[26]), 
                    this._$_canvasManager$_._$_SetLimitedToWebGL1$_(e[48]), this._$_canvasManager$_._$_SetMultitexturingMode$_(e[50]));
                    const r = e[43], n = (r && await this._$_LoadExportToVideoData$_(r), 
                    this._$_InitScriptInterfaces$_(), this._$_addonManager$_._$CreateSystemPlugin$_(), 
                    this._$_objectReferenceTable$_ = self._$C3_GetObjectRefTable$_(), 
                    e[2]);
                    for (const l of n[1]) this._$_addonManager$_._$CreateBehavior$_(l);
                    for (const u of n[0]) this._$_addonManager$_._$CreatePlugin$_(u);
                    this._$_objectReferenceTable$_ = self._$C3_GetObjectRefTable$_(), 
                    this._$_LoadJsPropNameTable$_(), this._$_addonManager$_._$_InitAddonScriptInterfaces$_();
                    for (const c of e[3]) {
                        const f = C33._$ObjectClass$_._$Create$_(this, this._$_allObjectClasses$_.length, c);
                        this._$_allObjectClasses$_.push(f), this._$_objectClassesByName$_.set(f._$GetName$_().toLowerCase(), f), 
                        this._$_objectClassesBySid$_.set(f._$GetSID$_(), f);
                    }
                    for (const d of e[4]) {
                        const p = this._$_allObjectClasses$_[d[0]];
                        p._$_LoadFamily$_(d);
                    }
                    for (const m of e[27]) {
                        const C = m.map(t => this._$_allObjectClasses$_[t]);
                        this._$_allContainers$_.push(C33._$New$_(C33._$Container$_, this, C));
                    }
                    this._$_InitObjectsScriptInterface$_();
                    for (const g of this._$_allObjectClasses$_) g._$_OnAfterCreate$_();
                    for (const S of e[5]) this._$_layoutManager$_._$Create$_(S);
                    const h = e[1];
                    if (h) {
                        const _ = this._$_layoutManager$_._$GetLayoutByName$_(h);
                        _ && this._$_layoutManager$_._$SetFirstLayout$_(_);
                    }
                    for (const T of e[35]) this._$_transitionManager$_._$Create$_(T);
                    for (const y of e[33]) this._$_timelineManager$_._$Create$_(y);
                    for (const E of e[44]) this._$_templateManager$_._$Create$_(E);
                    this._$_templateManager$_._$HasTemplates$_() || (this._$_templateManager$_._$Release$_(), 
                    this._$_templateManager$_ = null);
                    for (const A of e[49]) this._$_flowchartManager$_._$Create$_(A);
                    this._$_flowchartManager$_._$HasFlowcharts$_() || (this._$_flowchartManager$_._$Release$_(), 
                    this._$_flowchartManager$_ = null);
                    for (const I of e[6]) this._$_eventSheetManager$_._$Create$_(I);
                    this._$_eventSheetManager$_._$_PostInit$_(), this._$_InitGlobalVariableScriptInterface$_(), 
                    C33._$clearArray$_(this._$_objectReferenceTable$_), this._$FlushPendingInstances$_();
                    let o = "any", a = e[20];
                    1 === a ? o = "portrait" : 2 === a && (o = "landscape"), this._$PostComponentMessageToDOM$_("runtime", "set-target-orientation", {
                        targetOrientation: o
                    });
                }
                async _$_LoadExportToVideoData$_(t) {
                    const e = t.format;
                    "image-sequence" === e ? this._$_exportToVideo$_ = new self.C3ExportToImageSequence(this, t) : "image-sequence-gif" === e ? this._$_exportToVideo$_ = new self.C3ExportToGIF(this, t) : "webm" === e ? this._$_exportToVideo$_ = new self.C3ExportToWebMVideo(this, t) : "mp4" === e && (this._$_exportToVideo$_ = new self.C3ExportToMP4Video(this, t)), 
                    this._$_framerateMode$_ = "unlimited-frame", this._$_canvasManager$_._$SetFullscreenMode$_("off"), 
                    this._$_devicePixelRatio$_ = 1, self.devicePixelRatio = 1, await this._$PostComponentMessageToDOMAsync$_("runtime", "set-exporting-to-video", {
                        message: this._$_exportToVideo$_.GetExportingMessageForPercent(0),
                        duration: this._$_exportToVideo$_._$GetDuration$_()
                    });
                }
                _$GetLoaderStyle$_() {
                    return this._$_loaderStyle$_;
                }
                _$IsExportToVideo$_() {
                    return null !== this._$_exportToVideo$_;
                }
                _$GetExportVideoDuration$_() {
                    return this._$_exportToVideo$_._$GetDuration$_();
                }
                _$GetExportVideoFramerate$_() {
                    return this._$_exportToVideo$_.GetFramerate();
                }
                _$_InitExportToVideo$_() {
                    return this._$_exportToVideo$_._$Init$_({
                        width: this._$_canvasManager$_._$GetDeviceWidth$_(),
                        height: this._$_canvasManager$_._$GetDeviceHeight$_()
                    });
                }
                _$_ExportToVideoAddFrame$_() {
                    const t = this._$_tickCount$_ / this._$GetExportVideoFramerate$_();
                    return this._$_exportToVideo$_.AddFrame(this._$_canvasManager$_._$GetMainCanvas$_(), t);
                }
                _$_ExportToVideoAddKeyframe$_() {
                    this._$_exportToVideo$_ && this._$_exportToVideo$_._$AddKeyframe$_();
                }
                _$_OnOfflineAudioRenderCompleted$_(t) {
                    this._$_exportToVideo$_.OnOfflineAudioRenderCompleted(t);
                }
                _$_ExportToVideoFinish$_() {
                    return this._$_exportToVideo$_._$Finish$_();
                }
                _$IsFBInstantAvailable$_() {
                    return this._$_isFBInstantAvailable$_;
                }
                _$IsLoading$_() {
                    return this._$_isLoading$_;
                }
                _$AddLoadPromise$_(t) {
                    this._$_additionalLoadPromises$_.push(t);
                }
                _$SetUsingCreatePromises$_(t) {
                    this._$_isUsingCreatePromises$_ = !!t;
                }
                _$AddCreatePromise$_(t) {
                    this._$_isUsingCreatePromises$_ && this._$_additionalCreatePromises$_.push(t);
                }
                _$GetCreatePromises$_() {
                    return this._$_additionalCreatePromises$_;
                }
                _$_GetNextFamilyIndex$_() {
                    return this._$_familyCount$_++;
                }
                _$GetFamilyCount$_() {
                    return this._$_familyCount$_;
                }
                _$_AddEffectList$_(t) {
                    this._$_allEffectLists$_.add(t);
                }
                _$_RemoveEffectList$_(t) {
                    this._$_allEffectLists$_.delete(t);
                }
                _$_GetAllEffectLists$_() {
                    return this._$_allEffectLists$_;
                }
                async _$_InitialiseCanvas$_(t) {
                    this._$_canvasManager$_ && (await this._$_canvasManager$_._$CreateCanvas$_(t), 
                    this._$_canvasManager$_._$InitLoadingScreen$_(this._$_loaderStyle$_));
                }
                async _$Start$_() {
                    this._$_hasStarted$_ = !0, this._$_startTime$_ = Date.now();
                    let e = null, t = new Promise(t => e = t);
                    if (this._$_usesLoaderLayout$_) {
                        for (const r of this._$_allObjectClasses$_) r._$IsFamily$_() || r._$IsOnLoaderLayout$_() || !r._$IsWorldType$_() || r._$OnCreate$_();
                        (async () => {
                            await this._$_assetManager$_._$WaitForAllToLoad$_(), 
                            await t, this._$_isLoading$_ = !1, this._$_OnLoadFinished$_();
                        })();
                    } else this._$_isLoading$_ = !1;
                    this._$_assetManager$_._$SetInitialLoadFinished$_(), this._$IsDebug$_() && C3Debugger.RuntimeInit(ife);
                    for (const n of this._$_layoutManager$_._$GetAllLayouts$_()) n._$_CreateGlobalNonWorlds$_();
                    this._$IsExportToVideo$_() && await this._$_InitExportToVideo$_();
                    const s = this._$_layoutManager$_._$GetFirstLayout$_(), i = (await s._$_Load$_(null, this._$GetRenderer$_()), 
                    await s._$_StartRunning$_(!0), this._$_fpsLastTime$_ = performance.now(), 
                    e(), this._$_usesLoaderLayout$_ || this._$_OnLoadFinished$_(), 
                    await this._$PostComponentMessageToDOMAsync$_("runtime", "before-start-ticking"));
                    i.isSuspended && !this._$IsExportToVideo$_() ? (this._$_suspendCount$_++, 
                    this._$_isPageVisibilitySuspended$_ = !0) : this._$Tick$_();
                }
                _$_OnLoadFinished$_() {
                    this._$Trigger$_(C33._$Plugins$_._$System$_._$Cnds$_._$OnLoadFinished$_, null, null), 
                    this._$PostComponentMessageToDOM$_("runtime", "register-sw");
                }
                _$GetObjectReference$_(t) {
                    t = Math.floor(t);
                    const e = this._$_objectReferenceTable$_;
                    if (t < 0 || t >= e.length) throw new Error("invalid object reference");
                    return e[t];
                }
                _$_LoadJsPropNameTable$_() {
                    for (const t of self._$C3_JsPropNameTable$_) {
                        const e = C33.first(Object.keys(t));
                        this._$_jsPropNameTable$_.push(e);
                    }
                }
                _$GetJsPropName$_(t) {
                    t = Math.floor(t);
                    const e = this._$_jsPropNameTable$_;
                    if (t < 0 || t >= e.length) throw new Error("invalid prop reference");
                    return e[t];
                }
                _$HasDOM$_() {
                    return this._$_hasDom$_;
                }
                _$IsHeadless$_() {
                    return this._$_isHeadless$_;
                }
                _$IsInWorker$_() {
                    return this._$_isInWorker$_;
                }
                _$GetRuntimeBaseURL$_() {
                    return this._$_runtimeBaseUrl$_;
                }
                _$GetPreviewURL$_() {
                    return this._$_previewUrl$_;
                }
                _$GetEventSheetManager$_() {
                    return this._$_eventSheetManager$_;
                }
                _$GetEventStack$_() {
                    return this._$_eventSheetManager$_._$GetEventStack$_();
                }
                _$GetCurrentEventStackFrame$_() {
                    return this._$_eventSheetManager$_._$GetCurrentEventStackFrame$_();
                }
                _$GetCurrentEvent$_() {
                    return this._$_eventSheetManager$_._$GetCurrentEvent$_();
                }
                _$GetCurrentCondition$_() {
                    return this._$_eventSheetManager$_._$GetCurrentCondition$_();
                }
                _$IsCurrentConditionFirst$_() {
                    return 0 === this._$GetCurrentEventStackFrame$_()._$GetConditionIndex$_();
                }
                _$GetCurrentAction$_() {
                    return this._$_eventSheetManager$_._$GetCurrentAction$_();
                }
                _$GetAddonManager$_() {
                    return this._$_addonManager$_;
                }
                _$GetSystemPlugin$_() {
                    return this._$_addonManager$_._$GetSystemPlugin$_();
                }
                _$GetObjectClassByIndex$_(t) {
                    if ((t = Math.floor(t)) < 0 || t >= this._$_allObjectClasses$_.length) throw new RangeError("invalid index");
                    return this._$_allObjectClasses$_[t];
                }
                _$GetObjectClassByName$_(t) {
                    return this._$_objectClassesByName$_.get(t.toLowerCase()) || null;
                }
                _$GetObjectClassBySID$_(t) {
                    return this._$_objectClassesBySid$_.get(t) || null;
                }
                _$GetSingleGlobalObjectClassByCtor$_(t) {
                    const e = C33._$AddonManager$_._$GetPluginByConstructorFunction$_(t);
                    return e ? e._$GetSingleGlobalObjectClass$_() : null;
                }
                _$GetAllObjectClasses$_() {
                    return this._$_allObjectClasses$_;
                }
                *_$allInstances$_() {
                    for (const t of this._$_allObjectClasses$_) t._$IsFamily$_() || (yield* t.instances());
                }
                _$Dispatcher$_() {
                    return this._$_dispatcher$_;
                }
                _$UserScriptDispatcher$_() {
                    return this._$_userScriptDispatcher$_;
                }
                _$DispatchUserScriptEvent$_(t) {
                    t.runtime = this._$GetIRuntime$_();
                    const e = this._$IsDebug$_() && !this._$_eventSheetManager$_._$IsInEventEngine$_();
                    e && C3Debugger.StartMeasuringScriptTime(), this._$_userScriptDispatcher$_.dispatchEvent(t), 
                    e && C3Debugger.AddScriptTime();
                }
                _$DispatchUserScriptEventAsyncWait$_(t) {
                    return t.runtime = this._$GetIRuntime$_(), this._$_userScriptDispatcher$_._$dispatchEventAndWaitAsync$_(t);
                }
                _$GetOriginalViewportWidth$_() {
                    return this._$_originalViewportWidth$_;
                }
                _$GetOriginalViewportHeight$_() {
                    return this._$_originalViewportHeight$_;
                }
                _$SetOriginalViewportSize$_(t, e) {
                    if (this._$_originalViewportWidth$_ !== t || this._$_originalViewportHeight$_ !== e) {
                        this._$_originalViewportWidth$_ = t, this._$_originalViewportHeight$_ = e;
                        const s = this._$GetLayoutManager$_();
                        s._$SetAllLayerProjectionChanged$_(), s._$SetAllLayerMVChanged$_();
                    }
                }
                _$GetViewportWidth$_() {
                    return this._$_viewportWidth$_;
                }
                _$GetViewportHeight$_() {
                    return this._$_viewportHeight$_;
                }
                _$SetViewportSize$_(t, e) {
                    if (this._$_viewportWidth$_ !== t || this._$_viewportHeight$_ !== e) {
                        this._$_viewportWidth$_ = t, this._$_viewportHeight$_ = e;
                        const s = this._$GetLayoutManager$_();
                        s._$SetAllLayerProjectionChanged$_(), s._$SetAllLayerMVChanged$_();
                    }
                }
                _$_SetDevicePixelRatio$_(t) {
                    this._$IsExportToVideo$_() || (this._$_devicePixelRatio$_ = t);
                }
                _$GetDevicePixelRatio$_() {
                    return this._$_devicePixelRatio$_;
                }
                _$GetParallaxXOrigin$_() {
                    return this._$_parallaxXorigin$_;
                }
                _$GetParallaxYOrigin$_() {
                    return this._$_parallaxYorigin$_;
                }
                _$GetCanvasManager$_() {
                    return this._$_canvasManager$_;
                }
                _$GetDrawWidth$_() {
                    return this._$_canvasManager$_ ? this._$_canvasManager$_._$GetDrawWidth$_() : this._$_viewportWidth$_;
                }
                _$GetDrawHeight$_() {
                    return this._$_canvasManager$_ ? this._$_canvasManager$_._$GetDrawHeight$_() : this._$_viewportHeight$_;
                }
                _$GetRenderScale$_() {
                    return this._$_canvasManager$_ ? this._$_canvasManager$_._$GetRenderScale$_() : 1;
                }
                _$GetDisplayScale$_() {
                    return this._$_canvasManager$_ ? this._$_canvasManager$_._$GetDisplayScale$_() : 1;
                }
                _$GetEffectLayerScaleParam$_() {
                    return this._$_canvasManager$_ ? this._$_canvasManager$_._$GetEffectLayerScaleParam$_() : 1;
                }
                _$GetEffectDevicePixelRatioParam$_() {
                    return this._$_canvasManager$_ ? this._$_canvasManager$_._$GetEffectDevicePixelRatioParam$_() : 1;
                }
                _$GetCanvasClientX$_() {
                    return this._$_canvasManager$_ ? this._$_canvasManager$_._$GetCanvasClientX$_() : 0;
                }
                _$GetCanvasClientY$_() {
                    return this._$_canvasManager$_ ? this._$_canvasManager$_._$GetCanvasClientY$_() : 0;
                }
                _$GetCanvasCssWidth$_() {
                    return this._$_canvasManager$_ ? this._$_canvasManager$_._$GetCssWidth$_() : 0;
                }
                _$GetCanvasCssHeight$_() {
                    return this._$_canvasManager$_ ? this._$_canvasManager$_._$GetCssHeight$_() : 0;
                }
                _$GetFullscreenMode$_() {
                    return this._$_canvasManager$_ ? this._$_canvasManager$_._$GetFullscreenMode$_() : "off";
                }
                _$GetAdditionalRenderTarget$_(t) {
                    return this._$_canvasManager$_ ? this._$_canvasManager$_._$GetAdditionalRenderTarget$_(t) : null;
                }
                _$ReleaseAdditionalRenderTarget$_(t) {
                    this._$_canvasManager$_ && this._$_canvasManager$_._$ReleaseAdditionalRenderTarget$_(t);
                }
                _$UsesAnyBackgroundBlending$_() {
                    return this._$_usesAnyBackgroundBlending$_;
                }
                _$UsesAnyCrossSampling$_() {
                    return this._$_usesAnyCrossSampling$_;
                }
                _$UsesAnyDepthSampling$_() {
                    return this._$_usesAnyDepthSampling$_;
                }
                _$GetGPUUtilisation$_() {
                    return this._$_canvasManager$_ ? this._$_canvasManager$_._$GetGPUUtilisation$_() : NaN;
                }
                _$IsLinearSampling$_() {
                    return "nearest" !== this._$GetSampling$_();
                }
                _$GetFramerateMode$_() {
                    return this._$_framerateMode$_;
                }
                _$_SetFramerateMode$_(t) {
                    this._$_framerateMode$_ !== t && (this._$_framerateMode$_ = t, 
                    -1 !== this._$_rafId$_ || -1 !== this._$_ruafId$_) && (this._$_CancelAnimationFrame$_(), 
                    this._$_RequestAnimationFrame$_());
                }
                _$GetSampling$_() {
                    return this._$_sampling$_;
                }
                _$UsesLoaderLayout$_() {
                    return this._$_usesLoaderLayout$_;
                }
                _$GetLoadingLogoAsset$_() {
                    return this._$_loadingLogoAsset$_;
                }
                _$ReleaseLoadingLogoAsset$_() {
                    this._$_loadingLogoAsset$_ && (this._$_loadingLogoAsset$_._$ReleaseTexture$_(), 
                    this._$_loadingLogoAsset$_._$Release$_(), this._$_loadingLogoAsset$_ = null);
                }
                _$GetLayoutManager$_() {
                    return this._$_layoutManager$_;
                }
                _$GetMainRunningLayout$_() {
                    return this._$_layoutManager$_._$GetMainRunningLayout$_();
                }
                _$GetTimelineManager$_() {
                    return this._$_timelineManager$_;
                }
                _$GetTransitionManager$_() {
                    return this._$_transitionManager$_;
                }
                _$GetTemplateManager$_() {
                    return this._$_templateManager$_;
                }
                _$GetFlowchartManager$_() {
                    return this._$_flowchartManager$_;
                }
                _$GetAssetManager$_() {
                    return this._$_assetManager$_;
                }
                _$LoadImage$_(t) {
                    return this._$_assetManager$_._$LoadImage$_(t);
                }
                _$CreateInstance$_(t, e, s, i, r, n) {
                    if (n && this._$_templateManager$_) {
                        if (t instanceof C33._$ObjectClass$_ && t._$IsFamily$_()) {
                            const o = t._$GetFamilyMembers$_(), a = Math.floor(this._$Random$_() * o.length);
                            return this._$CreateInstance$_(o[a], e, s, i, r, n);
                        }
                        const h = this._$_templateManager$_._$GetTemplateData$_(t, n);
                        if (h) {
                            const l = this._$CreateInstanceFromData$_(h, e, !1, s, i, !1, r, void 0, r);
                            return this._$_templateManager$_._$MapInstanceToTemplateName$_(l, n), 
                            l;
                        }
                    }
                    return this._$CreateInstanceFromData$_(t, e, !1, s, i, !1, r, void 0, r);
                }
                _$CreateInstanceFromData$_(t, e, s, i, r, n, h, o, a) {
                    let l = null, u = null;
                    if (t instanceof C33._$ObjectClass$_) {
                        if ((u = t)._$IsFamily$_()) {
                            const T = u._$GetFamilyMembers$_(), y = Math.floor(this._$Random$_() * T.length);
                            u = T[y];
                        }
                        l = u._$GetDefaultInstanceData$_();
                    } else l = t, u = this._$GetObjectClassByIndex$_(l[1]);
                    const c = u._$GetPlugin$_()._$IsWorldType$_();
                    if (this._$_isLoading$_ && c && !u._$IsOnLoaderLayout$_()) return null;
                    const f = e;
                    c || (e = null);
                    let d;
                    d = s && !n && l && !this._$_instancesByUid$_.has(l[2]) ? l[2] : this._$_nextUid$_++;
                    const p = l ? l[0] : null, m = C33._$New$_(C33.Instance, {
                        runtime: this,
                        _$objectType$_: u,
                        _$layer$_: e,
                        _$worldData$_: p,
                        _$instVarData$_: l ? l[3] : null,
                        uid: d,
                        tags: l ? l[6] : null
                    });
                    this._$_instancesByUid$_.set(d, m);
                    let C = null, g = (c && (C = m._$GetWorldInfo$_(), void 0 !== i && void 0 !== r && (C._$SetX$_(i), 
                    C._$SetY$_(r)), u._$_SetAnyCollisionCellChanged$_(!0)), e && (a || e._$_AddInstance$_(m, !0), 
                    e._$GetLayout$_()._$MaybeLoadTexturesFor$_(u)), this._$_objectCount$_++, 
                    !0);
                    if (o) {
                        const E = o._$GetObjectClass$_();
                        if (E._$IsInContainer$_() && u._$IsInContainer$_()) {
                            const A = u._$GetContainer$_(), I = E._$GetContainer$_();
                            A === I && (g = !1);
                        }
                    }
                    if (u._$IsInContainer$_() && !s && !n && g) {
                        const M = new Set();
                        for (const w of u._$GetContainer$_()._$objectTypes$_()) if (w !== u) {
                            const v = this._$_MaybeGetChildInstanceForObjectTypeData$_(w, C, M);
                            if (v) {
                                const R = this._$CreateInstanceFromData$_(v, f, !1, C ? C._$GetX$_() : i, C ? C._$GetY$_() : r, !0, !1, void 0, a);
                                m._$_AddSibling$_(R);
                            } else {
                                const B = this._$CreateInstanceFromData$_(w, f, !1, C ? C._$GetX$_() : i, C ? C._$GetY$_() : r, !0, !1, void 0, a);
                                m._$_AddSibling$_(B);
                            }
                        }
                        for (const b of m._$siblings$_()) {
                            b._$_AddSibling$_(m);
                            for (const G of m._$siblings$_()) b !== G && b._$_AddSibling$_(G);
                        }
                    }
                    if (c && !s && h && this._$_CreateChildInstancesFromData$_(m, p, C, e, i, r, a), 
                    u._$IsInContainer$_() && !s && !n && h) for (const x of m._$siblings$_()) {
                        const P = x._$GetWorldInfo$_();
                        if (P) {
                            const k = x._$GetPlugin$_(), O = x._$GetObjectClass$_()._$GetDefaultInstanceData$_()[0];
                            k._$IsWorldType$_() ? this._$_CreateChildInstancesFromData$_(x, O, P, e, P._$GetX$_(), P._$GetY$_(), a) : this._$_CreateChildInstancesFromData$_(x, O, P, e, void 0, void 0, a);
                        }
                    }
                    if (!n && h) {
                        void 0 === i && (i = p[0]), void 0 === r && (r = p[1]);
                        const D = C._$GetTopParent$_(), $ = i - C._$GetX$_() + D._$GetX$_(), U = r - C._$GetY$_() + D._$GetY$_();
                        D._$SetXY$_($, U);
                    }
                    u._$_SetIIDsStale$_();
                    const N = l ? C33._$cloneArray$_(l[5]) : null, F = l ? l[4].map(t => C33._$cloneArray$_(t)) : null, S = c && p && p[13];
                    if (S && m._$_SetHasTilemap$_(), m._$_CreateSdkInstance$_(N, F), 
                    S) {
                        const L = p[13];
                        m._$GetSdkInstance$_()._$LoadTilemapData$_(L[2], L[0], L[1]);
                    }
                    this._$_instancesPendingCreate$_.push(m), this._$_hasPendingInstances$_ = !0, 
                    this._$IsDebug$_() && C3Debugger.InstanceCreated(m);
                    const _ = this._$_eventObjects$_.instancecreate;
                    return _.instance = m, this._$_dispatcher$_.dispatchEvent(_), 
                    m;
                }
                _$_GetInstanceData$_(t) {
                    const e = t[0], s = t[1], i = t[2], r = t[6];
                    if (r) return r;
                    const n = this._$_layoutManager$_._$GetLayoutBySID$_(e), h = n._$GetLayer$_(s);
                    return h._$GetInitialInstanceData$_(i);
                }
                _$_MaybeGetChildInstanceForObjectTypeData$_(t, e, s) {
                    const i = e?._$GetSceneGraphChildrenExportData$_() ?? [];
                    for (const r of i) {
                        const n = this._$_GetInstanceData$_(r), h = !!r[4], o = this._$GetObjectClassByIndex$_(n[1]);
                        if (!s.has(n) && t === o && h) return s.add(n), n;
                    }
                }
                _$_CreateChildInstancesFromData$_(a, t, e, l, u, c, f) {
                    const s = e._$GetSceneGraphZIndexExportData$_(), i = e._$GetSceneGraphChildrenExportData$_();
                    if (a._$GetWorldInfo$_()._$SetSceneGraphZIndex$_(s), i) {
                        void 0 === u && (u = t[0]), void 0 === c && (c = t[1]);
                        const d = new Set(), p = t[0], m = t[1];
                        for (const C of i) {
                            let t = C[0], e = C[1], s = C[2], i = C[3], r = !!C[4], n = C[5], h = C[6], o;
                            if (h) o = h; else {
                                const T = this._$_layoutManager$_._$GetLayoutBySID$_(t), y = T._$GetLayer$_(e);
                                o = y._$GetInitialInstanceData$_(s);
                            }
                            const g = this._$GetObjectClassByIndex$_(o[1]), S = a._$HasSibling$_(g), _ = d.has(g);
                            if (S && !_ && r) {
                                const E = a._$GetSibling$_(g), A = (E._$GetWorldInfo$_()._$Init$_(o[0]), 
                                u + o[0][0] - p), I = c + o[0][1] - m;
                                E._$GetWorldInfo$_()._$SetXY$_(A, I), E._$GetWorldInfo$_()._$SetSceneGraphZIndex$_(n), 
                                a._$AddChild$_(E, {
                                    _$transformX$_: !!(i >> 0 & 1),
                                    _$transformY$_: !!(i >> 1 & 1),
                                    _$transformWidth$_: !!(i >> 2 & 1),
                                    _$transformHeight$_: !!(i >> 3 & 1),
                                    _$transformAngle$_: !!(i >> 4 & 1),
                                    _$destroyWithParent$_: !!(i >> 5 & 1),
                                    _$transformZElevation$_: !!(i >> 6 & 1),
                                    _$transformOpacity$_: !!(i >> 7 & 1),
                                    _$transformVisibility$_: !!(i >> 8 & 1)
                                }), d.add(g);
                            } else {
                                const M = u + o[0][0] - p, w = c + o[0][1] - m, v = this._$CreateInstanceFromData$_(o, l, !1, M, w, !1, !0, a, f);
                                v._$GetWorldInfo$_()._$SetSceneGraphZIndex$_(n), 
                                a._$AddChild$_(v, {
                                    _$transformX$_: !!(i >> 0 & 1),
                                    _$transformY$_: !!(i >> 1 & 1),
                                    _$transformWidth$_: !!(i >> 2 & 1),
                                    _$transformHeight$_: !!(i >> 3 & 1),
                                    _$transformAngle$_: !!(i >> 4 & 1),
                                    _$destroyWithParent$_: !!(i >> 5 & 1),
                                    _$transformZElevation$_: !!(i >> 6 & 1),
                                    _$transformOpacity$_: !!(i >> 7 & 1),
                                    _$transformVisibility$_: !!(i >> 8 & 1)
                                });
                            }
                        }
                    }
                }
                _$DestroyInstance$_(s) {
                    if (!this._$_instancesPendingRelease$_.has(s)) {
                        let t = s._$GetObjectClass$_(), e = this._$_instancesPendingDestroy$_.get(t);
                        if (e) {
                            if (e.has(s)) return;
                            e.add(s);
                        } else (e = new Set()).add(s), this._$_instancesPendingDestroy$_.set(t, e);
                        if (this._$IsDebug$_() && C3Debugger.InstanceDestroyed(s), 
                        s._$_MarkDestroyed$_(), this._$_hasPendingInstances$_ = !0, 
                        s._$IsInContainer$_()) for (const i of s._$siblings$_()) this._$DestroyInstance$_(i);
                        for (const r of s.children()) r._$GetDestroyWithParent$_() && this._$DestroyInstance$_(r);
                        if (!this._$_layoutManager$_._$IsEndingLayout$_() && !this._$_isLoadingState$_) {
                            const n = this._$GetEventSheetManager$_();
                            n._$BlockFlushingInstances$_(!0), s._$_TriggerOnDestroyed$_(), 
                            n._$BlockFlushingInstances$_(!1);
                        }
                        s._$_FireDestroyedScriptEvents$_(this._$_layoutManager$_._$IsEndingLayout$_());
                    }
                }
                _$FlushPendingInstances$_() {
                    this._$_hasPendingInstances$_ && (this._$_isFlushingPendingInstances$_ = !0, 
                    this._$_FlushInstancesPendingCreate$_(), this._$_FlushInstancesPendingDestroy$_(), 
                    this._$_isFlushingPendingInstances$_ = !1, this._$_hasPendingInstances$_ = !1, 
                    this._$UpdateRender$_());
                }
                _$_FlushInstancesPendingCreate$_() {
                    for (const t of this._$_instancesPendingCreate$_) {
                        const e = t._$GetObjectClass$_();
                        e._$_AddInstance$_(t);
                        for (const s of e._$GetFamilies$_()) s._$_AddInstance$_(t), 
                        s._$_SetIIDsStale$_();
                    }
                    C33._$clearArray$_(this._$_instancesPendingCreate$_);
                }
                _$_FlushInstancesPendingDestroy$_() {
                    this._$_dispatcher$_._$SetDelayRemoveEventsEnabled$_(!0);
                    for (const [ t, e ] of this._$_instancesPendingDestroy$_.entries()) this._$_FlushInstancesPendingDestroyForObjectClass$_(t, e), 
                    e.clear();
                    this._$_instancesPendingDestroy$_.clear(), this._$_dispatcher$_._$SetDelayRemoveEventsEnabled$_(!1);
                }
                _$_FlushInstancesPendingDestroyForObjectClass$_(t, e) {
                    for (const s of e) {
                        const i = this._$_eventObjects$_.instancedestroy, r = (i.instance = s, 
                        this._$_dispatcher$_.dispatchEvent(i), this._$_instancesByUid$_.delete(s._$GetUID$_()), 
                        this._$_instanceTimes$_.delete(s), s._$GetWorldInfo$_());
                        r && (r._$_RemoveFromCollisionCells$_(), r._$_RemoveFromRenderCells$_(), 
                        r._$_MarkDestroyed$_()), this._$_instancesPendingRelease$_.add(s), 
                        this._$_objectCount$_--;
                    }
                    C33._$arrayRemoveAllInSet$_(t._$GetInstances$_(), e), t._$_SetIIDsStale$_(), 
                    this._$_instancesPendingReleaseAffectedObjectClasses$_.add(t);
                    for (const n of t._$GetFamilies$_()) C33._$arrayRemoveAllInSet$_(n._$GetInstances$_(), e), 
                    n._$_SetIIDsStale$_(), this._$_instancesPendingReleaseAffectedObjectClasses$_.add(n);
                    if (t._$GetPlugin$_()._$IsWorldType$_()) {
                        const h = new Set([ ...e ].map(t => t._$GetWorldInfo$_()._$GetLayer$_()));
                        for (const o of h) o._$_RemoveAllInstancesInSet$_(e);
                    }
                }
                _$_GetInstancesPendingCreate$_() {
                    return this._$_instancesPendingCreate$_;
                }
                *_$instancesPendingCreateForObjectClass$_(t) {
                    for (const e of this._$_GetInstancesPendingCreate$_()) t._$IsFamily$_() ? e._$GetObjectClass$_()._$BelongsToFamily$_(t) && (yield e) : e._$GetObjectClass$_() === t && (yield e);
                }
                _$_GetNewUID$_() {
                    return this._$_nextUid$_++;
                }
                _$_MapInstanceByUID$_(t, e) {
                    this._$_instancesByUid$_.set(t, e);
                }
                _$_SetAutoSuspendEnabled$_(t) {
                    this._$_isAutoSuspendEnabled$_ !== (t = !!t) && (this._$_isAutoSuspendEnabled$_ = !!t, 
                    this._$_isAutoSuspendEnabled$_) && this._$_isPageVisibilitySuspended$_ && (this._$SetSuspended$_(!1), 
                    this._$_isPageVisibilitySuspended$_ = !1);
                }
                _$_IsAutoSuspendEnabled$_() {
                    return this._$_isAutoSuspendEnabled$_;
                }
                _$_OnRendererContextLost$_() {
                    this._$_dispatcher$_.dispatchEvent(C33._$New$_(C33.Event, "renderercontextlost")), 
                    this._$SetSuspended$_(!0);
                    for (const e of this._$_allObjectClasses$_) !e._$IsFamily$_() && e._$HasLoadedTextures$_() && e._$ReleaseTextures$_();
                    const t = this._$GetMainRunningLayout$_();
                    t && t._$_OnRendererContextLost$_(), C33._$ImageInfo$_._$OnRendererContextLost$_(), 
                    C33._$ImageAsset$_._$OnRendererContextLost$_();
                }
                async _$_OnRendererContextRestored$_() {
                    await this._$GetMainRunningLayout$_()._$_Load$_(null, this._$GetRenderer$_()), 
                    this._$_dispatcher$_.dispatchEvent(C33._$New$_(C33.Event, "renderercontextrestored")), 
                    this._$SetSuspended$_(!1), this._$UpdateRender$_();
                }
                _$_OnVisibilityChange$_(t) {
                    if (this._$_isAutoSuspendEnabled$_) {
                        const e = t.hidden;
                        this._$SetSuspended$_(e), (this._$_isPageVisibilitySuspended$_ = e) || this._$UpdateRender$_();
                    }
                }
                _$_OnWindowBlur$_(t) {
                    this._$IsPreview$_() && this._$_pauseOnBlur$_ && !C33._$Platform$_._$IsMobile$_ && !t.data.parentHasFocus && (this._$SetSuspended$_(!0), 
                    this._$_isPausedOnBlur$_ = !0);
                }
                _$_OnWindowFocus$_() {
                    this._$_isPausedOnBlur$_ && (this._$SetSuspended$_(!1), this._$_isPausedOnBlur$_ = !1);
                }
                _$_RequestAnimationFrame$_() {
                    const t = this._$_tickCallbacks$_;
                    "vsync" === this._$_framerateMode$_ ? -1 === this._$_rafId$_ && (this._$_rafId$_ = self.requestAnimationFrame(t._$normal$_)) : "unlimited-tick" === this._$_framerateMode$_ ? (-1 === this._$_ruafId$_ && (this._$_ruafId$_ = C33._$RequestUnlimitedAnimationFrame$_(t._$tickOnly$_)), 
                    -1 === this._$_rafId$_ && (this._$_rafId$_ = self.requestAnimationFrame(t._$renderOnly$_))) : -1 === this._$_ruafId$_ && (this._$_ruafId$_ = C33._$RequestUnlimitedAnimationFrame$_(t._$normal$_));
                }
                _$_CancelAnimationFrame$_() {
                    -1 !== this._$_rafId$_ && (self.cancelAnimationFrame(this._$_rafId$_), 
                    this._$_rafId$_ = -1), -1 !== this._$_ruafId$_ && (C33._$CancelUnlimitedAnimationFrame$_(this._$_ruafId$_), 
                    this._$_ruafId$_ = -1);
                }
                _$IsSuspended$_() {
                    return 0 < this._$_suspendCount$_;
                }
                _$SetSuspended$_(t) {
                    if (!this._$IsExportToVideo$_()) {
                        const e = this._$IsSuspended$_(), s = (this._$_suspendCount$_ += t ? 1 : -1, 
                        this._$_suspendCount$_ < 0 && (this._$_suspendCount$_ = 0), 
                        this._$IsSuspended$_());
                        if (!e && s) console.log("[Construct] Suspending"), this._$_CancelAnimationFrame$_(), 
                        this._$_dispatcher$_.dispatchEvent(C33._$New$_(C33.Event, "suspend")), 
                        this._$Trigger$_(C33._$Plugins$_._$System$_._$Cnds$_._$OnSuspend$_, null, null); else if (e && !s) {
                            console.log("[Construct] Resuming");
                            const i = performance.now();
                            this._$_lastTickTime$_ = i, this._$_fpsLastTime$_ = i, 
                            this._$_fpsFrameCount$_ = 0, this._$_fps$_ = 0, this._$_tpsTickCount$_ = 0, 
                            this._$_tps$_ = 0, this._$_mainThreadTime$_ = 0, this._$_mainThreadTimeCounter$_ = 0, 
                            this._$_dispatcher$_.dispatchEvent(C33._$New$_(C33.Event, "resume")), 
                            this._$Trigger$_(C33._$Plugins$_._$System$_._$Cnds$_._$OnResume$_, null, null), 
                            this._$HitBreakpoint$_() || this._$Tick$_(i);
                        }
                    }
                }
                _$_AddBehInstToTick$_(t) {
                    this._$_behInstsToTick$_._$Add$_(t);
                }
                _$_AddBehInstToPostTick$_(t) {
                    this._$_behInstsToPostTick$_._$Add$_(t);
                }
                _$_AddBehInstToTick2$_(t) {
                    this._$_behInstsToTick2$_._$Add$_(t);
                }
                _$_RemoveBehInstToTick$_(t) {
                    this._$_behInstsToTick$_._$Remove$_(t);
                }
                _$_RemoveBehInstToPostTick$_(t) {
                    this._$_behInstsToPostTick$_._$Remove$_(t);
                }
                _$_RemoveBehInstToTick2$_(t) {
                    this._$_behInstsToTick2$_._$Remove$_(t);
                }
                _$_BehaviorTick$_() {
                    const t = globalThis._$ISDKBehaviorInstanceBase$_;
                    this._$_behInstsToTick$_._$SetQueueingEnabled$_(!0);
                    for (const e of this._$_behInstsToTick$_) e instanceof t ? e._$_tick$_() : e._$Tick$_();
                    this._$_behInstsToTick$_._$SetQueueingEnabled$_(!1);
                }
                _$_BehaviorPostTick$_() {
                    const t = globalThis._$ISDKBehaviorInstanceBase$_;
                    this._$_behInstsToPostTick$_._$SetQueueingEnabled$_(!0);
                    for (const e of this._$_behInstsToPostTick$_) e instanceof t ? e._$_postTick$_() : e._$PostTick$_();
                    this._$_behInstsToPostTick$_._$SetQueueingEnabled$_(!1);
                }
                _$_BehaviorTick2$_() {
                    const t = globalThis._$ISDKBehaviorInstanceBase$_;
                    this._$_behInstsToTick2$_._$SetQueueingEnabled$_(!0);
                    for (const e of this._$_behInstsToTick2$_) e instanceof t ? e._$_tick2$_() : e._$Tick2$_();
                    this._$_behInstsToTick2$_._$SetQueueingEnabled$_(!1);
                }
                *_$_DebugBehaviorTick$_() {
                    const e = globalThis._$ISDKBehaviorInstanceBase$_;
                    this._$_behInstsToTick$_._$SetQueueingEnabled$_(!0);
                    for (const s of this._$_behInstsToTick$_) {
                        let t;
                        t = s instanceof e ? s._$_tick$_() : s._$Tick$_(), C33._$IsIterator$_(t) && (yield* t);
                    }
                    this._$_behInstsToTick$_._$SetQueueingEnabled$_(!1);
                }
                *_$_DebugBehaviorPostTick$_() {
                    const e = globalThis._$ISDKBehaviorInstanceBase$_;
                    this._$_behInstsToPostTick$_._$SetQueueingEnabled$_(!0);
                    for (const s of this._$_behInstsToPostTick$_) {
                        let t;
                        t = s instanceof e ? s._$_postTick$_() : s._$PostTick$_(), 
                        C33._$IsIterator$_(t) && (yield* t);
                    }
                    this._$_behInstsToPostTick$_._$SetQueueingEnabled$_(!1);
                }
                *_$_DebugBehaviorTick2$_() {
                    const e = globalThis._$ISDKBehaviorInstanceBase$_;
                    this._$_behInstsToTick2$_._$SetQueueingEnabled$_(!0);
                    for (const s of this._$_behInstsToTick2$_) {
                        let t;
                        t = s instanceof e ? s._$_tick2$_() : s._$Tick2$_(), C33._$IsIterator$_(t) && (yield* t);
                    }
                    this._$_behInstsToTick2$_._$SetQueueingEnabled$_(!1);
                }
                async _$Tick$_(a, t, e) {
                    this._$_hasStartedTicking$_ = !0;
                    const l = "background-wake" === e, u = "background-wake" !== e && "skip-render" !== e, c = this._$GetLayoutManager$_(), f = this._$GetCanvasManager$_();
                    if (this._$_hasStarted$_ && (!this._$IsSuspended$_() || t || l)) {
                        let t = performance.now(), e = (this._$_isInTick$_ = !0, 
                        this._$_MeasureDt$_(a || 0), this._$_tpsTickCount$_++, this._$_ReleasePendingInstances$_(), 
                        this._$Step_BeforePreTick$_()), s = (this._$IsDebugging$_() && await e, 
                        this._$_dispatcher$_._$dispatchEventAndWait_AsyncOptional$_(this._$_eventObjects$_.pretick)), i = (s instanceof Promise && await s, 
                        this._$DispatchUserScriptEvent$_(this._$_userScriptEventObjects$_.pretick), 
                        this._$Step_AfterPreTick$_()), r = (this._$IsDebugging$_() && await i, 
                        this._$_NeedsHandleSaveOrLoad$_() && await this._$_HandleSaveOrLoad$_(), 
                        c._$IsPendingChangeMainLayout$_() && await this._$_MaybeChangeLayout$_(), 
                        this._$Step_RunEventsEtc$_()), n = (this._$IsDebugging$_() && await r, 
                        c._$GetMainRunningLayout$_()), h = n._$_GetPendingSetHTMLLayerCount$_(), o = !1;
                        if (-1 !== h && (n._$_ResetPendingHTMLLayerCount$_(), f._$GetHTMLLayerCount$_() !== h)) {
                            const d = this._$GetCanvasManager$_()._$SetHTMLLayerCount$_(h);
                            this._$IsInWorker$_() && (o = !0, await d);
                        }
                        this._$PostComponentMessageToDOM$_("canvas", "update-html-layer-dom-state", {
                            layersDomState: n._$_GetRootLayers$_().filter(t => t._$IsHTMLElementsLayer$_()).map(t => t._$_GetHTMLLayerDOMState$_())
                        }), u && this._$Render$_(), o && this._$PostComponentMessageToDOM$_("canvas", "cleanup-html-layers"), 
                        this._$IsExportToVideo$_() && (await this._$_ExportToVideoAddFrame$_(), 
                        this._$GetGameTime$_() >= this._$GetExportVideoDuration$_()) ? this._$_ExportToVideoFinish$_() : (this._$IsSuspended$_() || l || this._$_RequestAnimationFrame$_(), 
                        this._$_tickCount$_++, this._$_tickCountNoSave$_++, this._$_isInTick$_ = !1, 
                        this._$_mainThreadTimeCounter$_ += performance.now() - t);
                    }
                }
                async _$Step_BeforePreTick$_() {
                    const t = this._$_eventSheetManager$_, e = this._$IsDebug$_();
                    this._$FlushPendingInstances$_(), t._$BlockFlushingInstances$_(!0), 
                    this._$PushCurrentLayout$_(this._$GetMainRunningLayout$_()), 
                    e && C3Debugger.StartMeasuringTime(), this._$IsDebugging$_() ? await t._$DebugRunScheduledWaits$_() : t._$RunScheduledWaits$_(), 
                    e && C3Debugger.AddEventsTime(), this._$PopCurrentLayout$_(), 
                    t._$BlockFlushingInstances$_(!1), this._$FlushPendingInstances$_(), 
                    t._$BlockFlushingInstances$_(!0);
                }
                async _$Step_AfterPreTick$_() {
                    const t = this._$_eventSheetManager$_, e = this._$IsDebug$_(), s = this._$IsDebugging$_(), i = this._$_dispatcher$_, r = this._$_eventObjects$_, n = this._$_userScriptEventObjects$_;
                    e && C3Debugger.StartMeasuringTime(), s ? await this._$DebugIterateAndBreak$_(this._$_DebugBehaviorTick$_()) : this._$_BehaviorTick$_(), 
                    s ? await this._$DebugIterateAndBreak$_(this._$_DebugBehaviorPostTick$_()) : this._$_BehaviorPostTick$_(), 
                    e && C3Debugger.AddBehaviorTickTime(), e && C3Debugger.StartMeasuringTime(), 
                    s ? await this._$DebugFireGeneratorEventAndBreak$_(r.tick) : i.dispatchEvent(r.tick), 
                    e && C3Debugger.AddPluginTickTime(), t._$BlockFlushingInstances$_(!1), 
                    this._$DispatchUserScriptEvent$_(n.tick);
                }
                async _$Step_RunEventsEtc$_() {
                    const t = this._$_eventSheetManager$_, e = this._$_dispatcher$_, s = this._$_eventObjects$_, i = this._$_userScriptEventObjects$_, r = this._$IsDebug$_(), n = this._$IsDebugging$_();
                    r && C3Debugger.StartMeasuringTime(), n ? await t._$DebugRunEvents$_(this._$_layoutManager$_) : t._$RunEvents$_(this._$_layoutManager$_), 
                    r && C3Debugger.AddEventsTime(), this._$_collisionEngine$_._$ClearRegisteredCollisions$_(), 
                    this._$_ReleasePendingInstances$_(), this._$_isLayoutFirstTick$_ = !1, 
                    t._$BlockFlushingInstances$_(!0), r && C3Debugger.StartMeasuringTime(), 
                    n ? await this._$DebugIterateAndBreak$_(this._$_DebugBehaviorTick2$_()) : this._$_BehaviorTick2$_(), 
                    r && C3Debugger.AddBehaviorTickTime(), r && C3Debugger.StartMeasuringTime(), 
                    n ? await this._$DebugFireGeneratorEventAndBreak$_(s.tick2) : e.dispatchEvent(s.tick2), 
                    r && C3Debugger.AddPluginTickTime(), t._$BlockFlushingInstances$_(!1), 
                    this._$DispatchUserScriptEvent$_(i.tick2), n && await t._$RunQueuedDebugTriggersAsync$_();
                }
                _$_ReleasePendingInstances$_() {
                    if (0 !== this._$_instancesPendingRelease$_.size) {
                        const t = this._$_dispatcher$_;
                        t._$SetDelayRemoveEventsEnabled$_(!0);
                        for (const e of this._$_instancesPendingReleaseAffectedObjectClasses$_) e._$GetSolStack$_()._$RemoveInstances$_(this._$_instancesPendingRelease$_);
                        this._$_instancesPendingReleaseAffectedObjectClasses$_.clear(), 
                        this._$_eventSheetManager$_._$_OnInstancesReleased$_(this._$_instancesPendingRelease$_);
                        for (const s of this._$_instancesPendingRelease$_) s._$Release$_();
                        this._$_instancesPendingRelease$_.clear(), t._$SetDelayRemoveEventsEnabled$_(!1);
                    }
                }
                async _$_MaybeChangeLayout$_() {
                    let t = this._$GetLayoutManager$_(), e = 0;
                    for (;t._$IsPendingChangeMainLayout$_() && e++ < 10; ) await this._$_DoChangeLayout$_(t._$GetPendingChangeMainLayout$_());
                }
                _$_MeasureDt$_(t) {
                    let e = 0;
                    if (this._$IsExportToVideo$_()) e = 1 / this._$GetExportVideoFramerate$_(), 
                    this._$_dtRaw$_ = e, this._$_dt1$_ = e; else if (0 !== this._$_lastTickTime$_) {
                        const s = Math.max(t - this._$_lastTickTime$_, 0);
                        .5 < (e = s / 1e3) && (e = 0), this._$_dtRaw$_ = e, this._$_dt1$_ = C33._$clamp$_(e, this._$_minDt$_, this._$_maxDt$_);
                    }
                    this._$_lastTickTime$_ = t, this._$_dt$_ = this._$_dt1$_ * this._$_timeScale$_, 
                    this._$_gameTime$_._$Add$_(this._$_dt$_), this._$_gameTimeRaw$_._$Add$_(e * this._$_timeScale$_), 
                    this._$_wallTime$_._$Add$_(this._$_dt1$_);
                    for (const [ i, r ] of this._$_instanceTimes$_) r._$Add$_(this._$_dt1$_ * i._$GetTimeScale$_());
                    this._$_canvasManager$_ && this._$_canvasManager$_._$_UpdateTick$_(), 
                    1e3 <= t - this._$_fpsLastTime$_ && (this._$_fpsLastTime$_ += 1e3, 
                    1e3 <= t - this._$_fpsLastTime$_ && (this._$_fpsLastTime$_ = t), 
                    this._$_fps$_ = this._$_fpsFrameCount$_, this._$_fpsFrameCount$_ = 0, 
                    this._$_tps$_ = this._$_tpsTickCount$_, this._$_tpsTickCount$_ = 0, 
                    this._$_mainThreadTime$_ = Math.min(this._$_mainThreadTimeCounter$_ / 1e3, 1), 
                    this._$_mainThreadTimeCounter$_ = 0, this._$_canvasManager$_ && this._$_canvasManager$_._$_Update1sFrameRange$_(), 
                    this._$_collisionEngine$_._$_Update1sStats$_(), this._$IsDebug$_()) && C3Debugger.Update1sPerfStats();
                }
                _$_SetTrackingInstanceTime$_(t, e) {
                    if (e) {
                        if (!this._$_instanceTimes$_.has(t)) {
                            const s = C33._$New$_(C33._$KahanSum$_);
                            s._$Copy$_(this._$_gameTime$_), this._$_instanceTimes$_.set(t, s);
                        }
                    } else this._$_instanceTimes$_.delete(t);
                }
                _$_GetInstanceGameTime$_(t) {
                    const e = this._$_instanceTimes$_.get(t);
                    return e ? e._$Get$_() : this._$GetGameTime$_();
                }
                async _$_DoChangeLayout$_(t) {
                    const e = this._$_dispatcher$_, s = this._$GetLayoutManager$_(), i = s._$GetMainRunningLayout$_();
                    await i._$_StopRunning$_(), i._$_Unload$_(t, this._$GetRenderer$_()), 
                    i === t && this._$_eventSheetManager$_._$ClearAllScheduledWaits$_(), 
                    this._$_collisionEngine$_._$ClearRegisteredCollisions$_(), this._$_ReleasePendingInstances$_(), 
                    e.dispatchEvent(this._$_eventObjects$_.beforelayoutchange), 
                    C33._$Asyncify$_._$SetHighThroughputMode$_(!0), await t._$_Load$_(i, this._$GetRenderer$_()), 
                    C33._$Asyncify$_._$SetHighThroughputMode$_(!1), await t._$_StartRunning$_(!1), 
                    e.dispatchEvent(this._$_eventObjects$_.layoutchange), this._$UpdateRender$_(), 
                    this._$_isLayoutFirstTick$_ = !0, this._$FlushPendingInstances$_(), 
                    this._$_ExportToVideoAddKeyframe$_();
                }
                _$UpdateRender$_() {
                    this._$_needRender$_ = !0;
                }
                _$GetWebGLRenderer$_() {
                    return this._$_canvasManager$_ ? this._$_canvasManager$_._$GetWebGLRenderer$_() : null;
                }
                _$GetWebGPURenderer$_() {
                    return this._$_canvasManager$_ ? this._$_canvasManager$_._$GetWebGPURenderer$_() : null;
                }
                _$GetRenderer$_() {
                    return this._$_canvasManager$_ ? this._$_canvasManager$_._$GetRenderer$_() : null;
                }
                _$Render$_() {
                    const s = this._$_canvasManager$_;
                    if (s && !s._$IsRendererContextLost$_()) {
                        const i = this._$GetRenderer$_(), t = i._$SupportsGPUProfiling$_(), r = t && i._$IsWebGL$_(), n = t && i._$IsWebGPU$_();
                        if (r && i._$CheckForQueryResults$_(), this._$_needRender$_ || this._$IsExportToVideo$_()) {
                            const h = this._$_layoutManager$_._$GetMainRunningLayout$_(), o = (this._$_fpsFrameCount$_++, 
                            i._$Start$_(), this._$IsDebug$_());
                            o && C3Debugger.StartMeasuringTime(), this._$_needRender$_ = !1;
                            let t = null, e = (r && (t = s._$GetGPUFrameTimingsBuffer$_()._$AddTimeElapsedQuery$_(), 
                            i._$StartQuery$_(t)), null);
                            n && (e = i._$StartFrameTiming$_(2 * (1 + h._$GetLayerCount$_())), 
                            i._$StartMeasuringRenderPassTime$_(0, 1)), this._$Uses3DFeatures$_() && "low" === s._$GetCurrentFullscreenScalingQuality$_() ? i._$SetFixedSizeDepthBuffer$_(s._$GetDrawWidth$_(), s._$GetDrawHeight$_()) : i._$SetAutoSizeDepthBuffer$_(), 
                            this._$_Render$_(this._$GetRenderer$_(), h), t && i._$EndQuery$_(t), 
                            n && (i._$StopMeasuringRenderPassTime$_(), this._$_canvasManager$_._$_AddWebGPUFrameTiming$_(e)), 
                            i._$Finish$_(), o && (C3Debugger.AddDrawCallsTime(), 
                            C3Debugger.UpdateInspectHighlight()), s && s._$_MaybeTakeSnapshot$_();
                        } else i._$IncrementFrameNumber$_();
                    }
                }
                _$_NeedsHTMLLayerCompositing$_(t) {
                    return "low" === this._$GetCanvasManager$_()._$GetCurrentFullscreenScalingQuality$_() || t._$IsWebGL$_() && (this._$UsesAnyBackgroundBlending$_() || this._$Uses3DFeatures$_());
                }
                _$_Render$_(e, s) {
                    e._$SetTextureFillMode$_(), e._$SetAlphaBlend$_(), e._$SetColorRgba$_(1, 1, 1, 1), 
                    e._$SetRenderTarget$_(null), e._$SetTexture$_(null), e._$SetDepthEnabled$_(this._$Uses3DFeatures$_()), 
                    this._$_NeedsHTMLLayerCompositing$_(e) && s._$_MaybeStartDrawToOwnTexture$_(e);
                    const i = s._$GetHTMLLayerCount$_();
                    for (let t = 1; t < i; ++t) s._$DrawForHTMLLayerIndex$_(e, t), 
                    e._$IsWebGPU$_() && e._$Restart$_();
                    this._$_NeedsHTMLLayerCompositing$_(e) || s._$_MaybeStartDrawToOwnTexture$_(e), 
                    s._$DrawMain$_(e);
                }
                _$Trigger$_(t, e, s) {
                    if (!this._$_hasStarted$_) return !1;
                    let i = !this._$_isInTick$_ && !this._$_eventSheetManager$_._$IsInTrigger$_(), r = 0;
                    i && (r = performance.now());
                    const n = this._$IsDebug$_(), h = (n && this._$SetDebuggingEnabled$_(!1), 
                    this._$_eventSheetManager$_._$_Trigger$_(this._$_layoutManager$_, t, e, s));
                    if (i) {
                        const o = performance.now() - r;
                        this._$_mainThreadTimeCounter$_ += o, n && C3Debugger.AddTriggersTime(o);
                    }
                    return n && this._$SetDebuggingEnabled$_(!0), h;
                }
                _$DebugTrigger$_(t, e, s) {
                    if (!this._$IsDebugging$_()) return this._$Trigger$_(t, e, s);
                    if (this._$HitBreakpoint$_()) throw new Error("called DebugTrigger() while stopped on breakpoint");
                    if (this._$_isInTick$_ || this._$_eventSheetManager$_._$IsInTrigger$_()) return this._$_eventSheetManager$_._$_DebugTrigger$_(this._$_layoutManager$_, t, e, s);
                    throw new Error("called DebugTrigger() outside of event code - use TriggerAsync() instead");
                }
                async _$TriggerAsync$_(t, e, s) {
                    if (!this._$IsDebugging$_()) return this._$Trigger$_(t, e, s);
                    if (!this._$_hasStarted$_) return !1;
                    if (this._$HitBreakpoint$_()) return this._$_eventSheetManager$_._$QueueDebugTrigger$_(t, e, s);
                    if (!this._$GetMainRunningLayout$_()) return this._$_eventSheetManager$_._$QueueTrigger$_(t, e, s);
                    let i = performance.now(), r = this._$_eventSheetManager$_._$_DebugTrigger$_(this._$_layoutManager$_, t, e, s), n = r.next();
                    for (;!n.done; ) await this._$DebugBreak$_(n.value), n = r.next();
                    return this._$IsSuspended$_() || this._$_eventSheetManager$_._$IsInTrigger$_() || (await this._$_eventSheetManager$_._$RunQueuedDebugTriggersAsync$_(), 
                    this._$_hasStartedTicking$_ && !this._$_isInTick$_ && this._$_RequestAnimationFrame$_()), 
                    this._$_mainThreadTimeCounter$_ += performance.now() - i, n.value;
                }
                _$FastTrigger$_(t, e, s) {
                    const i = this._$IsDebug$_(), r = (i && this._$SetDebuggingEnabled$_(!1), 
                    this._$_eventSheetManager$_._$_FastTrigger$_(this._$_layoutManager$_, t, e, s));
                    return i && this._$SetDebuggingEnabled$_(!0), r;
                }
                _$DebugFastTrigger$_(t, e, s) {
                    return this._$_eventSheetManager$_._$_DebugFastTrigger$_(this._$_layoutManager$_, t, e, s);
                }
                _$ScheduleTriggers$_(t) {
                    return this._$_scheduleTriggersThrottle$_._$Add$_(t);
                }
                _$PushCurrentLayout$_(t) {
                    this._$_currentLayoutStack$_.push(t);
                }
                _$PopCurrentLayout$_() {
                    if (!this._$_currentLayoutStack$_.length) throw new Error("layout stack empty");
                    this._$_currentLayoutStack$_.pop();
                }
                _$GetCurrentLayout$_() {
                    return this._$_currentLayoutStack$_.length ? this._$_currentLayoutStack$_.at(-1) : this._$GetMainRunningLayout$_();
                }
                _$GetDt$_(t) {
                    return t && -1 !== t._$GetTimeScale$_() ? this._$_dt1$_ * t._$GetTimeScale$_() : this._$_dt$_;
                }
                _$_GetDtFast$_() {
                    return this._$_dt$_;
                }
                _$GetDt1$_() {
                    return this._$_dt1$_;
                }
                _$GetDtRaw$_() {
                    return this._$_dtRaw$_;
                }
                _$GetTimeScale$_() {
                    return this._$_timeScale$_;
                }
                _$SetTimeScale$_(t) {
                    (isNaN(t) || t < 0) && (t = 0), this._$_timeScale$_ = t;
                }
                _$SetMinDt$_(t) {
                    this._$_minDt$_ = Math.max(t, 0);
                }
                _$GetMinDt$_() {
                    return this._$_minDt$_;
                }
                _$SetMaxDt$_(t) {
                    this._$_maxDt$_ = Math.max(t, 0);
                }
                _$GetMaxDt$_() {
                    return this._$_maxDt$_;
                }
                _$GetFramesPerSecond$_() {
                    return this._$_fps$_;
                }
                _$GetTicksPerSecond$_() {
                    return this._$_tps$_;
                }
                _$GetMainThreadTime$_() {
                    return this._$_mainThreadTime$_;
                }
                _$GetStartTime$_() {
                    return this._$_startTime$_;
                }
                _$GetGameTime$_() {
                    return this._$_gameTime$_._$Get$_();
                }
                _$GetGameTimeRaw$_() {
                    return this._$_gameTimeRaw$_._$Get$_();
                }
                _$GetWallTime$_() {
                    return this._$_wallTime$_._$Get$_();
                }
                _$GetTickCount$_() {
                    return this._$_tickCount$_;
                }
                _$GetTickCountNoSave$_() {
                    return this._$_tickCountNoSave$_;
                }
                _$GetObjectCount$_() {
                    return this._$_objectCount$_;
                }
                _$GetProjectName$_() {
                    return this._$_projectName$_;
                }
                _$GetProjectVersion$_() {
                    return this._$_projectVersion$_;
                }
                _$GetProjectUniqueId$_() {
                    return this._$_projectUniqueId$_;
                }
                _$GetAppId$_() {
                    return this._$_appId$_;
                }
                _$GetExportTimestamp$_() {
                    return this._$_exportTimestamp$_;
                }
                _$GetInstanceByUID$_(t) {
                    if (this._$_isLoadingState$_) throw new Error("cannot call while loading state - wait until afterload event");
                    return this._$_instancesByUid$_.get(t) || null;
                }
                _$_RefreshUidMap$_() {
                    this._$_instancesByUid$_.clear();
                    for (const t of this._$_allObjectClasses$_) if (!t._$IsFamily$_()) for (const e of t._$GetInstances$_()) this._$_instancesByUid$_.set(e._$GetUID$_(), e);
                }
                _$IsPreview$_() {
                    return "preview" === this._$_exportType$_;
                }
                _$IsDebug$_() {
                    return this._$_isDebug$_;
                }
                _$GetExportType$_() {
                    return this._$_exportType$_;
                }
                _$IsNWjs$_() {
                    return "nwjs" === this._$GetExportType$_() || this._$_isNWjs$_;
                }
                _$IsCordova$_() {
                    return "cordova" === this._$_exportType$_;
                }
                _$IsAndroidWebView$_() {
                    return "Android" === C33._$Platform$_._$OS$_ && ("cordova" === this._$_exportType$_ || "playable-ad-single-file" === this._$_exportType$_ || "playable-ad-zip" === this._$_exportType$_ || "instant-games" === this._$_exportType$_);
                }
                _$IsiOSCordova$_() {
                    return this._$_isiOSCordova$_;
                }
                _$IsiOSWebView$_() {
                    return this._$_isiOSWebView$_;
                }
                _$IsWindowsWebView2$_() {
                    return this._$_isWindowsWebView2$_;
                }
                _$IsAnyWebView2Wrapper$_() {
                    return this._$_isAnyWebView2Wrapper$_;
                }
                _$GetCollisionEngine$_() {
                    return this._$_collisionEngine$_;
                }
                _$GetSolidBehavior$_() {
                    return this._$_addonManager$_._$GetSolidBehavior$_();
                }
                _$GetJumpthruBehavior$_() {
                    return this._$_addonManager$_._$GetJumpthruBehavior$_();
                }
                _$Uses3DFeatures$_() {
                    return this._$_uses3dFeatures$_;
                }
                _$GetZScaleFactor$_() {
                    return this._$GetRenderer$_()._$GetZAxisScaleFactor$_(this._$GetViewportHeight$_());
                }
                _$GetDefaultCameraZ$_(t) {
                    return this._$GetRenderer$_()._$GetDefaultCameraZ$_(t || this._$GetViewportHeight$_());
                }
                _$IsLayoutFirstTick$_() {
                    return this._$_isLayoutFirstTick$_;
                }
                _$SetPixelRoundingEnabled$_(t) {
                    this._$_isPixelRoundingEnabled$_ !== (t = !!t) && (this._$_isPixelRoundingEnabled$_ = t, 
                    this._$GetLayoutManager$_()._$SetAllLayerMVChanged$_(), this._$UpdateRender$_());
                }
                _$IsPixelRoundingEnabled$_() {
                    return this._$_isPixelRoundingEnabled$_;
                }
                _$GetTextIconSet$_(t) {
                    if (!this._$_iconChangeHandlers$_.has(t)) {
                        const s = () => this._$DeleteTextIconSet$_(t);
                        this._$_iconChangeHandlers$_.set(t, s), t._$Dispatcher$_().addEventListener("animationframeimagechange", s);
                    }
                    const e = this._$_textIconManager$_._$GetIconSet$_(t);
                    return e._$HasLoaded$_() || e._$LoadContent$_().then(() => this._$UpdateRender$_()), 
                    e;
                }
                _$DeleteTextIconSet$_(t) {
                    this._$_textIconManager$_._$DeleteIconSet$_(t);
                }
                _$_GetTextIconSetMeta$_(t) {
                    const e = [];
                    for (const s of t._$GetAnimations$_()) for (const i of s._$GetFrames$_()) {
                        const r = i._$GetImageInfo$_();
                        e.push({
                            source: i,
                            width: r._$GetWidth$_(),
                            height: r._$GetHeight$_(),
                            tag: i._$GetTag$_()
                        });
                    }
                    return {
                        _$icons$_: e
                    };
                }
                async _$_GetTextIconSetContent$_(t) {
                    const e = C33._$New$_(C33._$PromiseThrottle$_), s = [], r = new Map();
                    for (const h of t._$GetAnimations$_()) for (const o of h._$GetFrames$_()) {
                        const a = o._$GetImageInfo$_()._$GetImageAsset$_();
                        r.has(a) || (r.set(a, null), s.push(e._$Add$_(async () => {
                            const t = await a._$LoadToDrawable$_();
                            r.set(a, t);
                        })));
                    }
                    await Promise.all(s);
                    const i = [];
                    for (const l of t._$GetAnimations$_()) for (const u of l._$GetFrames$_()) i.push(e._$Add$_(async () => {
                        const t = u._$GetImageInfo$_(), e = r.get(t._$GetImageAsset$_()), s = await t._$ExtractImageToCanvas$_(e), i = await createImageBitmap(s);
                        return {
                            _$drawable$_: i
                        };
                    }));
                    const n = await Promise.all(i);
                    for (const c of r.values()) c instanceof ImageBitmap && c.close && c.close();
                    return {
                        _$icons$_: n
                    };
                }
                _$SaveToSlot$_(t) {
                    this._$_saveToSlotName$_ = t, this._$_saveToJsonString$_ = !1;
                }
                _$SaveToJsonString$_() {
                    this._$_saveToSlotName$_ = "", this._$_saveToJsonString$_ = !0;
                }
                _$LoadFromSlot$_(t) {
                    this._$_loadFromSlotName$_ = t;
                }
                _$LoadFromJsonString$_(t) {
                    this._$_loadFromJson$_ = t;
                }
                _$GetLastSaveJsonString$_() {
                    return this._$_lastSaveJson$_;
                }
                _$_NeedsHandleSaveOrLoad$_() {
                    return !!(this._$_saveToSlotName$_ || this._$_saveToJsonString$_ || this._$_loadFromSlotName$_ || null !== this._$_loadFromJson$_);
                }
                async _$_HandleSaveOrLoad$_() {
                    if (this._$_saveToSlotName$_ && (this._$FlushPendingInstances$_(), 
                    await this._$_DoSaveToSlot$_(this._$_saveToSlotName$_), this._$_ClearSaveOrLoad$_()), 
                    this._$_loadFromSlotName$_ && (await this._$_DoLoadFromSlot$_(this._$_loadFromSlotName$_), 
                    this._$_ClearSaveOrLoad$_(), this._$IsDebug$_()) && C3Debugger.StepIfPausedInDebugger(), 
                    this._$_saveToJsonString$_) {
                        const t = await this._$_SaveToJsonString$_();
                        this._$_lastSaveJson$_ = t, await this._$TriggerAsync$_(C33._$Plugins$_._$System$_._$Cnds$_._$OnSaveComplete$_, null), 
                        this._$_lastSaveJson$_ = "", this._$_ClearSaveOrLoad$_();
                    }
                    if (null !== this._$_loadFromJson$_) {
                        this._$FlushPendingInstances$_();
                        try {
                            await this._$_DoLoadFromJsonString$_(this._$_loadFromJson$_), 
                            this._$_lastSaveJson$_ = this._$_loadFromJson$_, await this._$TriggerAsync$_(C33._$Plugins$_._$System$_._$Cnds$_._$OnLoadComplete$_, null), 
                            this._$_lastSaveJson$_ = "";
                        } catch (t) {
                            console.error("[Construct] Failed to load state from JSON string: ", t), 
                            await this._$TriggerAsync$_(C33._$Plugins$_._$System$_._$Cnds$_._$OnLoadFailed$_, null);
                        }
                        this._$_ClearSaveOrLoad$_();
                    }
                }
                _$_ClearSaveOrLoad$_() {
                    this._$_saveToSlotName$_ = "", this._$_saveToJsonString$_ = !1, 
                    this._$_loadFromSlotName$_ = "", this._$_loadFromJson$_ = null;
                }
                _$_GetProjectStorage$_() {
                    return this._$_projectStorage$_ || (this._$_projectStorage$_ = localforage._$createInstance$_({
                        name: "c3-localstorage-" + this._$GetProjectUniqueId$_(),
                        description: this._$GetProjectName$_()
                    })), this._$_projectStorage$_;
                }
                _$_GetSavegamesStorage$_() {
                    return this._$_savegamesStorage$_ || (this._$_savegamesStorage$_ = localforage._$createInstance$_({
                        name: "c3-savegames-" + this._$GetProjectUniqueId$_(),
                        description: this._$GetProjectName$_()
                    })), this._$_savegamesStorage$_;
                }
                async _$_DoSaveToSlot$_(t) {
                    const e = await this._$_SaveToJsonString$_();
                    try {
                        await this._$_GetSavegamesStorage$_().setItem(t, e), console.log("[Construct] Saved state to storage (" + e.length + " chars)"), 
                        this._$_lastSaveJson$_ = e, await this._$TriggerAsync$_(C33._$Plugins$_._$System$_._$Cnds$_._$OnSaveComplete$_, null), 
                        this._$_lastSaveJson$_ = "";
                    } catch (t) {
                        console.error("[Construct] Failed to save state to storage: ", t), 
                        await this._$TriggerAsync$_(C33._$Plugins$_._$System$_._$Cnds$_._$OnSaveFailed$_, null);
                    }
                }
                async _$_DoLoadFromSlot$_(t) {
                    try {
                        const e = await this._$_GetSavegamesStorage$_().getItem(t);
                        if (!e) throw new Error("empty slot");
                        console.log("[Construct] Loaded state from storage (" + e.length + " chars)"), 
                        await this._$_DoLoadFromJsonString$_(e), this._$_lastSaveJson$_ = e, 
                        await this._$TriggerAsync$_(C33._$Plugins$_._$System$_._$Cnds$_._$OnLoadComplete$_, null), 
                        this._$_lastSaveJson$_ = "";
                    } catch (t) {
                        console.error("[Construct] Failed to load state from storage: ", t), 
                        await this._$TriggerAsync$_(C33._$Plugins$_._$System$_._$Cnds$_._$OnLoadFailed$_, null);
                    }
                }
                async _$_SaveToJsonString$_() {
                    const t = {
                        c3save: !0,
                        version: 1,
                        rt: {
                            time: this._$GetGameTime$_(),
                            timeRaw: this._$GetGameTimeRaw$_(),
                            walltime: this._$GetWallTime$_(),
                            timescale: this._$GetTimeScale$_(),
                            tickcount: this._$GetTickCount$_(),
                            next_uid: this._$_nextUid$_,
                            running_layout: this._$GetMainRunningLayout$_()._$GetSID$_(),
                            start_time_offset: Date.now() - this._$_startTime$_
                        },
                        types: {},
                        layouts: {},
                        events: this._$_eventSheetManager$_._$_SaveToJson$_(),
                        timelines: this._$_timelineManager$_._$_SaveToJson$_(),
                        user_script_data: null
                    };
                    for (const s of this._$_allObjectClasses$_) s._$IsFamily$_() || s._$HasNoSaveBehavior$_() || (t.types[s._$GetSID$_().toString()] = s._$_SaveToJson$_());
                    for (const i of this._$_layoutManager$_._$GetAllLayouts$_()) t.layouts[i._$GetSID$_().toString()] = i._$_SaveToJson$_();
                    const e = this._$_CreateUserScriptEvent$_("save");
                    return e.saveData = null, await this._$DispatchUserScriptEventAsyncWait$_(e), 
                    t.user_script_data = e.saveData, JSON.stringify(t);
                }
                _$IsLoadingState$_() {
                    return this._$_isLoadingState$_;
                }
                async _$_DoLoadFromJsonString$_(t) {
                    const e = this._$GetLayoutManager$_(), s = JSON.parse(t);
                    if (s.c2save) throw new Error("C2 saves are incompatible with C3 runtime");
                    if (!s.c3save) throw new Error("not valid C3 save data");
                    if (1 < s.version) throw new Error("C3 save data from future version");
                    this._$ClearIntancesNeedingAfterLoad$_(), this._$_dispatcher$_.dispatchEvent(C33._$New$_(C33.Event, "beforeload"));
                    for (const a of this._$allInstances$_()) {
                        const l = a._$GetObjectClass$_();
                        l._$HasNoSaveBehavior$_() || a._$_OnBeforeLoad$_();
                    }
                    let i = s.rt, r = (this._$_gameTime$_.Set(i.time), i.hasOwnProperty("timeRaw") && this._$_gameTimeRaw$_.Set(i.timeRaw), 
                    this._$_wallTime$_.Set(i.walltime), this._$_timeScale$_ = i.timescale, 
                    this._$_tickCount$_ = i.tickcount, this._$_startTime$_ = Date.now() - i.start_time_offset, 
                    i.running_layout), n = !(this._$_isLoadingState$_ = !0);
                    if (r !== this._$GetMainRunningLayout$_()._$GetSID$_()) {
                        const u = e._$GetLayoutBySID$_(r);
                        if (!u) return;
                        await this._$_DoChangeLayout$_(u), n = !0;
                    }
                    for (const [ c, f ] of Object.entries(s.layouts)) {
                        const d = parseInt(c, 10), p = e._$GetLayoutBySID$_(d);
                        p && p._$_LoadFromJson$_(f);
                    }
                    const h = new Set();
                    for (const [ m, C ] of Object.entries(s.types)) {
                        const g = parseInt(m, 10), S = this._$GetObjectClassBySID$_(g);
                        !S || S._$IsFamily$_() || S._$HasNoSaveBehavior$_() || S._$_LoadFromJson$_(C, h);
                    }
                    for (const _ of this._$_layoutManager$_._$GetAllLayouts$_()) for (const T of _._$allLayers$_()) T._$_LoadFromJsonAfterInstances$_();
                    if (this._$FlushPendingInstances$_(), this._$_RefreshUidMap$_(), 
                    this._$_isLoadingState$_ = !1, n) {
                        for (const y of this._$allInstances$_()) y._$SetupInitialSceneGraphConnections$_();
                        for (const [ E, A ] of Object.entries(s.types)) {
                            const I = parseInt(E, 10), M = this._$GetObjectClassBySID$_(I);
                            !M || M._$IsFamily$_() || M._$HasNoSaveBehavior$_() || M._$_SetupSceneGraphConnectionsOnChangeOfLayout$_(A);
                        }
                    }
                    this._$_nextUid$_ = i.next_uid, this._$_eventSheetManager$_._$_LoadFromJson$_(s.events);
                    for (const w of this._$_allObjectClasses$_) if (!w._$IsFamily$_() && w._$IsInContainer$_()) for (const v of w._$GetInstances$_()) {
                        const R = v._$GetIID$_();
                        for (const b of w._$GetContainer$_()._$objectTypes$_()) if (b !== w) {
                            const G = b._$GetInstances$_();
                            if (R < 0 || R >= G.length) throw new Error("missing sibling instance");
                            v._$_AddSibling$_(G[R]);
                        }
                    }
                    this._$_timelineManager$_._$_LoadFromJson$_(s.timelines), e._$SetAllLayerProjectionChanged$_(), 
                    e._$SetAllLayerMVChanged$_();
                    for (const x of h) x._$_OnCreatedForLoadingSavegame$_();
                    this._$DoAfterLoad$_(), this._$_dispatcher$_.dispatchEvent(C33._$New$_(C33.Event, "afterload")), 
                    this._$DispatchUserScriptEvent$_(this._$_CreateUserScriptEvent$_("afterload"));
                    for (const [ P, O ] of Object.entries(s.types)) {
                        const D = parseInt(P, 10), L = this._$GetObjectClassBySID$_(D);
                        L && L._$_ClearLoadInstancesJson$_();
                    }
                    const o = this._$_CreateUserScriptEvent$_("load");
                    o.saveData = s.user_script_data, await this._$DispatchUserScriptEventAsyncWait$_(o), 
                    this._$UpdateRender$_();
                }
                _$SortOnTmpHierarchyPosition$_(t, e) {
                    return t._$GetWorldInfo$_()._$GetTmpHierarchyPosition$_() - e._$GetWorldInfo$_()._$GetTmpHierarchyPosition$_();
                }
                _$AddInstanceNeedingAfterLoad$_(t, e) {
                    t._$GetWorldInfo$_() && !this._$_instancesNeedingAfterLoadMap$_.has(t) && (this._$_instancesNeedingAfterLoadMap$_.set(t, e), 
                    this._$_instancesNeedingAfterLoadArray$_.push(t));
                }
                _$ClearIntancesNeedingAfterLoad$_() {
                    this._$_instancesNeedingAfterLoadMap$_ = new WeakMap(), C33._$clearArray$_(this._$_instancesNeedingAfterLoadArray$_);
                }
                _$DoAfterLoad$_(t = "full", e = null) {
                    this._$_instancesNeedingAfterLoadArray$_.sort(this._$SortOnTmpHierarchyPosition$_);
                    for (const s of this._$_instancesNeedingAfterLoadArray$_) s._$_OnAfterLoad$_(this._$_instancesNeedingAfterLoadMap$_.get(s), t, e);
                    for (const i of this._$_instancesNeedingAfterLoadArray$_) i._$_OnAfterLoad2$_(this._$_instancesNeedingAfterLoadMap$_.get(i), t, e);
                    this._$ClearIntancesNeedingAfterLoad$_();
                }
                async _$AddJobWorkerScripts$_(t) {
                    const e = await Promise.all(t.map(async t => {
                        const e = this._$IsCordova$_() && this._$_assetManager$_._$IsFileProtocol$_();
                        if (e || "playable-ad-single-file" === this._$GetExportType$_()) {
                            const s = await this._$_assetManager$_._$FetchBlob$_(t);
                            return URL.createObjectURL(s);
                        }
                        return new URL(t, location.href).toString();
                    }));
                    this._$_jobScheduler$_._$ImportScriptsToJobWorkers$_(e);
                }
                _$AddJobWorkerBlob$_(t, e) {
                    this._$_jobScheduler$_._$SendBlobToJobWorkers$_(t, e);
                }
                _$AddJobWorkerBuffer$_(t, e) {
                    this._$_jobScheduler$_._$SendBufferToJobWorkers$_(t, e);
                }
                _$AddJob$_(t, e, s, i) {
                    return this._$_jobScheduler$_._$AddJob$_(t, e, s, null, null, i);
                }
                _$BroadcastJob$_(t, e, s, i) {
                    return this._$_jobScheduler$_._$BroadcastJob$_(t, e, s, i);
                }
                _$GetMaxNumJobWorkers$_() {
                    return this._$_jobScheduler$_._$GetMaxNumWorkers$_();
                }
                _$InvokeDownload$_(t, e) {
                    this._$PostComponentMessageToDOM$_("runtime", "invoke-download", {
                        url: t,
                        filename: e
                    });
                }
                async _$RasterSvgImage$_(t, e, s, i, r, n) {
                    if (i = i || e, r = r || s, this._$IsInWorker$_()) {
                        const h = await this._$PostComponentMessageToDOMAsync$_("runtime", "raster-svg-image", {
                            blob: t,
                            imageWidth: e,
                            imageHeight: s,
                            surfaceWidth: i,
                            surfaceHeight: r,
                            imageBitmapOpts: n
                        });
                        return h.imageBitmap;
                    }
                    {
                        const o = await self.C3_RasterSvgImageBlob(t, e, s, i, r);
                        return n ? self.createImageBitmap(o, n) : o;
                    }
                }
                async _$GetSvgImageSize$_(t) {
                    return this._$IsInWorker$_() ? this._$PostComponentMessageToDOMAsync$_("runtime", "get-svg-image-size", {
                        blob: t
                    }) : self.C3_GetSvgImageSize(t);
                }
                _$RequestDeviceOrientationEvent$_() {
                    this._$_didRequestDeviceOrientationEvent$_ || (this._$_didRequestDeviceOrientationEvent$_ = !0, 
                    this._$PostComponentMessageToDOM$_("runtime", "enable-device-orientation"));
                }
                _$RequestDeviceMotionEvent$_() {
                    this._$_didRequestDeviceMotionEvent$_ || (this._$_didRequestDeviceMotionEvent$_ = !0, 
                    this._$PostComponentMessageToDOM$_("runtime", "enable-device-motion"));
                }
                _$Random$_() {
                    return this._$_randomNumberCallback$_();
                }
                _$SetRandomNumberGeneratorCallback$_(t) {
                    this._$_randomNumberCallback$_ = t;
                }
                _$_GetRemotePreviewStatusInfo$_() {
                    const t = this._$GetRenderer$_();
                    return {
                        fps: this._$GetFramesPerSecond$_(),
                        tps: this._$GetTicksPerSecond$_(),
                        cpu: this._$GetMainThreadTime$_(),
                        gpu: this._$GetGPUUtilisation$_(),
                        layout: this._$GetMainRunningLayout$_() ? this._$GetMainRunningLayout$_()._$GetName$_() : "",
                        renderer: t._$IsWebGL$_() ? t._$GetUnmaskedRenderer$_() : t._$GetAdapterInfoString$_()
                    };
                }
                _$HitBreakpoint$_() {
                    return !!this._$IsDebug$_() && C3Debugger._$HitBreakpoint$_();
                }
                _$DebugBreak$_(t) {
                    return this._$IsDebugging$_() ? C3Debugger._$DebugBreak$_(t) : Promise.resolve();
                }
                _$DebugBreakNext$_() {
                    return !!this._$IsDebugging$_() && C3Debugger.BreakNext();
                }
                _$SetDebugBreakpointsEnabled$_(t) {
                    this._$_breakpointsEnabled$_ = !!t, this._$_UpdateDebuggingFlag$_();
                }
                _$AreDebugBreakpointsEnabled$_() {
                    return this._$_breakpointsEnabled$_;
                }
                _$IsDebugging$_() {
                    return this._$_isDebugging$_;
                }
                _$SetDebuggingEnabled$_(t) {
                    t ? this._$_debuggingDisabled$_-- : this._$_debuggingDisabled$_++, 
                    this._$_UpdateDebuggingFlag$_();
                }
                _$_UpdateDebuggingFlag$_() {
                    this._$_isDebugging$_ = this._$IsDebug$_() && this._$_breakpointsEnabled$_ && 0 === this._$_debuggingDisabled$_;
                }
                _$IsCPUProfiling$_() {
                    return this._$IsDebug$_() && C3Debugger._$IsCPUProfiling$_();
                }
                _$IsGPUProfiling$_() {
                    return this._$IsDebug$_() && this._$GetRenderer$_()._$SupportsGPUProfiling$_() && C3Debugger._$IsGPUProfiling$_();
                }
                async _$DebugIterateAndBreak$_(t) {
                    if (t) for (const e of t) await this._$DebugBreak$_(e);
                }
                _$DebugFireGeneratorEventAndBreak$_(t) {
                    return this._$DebugIterateAndBreak$_(this._$_dispatcher$_._$dispatchGeneratorEvent$_(t));
                }
                _$_InvokeFunctionFromJS$_(t) {
                    return this._$_eventSheetManager$_._$_InvokeFunctionFromJS$_(t.name, t.params);
                }
                _$_GetHTMLLayerWrapElement$_(t) {
                    if (this._$IsInWorker$_()) throw new Error("not supported in worker mode");
                    return self.c3_runtimeInterface._GetHTMLWrapElement(t);
                }
                _$GetIRuntime$_() {
                    return this._$_iRuntime$_;
                }
                _$_CreateUserScriptEvent$_(t) {
                    const e = C33._$New$_(C33.Event, t, !1);
                    return e.runtime = this._$_iRuntime$_, e;
                }
                _$_InitScriptInterfaces$_() {
                    this._$_iRuntime$_ = new self._$IRuntime$_(this), this._$_userScriptEventObjects$_ = {
                        pretick: this._$_CreateUserScriptEvent$_("pretick"),
                        tick: this._$_CreateUserScriptEvent$_("tick"),
                        tick2: this._$_CreateUserScriptEvent$_("tick2")
                    };
                }
                _$_InitObjectsScriptInterface$_() {
                    const t = {};
                    for (const e of this._$_allObjectClasses$_) t[e._$GetJsPropName$_()] = {
                        value: e._$GetIObjectClass$_(),
                        enumerable: !0,
                        writable: !1
                    };
                    this._$_iRuntime$_._$_InitObjects$_(t);
                }
                _$_InitGlobalVariableScriptInterface$_() {
                    const t = {};
                    for (const e of this._$GetEventSheetManager$_()._$GetAllGlobalVariables$_()) t[e._$GetJsPropName$_()] = e._$_GetScriptInterfaceDescriptor$_();
                    this._$_iRuntime$_._$_InitGlobalVars$_(t);
                }
                _$_GetCommonScriptInterfaces$_() {
                    return this._$_commonScriptInterfaces$_;
                }
                _$_MapScriptInterface$_(t, e) {
                    this._$_interfaceMap$_.set(t, e);
                }
                _$_UnwrapScriptInterface$_(t) {
                    return this._$_interfaceMap$_.get(t);
                }
                _$_UnwrapIObjectClass$_(t) {
                    if (!(t instanceof self._$IObjectClass$_)) throw new TypeError("expected IObjectClass");
                    const e = this._$_UnwrapScriptInterface$_(t);
                    if (e && e instanceof C33._$ObjectClass$_) return e;
                    throw new Error("invalid IObjectClass");
                }
                _$_UnwrapIInstance$_(t) {
                    if (!(t instanceof self._$IInstance$_)) throw new TypeError("expected IInstance");
                    const e = this._$_UnwrapScriptInterface$_(t);
                    if (e && e instanceof C33.Instance) return e;
                    throw new Error("invalid IInstance");
                }
                _$_UnwrapIWorldInstance$_(t) {
                    if (!(t instanceof self._$IWorldInstance$_)) throw new TypeError("expected IWorldInstance");
                    const e = this._$_UnwrapScriptInterface$_(t);
                    if (e && e instanceof C33.Instance) return e;
                    throw new Error("invalid IInstance");
                }
            }, self.C3_CreateRuntime = C33._$Runtime$_._$Create$_, self.C3_InitRuntime = (t, e) => t._$Init$_(e);
        }
        {
            const C33 = self._$C3$_;
            C33._$JobSchedulerRuntime$_ = class extends C33._$DefendedBase$_ {
                constructor(t, e) {
                    super(), this._$_runtime$_ = t, this._$_jobPromises$_ = new Map(), 
                    this._$_nextJobId$_ = 0, this._$_inputPort$_ = e.inputPort, 
                    e.outputPort.onmessage = t => this._$_OnJobWorkerMessage$_(t), 
                    this._$_maxNumWorkers$_ = e.maxNumWorkers, this._$_jobWorkerCount$_ = 1, 
                    this._$_isCreatingWorker$_ = !1, this._$_hadErrorCreatingWorker$_ = !1;
                }
                _$GetMaxNumWorkers$_() {
                    return this._$_maxNumWorkers$_;
                }
                _$ImportScriptsToJobWorkers$_(t) {
                    this._$_inputPort$_.postMessage({
                        type: "_import_scripts",
                        scripts: t
                    });
                }
                _$SendBlobToJobWorkers$_(t, e) {
                    this._$_inputPort$_.postMessage({
                        type: "_send_blob",
                        blob: t,
                        id: e
                    });
                }
                _$SendBufferToJobWorkers$_(t, e) {
                    this._$_inputPort$_.postMessage({
                        type: "_send_buffer",
                        buffer: t,
                        id: e
                    }, [ t ]);
                }
                _$AddJob$_(t, e, s, i, r, n) {
                    if (s = s || [], "number" == typeof n && (n = Math.floor(n)) <= 0) throw new Error("invalid maxWorkerNum");
                    const h = this._$_nextJobId$_++, o = {
                        type: t,
                        isBroadcast: !1,
                        maxWorkerNum: n,
                        jobId: h,
                        params: e,
                        transferables: s
                    }, a = new Promise((t, e) => {
                        this._$_jobPromises$_.set(h, {
                            resolve: t,
                            progress: i,
                            reject: e,
                            _$cancelled$_: !1,
                            maxWorkerNum: n
                        });
                    });
                    return r && r._$SetAction$_(() => this._$_CancelJob$_(h)), this._$_inputPort$_.postMessage(o, s), 
                    this._$_MaybeCreateExtraWorker$_(), a;
                }
                _$BroadcastJob$_(t, e, s, i) {
                    if (s = s || [], "number" == typeof i && (i = Math.floor(i)) <= 0) throw new Error("invalid maxWorkerNum");
                    const r = this._$_nextJobId$_++, n = {
                        type: t,
                        isBroadcast: !0,
                        maxWorkerNum: i,
                        jobId: r,
                        params: e,
                        transferables: s
                    };
                    this._$_inputPort$_.postMessage(n, s);
                }
                _$_CancelJob$_(t) {
                    const e = this._$_jobPromises$_.get(t);
                    e && (e._$cancelled$_ = !0, e.resolve = null, e.progress = null, 
                    e.reject = null, this._$_inputPort$_.postMessage({
                        type: "_cancel",
                        jobId: t
                    }));
                }
                _$_OnJobWorkerMessage$_(t) {
                    const e = t.data, s = e.type, i = e.jobId;
                    switch (s) {
                      case "result":
                        this._$_OnJobResult$_(i, e.result);
                        break;

                      case "progress":
                        this._$_OnJobProgress$_(i, e.progress);
                        break;

                      case "error":
                        this._$_OnJobError$_(i, e.error);
                        break;

                      case "ready":
                        this._$_OnJobWorkerReady$_();
                        break;

                      default:
                        throw new Error(`unknown message from worker '${s}'`);
                    }
                }
                _$_OnJobResult$_(t, e) {
                    const s = this._$_jobPromises$_.get(t);
                    if (!s) throw new Error("invalid job ID");
                    s._$cancelled$_ || s.resolve(e), this._$_jobPromises$_.delete(t);
                }
                _$_OnJobProgress$_(t, e) {
                    const s = this._$_jobPromises$_.get(t);
                    if (!s) throw new Error("invalid job ID");
                    !s._$cancelled$_ && s.progress && s.progress(e);
                }
                _$_OnJobError$_(t, e) {
                    const s = this._$_jobPromises$_.get(t);
                    if (!s) throw new Error("invalid job ID");
                    s._$cancelled$_ || s.reject(e), this._$_jobPromises$_.delete(t);
                }
                _$_OnJobWorkerReady$_() {
                    this._$_isCreatingWorker$_ && (this._$_isCreatingWorker$_ = !1, 
                    this._$_jobWorkerCount$_++, this._$_jobWorkerCount$_ < this._$_maxNumWorkers$_ ? this._$_MaybeCreateExtraWorker$_() : this._$_inputPort$_.postMessage({
                        type: "_no_more_workers"
                    }));
                }
                _$_GetWorkerCountNeededForPendingJobs$_() {
                    let t = 0, e = [ ...this._$_jobPromises$_.values() ].sort((t, e) => {
                        const s = t.maxWorkerNum || 1 / 0, i = e.maxWorkerNum || 1 / 0;
                        return s - i;
                    });
                    for (const s of e) {
                        const i = s.maxWorkerNum || 1 / 0;
                        t < i && t++;
                    }
                    return t;
                }
                async _$_MaybeCreateExtraWorker$_() {
                    if (!(this._$_jobWorkerCount$_ >= this._$_maxNumWorkers$_ || this._$_isCreatingWorker$_ || this._$_hadErrorCreatingWorker$_ || this._$_GetWorkerCountNeededForPendingJobs$_() <= this._$_jobWorkerCount$_)) try {
                        this._$_isCreatingWorker$_ = !0;
                        const t = await this._$_runtime$_._$PostComponentMessageToDOMAsync$_("runtime", "create-job-worker");
                        t.outputPort.onmessage = t => this._$_OnJobWorkerMessage$_(t);
                    } catch (t) {
                        this._$_hadErrorCreatingWorker$_ = !0, this._$_isCreatingWorker$_ = !1, 
                        console.error(`[Construct] Failed to create job worker; stopping creating any more (created ${this._$_jobWorkerCount$_} so far)`, t);
                    }
                }
            };
        }
        self.C3_Shaders = {};
        {
            let ForEachOrdered_SortInstances2 = function(t, e) {
                const s = t[1], i = e[1];
                if ("number" == typeof s && "number" == typeof i) return s - i;
                {
                    const r = "" + s, n = "" + i;
                    return r < n ? -1 : n < r ? 1 : 0;
                }
            }, a = (ForEachOrdered_SortInstances = ForEachOrdered_SortInstances2, 
            self._$C3$_), r = null, n = "", s = "", o = [], u = "", l = "", c = "", i = a._$New$_(a._$ArrayStack$_);
            a._$Plugins$_._$System$_ = class extends a._$SDKPluginBase$_ {
                constructor(t) {
                    super(t), this._$_loopStack$_ = this._$_runtime$_._$GetEventSheetManager$_()._$GetLoopStack$_(), 
                    this._$_eventStack$_ = this._$_runtime$_._$GetEventSheetManager$_()._$GetEventStack$_(), 
                    this._$_imagesLoadingTotal$_ = 0, this._$_imagesLoadingComplete$_ = 0, 
                    this._$_functionMaps$_ = new Map();
                }
                _$Release$_() {
                    super._$Release$_();
                }
                _$UpdateRender$_() {
                    this._$_runtime$_._$UpdateRender$_();
                }
                _$Trigger$_(t) {
                    this._$_runtime$_._$Trigger$_(t, null, null);
                }
                _$GetRegex$_(t, e) {
                    return r && t === n && e === s || (r = new RegExp(t, e), n = t, 
                    s = e), r.lastIndex = 0, r;
                }
                _$GetRegexMatches$_(t, e, s) {
                    if (t !== u || e !== l || s !== c) {
                        const i = this._$GetRegex$_(e, s);
                        o = t.match(i), u = t, l = e, c = s;
                    }
                    return o;
                }
                async _$_LoadTexturesForObjectClasses$_(t, e) {
                    if (e.length) {
                        this._$_imagesLoadingTotal$_ += e.length;
                        const s = [];
                        for (const i of e) s.push(t._$MaybeLoadTexturesFor$_(i));
                        await a._$PromiseAllWithProgress$_(s, () => {
                            this._$_imagesLoadingComplete$_++;
                        }), this._$_imagesLoadingComplete$_++, this._$_imagesLoadingComplete$_ === this._$_imagesLoadingTotal$_ && (this._$_imagesLoadingComplete$_ = 0, 
                        this._$_imagesLoadingTotal$_ = 0, this._$_runtime$_._$Trigger$_(a._$Plugins$_._$System$_._$Cnds$_._$OnImageLoadingComplete$_, null, null));
                    }
                }
                _$GetImageLoadingProgress$_() {
                    return 0 === this._$_imagesLoadingTotal$_ ? 1 : this._$_imagesLoadingComplete$_ / this._$_imagesLoadingTotal$_;
                }
                _$_UnloadTexturesForObjectClasses$_(t, e) {
                    for (const s of e) 0 === s._$GetInstanceCount$_() && t._$MaybeUnloadTexturesFor$_(s);
                }
                _$_GetForEachStack$_() {
                    return i;
                }
                _$_Repeat$_(e) {
                    const s = this._$_runtime$_._$GetEventSheetManager$_(), t = s._$GetEventStack$_(), i = t._$GetCurrentStackFrame$_(), r = i._$GetCurrentEvent$_(), n = r._$GetSolModifiers$_(), h = i._$IsSolModifierAfterCnds$_(), o = t._$Push$_(r), a = s._$GetLoopStack$_(), l = a._$Push$_();
                    if (l._$SetEnd$_(e), h) for (let t = 0; t < e && !l._$IsStopped$_(); ++t) s._$PushCopySol$_(n), 
                    l._$SetIndex$_(t), r._$Retrigger$_(i, o), s._$PopSol$_(n); else for (let t = 0; t < e && !l._$IsStopped$_(); ++t) l._$SetIndex$_(t), 
                    r._$Retrigger$_(i, o);
                    return t._$Pop$_(), a._$Pop$_(), !1;
                }
                *_$_DebugRepeat$_(e) {
                    const s = this._$_runtime$_._$GetEventSheetManager$_(), t = s._$GetEventStack$_(), i = t._$GetCurrentStackFrame$_(), r = i._$GetCurrentEvent$_(), n = r._$GetSolModifiers$_(), h = i._$IsSolModifierAfterCnds$_(), o = t._$Push$_(r), a = s._$GetLoopStack$_(), l = a._$Push$_();
                    if (l._$SetEnd$_(e), h) for (let t = 0; t < e && !l._$IsStopped$_(); ++t) s._$PushCopySol$_(n), 
                    l._$SetIndex$_(t), yield* r._$DebugRetrigger$_(i, o), s._$PopSol$_(n); else for (let t = 0; t < e && !l._$IsStopped$_(); ++t) l._$SetIndex$_(t), 
                    yield* r._$DebugRetrigger$_(i, o);
                    return t._$Pop$_(), a._$Pop$_(), !1;
                }
                _$_While$_() {
                    const e = this._$_runtime$_._$GetEventSheetManager$_(), t = e._$GetEventStack$_(), s = t._$GetCurrentStackFrame$_(), i = s._$GetCurrentEvent$_(), r = i._$GetSolModifiers$_(), n = s._$IsSolModifierAfterCnds$_(), h = t._$Push$_(i), o = e._$GetLoopStack$_(), a = o._$Push$_();
                    if (n) for (let t = 0; !a._$IsStopped$_(); ++t) e._$PushCopySol$_(r), 
                    a._$SetIndex$_(t), i._$Retrigger$_(s, h) || a._$Stop$_(), e._$PopSol$_(r); else for (let t = 0; !a._$IsStopped$_(); ++t) a._$SetIndex$_(t), 
                    i._$Retrigger$_(s, h) || a._$Stop$_();
                    return t._$Pop$_(), o._$Pop$_(), !1;
                }
                *_$_DebugWhile$_() {
                    const e = this._$_runtime$_._$GetEventSheetManager$_(), t = e._$GetEventStack$_(), s = t._$GetCurrentStackFrame$_(), i = s._$GetCurrentEvent$_(), r = i._$GetSolModifiers$_(), n = s._$IsSolModifierAfterCnds$_(), h = t._$Push$_(i), o = e._$GetLoopStack$_(), a = o._$Push$_();
                    if (n) for (let t = 0; !a._$IsStopped$_(); ++t) {
                        e._$PushCopySol$_(r), a._$SetIndex$_(t);
                        const l = yield* i._$DebugRetrigger$_(s, h);
                        l || a._$Stop$_(), e._$PopSol$_(r);
                    } else for (let t = 0; !a._$IsStopped$_(); ++t) {
                        a._$SetIndex$_(t);
                        const u = yield* i._$DebugRetrigger$_(s, h);
                        u || a._$Stop$_();
                    }
                    return t._$Pop$_(), o._$Pop$_(), !1;
                }
                _$_For$_(t, e, s) {
                    const i = this._$_runtime$_._$GetEventSheetManager$_(), r = i._$GetEventStack$_(), n = r._$GetCurrentStackFrame$_(), h = n._$GetCurrentEvent$_(), o = h._$GetSolModifiers$_(), a = n._$IsSolModifierAfterCnds$_(), l = r._$Push$_(h), u = i._$GetLoopStack$_(), c = u._$Push$_();
                    if (c._$SetName$_(t), c._$SetEnd$_(s), s < e) if (a) for (let t = e; t >= s && !c._$IsStopped$_(); --t) i._$PushCopySol$_(o), 
                    c._$SetIndex$_(t), h._$Retrigger$_(n, l), i._$PopSol$_(o); else for (let t = e; t >= s && !c._$IsStopped$_(); --t) c._$SetIndex$_(t), 
                    h._$Retrigger$_(n, l); else if (a) for (let t = e; t <= s && !c._$IsStopped$_(); ++t) i._$PushCopySol$_(o), 
                    c._$SetIndex$_(t), h._$Retrigger$_(n, l), i._$PopSol$_(o); else for (let t = e; t <= s && !c._$IsStopped$_(); ++t) c._$SetIndex$_(t), 
                    h._$Retrigger$_(n, l);
                    return r._$Pop$_(), u._$Pop$_(), !1;
                }
                *_$_DebugFor$_(t, e, s) {
                    const i = this._$_runtime$_._$GetEventSheetManager$_(), r = i._$GetEventStack$_(), n = r._$GetCurrentStackFrame$_(), h = n._$GetCurrentEvent$_(), o = h._$GetSolModifiers$_(), a = n._$IsSolModifierAfterCnds$_(), l = r._$Push$_(h), u = i._$GetLoopStack$_(), c = u._$Push$_();
                    if (c._$SetName$_(t), c._$SetEnd$_(s), s < e) if (a) for (let t = e; t >= s && !c._$IsStopped$_(); --t) i._$PushCopySol$_(o), 
                    c._$SetIndex$_(t), yield* h._$DebugRetrigger$_(n, l), i._$PopSol$_(o); else for (let t = e; t >= s && !c._$IsStopped$_(); --t) c._$SetIndex$_(t), 
                    yield* h._$DebugRetrigger$_(n, l); else if (a) for (let t = e; t <= s && !c._$IsStopped$_(); ++t) i._$PushCopySol$_(o), 
                    c._$SetIndex$_(t), yield* h._$DebugRetrigger$_(n, l), i._$PopSol$_(o); else for (let t = e; t <= s && !c._$IsStopped$_(); ++t) c._$SetIndex$_(t), 
                    yield* h._$DebugRetrigger$_(n, l);
                    return r._$Pop$_(), u._$Pop$_(), !1;
                }
                _$_ForEach$_(s) {
                    const t = s._$GetCurrentSol$_(), e = t._$GetInstances$_();
                    if (0 !== e.length) {
                        const r = this._$_runtime$_._$GetEventSheetManager$_(), n = r._$GetEventStack$_(), h = n._$GetCurrentStackFrame$_(), o = h._$GetCurrentEvent$_(), l = o._$GetSolModifiers$_(), u = h._$IsSolModifierAfterCnds$_(), c = n._$Push$_(o), f = r._$GetLoopStack$_(), d = f._$Push$_(), p = s._$IsInContainer$_(), m = i._$Push$_();
                        if (a._$shallowAssignArray$_(m, e), d._$SetEnd$_(m.length), 
                        u) for (let t = 0, e = m.length; t < e && !d._$IsStopped$_(); ++t) {
                            r._$PushCopySol$_(l);
                            const C = m[t];
                            s._$GetCurrentSol$_()._$SetSinglePicked$_(C), p && C._$SetSiblingsSinglePicked$_(), 
                            d._$SetIndex$_(t), o._$Retrigger$_(h, c), r._$PopSol$_(l);
                        } else {
                            t._$_SetSelectAll$_(!1);
                            const g = t._$_GetOwnInstances$_();
                            a._$clearArray$_(g), g.push(null);
                            for (let t = 0, e = m.length; t < e && !d._$IsStopped$_(); ++t) {
                                const S = m[t];
                                g[0] = S, p && S._$SetSiblingsSinglePicked$_(), 
                                d._$SetIndex$_(t), o._$Retrigger$_(h, c);
                            }
                        }
                        n._$Pop$_(), f._$Pop$_(), a._$clearArray$_(m), i._$Pop$_();
                    }
                    return !1;
                }
                *_$_DebugForEach$_(s) {
                    const t = s._$GetCurrentSol$_(), e = t._$GetInstances$_();
                    if (0 !== e.length) {
                        const r = this._$_runtime$_._$GetEventSheetManager$_(), n = r._$GetEventStack$_(), h = n._$GetCurrentStackFrame$_(), o = h._$GetCurrentEvent$_(), l = o._$GetSolModifiers$_(), u = h._$IsSolModifierAfterCnds$_(), c = n._$Push$_(o), f = r._$GetLoopStack$_(), d = f._$Push$_(), p = s._$IsInContainer$_(), m = i._$Push$_();
                        if (a._$shallowAssignArray$_(m, e), d._$SetEnd$_(m.length), 
                        u) for (let t = 0, e = m.length; t < e && !d._$IsStopped$_(); ++t) {
                            r._$PushCopySol$_(l);
                            const C = m[t];
                            s._$GetCurrentSol$_()._$SetSinglePicked$_(C), p && C._$SetSiblingsSinglePicked$_(), 
                            d._$SetIndex$_(t), yield* o._$DebugRetrigger$_(h, c), 
                            r._$PopSol$_(l);
                        } else {
                            t._$_SetSelectAll$_(!1);
                            const g = t._$_GetOwnInstances$_();
                            a._$clearArray$_(g), g.push(null);
                            for (let t = 0, e = m.length; t < e && !d._$IsStopped$_(); ++t) {
                                const S = m[t];
                                g[0] = S, p && S._$SetSiblingsSinglePicked$_(), 
                                d._$SetIndex$_(t), yield* o._$DebugRetrigger$_(h, c);
                            }
                        }
                        n._$Pop$_(), f._$Pop$_(), a._$clearArray$_(m), i._$Pop$_();
                    }
                    return !1;
                }
                _$_ForEachOrdered$_(s, t) {
                    const e = s._$GetCurrentSol$_(), r = e._$GetInstances$_();
                    if (0 !== r.length) {
                        const n = this._$_runtime$_._$GetEventSheetManager$_(), h = n._$GetEventStack$_(), o = n._$GetCurrentCondition$_(), l = h._$GetCurrentStackFrame$_(), u = l._$GetCurrentEvent$_(), c = u._$GetSolModifiers$_(), f = l._$IsSolModifierAfterCnds$_(), d = h._$Push$_(u), p = n._$GetLoopStack$_(), m = p._$Push$_(), C = s._$IsInContainer$_(), g = i._$Push$_();
                        a._$clearArray$_(g), m._$SetEnd$_(r.length);
                        for (let t = 0, e = r.length; t < e; ++t) g.push([ r[t], o._$ReevaluateParameter$_(1, t) ]);
                        if (g.sort(ForEachOrdered_SortInstances2), 1 === t && g.reverse(), 
                        f) for (let t = 0, e = g.length; t < e && !m._$IsStopped$_(); ++t) {
                            n._$PushCopySol$_(c);
                            const S = g[t][0];
                            s._$GetCurrentSol$_()._$SetSinglePicked$_(S), C && S._$SetSiblingsSinglePicked$_(), 
                            m._$SetIndex$_(t), u._$Retrigger$_(l, d), n._$PopSol$_(c);
                        } else {
                            e._$_SetSelectAll$_(!1);
                            const _ = e._$_GetOwnInstances$_();
                            a._$clearArray$_(_), _.push(null);
                            for (let t = 0, e = g.length; t < e && !m._$IsStopped$_(); ++t) {
                                const T = g[t][0];
                                _[0] = T, C && T._$SetSiblingsSinglePicked$_(), 
                                m._$SetIndex$_(t), u._$Retrigger$_(l, d);
                            }
                        }
                        h._$Pop$_(), p._$Pop$_(), a._$clearArray$_(g), i._$Pop$_();
                    }
                    return !1;
                }
                *_$_DebugForEachOrdered$_(s, t) {
                    const e = s._$GetCurrentSol$_(), r = e._$GetInstances$_();
                    if (0 !== r.length) {
                        const n = this._$_runtime$_._$GetEventSheetManager$_(), h = n._$GetEventStack$_(), o = n._$GetCurrentCondition$_(), l = h._$GetCurrentStackFrame$_(), u = l._$GetCurrentEvent$_(), c = u._$GetSolModifiers$_(), f = l._$IsSolModifierAfterCnds$_(), d = h._$Push$_(u), p = n._$GetLoopStack$_(), m = p._$Push$_(), C = s._$IsInContainer$_(), g = i._$Push$_();
                        a._$clearArray$_(g), m._$SetEnd$_(r.length);
                        for (let t = 0, e = r.length; t < e; ++t) g.push([ r[t], o._$ReevaluateParameter$_(1, t) ]);
                        if (g.sort(ForEachOrdered_SortInstances2), 1 === t && g.reverse(), 
                        f) for (let t = 0, e = g.length; t < e && !m._$IsStopped$_(); ++t) {
                            n._$PushCopySol$_(c);
                            const S = g[t][0];
                            s._$GetCurrentSol$_()._$SetSinglePicked$_(S), C && S._$SetSiblingsSinglePicked$_(), 
                            m._$SetIndex$_(t), yield* u._$DebugRetrigger$_(l, d), 
                            n._$PopSol$_(c);
                        } else {
                            e._$_SetSelectAll$_(!1);
                            const _ = e._$_GetOwnInstances$_();
                            a._$clearArray$_(_), _.push(null);
                            for (let t = 0, e = g.length; t < e && !m._$IsStopped$_(); ++t) {
                                const T = g[t][0];
                                _[0] = T, C && T._$SetSiblingsSinglePicked$_(), 
                                m._$SetIndex$_(t), yield* u._$DebugRetrigger$_(l, d);
                            }
                        }
                        h._$Pop$_(), p._$Pop$_(), a._$clearArray$_(g), i._$Pop$_();
                    }
                    return !1;
                }
                _$_GetFunctionMap$_(t, e) {
                    let s = this._$_functionMaps$_.get(t);
                    if (!s) {
                        if (!e) return null;
                        s = {
                            _$defaultFunc$_: null,
                            _$strMap$_: new Map()
                        }, this._$_functionMaps$_.set(t, s);
                    }
                    return s;
                }
                _$_DoCallMappedFunction$_(t, e, s, i, r) {
                    e._$GetEventBlock$_()._$RunAsMappedFunctionCall$_(s, e._$IsCopyPicked$_()), 
                    i && t._$PopSol$_(r);
                }
                *_$_DebugDoCallMappedFunction$_(t, e, s, i, r) {
                    yield* e._$GetEventBlock$_()._$DebugRunAsMappedFunctionCall$_(s, e._$IsCopyPicked$_()), 
                    i && t._$PopSol$_(r);
                }
            };
        }
        {
            const a1 = self._$C3$_;
            a1._$Plugins$_._$System$_._$Type$_ = class extends a1._$DefendedBase$_ {
                constructor(t) {
                    super(), this._$_objectClass$_ = t, this._$_runtime$_ = t._$GetRuntime$_(), 
                    this._$_plugin$_ = t._$GetPlugin$_();
                }
                _$OnCreate$_() {}
                _$Release$_() {
                    this._$_objectClass$_ = null, this._$_runtime$_ = null, this._$_plugin$_ = null;
                }
            };
        }
        {
            const d1 = self._$C3$_;
            d1._$Plugins$_._$System$_.Instance = class extends d1._$DefendedBase$_ {
                constructor(t, e) {
                    super(), this._$_inst$_ = t, this._$_objectClass$_ = this._$_inst$_._$GetObjectClass$_(), 
                    this._$_sdkType$_ = this._$_objectClass$_._$GetSdkType$_(), 
                    this._$_runtime$_ = this._$_inst$_._$GetRuntime$_();
                }
                _$Release$_() {
                    this._$_inst$_ = null, this._$_objectClass$_ = null, this._$_sdkType$_ = null, 
                    this._$_runtime$_ = null;
                }
            };
        }
        {
            const h1 = self._$C3$_, i1 = [];
            h1._$Plugins$_._$System$_._$Cnds$_ = {
                _$EveryTick$_() {
                    return !0;
                },
                _$OnLayoutStart$_() {
                    return !0;
                },
                _$OnLayoutEnd$_() {
                    return !0;
                },
                _$OnSuspend$_() {
                    return !0;
                },
                _$OnResume$_() {
                    return !0;
                },
                _$IsSuspended$_() {
                    return this._$_runtime$_._$IsSuspended$_();
                },
                _$Else$_() {
                    const t = this._$_runtime$_._$GetCurrentEventStackFrame$_();
                    return !t._$GetElseBranchRan$_() && !t._$GetLastEventTrue$_();
                },
                _$TriggerOnce$_() {
                    let t = this._$_runtime$_._$GetCurrentCondition$_(), e = t._$GetSavedDataMap$_(), s = e.get("TriggerOnce_lastTick");
                    void 0 === s && (s = -1, e.set("TriggerOnce_lastTick", -1));
                    const i = this._$_runtime$_._$GetTickCount$_();
                    return e.set("TriggerOnce_lastTick", i), this._$_runtime$_._$IsLayoutFirstTick$_() || s !== i - 1;
                },
                _$Every$_(t) {
                    const e = this._$_runtime$_._$GetCurrentCondition$_(), s = e._$GetSavedDataMap$_(), i = s.get("Every_lastTime") || 0, r = this._$_runtime$_._$GetGameTime$_(), n = (s.has("Every_seconds") || s.set("Every_seconds", t), 
                    s.get("Every_seconds"));
                    return i + n <= r ? (s.set("Every_lastTime", i + n), r >= s.get("Every_lastTime") + .04 && s.set("Every_lastTime", r), 
                    s.set("Every_seconds", t), !0) : (r < i - .1 && s.set("Every_lastTime", r), 
                    !1);
                },
                _$IsGroupActive$_(t) {
                    const e = this._$_runtime$_._$GetEventSheetManager$_()._$GetEventGroupByName$_(t);
                    return e && e._$IsGroupActive$_();
                },
                _$IsPreview$_() {
                    return this._$_runtime$_._$IsPreview$_();
                },
                _$IsMobile$_() {
                    return h1._$Platform$_._$IsMobile$_;
                },
                _$OnLoadFinished$_() {
                    return !0;
                },
                _$OnCanvasSnapshot$_() {
                    return !0;
                },
                _$EffectsSupported$_() {
                    return !0;
                },
                _$OnSaveComplete$_() {
                    return !0;
                },
                _$OnSaveFailed$_() {
                    return !0;
                },
                _$OnLoadComplete$_() {
                    return !0;
                },
                _$OnLoadFailed$_() {
                    return !0;
                },
                _$ObjectUIDExists$_(t) {
                    return !!this._$_runtime$_._$GetInstanceByUID$_(t);
                },
                _$IsOnPlatform$_(t) {
                    switch (t) {
                      case 0:
                        return "browser" === h1._$Platform$_._$Context$_;

                      case 1:
                        return "iOS" === h1._$Platform$_._$OS$_;

                      case 2:
                        return "Android" === h1._$Platform$_._$OS$_;

                      case 8:
                        return "cordova" === h1._$Platform$_._$Context$_;

                      case 9:
                        return "scirra-arcade" === this._$_runtime$_._$GetExportType$_();

                      case 10:
                        return "nwjs" === h1._$Platform$_._$Context$_;

                      case 13:
                        return "windows-uwp" === this._$_runtime$_._$GetExportType$_();

                      default:
                        return !1;
                    }
                },
                _$RegexTest$_(t, e, s) {
                    const i = this._$GetRegex$_(e, s);
                    return i.test(t);
                },
                _$Compare$_(t, e, s) {
                    return h1.compare(t, e, s);
                },
                _$CompareBetween$_(t, e, s) {
                    return e <= t && t <= s;
                },
                _$CompareVar$_(t, e, s) {
                    return h1.compare(t._$GetValue$_(), e, s);
                },
                _$CompareBoolVar$_(t) {
                    return !!t._$GetValue$_();
                },
                _$CompareTime$_(t, e) {
                    const s = this._$_runtime$_._$GetGameTime$_();
                    if (0 !== t) return h1.compare(s, t, e);
                    {
                        const i = this._$_runtime$_._$GetCurrentCondition$_(), r = i._$GetSavedDataMap$_();
                        return !r.get("CompareTime_executed") && e <= s && (r.set("CompareTime_executed", !0), 
                        !0);
                    }
                },
                _$IsNaN$_(t) {
                    return isNaN(t);
                },
                _$AngleWithin$_(t, e, s) {
                    return h1._$angleDiff$_(h1._$toRadians$_(t), h1._$toRadians$_(s)) <= h1._$toRadians$_(e);
                },
                _$IsClockwiseFrom$_(t, e) {
                    return h1._$angleClockwise$_(h1._$toRadians$_(t), h1._$toRadians$_(e));
                },
                _$IsBetweenAngles$_(t, e, s) {
                    let i = h1._$toRadians$_(t), r = h1._$toRadians$_(e), n = h1._$toRadians$_(s), h = !h1._$angleClockwise$_(n, r);
                    return h ? !(!h1._$angleClockwise$_(i, r) && h1._$angleClockwise$_(i, n)) : h1._$angleClockwise$_(i, r) && !h1._$angleClockwise$_(i, n);
                },
                _$IsValueType$_(t, e) {
                    return "number" == typeof t ? 0 === e : 1 === e;
                },
                _$EvaluateExpression$_(t) {
                    return !!t;
                },
                _$OnSignal$_(t) {
                    return t.toLowerCase() === this._$_runtime$_._$GetEventSheetManager$_()._$GetCurrentSignalTag$_();
                },
                _$PickByComparison$_(t, s, i, r) {
                    if (!t) return !1;
                    let e = this._$_GetForEachStack$_(), n = e._$Push$_(), h = t._$GetCurrentSol$_(), o = (h1._$shallowAssignArray$_(n, h._$GetInstances$_()), 
                    h._$IsSelectAll$_() && h1._$clearArray$_(h._$_GetOwnElseInstances$_()), 
                    this._$_runtime$_._$GetCurrentCondition$_()), a = 0;
                    for (let t = 0, e = n.length; t < e; ++t) {
                        const u = n[t];
                        n[a] = u, s = o._$ReevaluateParameter$_(1, t), r = o._$ReevaluateParameter$_(3, t), 
                        h1.compare(s, i, r) ? ++a : h._$_PushElseInstance$_(u);
                    }
                    h1._$truncateArray$_(n, a), h._$SetArrayPicked$_(n);
                    const l = !!n.length;
                    return h1._$clearArray$_(n), e._$Pop$_(), t._$ApplySolToContainer$_(), 
                    l;
                },
                _$PickByEvaluate$_(t, e) {
                    if (!t) return !1;
                    let s = this._$_GetForEachStack$_(), i = s._$Push$_(), r = t._$GetCurrentSol$_(), n = (h1._$shallowAssignArray$_(i, r._$GetInstances$_()), 
                    r._$IsSelectAll$_() && h1._$clearArray$_(r._$_GetOwnElseInstances$_()), 
                    this._$_runtime$_._$GetCurrentCondition$_()), h = 0;
                    for (let t = 0, e = i.length; t < e; ++t) {
                        const a = i[t];
                        i[h] = a, n._$ReevaluateParameter$_(1, t) ? ++h : r._$_PushElseInstance$_(a);
                    }
                    h1._$truncateArray$_(i, h), r._$SetArrayPicked$_(i);
                    const o = !!i.length;
                    return h1._$clearArray$_(i), s._$Pop$_(), t._$ApplySolToContainer$_(), 
                    o;
                },
                _$PickByHighestLowestValue$_(t, s, i) {
                    if (!t) return !1;
                    const e = t._$GetCurrentSol$_(), r = e._$GetInstances$_();
                    if (0 === r.length) return !1;
                    let n = this._$_runtime$_._$GetCurrentCondition$_(), h = null, o = 0;
                    for (let t = 0, e = r.length; t < e; ++t) {
                        const a = r[t];
                        i = n._$ReevaluateParameter$_(2, t), (null === h || 0 === s && i < o || 1 === s && i > o) && (o = i, 
                        h = a);
                    }
                    return e._$PickOne$_(h), t._$ApplySolToContainer$_(), !0;
                },
                _$PickNth$_(t, e) {
                    if (!t) return !1;
                    const s = t._$GetCurrentSol$_(), i = s._$GetInstances$_();
                    if ((e = Math.floor(e)) >= i.length) return !1;
                    const r = i[e];
                    return s._$PickOne$_(r), t._$ApplySolToContainer$_(), !0;
                },
                _$PickRandom$_(t) {
                    if (!t) return !1;
                    const e = t._$GetCurrentSol$_(), s = e._$GetInstances$_(), i = Math.floor(this._$_runtime$_._$Random$_() * s.length);
                    if (i >= s.length) return !1;
                    const r = s[i];
                    return e._$PickOne$_(r), t._$ApplySolToContainer$_(), !0;
                },
                _$PickAll$_(t) {
                    if (!t) return !1;
                    if (!t._$GetInstanceCount$_()) return !1;
                    const e = t._$GetCurrentSol$_();
                    return e._$_SetSelectAll$_(!0), t._$ApplySolToContainer$_(), 
                    !0;
                },
                _$PickOverlappingPoint$_(t, s, i) {
                    if (!t) return !1;
                    const r = t._$GetCurrentSol$_(), e = r._$GetInstances$_(), n = this._$_runtime$_._$GetCurrentEvent$_(), h = n._$IsOrBlock$_(), o = this._$_runtime$_._$GetCurrentCondition$_()._$IsInverted$_();
                    r._$IsSelectAll$_() ? (h1._$shallowAssignArray$_(i1, e), r._$ClearArrays$_(), 
                    r._$_SetSelectAll$_(!1)) : h ? (h1._$shallowAssignArray$_(i1, r._$_GetOwnElseInstances$_()), 
                    h1._$clearArray$_(r._$_GetOwnElseInstances$_())) : (h1._$shallowAssignArray$_(i1, r._$_GetOwnInstances$_()), 
                    h1._$clearArray$_(r._$_GetOwnInstances$_()));
                    for (let t = 0, e = i1.length; t < e; ++t) {
                        const a = i1[t];
                        h1.xor(a._$GetWorldInfo$_()._$ContainsPoint$_(s, i), o) ? r._$_PushInstance$_(a) : r._$_PushElseInstance$_(a);
                    }
                    return t._$ApplySolToContainer$_(), h1.xor(!!r._$_GetOwnInstances$_().length, o);
                },
                _$PickLastCreated$_(e) {
                    if (!e) return !1;
                    let s = e._$IsFamily$_(), i = null, r = this._$_runtime$_._$_GetInstancesPendingCreate$_();
                    for (let t = r.length - 1; 0 <= t; --t) {
                        const n = r[t];
                        if (s) {
                            if (n._$GetObjectClass$_()._$BelongsToFamily$_(e)) {
                                i = n;
                                break;
                            }
                        } else if (n._$GetObjectClass$_() === e) {
                            i = n;
                            break;
                        }
                    }
                    if (!i) {
                        const h = e._$GetInstances$_();
                        h.length && (i = h.at(-1));
                    }
                    if (!i) return !1;
                    const t = e._$GetCurrentSol$_();
                    return t._$PickOne$_(i), e._$ApplySolToContainer$_(), !0;
                },
                _$Repeat$_(t) {
                    return this._$_runtime$_._$IsDebugging$_() ? this._$_DebugRepeat$_(t) : this._$_Repeat$_(t);
                },
                _$While$_() {
                    return this._$_runtime$_._$IsDebugging$_() ? this._$_DebugWhile$_() : this._$_While$_();
                },
                _$For$_(t, e, s) {
                    return this._$_runtime$_._$IsDebugging$_() ? this._$_DebugFor$_(t, e, s) : this._$_For$_(t, e, s);
                },
                _$ForEach$_(t) {
                    return this._$_runtime$_._$IsDebugging$_() ? this._$_DebugForEach$_(t) : this._$_ForEach$_(t);
                },
                _$ForEachOrdered$_(t, e, s) {
                    return this._$_runtime$_._$IsDebugging$_() ? this._$_DebugForEachOrdered$_(t, s) : this._$_ForEachOrdered$_(t, s);
                },
                _$LayerVisible$_(t) {
                    return !!t && t._$IsVisible$_();
                },
                _$LayerInteractive$_(t) {
                    return !!t && t._$IsSelfAndParentsInteractive$_();
                },
                _$LayerIsHTML$_(t) {
                    return !!t && t._$IsHTMLElementsLayer$_();
                },
                _$LayerEmpty$_(t) {
                    return !!t && !t._$GetInstanceCount$_();
                },
                _$LayerCmpOpacity$_(t, e, s) {
                    return !!t && h1.compare(100 * t._$GetOpacity$_(), e, s);
                },
                _$LayerNameExists$_(t) {
                    const e = this._$_runtime$_._$GetMainRunningLayout$_();
                    return !!e && e._$HasLayerByName$_(t);
                },
                _$OnImageLoadingComplete$_() {
                    return !0;
                },
                _$IsLoadingImages$_() {
                    return 0 < this._$_imagesLoadingTotal$_;
                },
                _$TemplateExists$_(t, e) {
                    const s = this._$_runtime$_._$GetTemplateManager$_();
                    return !!s && !!e && !!s._$GetTemplateData$_(t, e);
                }
            };
        }
        {
            let SortZOrderList2 = function(t, e) {
                const s = t[0], i = e[0], r = s - i;
                if (0 != r) return r;
                const n = t[1], h = e[1];
                return n - h;
            }, SortInstancesByValue2 = function(t, e) {
                return t[1] - e[1];
            };
            SortZOrderList = SortZOrderList2, SortInstancesByValue = SortInstancesByValue2;
            const M2 = self._$C3$_, N2 = [], O2 = [], P2 = M2._$New$_(M2.Rect), Q2 = M2._$New$_(M2._$Color$_), R2 = [];
            M2._$Plugins$_._$System$_._$Acts$_ = {
                _$SetVar$_(t, e) {
                    t._$SetValue$_(e);
                },
                _$AddVar$_(t, e) {
                    t._$IsNumber$_() && "number" != typeof e && (e = parseFloat(e)), 
                    t._$SetValue$_(t._$GetValue$_() + e);
                },
                _$SubVar$_(t, e) {
                    t._$IsNumber$_() && t._$SetValue$_(t._$GetValue$_() - e);
                },
                _$SetBoolVar$_(t, e) {
                    t._$SetValue$_(!!e);
                },
                _$ToggleBoolVar$_(t) {
                    t._$SetValue$_(!t._$GetValue$_());
                },
                _$ResetEventVar$_(t) {
                    t._$SetValue$_(t._$GetInitialValue$_());
                },
                _$ResetGlobals$_(t) {
                    this._$_runtime$_._$GetEventSheetManager$_()._$ResetAllGlobalsToInitialValue$_(t);
                },
                _$CreateObject$_(t, e, s, i, r, n) {
                    if (t && e) {
                        const h = this._$_runtime$_._$CreateInstance$_(t, e, s, i, r, n);
                        if (h) {
                            r && e._$SortAndAddInstancesByZIndex$_(h);
                            const o = this._$_runtime$_._$GetEventSheetManager$_(), a = (o._$BlockFlushingInstances$_(!0), 
                            h._$_TriggerOnCreatedOnSelfAndRelated$_(), o._$BlockFlushingInstances$_(!1), 
                            new Map());
                            h._$CollectInstancesToPick$_(a, t, r);
                            for (const [ l, u ] of a) l._$GetCurrentSol$_()._$SetSetPicked$_(u);
                        }
                    }
                },
                _$CreateObjectByName$_(t, e, s, i, r, n) {
                    if (t && e) {
                        const h = this._$_runtime$_._$GetObjectClassByName$_(t);
                        h && M2._$Plugins$_._$System$_._$Acts$_._$CreateObject$_.call(this, h, e, s, i, r, n);
                    }
                },
                _$RecreateInitialObjects$_(r, n, h, o, a, t, l, u, c, f, d) {
                    if (r) {
                        let e = this._$_runtime$_._$GetCurrentLayout$_(), s = e;
                        if (t) {
                            const p = this._$_runtime$_._$GetLayoutManager$_()._$GetLayoutByName$_(t);
                            if (!p) return;
                            s = p;
                        }
                        let i = null;
                        if (!("number" != typeof l || 0 <= l) || (i = s._$GetLayer$_(l))) {
                            let t = null;
                            if (!("number" != typeof u || 0 <= u) || (t = e._$GetLayer$_(u))) {
                                P2.set(n, h, o, a);
                                const m = s._$RecreateInitialObjects$_(r, P2, i, t, c, f, d);
                                r._$GetCurrentSol$_()._$SetArrayPicked$_(m), r._$ApplySolToContainer$_();
                            }
                        }
                    }
                },
                _$StopLoop$_() {
                    const t = this._$_loopStack$_;
                    t._$IsInLoop$_() && t._$GetCurrent$_()._$Stop$_();
                },
                _$SetGroupActive$_(t, e) {
                    const s = this._$_runtime$_._$GetEventSheetManager$_()._$GetEventGroupByName$_(t);
                    s && (0 === e ? s._$SetGroupActive$_(!1) : 1 === e ? s._$SetGroupActive$_(!0) : s._$SetGroupActive$_(!s._$IsGroupActive$_()));
                },
                _$SetTimescale$_(t) {
                    this._$_runtime$_._$SetTimeScale$_(t);
                },
                _$SetObjectTimescale$_(t, e) {
                    if (e < 0 && (e = 0), t) {
                        const s = t._$GetCurrentSol$_(), i = s._$GetInstances$_();
                        for (const r of i) r._$SetTimeScale$_(e);
                    }
                },
                _$RestoreObjectTimescale$_(t) {
                    if (t) {
                        const e = t._$GetCurrentSol$_(), s = e._$GetInstances$_();
                        for (const i of s) i._$RestoreTimeScale$_();
                    }
                },
                _$Wait$_(t, e) {
                    if (!(t < 0)) {
                        const s = this._$_runtime$_._$GetEventSheetManager$_()._$AddScheduledWait$_();
                        return e ? s._$InitTimer$_(t) : s._$InitWallTimer$_(t), 
                        !0;
                    }
                },
                _$WaitForSignal$_(t) {
                    return this._$_runtime$_._$GetEventSheetManager$_()._$AddScheduledWait$_()._$InitSignal$_(t), 
                    !0;
                },
                _$WaitForPreviousActions$_() {
                    const t = this._$_runtime$_._$GetEventSheetManager$_();
                    return t._$AddScheduledWait$_()._$InitPromise$_(t._$GetPromiseForAllAsyncActions$_()), 
                    !0;
                },
                _$Signal$_(t) {
                    this._$_runtime$_._$GetEventSheetManager$_()._$Signal$_(t);
                },
                async _$SnapshotCanvas$_(t, e, s, i, r, n) {
                    const h = this._$_runtime$_._$GetCanvasManager$_();
                    h && (this._$UpdateRender$_(), await h._$SnapshotCanvas$_(0 === t ? "image/png" : "image/jpeg", e / 100, s, i, r, n), 
                    await this._$_runtime$_._$TriggerAsync$_(M2._$Plugins$_._$System$_._$Cnds$_._$OnCanvasSnapshot$_, null));
                },
                _$SetCanvasSize$_(t, e) {
                    if (!(t <= 0 || e <= 0)) {
                        this._$_runtime$_._$SetViewportSize$_(t, e), this._$_runtime$_._$GetCurrentLayout$_()._$BoundScrolling$_();
                        const s = this._$_runtime$_._$GetCanvasManager$_();
                        s && ("off" !== s._$GetCurrentFullscreenMode$_() && this._$_runtime$_._$SetOriginalViewportSize$_(t, e), 
                        s._$SetSize$_(s._$GetLastWidth$_(), s._$GetLastHeight$_(), !0), 
                        this._$_runtime$_._$UpdateRender$_());
                    }
                },
                _$SetFullscreenQuality$_(t) {
                    const e = this._$_runtime$_._$GetCanvasManager$_();
                    e && "off" !== e._$GetCurrentFullscreenMode$_() && (e._$SetFullscreenScalingQuality$_(0 !== t ? "high" : "low"), 
                    e._$SetSize$_(e._$GetLastWidth$_(), e._$GetLastHeight$_(), !0));
                },
                _$SaveState$_(t) {
                    this._$_runtime$_._$SaveToSlot$_(t);
                },
                _$SaveStateJSON$_() {
                    this._$_runtime$_._$SaveToJsonString$_();
                },
                _$LoadState$_(t) {
                    this._$_runtime$_._$LoadFromSlot$_(t);
                },
                _$LoadStateJSON$_(t) {
                    this._$_runtime$_._$LoadFromJsonString$_(t);
                },
                _$SetHalfFramerateMode$_(t) {},
                _$ResetPersisted$_() {
                    for (const t of this._$_runtime$_._$GetLayoutManager$_()._$GetAllLayouts$_()) t._$ResetPersistData$_();
                },
                _$SetPixelRounding$_(t) {
                    this._$_runtime$_._$SetPixelRoundingEnabled$_(0 !== t);
                },
                _$SetFramerateMinMax$_(t, e) {
                    this._$_runtime$_._$SetMaxDt$_(1 / t), this._$_runtime$_._$SetMinDt$_(1 / e);
                },
                _$SetDeltaTimeMinMax$_(t, e) {
                    this._$_runtime$_._$SetMinDt$_(t), this._$_runtime$_._$SetMaxDt$_(e);
                },
                _$SetFramerateMode$_(t) {
                    this._$_runtime$_._$_SetFramerateMode$_([ "vsync", "unlimited-tick", "unlimited-frame" ][t]);
                },
                _$SortZOrderByInstVar$_(t, s) {
                    if (t) {
                        const e = t._$GetCurrentSol$_(), i = e._$GetInstances$_(), r = N2, n = O2, h = this._$_runtime$_._$GetCurrentLayout$_(), o = t._$IsFamily$_(), a = t._$GetFamilyIndex$_();
                        for (let t = 0, e = i.length; t < e; ++t) {
                            const l = i[t], u = l._$GetWorldInfo$_();
                            if (u) {
                                let t;
                                t = o ? l._$GetInstanceVariableValue$_(s + l._$GetObjectClass$_()._$GetFamilyInstanceVariableOffset$_(a)) : l._$GetInstanceVariableValue$_(s), 
                                r.push([ u._$GetLayer$_()._$GetIndex$_(), u._$GetZIndex$_() ]), 
                                n.push([ l, t ]);
                            }
                        }
                        if (r.length) {
                            r.sort(SortZOrderList2), n.sort(SortInstancesByValue2);
                            let s = !1;
                            for (let t = 0, e = r.length; t < e; ++t) {
                                const c = n[t][0], f = h._$GetLayerByIndex$_(r[t][0]), d = r[t][1], p = f._$_GetInstances$_();
                                p[d] !== c && ((p[d] = c)._$GetWorldInfo$_()._$_SetLayer$_(f, !0), 
                                f._$SetZIndicesChanged$_(c), s = !0);
                            }
                            s && this._$_runtime$_._$UpdateRender$_(), M2._$clearArray$_(N2), 
                            M2._$clearArray$_(O2);
                        }
                    }
                },
                _$SetCollisionCellSize$_(t, e) {
                    t = Math.floor(t), e = Math.floor(e), t <= 0 || e <= 0 || !Number.isFinite(t) || !Number.isFinite(e) || this._$_runtime$_._$GetCollisionEngine$_()._$SetCollisionCellSize$_(t, e);
                },
                _$GoToLayout$_(t) {
                    if (!this._$_runtime$_._$IsLoading$_()) {
                        const e = this._$_runtime$_._$GetLayoutManager$_();
                        e._$IsPendingChangeMainLayout$_() || e._$ChangeMainLayout$_(t);
                    }
                },
                _$GoToLayoutByName$_(t) {
                    if (!this._$_runtime$_._$IsLoading$_()) {
                        const e = this._$_runtime$_._$GetLayoutManager$_();
                        if (!e._$IsPendingChangeMainLayout$_()) {
                            const s = e._$GetLayoutByName$_(t);
                            s && e._$ChangeMainLayout$_(s);
                        }
                    }
                },
                _$NextPrevLayout$_(t) {
                    if (!this._$_runtime$_._$IsLoading$_()) {
                        const e = this._$_runtime$_._$GetLayoutManager$_();
                        if (!e._$IsPendingChangeMainLayout$_()) {
                            const s = e._$GetAllLayouts$_(), i = s.indexOf(e._$GetMainRunningLayout$_());
                            if ((!t || 0 !== i) && (t || i !== s.length - 1)) {
                                const r = s[i + (t ? -1 : 1)];
                                e._$ChangeMainLayout$_(r);
                            }
                        }
                    }
                },
                _$RestartLayout$_() {
                    if (!this._$_runtime$_._$IsLoading$_()) {
                        const t = this._$_runtime$_._$GetLayoutManager$_();
                        t._$IsPendingChangeMainLayout$_() || (t._$ChangeMainLayout$_(t._$GetMainRunningLayout$_()), 
                        this._$_runtime$_._$GetEventSheetManager$_()._$ResetAllGroupsInitialActivation$_());
                    }
                },
                _$SetLayerVisible$_(t, e) {
                    t && t._$SetVisible$_(e);
                },
                _$SetLayerInteractive$_(t, e) {
                    t && t._$SetInteractive$_(e);
                },
                _$SetLayerHTML$_(t, e) {
                    t && t._$SetIsHTMLElementsLayer$_(e);
                },
                _$SetLayerOpacity$_(t, e) {
                    t && t._$SetOpacity$_(e / 100);
                },
                _$SetLayerScale$_(t, e) {
                    t && t._$SetOwnScale$_(e);
                },
                _$SetLayerScaleRate$_(t, e) {
                    t && t._$SetScaleRate$_(e);
                },
                _$SetLayerAngle$_(t, e) {
                    t && t._$SetAngle$_(M2._$toRadians$_(+e));
                },
                _$SetLayerScroll$_(t, e, s) {
                    t && (t._$SetOwnScrollPositionEnabled$_(!0), t._$SetScrollX$_(e), 
                    t._$SetScrollY$_(s));
                },
                _$RestoreLayerScroll$_(t) {
                    t && t._$SetOwnScrollPositionEnabled$_(!1);
                },
                _$SetLayerParallax$_(t, e, s) {
                    t && t._$SetParallax$_(e / 100, s / 100);
                },
                _$SetLayerZElevation$_(t, e) {
                    t && t._$SetZElevation$_(+e);
                },
                _$SetLayerBackground$_(t, e) {
                    if (t) {
                        Q2._$setFromRgbValue$_(e), Q2._$clamp$_();
                        const s = t._$GetBackgroundColor$_();
                        s._$equalsIgnoringAlpha$_(Q2) || (s._$copyRgb$_(Q2), this._$UpdateRender$_());
                    }
                },
                _$SetLayerTransparent$_(t, e) {
                    t && t._$SetTransparent$_(e);
                },
                _$SetLayerBlendMode$_(t, e) {
                    t && t._$SetBlendMode$_(e);
                },
                _$SetLayerEffectEnabled$_(t, e, s) {
                    if (t) {
                        const i = t._$GetEffectList$_(), r = i._$GetEffectTypeByName$_(s);
                        if (r) {
                            const n = 1 === e;
                            r._$IsActive$_() !== n && (r._$SetActive$_(n), t._$UpdateActiveEffects$_(), 
                            this._$_runtime$_._$UpdateRender$_());
                        }
                    }
                },
                _$SetLayerEffectParam$_(t, e, s, i) {
                    if (t) {
                        const r = t._$GetEffectList$_(), n = r._$GetEffectTypeByName$_(e);
                        if (n) {
                            s = Math.floor(s);
                            const h = n._$GetShaderProgram$_()._$GetParameterType$_(s);
                            if (h) {
                                "color" === h ? (Q2._$setFromRgbValue$_(i), i = Q2) : "percent" === h && (i /= 100);
                                const o = r._$SetEffectParameter$_(n._$GetIndex$_(), s, i);
                                o && n._$IsActive$_() && this._$_runtime$_._$UpdateRender$_();
                            }
                        }
                    }
                },
                _$SetLayerForceOwnTexture$_(t, e) {
                    t && t._$SetForceOwnTexture$_(e);
                },
                _$SetLayoutScale$_(t) {
                    this._$_runtime$_._$GetCurrentLayout$_()._$SetScale$_(+t);
                },
                _$SetLayoutAngle$_(t) {
                    this._$_runtime$_._$GetCurrentLayout$_()._$SetAngle$_(M2._$toRadians$_(+t));
                },
                _$SetLayoutEffectEnabled$_(t, e) {
                    const s = this._$_runtime$_._$GetCurrentLayout$_(), i = s._$GetEffectList$_(), r = i._$GetEffectTypeByName$_(e);
                    if (r) {
                        const n = 1 === t;
                        r._$IsActive$_() !== n && (r._$SetActive$_(n), s._$UpdateActiveEffects$_(), 
                        this._$_runtime$_._$UpdateRender$_());
                    }
                },
                _$SetLayoutEffectParam$_(t, e, s) {
                    const i = this._$_runtime$_._$GetCurrentLayout$_(), r = i._$GetEffectList$_(), n = r._$GetEffectTypeByName$_(t);
                    if (n) {
                        e = Math.floor(e);
                        const h = n._$GetShaderProgram$_()._$GetParameterType$_(e);
                        if (h) {
                            "color" === h ? (Q2._$setFromRgbValue$_(s), s = Q2) : "percent" === h && (s /= 100);
                            const o = r._$SetEffectParameter$_(n._$GetIndex$_(), e, s);
                            o && n._$IsActive$_() && this._$_runtime$_._$UpdateRender$_();
                        }
                    }
                },
                _$SetLayoutVanishingPoint$_(t, e) {
                    const s = this._$_runtime$_._$GetCurrentLayout$_();
                    s._$SetVanishingPointXY$_(t / 100, e / 100);
                },
                _$SetLayoutProjection$_(t) {
                    const e = this._$_runtime$_._$GetCurrentLayout$_();
                    0 === t ? e._$SetPerspectiveProjection$_() : e._$SetOrthographicProjection$_();
                },
                _$ScrollX$_(t) {
                    const e = this._$_runtime$_._$GetCurrentLayout$_();
                    e._$SetScrollX$_(t);
                },
                _$ScrollY$_(t) {
                    const e = this._$_runtime$_._$GetCurrentLayout$_();
                    e._$SetScrollY$_(t);
                },
                _$Scroll$_(t, e) {
                    const s = this._$_runtime$_._$GetCurrentLayout$_();
                    s._$SetScrollX$_(t), s._$SetScrollY$_(e);
                },
                _$ScrollToObject$_(t) {
                    if (t) {
                        const e = t._$GetFirstPicked$_();
                        if (e) {
                            const s = e._$GetWorldInfo$_();
                            if (s) {
                                const i = this._$_runtime$_._$GetCurrentLayout$_();
                                i._$SetScrollX$_(s._$GetX$_()), i._$SetScrollY$_(s._$GetY$_());
                            }
                        }
                    }
                },
                _$AddLayer$_(t, e, s) {
                    const i = this._$_runtime$_._$GetCurrentLayout$_();
                    try {
                        i._$AddLayer$_(t, e, s);
                    } catch (t) {
                        console.warn("[Construct] Cannot add layer: ", t);
                    }
                },
                _$MoveLayer$_(t, e, s) {
                    if (t) {
                        const i = this._$_runtime$_._$GetCurrentLayout$_();
                        try {
                            i._$MoveLayer$_(t, e, s);
                        } catch (t) {
                            console.warn("[Construct] Cannot move layer: ", t);
                        }
                    }
                },
                _$RemoveLayer$_(t) {
                    if (t) {
                        const e = this._$_runtime$_._$GetCurrentLayout$_();
                        e._$RemoveLayer$_(t);
                    }
                },
                _$RemoveAllDynamicLayers$_() {
                    this._$_runtime$_._$GetCurrentLayout$_()._$RemoveAllDynamicLayers$_();
                },
                async _$LoadObjectTextures$_(t) {
                    const e = this._$_runtime$_._$GetMainRunningLayout$_();
                    if (e && t && !this._$_runtime$_._$IsLoading$_()) {
                        const s = t._$IsFamily$_() ? t._$GetFamilyMembers$_() : [ t ];
                        await this._$_LoadTexturesForObjectClasses$_(e, s);
                    }
                },
                async _$LoadObjectTexturesByName$_(t) {
                    await M2._$Plugins$_._$System$_._$Acts$_._$LoadObjectTextures$_.call(this, this._$_runtime$_._$GetObjectClassByName$_(t));
                },
                _$UnloadObjectTextures$_(t) {
                    const e = this._$_runtime$_._$GetMainRunningLayout$_();
                    if (e && t) {
                        const s = t._$IsFamily$_() ? t._$GetFamilyMembers$_() : [ t ];
                        this._$_UnloadTexturesForObjectClasses$_(e, s);
                    }
                },
                _$UnloadObjectTexturesByName$_(t) {
                    M2._$Plugins$_._$System$_._$Acts$_._$UnloadObjectTextures$_.call(this, this._$_runtime$_._$GetObjectClassByName$_(t));
                },
                _$UnloadUnusedTextures$_() {
                    const t = this._$_runtime$_._$GetMainRunningLayout$_();
                    if (t) {
                        const e = t._$_GetTextureLoadedObjectTypes$_();
                        this._$_UnloadTexturesForObjectClasses$_(t, e);
                    }
                },
                async _$LoadLayoutTextures$_(t) {
                    const e = this._$_runtime$_._$GetMainRunningLayout$_();
                    t && e && !this._$_runtime$_._$IsLoading$_() && await this._$_LoadTexturesForObjectClasses$_(e, t._$_GetInitialObjectClasses$_());
                },
                async _$LoadLayoutTexturesByName$_(t) {
                    const e = this._$_runtime$_._$GetMainRunningLayout$_(), s = this._$_runtime$_._$GetLayoutManager$_()._$GetLayoutByName$_(t);
                    s && e && !this._$_runtime$_._$IsLoading$_() && await this._$_LoadTexturesForObjectClasses$_(e, s._$_GetInitialObjectClasses$_());
                },
                _$SetFunctionReturnValue$_(t) {
                    const e = this._$_eventStack$_._$GetCurrentExpFuncStackFrame$_();
                    if (e) switch (e._$GetFunctionReturnType$_()) {
                      case 1:
                        "number" == typeof t && e._$SetFunctionReturnValue$_(t);
                        break;

                      case 2:
                        "string" == typeof t && e._$SetFunctionReturnValue$_(t);
                        break;

                      case 3:
                        e._$SetFunctionReturnValue$_(t);
                    }
                },
                _$MapFunction$_(t, e, s) {
                    const i = this._$_GetFunctionMap$_(t.toLowerCase(), !0), r = i._$strMap$_, n = e.toLowerCase(), h = (r.has(n) && console.warn(`[Construct] Function map '${t}' string '${e}' already in map; overwriting entry`), 
                    M2.first(r.values()) || i._$defaultFunc$_);
                    if (h) {
                        const o = 0 !== h._$GetReturnType$_(), a = 0 !== s._$GetReturnType$_();
                        if (o != a) return void console.error(`[Construct] Function map '${t}' string '${e}' function return type not compatible with other functions in the map; entry ignored`);
                    }
                    r.set(n, s);
                },
                _$MapFunctionDefault$_(t, e) {
                    const s = this._$_GetFunctionMap$_(t.toLowerCase(), !0), i = (s._$defaultFunc$_ && console.warn(`[Construct] Function map '${t}' already has a default; overwriting entry`), 
                    M2.first(s._$strMap$_.values()) || s._$defaultFunc$_);
                    if (i) {
                        const r = 0 !== i._$GetReturnType$_(), n = 0 !== e._$GetReturnType$_();
                        if (r != n) return void console.error(`[Construct] Function map '${t}' default: function return type not compatible with other functions in the map; entry ignored`);
                    }
                    s._$defaultFunc$_ = e;
                },
                _$CallMappedFunction$_(t, e, s) {
                    const i = this._$_runtime$_, r = i._$IsDebugging$_() ? R2 : null, n = (s = Math.floor(s), 
                    this._$_GetFunctionMap$_(t.toLowerCase(), !1));
                    if (!n) return console.warn(`[Construct] Call mapped function: map name '${t}' not found; call ignored`), 
                    r;
                    let h = n._$strMap$_.get(e.toLowerCase());
                    if (!h) {
                        if (!n._$defaultFunc$_) return console.warn(`[Construct] Call mapped function: no function associated with map '${t}' string '${e}'; call ignored (consider setting a default)`), 
                        r;
                        h = n._$defaultFunc$_, s = 0;
                    }
                    if (!h._$IsEnabled$_()) return r;
                    if (0 !== h._$GetReturnType$_()) return console.warn(`[Construct] Call mapped function: map '${t}' string '${e}' has a return type so cannot be called`), 
                    r;
                    const o = i._$GetEventSheetManager$_(), a = o._$GetCurrentEvent$_(), l = a._$GetSolModifiersIncludingParents$_(), u = 0 < l.length, c = (u && (h._$IsCopyPicked$_() ? o._$PushCopySol$_(l) : o._$PushCleanSol$_(l)), 
                    []), f = o._$FindFirstFunctionBlockParent$_(a);
                    if (f) {
                        const p = f._$GetFunctionParameters$_();
                        for (let t = s, e = p.length; t < e; ++t) c.push(p[t]._$GetValue$_());
                    }
                    const d = h._$GetFunctionParameters$_();
                    for (let t = c.length, e = d.length; t < e; ++t) c.push(d[t]._$GetInitialValue$_());
                    return i._$IsDebugging$_() ? this._$_DebugDoCallMappedFunction$_(o, h, c, u, l) : this._$_DoCallMappedFunction$_(o, h, c, u, l);
                }
            };
        }
        {
            const Xf = self._$C3$_;
            Xf._$Plugins$_._$System$_._$Exps$_ = {
                _$int$_: function(t) {
                    return "string" == typeof t && (t = parseInt(t, 10), isNaN(t)) && (t = 0), 
                    Math.floor(t);
                },
                float: function(t) {
                    return "string" == typeof t && (t = parseFloat(t), isNaN(t)) ? 0 : t;
                },
                _$str$_(t) {
                    return t.toString();
                },
                _$len$_(t) {
                    return "string" == typeof t ? t.length : 0;
                },
                random(t, e) {
                    return void 0 === e ? this._$_runtime$_._$Random$_() * t : this._$_runtime$_._$Random$_() * (e - t) + t;
                },
                _$choose$_(...t) {
                    const e = Math.floor(this._$_runtime$_._$Random$_() * t.length);
                    return t[e];
                },
                _$chooseindex$_(t, ...e) {
                    return "number" != typeof t && (t = 0), e[t = Xf._$clamp$_(Math.floor(t), 0, e.length - 1)];
                },
                pi() {
                    return Math.PI;
                },
                _$infinity$_() {
                    return 1 / 0;
                },
                sqrt(t) {
                    return Math.sqrt(t);
                },
                abs(t) {
                    return Math.abs(t);
                },
                round(t) {
                    return Math.round(t);
                },
                _$roundtodp$_(t, e) {
                    e = Math.max(Math.floor(e), 0);
                    const s = Math.pow(10, e);
                    return Math.round((t + Number.EPSILON) * s) / s;
                },
                floor(t) {
                    return Math.floor(t);
                },
                ceil(t) {
                    return Math.ceil(t);
                },
                sign(t) {
                    return Math.sign(t);
                },
                sin(t) {
                    return Math.sin(Xf._$toRadians$_(t));
                },
                cos(t) {
                    return Math.cos(Xf._$toRadians$_(t));
                },
                tan(t) {
                    return Math.tan(Xf._$toRadians$_(t));
                },
                asin(t) {
                    return Xf._$toDegrees$_(Math.asin(t));
                },
                acos(t) {
                    return Xf._$toDegrees$_(Math.acos(t));
                },
                atan(t) {
                    return Xf._$toDegrees$_(Math.atan(t));
                },
                exp(t) {
                    return Math.exp(t);
                },
                _$ln$_(t) {
                    return Math.log(t);
                },
                log10(t) {
                    return Math.log10(t);
                },
                max(...s) {
                    let i = s[0];
                    "number" != typeof i && (i = 0);
                    for (let e = 1, t = s.length; e < t; ++e) {
                        let t = s[e];
                        "number" == typeof t && i < t && (i = t);
                    }
                    return i;
                },
                min(...s) {
                    let i = s[0];
                    "number" != typeof i && (i = 0);
                    for (let e = 1, t = s.length; e < t; ++e) {
                        let t = s[e];
                        "number" == typeof t && i > t && (i = t);
                    }
                    return i;
                },
                _$clamp$_(t, e, s) {
                    return Xf._$clamp$_(t, e, s);
                },
                _$distance$_(t, e, s, i) {
                    return Xf._$distanceTo$_(t, e, s, i);
                },
                angle(t, e, s, i) {
                    return Xf._$toDegrees$_(Xf._$angleTo$_(t, e, s, i));
                },
                _$lerp$_(t, e, s) {
                    return Xf._$lerp$_(t, e, s);
                },
                _$unlerp$_(t, e, s) {
                    return Xf._$unlerp$_(t, e, s);
                },
                _$qarp$_(t, e, s, i) {
                    return Xf._$qarp$_(t, e, s, i);
                },
                _$cubic$_(t, e, s, i, r) {
                    return Xf._$cubic$_(t, e, s, i, r);
                },
                _$cosp$_(t, e, s) {
                    return Xf._$cosp$_(t, e, s);
                },
                _$anglediff$_(t, e) {
                    return Xf._$toDegrees$_(Xf._$angleDiff$_(Xf._$toRadians$_(t), Xf._$toRadians$_(e)));
                },
                _$anglelerp$_(t, e, s) {
                    return Xf._$toDegrees$_(Xf._$angleLerp$_(Xf._$toRadians$_(t), Xf._$toRadians$_(e), s));
                },
                _$anglerotate$_(t, e, s) {
                    return Xf._$toDegrees$_(Xf._$angleRotate$_(Xf._$toRadians$_(t), Xf._$toRadians$_(e), Xf._$toRadians$_(s)));
                },
                _$setbit$_(t, e, s) {
                    return (t |= 0) & ~(1 << (e |= 0)) | (s = 0 !== s ? 1 : 0) << e;
                },
                _$togglebit$_(t, e) {
                    return (t |= 0) ^ 1 << (0 | e);
                },
                _$getbit$_(t, e) {
                    return (t |= 0) & 1 << (0 | e) ? 1 : 0;
                },
                _$newline$_() {
                    return "\n";
                },
                _$uppercase$_(t) {
                    return "string" == typeof t ? t.toUpperCase() : "";
                },
                _$lowercase$_(t) {
                    return "string" == typeof t ? t.toLowerCase() : "";
                },
                left(t, e) {
                    return "string" == typeof t ? t.substr(0, e) : "";
                },
                mid(t, e, s) {
                    return "string" != typeof t ? "" : s < 0 ? t.substr(e) : t.substr(e, s);
                },
                right(t, e) {
                    return "string" == typeof t ? t.substr(Math.max(t.length - e, 0)) : "";
                },
                trim(t) {
                    return "string" == typeof t ? t.trim() : "";
                },
                _$tokenat$_(t, e, s) {
                    if ("string" != typeof t || "string" != typeof s) return "";
                    let i = t.split(s);
                    return (e = Math.floor(e)) < 0 || e >= i.length ? "" : i[e];
                },
                _$tokencount$_(t, e) {
                    return "string" == typeof t && "string" == typeof e && t.length ? t.split(e).length : 0;
                },
                find(t, e) {
                    return "string" == typeof t && "string" == typeof e ? t.search(new RegExp(Xf._$EscapeRegex$_(e), "i")) : -1;
                },
                _$findcase$_(t, e) {
                    return "string" == typeof t && "string" == typeof e ? t.search(new RegExp(Xf._$EscapeRegex$_(e), "")) : -1;
                },
                replace(t, e, s) {
                    return "string" == typeof t && "string" == typeof e && "string" == typeof s ? t.replace(new RegExp(Xf._$EscapeRegex$_(e), "gi"), s) : "string" == typeof t ? t : "";
                },
                _$stringsub$_(t, ...s) {
                    let i = t;
                    for (let t = 0, e = s.length; t < e; ++t) i = i.replaceAll(`{${t}}`, s[t].toString());
                    return i;
                },
                _$regexsearch$_(t, e, s) {
                    const i = this._$GetRegex$_(e, s);
                    return t ? t.search(i) : -1;
                },
                _$regexreplace$_(t, e, s, i) {
                    const r = this._$GetRegex$_(e, s);
                    return t ? t.replace(r, i) : "";
                },
                _$regexmatchcount$_(t, e, s) {
                    const i = this._$GetRegexMatches$_(t.toString(), e, s);
                    return i ? i.length : 0;
                },
                _$regexmatchat$_(t, e, s, i) {
                    i = Math.floor(i);
                    const r = this._$GetRegexMatches$_(t.toString(), e, s);
                    return !r || i < 0 || i >= r.length ? "" : r[i];
                },
                _$zeropad$_(t, e) {
                    let s = t < 0 ? "-" : "", i = e - (t = t < 0 ? -t : t).toString().length;
                    return (s += "0".repeat(Math.max(i, 0))) + t.toString();
                },
                _$urlencode$_(t) {
                    return encodeURIComponent(t);
                },
                _$urldecode$_(t) {
                    return decodeURIComponent(t);
                },
                dt() {
                    return this._$_runtime$_._$_GetDtFast$_();
                },
                _$wallclockdt$_() {
                    return this._$_runtime$_._$GetDt1$_();
                },
                timescale() {
                    return this._$_runtime$_._$GetTimeScale$_();
                },
                _$wallclocktime$_() {
                    return (Date.now() - this._$_runtime$_._$GetStartTime$_()) / 1e3;
                },
                _$unixtime$_() {
                    return Date.now();
                },
                time() {
                    return this._$_runtime$_._$GetGameTime$_();
                },
                tickcount() {
                    return this._$_runtime$_._$GetTickCount$_();
                },
                _$objectcount$_() {
                    return this._$_runtime$_._$GetObjectCount$_();
                },
                fps() {
                    return this._$_runtime$_._$GetFramesPerSecond$_();
                },
                _$cpuutilisation$_() {
                    return this._$_runtime$_._$GetMainThreadTime$_();
                },
                _$gpuutilisation$_() {
                    return this._$_runtime$_._$GetGPUUtilisation$_();
                },
                _$windowwidth$_() {
                    return this._$_runtime$_._$GetCanvasManager$_()._$GetDeviceWidth$_();
                },
                _$windowheight$_() {
                    return this._$_runtime$_._$GetCanvasManager$_()._$GetDeviceHeight$_();
                },
                _$originalwindowwidth$_() {
                    return this._$_runtime$_._$GetOriginalViewportWidth$_();
                },
                _$originalwindowheight$_() {
                    return this._$_runtime$_._$GetOriginalViewportHeight$_();
                },
                _$originalviewportwidth$_() {
                    return this._$_runtime$_._$GetOriginalViewportWidth$_();
                },
                _$originalviewportheight$_() {
                    return this._$_runtime$_._$GetOriginalViewportHeight$_();
                },
                _$scrollx$_() {
                    return this._$_runtime$_._$GetCurrentLayout$_()._$GetScrollX$_();
                },
                _$scrolly$_() {
                    return this._$_runtime$_._$GetCurrentLayout$_()._$GetScrollY$_();
                },
                _$layoutname$_() {
                    return this._$_runtime$_._$GetCurrentLayout$_()._$GetName$_();
                },
                _$layoutscale$_() {
                    return this._$_runtime$_._$GetCurrentLayout$_()._$GetScale$_();
                },
                _$layoutangle$_() {
                    return Xf._$toDegrees$_(this._$_runtime$_._$GetCurrentLayout$_().GetAngle());
                },
                _$layoutwidth$_() {
                    return this._$_runtime$_._$GetCurrentLayout$_()._$GetWidth$_();
                },
                _$layoutheight$_() {
                    return this._$_runtime$_._$GetCurrentLayout$_()._$GetHeight$_();
                },
                _$vanishingpointx$_() {
                    return 100 * this._$_runtime$_._$GetCurrentLayout$_()._$GetVanishingPointX$_();
                },
                _$vanishingpointy$_() {
                    return 100 * this._$_runtime$_._$GetCurrentLayout$_()._$GetVanishingPointY$_();
                },
                _$viewportleft$_(t) {
                    const e = this._$_runtime$_._$GetCurrentLayout$_()._$GetLayer$_(t);
                    return e ? e._$GetViewport3D$_()._$getLeft$_() : 0;
                },
                _$viewporttop$_(t) {
                    const e = this._$_runtime$_._$GetCurrentLayout$_()._$GetLayer$_(t);
                    return e ? e._$GetViewport3D$_()._$getTop$_() : 0;
                },
                _$viewportright$_(t) {
                    const e = this._$_runtime$_._$GetCurrentLayout$_()._$GetLayer$_(t);
                    return e ? e._$GetViewport3D$_()._$getRight$_() : 0;
                },
                _$viewportbottom$_(t) {
                    const e = this._$_runtime$_._$GetCurrentLayout$_()._$GetLayer$_(t);
                    return e ? e._$GetViewport3D$_()._$getBottom$_() : 0;
                },
                _$viewportwidth$_(t) {
                    const e = this._$_runtime$_._$GetCurrentLayout$_()._$GetLayer$_(t);
                    return e ? e._$GetViewport3D$_().width() : 0;
                },
                _$viewportheight$_(t) {
                    const e = this._$_runtime$_._$GetCurrentLayout$_()._$GetLayer$_(t);
                    return e ? e._$GetViewport3D$_().height() : 0;
                },
                _$viewportmidx$_(t) {
                    const e = this._$_runtime$_._$GetCurrentLayout$_()._$GetLayer$_(t);
                    if (e) {
                        const s = e._$GetViewport3D$_();
                        return (s._$getLeft$_() + s._$getRight$_()) / 2;
                    }
                    return 0;
                },
                _$viewportmidy$_(t) {
                    const e = this._$_runtime$_._$GetCurrentLayout$_()._$GetLayer$_(t);
                    if (e) {
                        const s = e._$GetViewport3D$_();
                        return (s._$getTop$_() + s._$getBottom$_()) / 2;
                    }
                    return 0;
                },
                _$canvastolayerx$_(t, e, s) {
                    const i = this._$_runtime$_._$GetCurrentLayout$_()._$GetLayer$_(t);
                    return i ? i._$CanvasCssToLayer$_(e, s)[0] : 0;
                },
                _$canvastolayery$_(t, e, s) {
                    const i = this._$_runtime$_._$GetCurrentLayout$_()._$GetLayer$_(t);
                    return i ? i._$CanvasCssToLayer$_(e, s)[1] : 0;
                },
                _$layertocanvasx$_(t, e, s) {
                    const i = this._$_runtime$_._$GetCurrentLayout$_()._$GetLayer$_(t);
                    return i ? i._$LayerToCanvasCss$_(e, s)[0] : 0;
                },
                _$layertocanvasy$_(t, e, s) {
                    const i = this._$_runtime$_._$GetCurrentLayout$_()._$GetLayer$_(t);
                    return i ? i._$LayerToCanvasCss$_(e, s)[1] : 0;
                },
                _$layertolayerx$_(t, e, s, i) {
                    const r = this._$_runtime$_._$GetCurrentLayout$_(), n = r._$GetLayer$_(t), h = r._$GetLayer$_(e);
                    if (!n || !h || n === h) return s;
                    const [ o, a ] = n._$LayerToCanvasCss$_(s, i);
                    return h._$CanvasCssToLayer$_(o, a)[0];
                },
                _$layertolayery$_(t, e, s, i) {
                    const r = this._$_runtime$_._$GetCurrentLayout$_(), n = r._$GetLayer$_(t), h = r._$GetLayer$_(e);
                    if (!n || !h || n === h) return i;
                    const [ o, a ] = n._$LayerToCanvasCss$_(s, i);
                    return h._$CanvasCssToLayer$_(o, a)[1];
                },
                _$layerscale$_(t) {
                    const e = this._$_runtime$_._$GetCurrentLayout$_()._$GetLayer$_(t);
                    return e ? e._$GetOwnScale$_() : 0;
                },
                _$layerangle$_(t) {
                    const e = this._$_runtime$_._$GetCurrentLayout$_()._$GetLayer$_(t);
                    return e ? Xf._$toDegrees$_(e._$GetOwnAngle$_()) : 0;
                },
                _$layeropacity$_(t) {
                    const e = this._$_runtime$_._$GetCurrentLayout$_()._$GetLayer$_(t);
                    return e ? 100 * e._$GetOpacity$_() : 0;
                },
                _$layerscalerate$_(t) {
                    const e = this._$_runtime$_._$GetCurrentLayout$_()._$GetLayer$_(t);
                    return e ? e._$GetScaleRate$_() : 0;
                },
                _$layerscrollx$_(t) {
                    const e = this._$_runtime$_._$GetCurrentLayout$_()._$GetLayer$_(t);
                    return e ? e._$GetScrollX$_() : 0;
                },
                _$layerscrolly$_(t) {
                    const e = this._$_runtime$_._$GetCurrentLayout$_()._$GetLayer$_(t);
                    return e ? e._$GetScrollY$_() : 0;
                },
                _$layerparallaxx$_(t) {
                    const e = this._$_runtime$_._$GetCurrentLayout$_()._$GetLayer$_(t);
                    return e ? 100 * e._$GetParallaxX$_() : 0;
                },
                _$layerparallaxy$_(t) {
                    const e = this._$_runtime$_._$GetCurrentLayout$_()._$GetLayer$_(t);
                    return e ? 100 * e._$GetParallaxY$_() : 0;
                },
                _$layerzelevation$_(t) {
                    const e = this._$_runtime$_._$GetCurrentLayout$_()._$GetLayer$_(t);
                    return e ? e._$GetZElevation$_() : 0;
                },
                _$layerindex$_(t) {
                    const e = this._$_runtime$_._$GetCurrentLayout$_()._$GetLayer$_(t);
                    return e ? e._$GetIndex$_() : -1;
                },
                _$canvassnapshot$_() {
                    const t = this._$_runtime$_._$GetCanvasManager$_();
                    return t ? t._$GetCanvasSnapshotUrl$_() : "";
                },
                _$loopindex$_(t) {
                    const e = this._$_loopStack$_;
                    if (!e._$IsInLoop$_()) return 0;
                    if (t) {
                        const s = e._$FindByName$_(t);
                        return s ? s._$GetIndex$_() : 0;
                    }
                    return e._$GetCurrent$_()._$GetIndex$_();
                },
                _$savestatejson$_() {
                    return this._$_runtime$_._$GetLastSaveJsonString$_();
                },
                _$callmapped$_(t, e, ...s) {
                    const i = this._$_GetFunctionMap$_(t.toLowerCase(), !1);
                    if (!i) return console.warn(`[Construct] Call mapped function: map name '${t}' not found; returning 0`), 
                    0;
                    let r = i._$strMap$_.get(e.toLowerCase());
                    if (!r) {
                        if (!i._$defaultFunc$_) return console.warn(`[Construct] Call mapped function: no function associated with map '${t}' string '${e}'; returning 0 (consider setting a default)`), 
                        0;
                        r = i._$defaultFunc$_;
                    }
                    const n = r._$GetReturnType$_(), h = r._$GetDefaultReturnValue$_();
                    if (0 === n) return console.warn(`[Construct] Call mapped function: map '${t}' string '${e}' has no return type so cannot be called from an expression; returning 0`), 
                    0;
                    if (!r._$IsEnabled$_()) return h;
                    const o = this._$_runtime$_, a = o._$GetEventSheetManager$_(), l = a._$GetCurrentEvent$_(), u = l._$GetSolModifiersIncludingParents$_(), c = 0 < u.length, f = (c && (r._$IsCopyPicked$_() ? a._$PushCopySol$_(u) : a._$PushCleanSol$_(u)), 
                    r._$GetFunctionParameters$_());
                    for (let t = s.length, e = f.length; t < e; ++t) s.push(f[t]._$GetInitialValue$_());
                    const d = r._$GetEventBlock$_(), p = d._$RunAsExpressionFunctionCall$_(d._$GetSolModifiersIncludingParents$_(), r._$IsCopyPicked$_(), n, h, ...s);
                    return c && a._$PopSol$_(u), p;
                },
                _$loadingprogress$_() {
                    return this._$_runtime$_._$GetAssetManager$_()._$GetLoadProgress$_();
                },
                _$imageloadingprogress$_() {
                    return this._$GetImageLoadingProgress$_();
                },
                renderer() {
                    return this._$_runtime$_._$GetWebGPURenderer$_() ? "webgpu" : "webgl";
                },
                _$rendererdetail$_() {
                    return this._$_runtime$_._$GetWebGPURenderer$_() ? this._$_runtime$_._$GetWebGPURenderer$_()._$GetAdapterInfoString$_() : this._$_runtime$_._$GetWebGLRenderer$_()._$GetUnmaskedRenderer$_();
                },
                _$imagememoryusage$_() {
                    let t = this._$_runtime$_._$GetRenderer$_()._$GetEstimatedTextureMemoryUsage$_();
                    return Math.round(100 * t / 1048576) / 100;
                },
                _$rgb$_(t, e, s) {
                    return Xf._$PackRGB$_(t, e, s);
                },
                _$rgbex$_(t, e, s) {
                    return Xf._$PackRGBEx$_(t / 100, e / 100, s / 100);
                },
                _$rgba$_(t, e, s, i) {
                    return Xf._$PackRGBAEx$_(t / 100, e / 100, s / 100, i / 100);
                },
                _$rgbex255$_(t, e, s) {
                    return Xf._$PackRGBEx$_(t / 255, e / 255, s / 255);
                },
                _$rgba255$_(t, e, s, i) {
                    return Xf._$PackRGBAEx$_(t / 255, e / 255, s / 255, i / 255);
                },
                _$projectname$_() {
                    return this._$_runtime$_._$GetProjectName$_();
                },
                _$projectversion$_() {
                    return this._$_runtime$_._$GetProjectVersion$_();
                },
                _$currenteventsheetname$_() {
                    return this._$_runtime$_._$GetCurrentEvent$_()._$GetEventSheet$_()._$GetName$_();
                },
                _$currenteventnumber$_() {
                    return this._$_runtime$_._$GetCurrentEvent$_()._$GetDisplayNumber$_();
                }
            };
        }
        {
            const a = self._$C3$_, b = "button";
            a._$Plugins$_._$Button$_ = class extends a._$SDKDOMPluginBase$_ {
                constructor(t) {
                    super(t, b), this._$AddElementMessageHandler$_("click", (t, e) => t._$_OnClick$_(e));
                }
                _$Release$_() {
                    super._$Release$_();
                }
            };
        }
        {
            const g = self._$C3$_;
            g._$Plugins$_._$Button$_._$Type$_ = class extends g._$SDKTypeBase$_ {
                constructor(t) {
                    super(t);
                }
                _$Release$_() {
                    super._$Release$_();
                }
                _$OnCreate$_() {}
            };
        }
        {
            const j = self._$C3$_, k = self._$C3X$_, l = 0, m = 1, n = 2, o = 3, p = 4, q = 5, r = 6, s = 7, t = 8, u = "button", v = (j._$Plugins$_._$Button$_.Instance = class extends j._$SDKDOMInstanceBase$_ {
                constructor(e, i) {
                    super(e, u), this._$_text$_ = "OK", this._$_isCheckbox$_ = !1, 
                    this._$_isChecked$_ = !1, this._$_title$_ = "", this._$_id$_ = "", 
                    this._$_className$_ = "", this._$_isEnabled$_ = !0, this._$_autoFontSize$_ = !0, 
                    i && (this._$_isCheckbox$_ = 1 === i[l], this._$_text$_ = i[m], 
                    this._$_title$_ = i[n], this._$GetWorldInfo$_()._$SetVisible$_(i[o]), 
                    this._$_isEnabled$_ = i[p], this._$_autoFontSize$_ = i[q], this._$_isChecked$_ = i[r], 
                    this._$_id$_ = i[s], this._$_className$_ = i[t]), this._$CreateElement$_({
                        id: this._$_id$_,
                        className: this._$_className$_
                    });
                }
                _$Release$_() {
                    super._$Release$_();
                }
                _$GetElementState$_() {
                    return {
                        text: this._$_text$_,
                        isCheckbox: this._$_isCheckbox$_,
                        isChecked: this._$_isChecked$_,
                        title: this._$_title$_,
                        isVisible: this._$GetWorldInfo$_()._$IsVisible$_(),
                        isEnabled: this._$_isEnabled$_
                    };
                }
                async _$_OnClick$_(t) {
                    this._$_isChecked$_ = t.isChecked, this._$DispatchScriptEvent$_("click", !0), 
                    await this._$TriggerAsync$_(j._$Plugins$_._$Button$_._$Cnds$_._$OnClicked$_);
                }
                _$_SetText$_(t) {
                    this._$_text$_ !== t && (this._$_text$_ = t, this._$UpdateElementState$_());
                }
                _$_GetText$_() {
                    return this._$_text$_;
                }
                _$_SetTooltip$_(t) {
                    this._$_title$_ !== t && (this._$_title$_ = t, this._$UpdateElementState$_());
                }
                _$_GetTooltip$_() {
                    return this._$_title$_;
                }
                _$_SetEnabled$_(t) {
                    this._$_isEnabled$_ !== (t = !!t) && (this._$_isEnabled$_ = t, 
                    this._$UpdateElementState$_());
                }
                _$_IsEnabled$_() {
                    return this._$_isEnabled$_;
                }
                _$_SetChecked$_(t) {
                    this._$_isCheckbox$_ && this._$_isChecked$_ !== (t = !!t) && (this._$_isChecked$_ = t, 
                    this._$UpdateElementState$_());
                }
                _$_IsChecked$_() {
                    return this._$_isChecked$_;
                }
                _$Draw$_(t) {}
                _$SaveToJson$_() {
                    return {
                        text: this._$_text$_,
                        checked: this._$_isChecked$_,
                        title: this._$_title$_,
                        enabled: this._$_isEnabled$_
                    };
                }
                _$LoadFromJson$_(t) {
                    this._$_text$_ = t.text, this._$_isChecked$_ = t.checked, this._$_title$_ = t.title, 
                    this._$_isEnabled$_ = t.enabled, this._$UpdateElementState$_();
                }
                _$GetPropertyValueByIndex$_(t) {
                    switch (t) {
                      case m:
                        return this._$_GetText$_();

                      case n:
                        return this._$_GetTooltip$_();

                      case p:
                        return this._$_IsEnabled$_();

                      case q:
                        return this._$_autoFontSize$_;

                      case r:
                        return this._$_IsChecked$_();
                    }
                }
                _$SetPropertyValueByIndex$_(t, e) {
                    switch (t) {
                      case m:
                        this._$_SetText$_(e);
                        break;

                      case n:
                        this._$_SetTooltip$_(e);
                        break;

                      case p:
                        this._$_SetEnabled$_(!!e);
                        break;

                      case q:
                        this._$_autoFontSize$_ = !!e;
                        break;

                      case r:
                        this._$_SetChecked$_(!!e);
                    }
                }
                _$GetDebuggerProperties$_() {
                    const t = "plugins.button";
                    return [ {
                        title: t + ".name",
                        properties: [ {
                            name: t + ".properties.text.name",
                            value: this._$_GetText$_(),
                            _$onedit$_: t => this._$_SetText$_(t)
                        }, {
                            name: t + ".properties.enabled.name",
                            value: this._$_IsEnabled$_(),
                            _$onedit$_: t => this._$_SetEnabled$_(t)
                        }, {
                            name: t + ".properties.checked.name",
                            value: this._$_IsChecked$_(),
                            _$onedit$_: t => this._$_SetChecked$_(t)
                        } ]
                    } ];
                }
                _$GetScriptInterfaceClass$_() {
                    return self._$IButtonInstance$_;
                }
            }, new WeakMap());
            self._$IButtonInstance$_ = class extends self._$IDOMInstance$_ {
                constructor() {
                    super(), v.set(this, self._$IInstance$_._$_GetInitInst$_()._$GetSdkInstance$_());
                }
                set text(t) {
                    k._$RequireString$_(t), v.get(this)._$_SetText$_(t);
                }
                get text() {
                    return v.get(this)._$_GetText$_();
                }
                set _$tooltip$_(t) {
                    k._$RequireString$_(t), v.get(this)._$_SetTooltip$_(t);
                }
                get _$tooltip$_() {
                    return v.get(this)._$_GetTooltip$_();
                }
                set isEnabled(t) {
                    v.get(this)._$_SetEnabled$_(t);
                }
                get isEnabled() {
                    return v.get(this)._$_IsEnabled$_();
                }
                set isChecked(t) {
                    v.get(this)._$_SetChecked$_(t);
                }
                get isChecked() {
                    return v.get(this)._$_IsChecked$_();
                }
            };
        }
        {
            const S = self._$C3$_;
            S._$Plugins$_._$Button$_._$Cnds$_ = {
                _$OnClicked$_() {
                    return !0;
                },
                _$IsChecked$_() {
                    return this._$_isChecked$_;
                },
                _$CompareText$_(t, e) {
                    return e ? this._$_text$_ === t : S._$equalsNoCase$_(this._$_text$_, t);
                }
            };
        }
        {
            const V = self._$C3$_;
            V._$Plugins$_._$Button$_._$Acts$_ = {
                _$SetText$_(t) {
                    this._$_SetText$_(t);
                },
                _$SetTooltip$_(t) {
                    this._$_SetTooltip$_(t);
                },
                _$SetChecked$_(t) {
                    this._$_SetChecked$_(0 !== t);
                },
                _$ToggleChecked$_() {
                    this._$_isCheckbox$_ && (this._$_isChecked$_ = !this._$_isChecked$_, 
                    this._$UpdateElementState$_());
                }
            };
        }
        {
            const Z = self._$C3$_;
            Z._$Plugins$_._$Button$_._$Exps$_ = {
                Text() {
                    return this._$_text$_;
                }
            };
        }
        {
            const a = self._$C3$_;
            a._$Plugins$_._$Sprite$_ = class extends a._$SDKPluginBase$_ {
                constructor(t) {
                    super(t);
                }
                _$Release$_() {
                    super._$Release$_();
                }
            };
        }
        {
            const d = self._$C3$_, e = self._$C3X$_, f = [], g = (d._$Plugins$_._$Sprite$_._$Type$_ = class extends d._$SDKTypeBase$_ {
                constructor(t) {
                    super(t), this._$_animations$_ = t._$GetAnimations$_();
                }
                _$Release$_() {
                    d._$clearArray$_(this._$_animations$_), super._$Release$_();
                }
                _$OnCreate$_() {
                    for (const t of this._$_animations$_) t._$LoadAllAssets$_(this._$_runtime$_);
                }
                _$LoadTextures$_(e) {
                    const s = {
                        _$sampling$_: this._$_runtime$_._$GetSampling$_()
                    };
                    return Promise.all(this._$_animations$_.map(t => t._$LoadAllTextures$_(e, s)));
                }
                _$ReleaseTextures$_() {
                    for (const t of this._$_animations$_) t._$ReleaseAllTextures$_();
                }
                _$OnDynamicTextureLoadComplete$_() {
                    this._$_UpdateAllCurrentTexture$_();
                }
                _$_UpdateAllCurrentTexture$_() {
                    for (const t of this._$_objectClass$_._$instancesIncludingPendingCreate$_()) t._$GetSdkInstance$_()._$_UpdateCurrentTexture$_();
                }
                _$FinishCondition$_(t) {
                    d._$Plugins$_._$Sprite$_._$FinishCollisionCondition$_(this, t);
                }
                _$BeforeRunAction$_(t) {
                    f.push({
                        _$objectClass$_: null,
                        _$createHierarchy$_: !1,
                        instances: []
                    });
                }
                _$_SpawnPickInstance$_(t, e, s) {
                    const i = f.at(-1);
                    i._$objectClass$_ = t, i._$createHierarchy$_ = s, i.instances.push(e);
                }
                _$AfterRunAction$_(t) {
                    const e = f.pop(), s = e._$objectClass$_, i = e._$createHierarchy$_;
                    if (s) {
                        const r = new Map();
                        for (const n of e.instances) n._$CollectInstancesToPick$_(r, s, i);
                        for (const [ h, o ] of r) h._$GetCurrentSol$_()._$SetSetPicked$_(o);
                    }
                }
                _$_AddAnimation$_(t) {
                    const e = this._$GetObjectClass$_()._$AddAnimation$_(t), s = this._$GetRuntime$_(), i = e._$GetFrameAt$_(0);
                    return i._$GetImageInfo$_()._$LoadStaticTexture$_(s._$GetRenderer$_(), {
                        _$sampling$_: s._$GetSampling$_()
                    }).then(() => this._$_UpdateAllCurrentTexture$_()), e;
                }
                _$_RemoveAnimation$_(t) {
                    for (const e of this._$_objectClass$_._$instancesIncludingPendingCreate$_()) e._$GetSdkInstance$_()._$_OnAnimationRemoved$_(t);
                    this._$GetObjectClass$_()._$RemoveAnimation$_(t);
                }
                _$_AddAnimationFrame$_(t, e) {
                    const s = this._$_objectClass$_._$GetAnimationByName$_(t);
                    if (!s) throw new Error(`cannot find animation name '${t}'`);
                    let i = s._$FrameTagOrIndexToIndex$_(e);
                    i < 0 && (i += s._$GetFrameCount$_() + 1);
                    const r = d._$AnimationFrameInfo$_._$CreateDynamic$_(this._$GetRuntime$_()), n = (s._$InsertFrameAt$_(r, i), 
                    this._$GetRuntime$_());
                    r._$GetImageInfo$_()._$LoadStaticTexture$_(n._$GetRenderer$_(), {
                        _$sampling$_: n._$GetSampling$_()
                    }).then(() => this._$_UpdateAllCurrentTexture$_());
                    for (const h of this._$_objectClass$_._$instancesIncludingPendingCreate$_()) h._$GetSdkInstance$_()._$_OnAnimationFramesChanged$_();
                    return r;
                }
                _$_RemoveAnimationFrame$_(t, e) {
                    const s = this._$_objectClass$_._$GetAnimationByName$_(t);
                    if (!s) throw new Error(`cannot find animation name '${t}'`);
                    if (1 === s._$GetFrameCount$_()) throw new Error(`cannot remove last frame from animation '${t}'`);
                    let i = s._$FrameTagOrIndexToIndex$_(e);
                    i < 0 && (i += s._$GetFrameCount$_()), s._$RemoveFrameAt$_(i);
                    for (const r of this._$_objectClass$_._$instancesIncludingPendingCreate$_()) r._$GetSdkInstance$_()._$_OnAnimationFramesChanged$_();
                }
                _$GetScriptInterfaceClass$_() {
                    return self._$ISpriteObjectType$_;
                }
            }, new WeakMap());
            self._$ISpriteObjectType$_ = class extends self._$IObjectClass$_ {
                constructor(t) {
                    super(t), g.set(this, t._$GetSdkType$_());
                }
                _$getAnimation$_(t) {
                    e._$RequireString$_(t);
                    const s = g.get(this)._$GetObjectClass$_()._$GetAnimationByName$_(t);
                    return s ? s._$GetIAnimation$_() : null;
                }
                _$getAllAnimations$_() {
                    return g.get(this)._$GetObjectClass$_()._$GetAllAnimations$_().map(t => t._$GetIAnimation$_());
                }
                _$addAnimation$_(t) {
                    return e._$RequireString$_(t), g.get(this)._$_AddAnimation$_(t)._$GetIAnimation$_();
                }
                _$removeAnimation$_(t) {
                    e._$RequireString$_(t), g.get(this)._$_RemoveAnimation$_(t);
                }
                _$addAnimationFrame$_(t, s) {
                    if (e._$RequireString$_(t), "number" != typeof s && "string" != typeof s) throw new TypeError("invalid insert location");
                    return g.get(this)._$_AddAnimationFrame$_(t, s)._$GetIAnimationFrame$_();
                }
                _$removeAnimationFrame$_(t, s) {
                    if (e._$RequireString$_(t), "number" != typeof s && "string" != typeof s) throw new TypeError("invalid insert location");
                    g.get(this)._$_RemoveAnimationFrame$_(t, s);
                }
            };
        }
        {
            const ea = self._$C3$_, fa = self._$C3X$_, ga = 0, ha = 1, ia = 2, ja = 3, ka = ea._$New$_(ea.Rect), la = ea._$New$_(ea._$Quad$_), ma = ea._$New$_(ea._$Vector2$_), na = 1, oa = 2, pa = 4, qa = (ea._$Plugins$_._$Sprite$_.Instance = class extends ea._$SDKWorldInstanceBase$_ {
                constructor(t, e) {
                    super(t);
                    let s = !0, i = "", r = 0, n = !0;
                    e && (s = !!e[ga], i = e[ha], r = e[ia], n = e[ja]), this._$_currentAnimation$_ = this._$_objectClass$_._$GetAnimationByName$_(i) || this._$_objectClass$_._$GetAnimations$_()[0], 
                    this._$_currentFrameIndex$_ = ea._$clamp$_(r, 0, this._$_currentAnimation$_._$GetFrameCount$_() - 1), 
                    this._$_currentAnimationFrame$_ = this._$_currentAnimation$_._$GetFrameAt$_(this._$_currentFrameIndex$_);
                    const h = this._$_currentAnimationFrame$_._$GetImageInfo$_(), o = (this._$_currentTexture$_ = h._$GetTexture$_(), 
                    this._$_currentRcTex$_ = h._$GetTexRect$_(), this._$_currentQuadTex$_ = h._$GetTexQuad$_(), 
                    this._$HandleRendererContextLoss$_(), t._$SetFlag$_(oa, !0), 
                    t._$SetFlag$_(na, 0 <= this._$_currentAnimation$_._$GetSpeed$_()), 
                    this._$_currentAnimationSpeed$_ = Math.abs(this._$_currentAnimation$_._$GetSpeed$_()), 
                    this._$_currentAnimationRepeatTo$_ = this._$_currentAnimation$_._$GetRepeatTo$_(), 
                    this._$_animationTimer$_ = ea._$New$_(ea._$KahanSum$_), this._$_frameStartTime$_ = 0, 
                    this._$_animationRepeats$_ = 0, this._$_animTriggerName$_ = "", 
                    this._$_changeAnimFrameIndex$_ = -1, this._$_changeAnimationName$_ = "", 
                    this._$_changeAnimationFrom$_ = 0, this._$GetWorldInfo$_());
                    this._$_bquadRef$_ = o._$GetBoundingQuad$_(), o._$SetVisible$_(s), 
                    o._$SetCollisionEnabled$_(n), o._$SetOriginX$_(this._$_currentAnimationFrame$_._$GetOriginX$_()), 
                    o._$SetOriginY$_(this._$_currentAnimationFrame$_._$GetOriginY$_()), 
                    o._$SetSourceCollisionPoly$_(this._$_currentAnimationFrame$_._$GetCollisionPoly$_()), 
                    o._$SetBboxChanged$_(), 1 === this._$_objectClass$_._$GetAnimationCount$_() && 1 === this._$_objectClass$_._$GetAnimations$_()[0]._$GetFrameCount$_() || 0 === this._$_currentAnimationSpeed$_ || this._$_StartTicking$_();
                }
                _$Release$_() {
                    this._$_currentAnimation$_ = null, this._$_currentAnimationFrame$_ = null, 
                    this._$_currentTexture$_ = null, this._$_animationTimer$_ = null, 
                    super._$Release$_();
                }
                _$GetCurrentImageInfo$_() {
                    return this._$_currentAnimationFrame$_._$GetImageInfo$_();
                }
                _$IsOriginalSizeKnown$_() {
                    return !0;
                }
                _$OnRendererContextLost$_() {
                    this._$_currentTexture$_ = null;
                }
                _$OnRendererContextRestored$_() {
                    this._$_UpdateCurrentTexture$_();
                }
                _$Draw$_(t) {
                    const e = this._$_currentTexture$_;
                    if (null !== e) {
                        t._$SetTexture$_(e);
                        const s = this._$GetWorldInfo$_();
                        s._$HasMesh$_() ? this._$_DrawMesh$_(s, t) : this._$_DrawStandard$_(s, t);
                    }
                }
                _$_DrawStandard$_(t, e) {
                    let s = this._$_bquadRef$_;
                    this._$_runtime$_._$IsPixelRoundingEnabled$_() && (s = t._$PixelRoundQuad$_(s)), 
                    e._$Quad4$_(s, this._$_currentQuadTex$_);
                }
                _$_DrawMesh$_(e, t) {
                    const s = e._$GetTransformedMesh$_();
                    if (e._$IsMeshChanged$_()) {
                        e._$CalculateBbox$_(ka, la, !1);
                        let t = la;
                        this._$_runtime$_._$IsPixelRoundingEnabled$_() && (t = e._$PixelRoundQuad$_(t)), 
                        s._$CalculateTransformedMesh$_(e._$GetSourceMesh$_(), t, this._$_currentQuadTex$_), 
                        e._$SetMeshChanged$_(!1);
                    }
                    s._$Draw$_(t);
                }
                _$GetAnimationTime$_() {
                    return this._$_animationTimer$_._$Get$_();
                }
                _$IsAnimationPlaying$_() {
                    return this._$_inst$_._$GetFlag$_(oa);
                }
                _$SetAnimationPlaying$_(t) {
                    this._$_inst$_._$SetFlag$_(oa, t);
                }
                _$IsPlayingForwards$_() {
                    return this._$_inst$_._$GetFlag$_(na);
                }
                _$SetPlayingForwards$_(t) {
                    this._$_inst$_._$SetFlag$_(na, t);
                }
                _$IsInAnimationTrigger$_() {
                    return this._$_inst$_._$GetFlag$_(pa);
                }
                _$SetInAnimationTrigger$_(t) {
                    this._$_inst$_._$SetFlag$_(pa, t);
                }
                _$Tick$_() {
                    this._$_changeAnimationName$_ && this._$_DoChangeAnimation$_(), 
                    0 <= this._$_changeAnimFrameIndex$_ && this._$_DoChangeAnimFrame$_();
                    const t = this._$_currentAnimationSpeed$_;
                    if (this._$IsAnimationPlaying$_() && 0 !== t) {
                        const e = this._$_runtime$_._$GetDt$_(this._$_inst$_), s = (this._$_animationTimer$_._$Add$_(e), 
                        this._$GetAnimationTime$_()), i = this._$_currentAnimationFrame$_, r = i._$GetDuration$_() / t;
                        if (!(s < this._$_frameStartTime$_ + r)) {
                            const n = this._$_currentAnimation$_, h = this._$_currentAnimationRepeatTo$_, o = n._$GetFrameCount$_(), a = n._$GetRepeatCount$_(), l = n._$IsLooping$_(), u = n._$IsPingPong$_(), c = (this._$IsPlayingForwards$_() ? this._$_currentFrameIndex$_++ : this._$_currentFrameIndex$_--, 
                            this._$_frameStartTime$_ += r, this._$_currentFrameIndex$_ >= o && (u ? (this._$SetPlayingForwards$_(!1), 
                            this._$_currentFrameIndex$_ = o - 2) : !l && (this._$_animationRepeats$_++, 
                            this._$_animationRepeats$_ >= a) ? this._$_FinishAnimation$_(!1) : this._$_currentFrameIndex$_ = h), 
                            this._$_currentFrameIndex$_ < 0 && (u ? (this._$_currentFrameIndex$_ = 1, 
                            this._$SetPlayingForwards$_(!0), l || (this._$_animationRepeats$_++, 
                            this._$_animationRepeats$_ >= a && this._$_FinishAnimation$_(!0))) : !l && (this._$_animationRepeats$_++, 
                            this._$_animationRepeats$_ >= a) ? this._$_FinishAnimation$_(!0) : this._$_currentFrameIndex$_ = h), 
                            this._$_currentFrameIndex$_ = ea._$clamp$_(this._$_currentFrameIndex$_, 0, o - 1), 
                            n._$GetFrameAt$_(this._$_currentFrameIndex$_));
                            s > this._$_frameStartTime$_ + c._$GetDuration$_() / t && (this._$_frameStartTime$_ = s), 
                            this._$_OnFrameChanged$_(i, c);
                        }
                    } else this._$_StopTicking$_();
                }
                _$_FinishAnimation$_(t) {
                    this._$_currentFrameIndex$_ = t ? 0 : this._$_currentAnimation$_._$GetFrameCount$_() - 1, 
                    this._$SetAnimationPlaying$_(!1), this._$_animTriggerName$_ = this._$_currentAnimation$_._$GetName$_(), 
                    this._$SetInAnimationTrigger$_(!0), this._$DispatchScriptEvent$_("animationend", !1, {
                        animationName: this._$_animTriggerName$_
                    }), this._$Trigger$_(ea._$Plugins$_._$Sprite$_._$Cnds$_._$OnAnyAnimFinished$_), 
                    this._$Trigger$_(ea._$Plugins$_._$Sprite$_._$Cnds$_._$OnAnimFinished$_), 
                    this._$SetInAnimationTrigger$_(!1), this._$_animationRepeats$_ = 0;
                }
                _$_OnFrameChanged$_(s, i, t) {
                    if (s !== i) {
                        const e = this._$GetWorldInfo$_(), r = s._$GetImageInfo$_(), n = i._$GetImageInfo$_(), h = r._$GetWidth$_(), o = r._$GetHeight$_(), a = n._$GetWidth$_(), l = n._$GetHeight$_(), u = (t && t.onFrameChange ? t.onFrameChange(e, h, o, a, l) : (h !== a && e._$SetWidth$_(e._$GetWidth$_() * (a / h)), 
                        o !== l && e._$SetHeight$_(e._$GetHeight$_() * (l / o))), 
                        e._$SetOriginX$_(i._$GetOriginX$_()), e._$SetOriginY$_(i._$GetOriginY$_()), 
                        e._$SetSourceCollisionPoly$_(i._$GetCollisionPoly$_()), 
                        e._$SetBboxChanged$_(), this._$_currentAnimationFrame$_ = i, 
                        this._$_currentTexture$_ = n._$GetTexture$_(), this._$_currentRcTex$_ = n._$GetTexRect$_(), 
                        this._$_currentQuadTex$_ = n._$GetTexQuad$_(), this._$GetInstance$_()._$GetBehaviorInstances$_());
                        for (let t = 0, e = u.length; t < e; ++t) u[t]._$OnSpriteFrameChanged$_(s, i);
                        this._$DispatchScriptEvent$_("framechange", !1, {
                            animationName: this._$_currentAnimation$_._$GetName$_(),
                            _$animationFrame$_: this._$_currentFrameIndex$_
                        }), this._$Trigger$_(ea._$Plugins$_._$Sprite$_._$Cnds$_._$OnFrameChanged$_), 
                        this._$_runtime$_._$UpdateRender$_();
                    }
                }
                _$_StartAnim$_(t) {
                    this._$SetAnimationPlaying$_(!0), this._$_frameStartTime$_ = this._$GetAnimationTime$_(), 
                    1 === t && 0 !== this._$_currentFrameIndex$_ && (this._$_changeAnimFrameIndex$_ = 0, 
                    this._$IsInAnimationTrigger$_() || this._$_DoChangeAnimFrame$_()), 
                    this._$_StartTicking$_();
                }
                _$_SetAnim$_(t, e, s) {
                    this._$_changeAnimationName$_ = t, this._$_changeAnimationFrom$_ = e, 
                    this._$_StartTicking$_(), !s && this._$IsInAnimationTrigger$_() || this._$_DoChangeAnimation$_();
                }
                _$_GetCurrentAnimation$_() {
                    return this._$_currentAnimation$_;
                }
                _$_GetCurrentAnimationName$_() {
                    return this._$_changeAnimationName$_ || this._$_currentAnimation$_._$GetName$_();
                }
                _$_OnAnimationRemoved$_(t) {
                    ea._$equalsNoCase$_(t, this._$_GetCurrentAnimationName$_()) && this._$_SetAnim$_(this._$_objectClass$_._$GetFirstAnimation$_()._$GetName$_(), 1, !0);
                }
                _$_SetAnimFrame$_(t) {
                    if ("string" == typeof t) if (String(Number(t)) === t) t = Number(t); else {
                        const e = this._$_objectClass$_._$GetAnimationByName$_(this._$_GetCurrentAnimationName$_());
                        if (!e) return;
                        if (-1 === (t = e._$GetFrameIndexByTag$_(t))) return;
                    }
                    isFinite(t) && (this._$_changeAnimFrameIndex$_ = t, this._$IsInAnimationTrigger$_() || this._$_DoChangeAnimFrame$_());
                }
                _$_OnAnimationFramesChanged$_() {
                    if (!this._$_changeAnimationName$_ && -1 === this._$_changeAnimFrameIndex$_) {
                        const t = this._$_currentAnimationFrame$_, e = this._$_currentAnimation$_._$GetFrameAt$_(ea._$clamp$_(this._$_currentFrameIndex$_, 0, this._$_currentAnimation$_._$GetFrameCount$_() - 1));
                        t !== e && this._$_OnFrameChanged$_(t, e), 1 < this._$_currentAnimation$_._$GetFrameCount$_() && 0 < this._$_currentAnimationSpeed$_ && this._$_StartTicking$_();
                    }
                }
                _$_GetAnimFrame$_() {
                    return this._$_currentFrameIndex$_;
                }
                _$_GetAnimFrameTag$_() {
                    return this._$_currentAnimationFrame$_._$GetTag$_();
                }
                _$_SetAnimSpeed$_(t) {
                    this._$_currentAnimationSpeed$_ = Math.abs(t), this._$SetPlayingForwards$_(0 <= t), 
                    0 < this._$_currentAnimationSpeed$_ && this._$_StartTicking$_();
                }
                _$_GetAnimSpeed$_() {
                    return this._$IsPlayingForwards$_() ? this._$_currentAnimationSpeed$_ : -this._$_currentAnimationSpeed$_;
                }
                _$_SetAnimRepeatToFrame$_(t) {
                    "string" == typeof t && -1 === (t = this._$_currentAnimation$_._$GetFrameIndexByTag$_(t)) || (t = ea._$clamp$_(Math.floor(t), 0, this._$_currentAnimation$_._$GetFrameCount$_() - 1), 
                    this._$_currentAnimationRepeatTo$_ = t);
                }
                _$_GetAnimRepeatToFrame$_() {
                    return this._$_currentAnimationRepeatTo$_;
                }
                _$_DoChangeAnimation$_(t) {
                    const e = this._$_currentAnimationFrame$_, s = this._$_objectClass$_._$GetAnimationByName$_(this._$_changeAnimationName$_);
                    if (this._$_changeAnimationName$_ = "", s && (s !== this._$_currentAnimation$_ || !this._$IsAnimationPlaying$_())) {
                        this._$_currentAnimation$_ = s, this._$SetPlayingForwards$_(0 <= s._$GetSpeed$_()), 
                        this._$_currentAnimationSpeed$_ = Math.abs(s._$GetSpeed$_()), 
                        this._$_currentAnimationRepeatTo$_ = s._$GetRepeatTo$_(), 
                        this._$_currentFrameIndex$_ = ea._$clamp$_(this._$_currentFrameIndex$_, 0, this._$_currentAnimation$_._$GetFrameCount$_() - 1), 
                        1 === this._$_changeAnimationFrom$_ && (this._$_currentFrameIndex$_ = 0), 
                        this._$SetAnimationPlaying$_(!0), this._$_frameStartTime$_ = this._$GetAnimationTime$_();
                        const i = this._$_currentAnimation$_._$GetFrameAt$_(this._$_currentFrameIndex$_);
                        this._$_OnFrameChanged$_(e, i, t);
                    }
                }
                _$_DoChangeAnimFrame$_(t) {
                    const e = this._$_currentAnimationFrame$_, s = this._$_currentFrameIndex$_;
                    if (this._$_currentFrameIndex$_ = ea._$clamp$_(Math.floor(this._$_changeAnimFrameIndex$_), 0, this._$_currentAnimation$_._$GetFrameCount$_() - 1), 
                    this._$_changeAnimFrameIndex$_ = -1, t || s !== this._$_currentFrameIndex$_) {
                        const i = this._$_currentAnimation$_._$GetFrameAt$_(this._$_currentFrameIndex$_);
                        this._$_OnFrameChanged$_(e, i), this._$_frameStartTime$_ = this._$GetAnimationTime$_();
                    }
                }
                _$_UpdateCurrentTexture$_() {
                    const t = this._$_currentAnimationFrame$_._$GetImageInfo$_();
                    this._$_currentTexture$_ = t._$GetTexture$_(), this._$_currentRcTex$_ = t._$GetTexRect$_(), 
                    this._$_currentQuadTex$_ = t._$GetTexQuad$_(), this._$GetWorldInfo$_()._$SetMeshChanged$_(!0);
                }
                _$GetTexture$_() {
                    return this._$_currentTexture$_;
                }
                _$GetTexRect$_() {
                    return this._$_currentRcTex$_;
                }
                _$GetTexQuad$_() {
                    return this._$_currentQuadTex$_;
                }
                _$GetImagePointCount$_() {
                    return this._$_currentAnimationFrame$_._$GetImagePointCount$_();
                }
                _$GetImagePoint$_(t) {
                    let e = this._$_currentAnimationFrame$_, s = this._$GetWorldInfo$_(), i = null;
                    if ("string" == typeof t) i = e._$GetImagePointByName$_(t); else {
                        if ("number" != typeof t) throw new TypeError("expected string or number");
                        i = e._$GetImagePointByIndex$_(t - 1);
                    }
                    let r = s._$GetTotalZElevation$_();
                    if (!i) return [ s._$GetX$_(), s._$GetY$_(), r ];
                    if (ma._$copy$_(i._$GetVec2$_()), s._$HasMesh$_()) {
                        const [ n, h, o ] = s._$GetSourceMesh$_()._$TransformPoint$_(ma._$getX$_(), ma._$getY$_());
                        ma.set(n, h), r += o;
                    }
                    return ma.offset(-e._$GetOriginX$_(), -e._$GetOriginY$_()), 
                    ma.scale(s._$GetWidth$_(), s._$GetHeight$_()), ma.rotate(s.GetAngle()), 
                    ma.offset(s._$GetX$_(), s._$GetY$_()), [ ma._$getX$_(), ma._$getY$_(), r ];
                }
                _$GetCollisionPolyPointCount$_() {
                    return this._$GetWorldInfo$_()._$GetTransformedCollisionPoly$_()._$pointCount$_();
                }
                _$GetCollisionPolyPoint$_(t) {
                    t = Math.floor(t);
                    const e = this._$GetWorldInfo$_(), s = e._$GetTransformedCollisionPoly$_(), i = s._$pointCount$_();
                    if ((t = t === i ? 0 : t) < 0 || i <= t) return [ 0, 0 ];
                    const r = s._$pointsArr$_();
                    return [ r[2 * t + 0] + e._$GetX$_(), r[2 * t + 1] + e._$GetY$_() ];
                }
                _$GetDebuggerProperties$_() {
                    const e = ea._$Plugins$_._$Sprite$_._$Acts$_, t = "plugins.sprite.debugger.animation-properties";
                    return [ {
                        title: t + ".title",
                        properties: [ {
                            name: t + ".current-animation",
                            value: this._$_currentAnimation$_._$GetName$_(),
                            _$onedit$_: t => this._$CallAction$_(e._$SetAnim$_, t, 0)
                        }, {
                            name: t + ".current-frame",
                            value: this._$_currentFrameIndex$_,
                            _$onedit$_: t => this._$CallAction$_(e._$SetAnimFrame$_, t)
                        }, {
                            name: t + ".is-playing",
                            value: this._$IsAnimationPlaying$_(),
                            _$onedit$_: t => t ? this._$CallAction$_(e._$StartAnim$_, 0) : this._$CallAction$_(e._$StopAnim$_)
                        }, {
                            name: t + ".speed",
                            value: this._$_currentAnimationSpeed$_,
                            _$onedit$_: t => this._$CallAction$_(e._$SetAnimSpeed$_, t)
                        }, {
                            name: t + ".repeats",
                            value: this._$_animationRepeats$_,
                            _$onedit$_: t => this._$_animationRepeats$_ = t
                        } ]
                    } ];
                }
                _$SaveToJson$_() {
                    const t = {
                        a: this._$_currentAnimation$_._$GetSID$_()
                    }, e = (0 !== this._$_frameStartTime$_ && (t.fs = this._$_frameStartTime$_), 
                    this._$GetAnimationTime$_()), s = (0 !== e && (t.at = e), 0 !== this._$_currentFrameIndex$_ && (t.f = this._$_currentFrameIndex$_), 
                    0 !== this._$_currentAnimationSpeed$_ && (t.cas = this._$_currentAnimationSpeed$_), 
                    1 !== this._$_animationRepeats$_ && (t.ar = this._$_animationRepeats$_), 
                    0 !== this._$_currentAnimationRepeatTo$_ && (t.rt = this._$_currentAnimationRepeatTo$_), 
                    this._$IsAnimationPlaying$_() || (t.ap = this._$IsAnimationPlaying$_()), 
                    this._$IsPlayingForwards$_() || (t.af = this._$IsPlayingForwards$_()), 
                    this._$GetWorldInfo$_());
                    return s._$IsCollisionEnabled$_() && (t.ce = s._$IsCollisionEnabled$_()), 
                    t;
                }
                _$LoadFromJson$_(t) {
                    const e = this._$GetObjectClass$_()._$GetAnimationBySID$_(t.a), s = (e && (this._$_currentAnimation$_ = e), 
                    this._$_frameStartTime$_ = t.hasOwnProperty("fs") ? t.fs : 0, 
                    this._$_animationTimer$_.Set(t.hasOwnProperty("at") ? t.at : 0), 
                    t.hasOwnProperty("f") ? t.f : 0), i = (this._$_currentFrameIndex$_ = ea._$clamp$_(s, 0, this._$_currentAnimation$_._$GetFrameCount$_() - 1), 
                    this._$_currentAnimationSpeed$_ = t.hasOwnProperty("cas") ? t.cas : 0, 
                    this._$_animationRepeats$_ = t.hasOwnProperty("ar") ? t.ar : 1, 
                    t.hasOwnProperty("rt") ? t.rt : 0), r = (this._$_currentAnimationRepeatTo$_ = ea._$clamp$_(i, 0, this._$_currentAnimation$_._$GetFrameCount$_() - 1), 
                    this._$SetAnimationPlaying$_(!t.hasOwnProperty("ap") || !!t.ap), 
                    this._$SetPlayingForwards$_(!t.hasOwnProperty("af") || !!t.af), 
                    this._$_currentAnimation$_._$GetFrameAt$_(this._$_currentFrameIndex$_)), n = (this._$_currentAnimationFrame$_ = r, 
                    this._$_UpdateCurrentTexture$_(), this._$GetWorldInfo$_());
                    n._$SetOriginX$_(r._$GetOriginX$_()), n._$SetOriginY$_(r._$GetOriginY$_()), 
                    n._$SetSourceCollisionPoly$_(r._$GetCollisionPoly$_()), n._$SetCollisionEnabled$_(!!t.ce), 
                    this._$IsAnimationPlaying$_() && this._$_StartTicking$_();
                }
                _$GetPropertyValueByIndex$_(t) {
                    const e = this._$GetWorldInfo$_();
                    switch (t) {
                      case ja:
                        return e._$IsCollisionEnabled$_();

                      case ia:
                        return ea._$clamp$_(this._$_currentFrameIndex$_, 0, this._$_currentAnimation$_._$GetFrameCount$_() - 1);

                      case ha:
                        return this._$_currentAnimation$_._$GetName$_();
                    }
                }
                _$SetPropertyValueByIndex$_(t, e, s) {
                    const i = this._$GetWorldInfo$_();
                    switch (t) {
                      case ja:
                        i._$SetCollisionEnabled$_(!!e);
                        break;

                      case ia:
                        {
                            this._$SetAnimationPlaying$_(!1);
                            const r = this._$_currentAnimation$_._$GetFrameCount$_() - 1, n = e = ea._$clamp$_(e, 0, r), h = this._$_currentAnimation$_._$GetFrameAt$_(this._$_currentFrameIndex$_), o = this._$_currentAnimation$_._$GetFrameAt$_(n);
                            this._$_OnFrameChanged$_(h, o, s), this._$_currentFrameIndex$_ = ea._$clamp$_(n, 0, r);
                            break;
                        }

                      case ha:
                        {
                            this._$_changeAnimationName$_ = e, this._$_DoChangeAnimation$_(s);
                            const a = this._$_currentAnimation$_._$GetFrameCount$_();
                            1 < a && 0 < this._$_currentAnimation$_._$GetSpeed$_() ? this._$_StartTicking$_() : this._$_StopTicking$_();
                            break;
                        }
                    }
                }
                _$GetScriptInterfaceClass$_() {
                    return self._$ISpriteInstance$_;
                }
            }, new WeakMap()), ra = new Map([ [ "current-frame", 0 ], [ "beginning", 1 ] ]);
            self._$ISpriteInstance$_ = class extends self._$IWorldInstance$_ {
                constructor() {
                    super(), qa.set(this, self._$IInstance$_._$_GetInitInst$_()._$GetSdkInstance$_());
                }
                _$getImagePointCount$_() {
                    return qa.get(this)._$GetImagePointCount$_();
                }
                _$getImagePointX$_(t) {
                    return this._$getImagePoint$_(t)[0];
                }
                _$getImagePointY$_(t) {
                    return this._$getImagePoint$_(t)[1];
                }
                _$getImagePointZ$_(t) {
                    return this._$getImagePoint$_(t)[2];
                }
                _$getImagePoint$_(t) {
                    if ("string" != typeof t && "number" != typeof t) throw new TypeError("expected string or number");
                    return qa.get(this)._$GetImagePoint$_(t);
                }
                _$getPolyPointCount$_() {
                    return qa.get(this)._$GetCollisionPolyPointCount$_();
                }
                _$getPolyPointX$_(t) {
                    return fa._$RequireFiniteNumber$_(t), qa.get(this)._$GetCollisionPolyPoint$_(t)[0];
                }
                _$getPolyPointY$_(t) {
                    return fa._$RequireFiniteNumber$_(t), qa.get(this)._$GetCollisionPolyPoint$_(t)[1];
                }
                _$getPolyPoint$_(t) {
                    return fa._$RequireFiniteNumber$_(t), qa.get(this)._$GetCollisionPolyPoint$_(t);
                }
                _$stopAnimation$_() {
                    qa.get(this)._$SetAnimationPlaying$_(!1);
                }
                _$startAnimation$_(t = "current-frame") {
                    fa._$RequireString$_(t);
                    const e = ra.get(t);
                    if (void 0 === e) throw new Error("invalid mode");
                    qa.get(this)._$_StartAnim$_(e);
                }
                _$setAnimation$_(t, e = "beginning") {
                    fa._$RequireString$_(t), fa._$RequireString$_(e);
                    const s = ra.get(e);
                    if (void 0 === s) throw new Error("invalid mode");
                    const i = qa.get(this);
                    if (!i._$GetObjectClass$_()._$GetAnimationByName$_(t)) throw new Error(`animation name "${t}" does not exist`);
                    i._$_SetAnim$_(t, s);
                }
                _$getAnimation$_(t) {
                    fa._$RequireString$_(t);
                    const e = qa.get(this)._$GetObjectClass$_()._$GetAnimationByName$_(t);
                    return e ? e._$GetIAnimation$_() : null;
                }
                get animation() {
                    return qa.get(this)._$_GetCurrentAnimation$_()._$GetIAnimation$_();
                }
                get animationName() {
                    return qa.get(this)._$_GetCurrentAnimationName$_();
                }
                set _$animationFrame$_(t) {
                    fa._$RequireFiniteNumber$_(t), qa.get(this)._$_SetAnimFrame$_(t);
                }
                get _$animationFrame$_() {
                    return qa.get(this)._$_GetAnimFrame$_();
                }
                set _$animationFrameTag$_(t) {
                    fa._$RequireString$_(t), qa.get(this)._$_SetAnimFrame$_(t);
                }
                get _$animationFrameTag$_() {
                    return qa.get(this)._$_GetAnimFrameTag$_();
                }
                set _$animationSpeed$_(t) {
                    fa._$RequireFiniteNumber$_(t), qa.get(this)._$_SetAnimSpeed$_(t);
                }
                get _$animationSpeed$_() {
                    return qa.get(this)._$_GetAnimSpeed$_();
                }
                set _$animationRepeatToFrame$_(t) {
                    fa._$RequireFiniteNumber$_(t), qa.get(this)._$_SetAnimRepeatToFrame$_(t);
                }
                get _$animationRepeatToFrame$_() {
                    return qa.get(this)._$_GetAnimRepeatToFrame$_();
                }
                get imageWidth() {
                    return qa.get(this)._$GetCurrentImageInfo$_()._$GetWidth$_();
                }
                get imageHeight() {
                    return qa.get(this)._$GetCurrentImageInfo$_()._$GetHeight$_();
                }
                _$getImageSize$_() {
                    const t = qa.get(this)._$GetCurrentImageInfo$_();
                    return [ t._$GetWidth$_(), t._$GetHeight$_() ];
                }
                async _$replaceCurrentAnimationFrame$_(t) {
                    fa._$RequireInstanceOf$_(t, Blob);
                    const e = qa.get(this), s = e._$GetRuntime$_(), i = e._$GetCurrentImageInfo$_(), r = ea._$New$_(ea._$ImageInfo$_);
                    if (r._$LoadDynamicBlobAsset$_(s, t), await r._$LoadStaticTexture$_(s._$GetRenderer$_(), {
                        _$sampling$_: s._$GetSampling$_()
                    }), e._$WasReleased$_()) r._$Release$_(); else {
                        i._$ReplaceWith$_(r);
                        const n = e._$GetSdkType$_();
                        n._$_UpdateAllCurrentTexture$_(), n._$GetObjectClass$_()._$Dispatcher$_().dispatchEvent(new ea.Event("animationframeimagechange")), 
                        s._$UpdateRender$_();
                    }
                }
                _$setSolidCollisionFilter$_(t, e) {
                    fa._$RequireString$_(e), qa.get(this)._$GetWorldInfo$_()._$SetSolidCollisionFilter$_(!!t, e);
                }
            };
        }
        {
            const Vb = self._$C3$_;
            Vb._$Plugins$_._$Sprite$_._$Cnds$_ = {
                _$IsAnimPlaying$_(t) {
                    return Vb._$equalsNoCase$_(this._$_GetCurrentAnimationName$_(), t);
                },
                _$CompareFrame$_(t, e) {
                    return Vb.compare(this._$_currentFrameIndex$_, t, e);
                },
                _$CompareFrameTag$_(t, e) {
                    if ("string" != typeof e) return !1;
                    const s = this._$_currentAnimationFrame$_._$GetTag$_();
                    return Vb.compare(s.toLowerCase(), t, e.toLowerCase());
                },
                _$CompareAnimSpeed$_(t, e) {
                    return Vb.compare(this._$_GetAnimSpeed$_(), t, e);
                },
                _$OnAnimFinished$_(t) {
                    return Vb._$equalsNoCase$_(this._$_animTriggerName$_, t);
                },
                _$OnAnyAnimFinished$_() {
                    return !0;
                },
                _$OnFrameChanged$_() {
                    return !0;
                },
                _$IsMirrored$_() {
                    return this._$GetWorldInfo$_()._$GetWidth$_() < 0;
                },
                _$IsFlipped$_() {
                    return this._$GetWorldInfo$_()._$GetHeight$_() < 0;
                },
                _$OnURLLoaded$_() {
                    return !0;
                },
                _$OnURLFailed$_() {
                    return !0;
                },
                _$IsCollisionEnabled$_() {
                    return this._$GetWorldInfo$_()._$IsCollisionEnabled$_();
                }
            };
        }
        {
            const d1 = self._$C3$_;
            d1._$Plugins$_._$Sprite$_._$Acts$_ = {
                _$Spawn$_(t, e, s, i, r) {
                    if (t && e) {
                        const [ n, h ] = this._$GetImagePoint$_(s), o = this._$_runtime$_._$CreateInstance$_(t, e, n, h, i, r);
                        if (o) {
                            if (i && e._$SortAndAddInstancesByZIndex$_(o), t._$GetPlugin$_()._$IsRotatable$_()) {
                                const l = o._$GetWorldInfo$_();
                                l._$SetAngle$_(this._$GetWorldInfo$_().GetAngle()), 
                                l._$SetBboxChanged$_();
                            }
                            const a = this._$_runtime$_._$GetEventSheetManager$_();
                            a._$BlockFlushingInstances$_(!0), o._$_TriggerOnCreatedOnSelfAndRelated$_(), 
                            a._$BlockFlushingInstances$_(!1), t !== this._$_runtime$_._$GetCurrentAction$_()._$GetObjectClass$_() && this._$_sdkType$_._$_SpawnPickInstance$_(t, o, i);
                        }
                    }
                },
                _$StopAnim$_() {
                    this._$SetAnimationPlaying$_(!1);
                },
                _$StartAnim$_(t) {
                    this._$_StartAnim$_(t);
                },
                _$SetAnim$_(t, e) {
                    this._$_SetAnim$_(t, e);
                },
                _$SetAnimFrame$_(t) {
                    this._$_SetAnimFrame$_(t);
                },
                _$SetAnimSpeed$_(t) {
                    this._$_SetAnimSpeed$_(t);
                },
                _$SetAnimRepeatToFrame$_(t) {
                    this._$_SetAnimRepeatToFrame$_(t);
                },
                _$AddRemoveAnimation$_(e, t) {
                    try {
                        0 === e ? this._$GetSdkType$_()._$_AddAnimation$_(t) : this._$GetSdkType$_()._$_RemoveAnimation$_(t);
                    } catch (t) {
                        console.error(`[Construct] Error ${0 === e ? "adding" : "removing"} animation: `, t);
                    }
                },
                _$AddRemoveAnimationFrame$_(e, t, s) {
                    try {
                        0 === e ? this._$GetSdkType$_()._$_AddAnimationFrame$_(t, s) : this._$GetSdkType$_()._$_RemoveAnimationFrame$_(t, s);
                    } catch (t) {
                        console.error(`[Construct] Error ${0 === e ? "adding" : "removing"} animation frame: `, t);
                    }
                },
                _$SetMirrored$_(t) {
                    const e = this._$GetWorldInfo$_(), s = e._$GetWidth$_(), i = Math.abs(s) * (0 === t ? -1 : 1);
                    s !== i && (e._$SetWidth$_(i), e._$SetBboxChanged$_());
                },
                _$SetFlipped$_(t) {
                    const e = this._$GetWorldInfo$_(), s = e._$GetHeight$_(), i = Math.abs(s) * (0 === t ? -1 : 1);
                    s !== i && (e._$SetHeight$_(i), e._$SetBboxChanged$_());
                },
                _$SetScale$_(t) {
                    const e = this._$_currentAnimationFrame$_, s = e._$GetImageInfo$_(), i = this._$GetWorldInfo$_(), r = i._$GetWidth$_() < 0 ? -1 : 1, n = i._$GetHeight$_() < 0 ? -1 : 1, h = s._$GetWidth$_() * t * r, o = s._$GetHeight$_() * t * n;
                    i._$GetWidth$_() === h && i._$GetHeight$_() === o || (i._$SetSize$_(h, o), 
                    i._$SetBboxChanged$_());
                },
                async _$LoadURL$_(t, e, s) {
                    const i = this._$_currentAnimationFrame$_, r = i._$GetImageInfo$_(), n = this._$GetWorldInfo$_(), h = this._$_runtime$_, o = this._$_sdkType$_;
                    if (r._$GetURL$_() === t) 0 === e && (n._$SetSize$_(r._$GetWidth$_(), r._$GetHeight$_()), 
                    n._$SetBboxChanged$_()), this._$Trigger$_(d1._$Plugins$_._$Sprite$_._$Cnds$_._$OnURLLoaded$_); else {
                        const a = d1._$New$_(d1._$ImageInfo$_);
                        try {
                            if (await a._$LoadDynamicAsset$_(h, t), !a._$IsLoaded$_()) throw new Error("image failed to load");
                            if (this._$WasReleased$_()) return void a._$Release$_();
                            await a._$LoadStaticTexture$_(h._$GetRenderer$_(), {
                                _$sampling$_: h._$GetSampling$_()
                            });
                        } catch (t) {
                            return console.error("Load image from URL failed: ", t), 
                            void (this._$WasReleased$_() || this._$Trigger$_(d1._$Plugins$_._$Sprite$_._$Cnds$_._$OnURLFailed$_));
                        }
                        this._$WasReleased$_() ? a._$Release$_() : (r._$ReplaceWith$_(a), 
                        o._$_UpdateAllCurrentTexture$_(), o._$GetObjectClass$_()._$Dispatcher$_().dispatchEvent(new d1.Event("animationframeimagechange")), 
                        h._$UpdateRender$_(), 0 === e && (n._$SetSize$_(r._$GetWidth$_(), r._$GetHeight$_()), 
                        n._$SetBboxChanged$_()), await this._$TriggerAsync$_(d1._$Plugins$_._$Sprite$_._$Cnds$_._$OnURLLoaded$_));
                    }
                },
                _$SetCollisions$_(t) {
                    this._$GetWorldInfo$_()._$SetCollisionEnabled$_(t);
                },
                _$SetSolidCollisionFilter$_(t, e) {
                    this._$GetWorldInfo$_()._$SetSolidCollisionFilter$_(0 === t, e);
                },
                _$SetEffect$_(t) {
                    this._$GetWorldInfo$_()._$SetBlendMode$_(t), this._$_runtime$_._$UpdateRender$_();
                }
            };
        }
        {
            const dc = self._$C3$_;
            dc._$Plugins$_._$Sprite$_._$Exps$_ = {
                _$AnimationFrame$_() {
                    return this._$_GetAnimFrame$_();
                },
                _$AnimationFrameTag$_() {
                    return this._$_GetAnimFrameTag$_();
                },
                _$AnimationFrameCount$_() {
                    return this._$_currentAnimation$_._$GetFrameCount$_();
                },
                _$AnimationName$_() {
                    return this._$_currentAnimation$_._$GetName$_();
                },
                _$AnimationSpeed$_() {
                    return this._$_GetAnimSpeed$_();
                },
                _$OriginalAnimationSpeed$_() {
                    return this._$_currentAnimation$_._$GetSpeed$_();
                },
                _$ImagePointX$_(t) {
                    return this._$GetImagePoint$_(t)[0];
                },
                _$ImagePointY$_(t) {
                    return this._$GetImagePoint$_(t)[1];
                },
                _$ImagePointZ$_(t) {
                    return this._$GetImagePoint$_(t)[2];
                },
                _$ImagePointCount$_() {
                    return this._$GetImagePointCount$_();
                },
                _$ImageWidth$_() {
                    return this._$GetCurrentImageInfo$_()._$GetWidth$_();
                },
                _$ImageHeight$_() {
                    return this._$GetCurrentImageInfo$_()._$GetHeight$_();
                },
                _$PolyPointXAt$_(t) {
                    return this._$GetCollisionPolyPoint$_(t)[0];
                },
                _$PolyPointYAt$_(t) {
                    return this._$GetCollisionPolyPoint$_(t)[1];
                },
                _$PolyPointCount$_() {
                    return this._$GetCollisionPolyPointCount$_();
                }
            };
        }
        {
            const a = self._$C3$_;
            a._$Plugins$_.gamepad = class extends a._$SDKPluginBase$_ {
                constructor(t) {
                    super(t);
                }
                _$Release$_() {
                    super._$Release$_();
                }
            };
        }
        {
            const d = self._$C3$_;
            d._$Plugins$_.gamepad._$Type$_ = class extends d._$SDKTypeBase$_ {
                constructor(t) {
                    super(t);
                }
                _$Release$_() {
                    super._$Release$_();
                }
                _$OnCreate$_() {}
            };
        }
        {
            const g = self._$C3$_, h = "gamepad";
            class i {
                constructor(t, e, s) {
                    this._$_index$_ = t, this._$_id$_ = e, this._$_vibrationEffects$_ = new Set(s), 
                    this._$_state$_ = new j(), this._$_oldState$_ = new j(), this._$_buttonsPressed$_ = [], 
                    this._$_buttonsReleased$_ = [];
                }
                _$GetID$_() {
                    return this._$_id$_;
                }
                _$Update$_(t, e) {
                    const s = this._$_oldState$_;
                    this._$_oldState$_ = this._$_state$_, this._$_state$_ = s, this._$_state$_._$Update$_(t, e), 
                    g._$resizeArray$_(this._$_buttonsPressed$_, this._$_state$_._$GetButtonCount$_(), !1), 
                    g._$resizeArray$_(this._$_buttonsReleased$_, this._$_state$_._$GetButtonCount$_(), !1);
                    for (let t = 0, e = this._$_state$_._$GetButtonCount$_(); t < e; ++t) {
                        const i = this._$_oldState$_._$GetButtonAt$_(t), r = this._$_state$_._$GetButtonAt$_(t);
                        .5 <= r && i < .5 && (this._$_buttonsPressed$_[t] = !0), 
                        r < .5 && .5 <= i && (this._$_buttonsReleased$_[t] = !0);
                    }
                }
                _$GetButtonCount$_() {
                    return this._$_state$_._$GetButtonCount$_();
                }
                _$GetAxisCount$_() {
                    return this._$_state$_._$GetAxisCount$_();
                }
                _$HasButtonBecomePressed$_(t) {
                    return !((t = Math.floor(t)) < 0 || t >= this._$_buttonsPressed$_.length) && this._$_buttonsPressed$_[t];
                }
                _$HasButtonBecomeReleased$_(t) {
                    return !((t = Math.floor(t)) < 0 || t >= this._$_buttonsReleased$_.length) && this._$_buttonsReleased$_[t];
                }
                _$ResetButtonPressAndReleaseFlags$_() {
                    this._$_buttonsPressed$_.fill(!1), this._$_buttonsReleased$_.fill(!1);
                }
                _$GetButtonAt$_(t) {
                    return this._$_state$_._$GetButtonAt$_(t);
                }
                _$IsButtonDown$_(t) {
                    return .5 <= this._$_state$_._$GetButtonAt$_(t);
                }
                _$GetAxisAt$_(t) {
                    return this._$_state$_._$GetAxisAt$_(t);
                }
                _$GetIndex$_() {
                    return this._$_index$_;
                }
                _$GetVibrationEffects$_() {
                    return this._$_vibrationEffects$_;
                }
            }
            class j {
                constructor() {
                    this._$_buttons$_ = [], this._$_axes$_ = [];
                }
                _$Update$_(e, t) {
                    let s = this._$_buttons$_, i = 0;
                    for (let t = e.length; i < t; ++i) {
                        const r = e[i];
                        i === s.length ? s.push(r.value) : s[i] = r.value;
                    }
                    i < s.length && g._$truncateArray$_(s, i), g._$shallowAssignArray$_(this._$_axes$_, t);
                }
                _$GetButtonCount$_() {
                    return this._$_buttons$_.length;
                }
                _$GetAxisCount$_() {
                    return this._$_axes$_.length;
                }
                _$GetButtonAt$_(t) {
                    return (t = Math.floor(t)) < 0 || t >= this._$_buttons$_.length ? 0 : this._$_buttons$_[t];
                }
                _$GetAxisAt$_(t) {
                    return (t = Math.floor(t)) < 0 || t >= this._$_axes$_.length ? 0 : this._$_axes$_[t];
                }
            }
            g._$Plugins$_.gamepad.Instance = class extends g._$SDKInstanceBase$_ {
                constructor(t, e) {
                    super(t, h), this._$_deadZone$_ = 25, this._$_lastButton$_ = 0, 
                    this._$_lastIndex$_ = -1, this._$_gamepads$_ = new Map(), e && (this._$_deadZone$_ = e[0]), 
                    this._$AddDOMMessageHandler$_("gamepad-connected", t => this._$_OnGamepadConnected$_(t)), 
                    this._$AddDOMMessageHandler$_("gamepad-disconnected", t => this._$_OnGamepadDisconnected$_(t)), 
                    this._$AddDOMMessageHandler$_("input-update", t => this._$_OnInputUpdate$_(t));
                    const s = this._$GetRuntime$_()._$Dispatcher$_();
                    this._$_disposables$_ = new g._$CompositeDisposable$_(g._$Disposable$_._$From$_(s, "tick2", () => this._$_OnTick2$_()), g._$Disposable$_._$From$_(s, "suspend", () => this._$_OnSuspend$_()), g._$Disposable$_._$From$_(s, "resume", () => this._$_OnResume$_())), 
                    this._$PostToDOM$_("ready");
                }
                _$Release$_() {
                    super._$Release$_();
                }
                _$_OnGamepadConnected$_(t) {
                    const e = t.index, s = t.id, r = t.vibrationEffects;
                    this._$_gamepads$_.has(e) || (this._$_gamepads$_.set(e, new i(e, s, r)), 
                    this._$_lastIndex$_ = e, this._$Trigger$_(g._$Plugins$_.gamepad._$Cnds$_._$OnGamepadConnected$_), 
                    this._$_lastIndex$_ = -1);
                }
                _$_OnGamepadDisconnected$_(t) {
                    const e = t.index;
                    this._$_lastIndex$_ = e, this._$Trigger$_(g._$Plugins$_.gamepad._$Cnds$_._$OnGamepadDisconnected$_), 
                    this._$_lastIndex$_ = -1, this._$_gamepads$_.delete(e);
                }
                _$_OnInputUpdate$_(t) {
                    for (const e of t) this._$_OnGamepadInputUpdate$_(e);
                }
                _$_OnGamepadInputUpdate$_(t) {
                    const e = t.index, s = (this._$_gamepads$_.has(e) || this._$_OnGamepadConnected$_(t), 
                    this._$_gamepads$_.get(e));
                    s._$Update$_(t.buttons, t.axes);
                    for (let t = 0, e = s._$GetButtonCount$_(); t < e; ++t) s._$HasButtonBecomePressed$_(t) && (this._$_lastButton$_ = t);
                }
                _$_GetGamepadByIndex$_(t) {
                    return this._$_gamepads$_.get(Math.floor(t)) || null;
                }
                _$_GetAllGamepadsByIndex$_(t) {
                    if (-1 === t) return [ ...this._$_gamepads$_.values() ];
                    {
                        const e = this._$_gamepads$_.get(Math.floor(t));
                        return e ? [ e ] : [];
                    }
                }
                _$_OnTick2$_() {
                    for (const t of this._$_gamepads$_.values()) t._$ResetButtonPressAndReleaseFlags$_();
                }
                _$_OnSuspend$_() {
                    this._$PostToDOM$_("suspend");
                }
                _$_OnResume$_() {
                    this._$PostToDOM$_("resume");
                }
                _$GetDebuggerProperties$_() {
                    const t = "plugins.gamepad";
                    return [ {
                        title: t + ".name",
                        properties: [ {
                            name: t + ".debugger.last-button",
                            value: this._$_lastButton$_
                        }, {
                            name: t + ".properties.analog-deadzone.name",
                            value: this._$_deadZone$_
                        } ]
                    } ];
                }
            };
        }
        {
            const ea = self._$C3$_;
            ea._$Plugins$_.gamepad._$Cnds$_ = {
                _$OnGamepadConnected$_() {
                    return !0;
                },
                _$OnGamepadDisconnected$_() {
                    return !0;
                },
                _$IsButtonDown$_(t, e) {
                    const s = this._$_GetGamepadByIndex$_(t);
                    if (!s) return !1;
                    const i = s._$IsButtonDown$_(e);
                    return i && (this._$_lastButton$_ = e), i;
                },
                _$OnButtonDown$_(t, e) {
                    const s = this._$_GetGamepadByIndex$_(t);
                    if (!s) return !1;
                    const i = s._$HasButtonBecomePressed$_(e);
                    return i && (this._$_lastButton$_ = e), i;
                },
                _$OnButtonUp$_(t, e) {
                    const s = this._$_GetGamepadByIndex$_(t);
                    if (!s) return !1;
                    const i = s._$HasButtonBecomeReleased$_(e);
                    return i && (this._$_lastButton$_ = e), i;
                },
                _$HasGamepads$_() {
                    return 0 < this._$_gamepads$_.size;
                },
                _$CompareAxis$_(t, e, s, i) {
                    e = Math.floor(e);
                    const r = this._$_GetGamepadByIndex$_(t);
                    if (!r) return !1;
                    let n = r._$GetAxisAt$_(e), h;
                    return h = e % 2 == 0 ? r._$GetAxisAt$_(e + 1) : r._$GetAxisAt$_(e - 1), 
                    n *= 100, h *= 100, Math.hypot(n, h) <= this._$_deadZone$_ && (n = 0), 
                    ea.compare(n, s, i);
                },
                _$OnAnyButtonDown$_(t) {
                    const e = this._$_GetAllGamepadsByIndex$_(t);
                    if (0 !== e.length) {
                        const s = this._$_runtime$_, i = s._$GetEventSheetManager$_(), r = s._$GetCurrentEvent$_(), n = r._$GetSolModifiers$_(), h = s._$GetEventStack$_(), o = h._$GetCurrentStackFrame$_(), a = h._$Push$_(r);
                        s._$SetDebuggingEnabled$_(!1);
                        for (const l of e) for (let t = 0, e = l._$GetButtonCount$_(); t < e; ++t) l._$HasButtonBecomePressed$_(t) && (this._$_lastIndex$_ = l._$GetIndex$_(), 
                        this._$_lastButton$_ = t, i._$PushCopySol$_(n), r._$Retrigger$_(o, a), 
                        i._$PopSol$_(n), this._$_lastIndex$_ = -1);
                        s._$SetDebuggingEnabled$_(!0), h._$Pop$_();
                    }
                    return !1;
                },
                _$OnAnyButtonUp$_(t) {
                    const e = this._$_GetAllGamepadsByIndex$_(t);
                    if (0 !== e.length) {
                        const s = this._$_runtime$_, i = s._$GetEventSheetManager$_(), r = s._$GetCurrentEvent$_(), n = r._$GetSolModifiers$_(), h = s._$GetEventStack$_(), o = h._$GetCurrentStackFrame$_(), a = h._$Push$_(r);
                        s._$SetDebuggingEnabled$_(!1);
                        for (const l of e) for (let t = 0, e = l._$GetButtonCount$_(); t < e; ++t) l._$HasButtonBecomeReleased$_(t) && (this._$_lastIndex$_ = l._$GetIndex$_(), 
                        this._$_lastButton$_ = t, i._$PushCopySol$_(n), r._$Retrigger$_(o, a), 
                        i._$PopSol$_(n), this._$_lastIndex$_ = -1);
                        s._$SetDebuggingEnabled$_(!0), h._$Pop$_();
                    }
                    return !1;
                },
                _$IsButtonIndexDown$_(t, e) {
                    e = Math.floor(e);
                    const s = this._$_GetGamepadByIndex$_(t);
                    if (!s) return !1;
                    const i = s._$IsButtonDown$_(e);
                    return i && (this._$_lastButton$_ = e), i;
                },
                _$OnButtonIndexDown$_(t, e) {
                    e = Math.floor(e);
                    const s = this._$_GetGamepadByIndex$_(t);
                    if (!s) return !1;
                    const i = s._$HasButtonBecomePressed$_(e);
                    return i && (this._$_lastButton$_ = e), i;
                },
                _$OnButtonIndexUp$_(t, e) {
                    e = Math.floor(e);
                    const s = this._$_GetGamepadByIndex$_(t);
                    if (!s) return !1;
                    const i = s._$HasButtonBecomeReleased$_(e);
                    return i && (this._$_lastButton$_ = e), i;
                },
                _$GamepadSupportsVibrationType$_(t, e) {
                    const s = this._$_GetGamepadByIndex$_(t);
                    if (!s) return !1;
                    const i = s._$GetVibrationEffects$_();
                    return 0 === e ? i.has("dual-rumble") : 1 === e && i.has("trigger-rumble");
                },
                _$SupportsGamepad$_() {
                    return !0;
                }
            };
        }
        {
            const k0 = self._$C3$_;
            k0._$Plugins$_.gamepad._$Acts$_ = {
                _$VibrateDualRumble$_(t, e, s, i) {
                    this._$PostToDOM$_("vibrate-dual-rumble", {
                        index: t,
                        duration: e,
                        weakMag: k0._$clamp$_(s / 100, 0, 1),
                        strongMag: k0._$clamp$_(i / 100, 0, 1)
                    });
                },
                _$VibrateTriggerRumble$_(t, e, s, i, r, n) {
                    this._$PostToDOM$_("vibrate-trigger-rumble", {
                        index: t,
                        duration: e,
                        weakMag: k0._$clamp$_(s / 100, 0, 1),
                        strongMag: k0._$clamp$_(i / 100, 0, 1),
                        leftMag: k0._$clamp$_(r / 100, 0, 1),
                        rightMag: k0._$clamp$_(n / 100, 0, 1)
                    });
                },
                _$ResetVibrate$_(t) {
                    this._$PostToDOM$_("reset-vibrate", {
                        index: t
                    });
                }
            };
        }
        {
            const w0 = self._$C3$_;
            w0._$Plugins$_.gamepad._$Exps$_ = {
                _$GamepadCount$_() {
                    return this._$_gamepads$_.size;
                },
                _$GamepadID$_(t) {
                    const e = this._$_GetGamepadByIndex$_(t);
                    return e ? e._$GetID$_() : "";
                },
                _$GamepadIndex$_() {
                    return this._$_lastIndex$_;
                },
                _$GamepadAxes$_(t) {
                    const s = this._$_GetGamepadByIndex$_(t);
                    if (!s) return "";
                    let i = "";
                    for (let t = 0, e = s._$GetAxisCount$_(); t < e; ++t) i += `Axis ${t}: ${Math.round(100 * s._$GetAxisAt$_(t))}
`;
                    return i;
                },
                _$GamepadButtons$_(t) {
                    const s = this._$_GetGamepadByIndex$_(t);
                    if (!s) return "";
                    let i = "";
                    for (let t = 0, e = s._$GetButtonCount$_(); t < e; ++t) i += `Button ${t}: ${Math.round(100 * s._$GetButtonAt$_(t))}
`;
                    return i;
                },
                _$RawButton$_(t, e) {
                    const s = this._$_GetGamepadByIndex$_(t);
                    return s ? s._$GetButtonAt$_(Math.floor(e)) : 0;
                },
                _$RawAxis$_(t, e) {
                    const s = this._$_GetGamepadByIndex$_(t);
                    return s ? s._$GetAxisAt$_(Math.floor(e)) : 0;
                },
                _$RawButtonCount$_(t) {
                    const e = this._$_GetGamepadByIndex$_(t);
                    return e ? e._$GetButtonCount$_() : 0;
                },
                _$RawAxisCount$_(t) {
                    const e = this._$_GetGamepadByIndex$_(t);
                    return e ? e._$GetAxisCount$_() : 0;
                },
                _$Button$_(t, e) {
                    const s = this._$_GetGamepadByIndex$_(t);
                    return s ? 100 * s._$GetButtonAt$_(Math.floor(e)) : 0;
                },
                _$Axis$_(t, e) {
                    e = Math.floor(e);
                    const s = this._$_GetGamepadByIndex$_(t);
                    if (!s) return 0;
                    let i = s._$GetAxisAt$_(e), r;
                    return r = e % 2 == 0 ? s._$GetAxisAt$_(e + 1) : s._$GetAxisAt$_(e - 1), 
                    i *= 100, r *= 100, Math.hypot(i, r) <= this._$_deadZone$_ ? 0 : i;
                },
                _$ButtonIndex$_() {
                    return this._$_lastButton$_;
                },
                _$LastButton$_() {
                    return this._$_lastButton$_;
                }
            };
        }
        {
            const a = self._$C3$_;
            a._$Plugins$_._$Mouse$_ = class extends a._$SDKPluginBase$_ {
                constructor(t) {
                    super(t);
                }
                _$Release$_() {
                    super._$Release$_();
                }
            };
        }
        {
            let GetMouseSdkInstance2 = function() {
                return t._$GetSingleGlobalInstance$_()._$GetSdkInstance$_();
            };
            GetMouseSdkInstance = GetMouseSdkInstance2;
            const d = self._$C3$_, e = self._$C3X$_;
            d._$Plugins$_._$Mouse$_._$Type$_ = class extends d._$SDKTypeBase$_ {
                constructor(t) {
                    super(t);
                }
                _$Release$_() {
                    super._$Release$_();
                }
                _$OnCreate$_() {}
                _$GetScriptInterfaceClass$_() {
                    return self._$IMouseObjectType$_;
                }
            };
            let t = null;
            self._$IMouseObjectType$_ = class extends self._$IObjectClass$_ {
                constructor(e) {
                    super(e), (t = e)._$GetRuntime$_()._$_GetCommonScriptInterfaces$_()._$mouse$_ = this;
                }
                _$getMouseX$_(t) {
                    return GetMouseSdkInstance2()._$GetMousePositionForLayer$_(t)[0];
                }
                _$getMouseY$_(t) {
                    return GetMouseSdkInstance2()._$GetMousePositionForLayer$_(t)[1];
                }
                _$getMousePosition$_(t) {
                    return GetMouseSdkInstance2()._$GetMousePositionForLayer$_(t);
                }
                _$isMouseButtonDown$_(t) {
                    return GetMouseSdkInstance2()._$IsMouseButtonDown$_(t);
                }
                _$setCursorStyle$_(t) {
                    e._$RequireString$_(t), GetMouseSdkInstance2()._$SetCursorStyle$_(t);
                }
                _$setCursorObjectClass$_(t) {
                    const e = GetMouseSdkInstance2(), s = e._$GetRuntime$_(), i = s._$_UnwrapIObjectClass$_(t);
                    e._$SetCursorObjectClass$_(i);
                }
            };
        }
        {
            let t = self._$C3$_, u = "mouse", a = null;
            t._$Plugins$_._$Mouse$_.Instance = class extends t._$SDKInstanceBase$_ {
                constructor(e, s) {
                    super(e, u), this._$_buttonMap$_ = [ !1, !1, !1, !1, !1 ], this._$_mouseXcanvas$_ = 0, 
                    this._$_mouseYcanvas$_ = 0, this._$_triggerButton$_ = 0, this._$_triggerType$_ = 0, 
                    this._$_triggerDir$_ = 0, this._$_wheelDeltaX$_ = 0, this._$_wheelDeltaY$_ = 0, 
                    this._$_wheelDeltaZ$_ = 0, this._$_hasPointerLock$_ = !1, this._$_movementX$_ = 0, 
                    this._$_movementY$_ = 0, this._$AddDOMMessageHandlers$_([ [ "pointer-lock-change", t => this._$_OnPointerLockChange$_(t) ], [ "pointer-lock-error", t => this._$_OnPointerLockError$_(t) ] ]);
                    const i = this._$GetRuntime$_()._$Dispatcher$_();
                    this._$_disposables$_ = new t._$CompositeDisposable$_(t._$Disposable$_._$From$_(i, "pointermove", t => this._$_OnPointerMove$_(t.data)), t._$Disposable$_._$From$_(i, "pointerdown", t => this._$_OnPointerDown$_(t.data)), t._$Disposable$_._$From$_(i, "pointerup", t => this._$_OnPointerUp$_(t.data)), t._$Disposable$_._$From$_(i, "dblclick", t => this._$_OnDoubleClick$_(t.data)), t._$Disposable$_._$From$_(i, "wheel", t => this._$_OnMouseWheel$_(t.data)), t._$Disposable$_._$From$_(i, "window-blur", () => this._$_OnWindowBlur$_()));
                }
                _$Release$_() {
                    super._$Release$_();
                }
                _$_OnPointerDown$_(t) {
                    "mouse" === t.pointerType && (this._$_mouseXcanvas$_ = t.pageX - this._$_runtime$_._$GetCanvasClientX$_(), 
                    this._$_mouseYcanvas$_ = t.pageY - this._$_runtime$_._$GetCanvasClientY$_(), 
                    this._$_CheckButtonChanges$_(t.lastButtons, t.buttons));
                }
                _$_OnPointerMove$_(e) {
                    this._$_movementX$_ = e.movementX, this._$_movementY$_ = e.movementY, 
                    this._$Trigger$_(t._$Plugins$_._$Mouse$_._$Cnds$_._$OnMovement$_), 
                    this._$_movementX$_ = 0, this._$_movementY$_ = 0, "mouse" === e.pointerType && (this._$_mouseXcanvas$_ = e.pageX - this._$_runtime$_._$GetCanvasClientX$_(), 
                    this._$_mouseYcanvas$_ = e.pageY - this._$_runtime$_._$GetCanvasClientY$_(), 
                    this._$_CheckButtonChanges$_(e.lastButtons, e.buttons));
                }
                _$_OnPointerUp$_(t) {
                    "mouse" === t.pointerType && this._$_CheckButtonChanges$_(t.lastButtons, t.buttons);
                }
                _$_CheckButtonChanges$_(t, e) {
                    this._$_CheckButtonChange$_(t, e, 1, 0), this._$_CheckButtonChange$_(t, e, 4, 1), 
                    this._$_CheckButtonChange$_(t, e, 2, 2), this._$_CheckButtonChange$_(t, e, 8, 3), 
                    this._$_CheckButtonChange$_(t, e, 16, 4);
                }
                _$_CheckButtonChange$_(t, e, s, i) {
                    !(t & s) && e & s ? this._$_OnMouseDown$_(i) : t & s && !(e & s) && this._$_OnMouseUp$_(i);
                }
                _$_OnMouseDown$_(e) {
                    this._$_buttonMap$_[e] = !0, this._$Trigger$_(t._$Plugins$_._$Mouse$_._$Cnds$_._$OnAnyClick$_), 
                    this._$_triggerButton$_ = e, this._$_triggerType$_ = 0, this._$Trigger$_(t._$Plugins$_._$Mouse$_._$Cnds$_._$OnClick$_), 
                    this._$Trigger$_(t._$Plugins$_._$Mouse$_._$Cnds$_._$OnObjectClicked$_);
                }
                _$_OnMouseUp$_(e) {
                    this._$_buttonMap$_[e] && (this._$_buttonMap$_[e] = !1, this._$_triggerButton$_ = e, 
                    this._$Trigger$_(t._$Plugins$_._$Mouse$_._$Cnds$_._$OnRelease$_));
                }
                _$_OnDoubleClick$_(e) {
                    this._$_triggerButton$_ = e.button, this._$_triggerType$_ = 1, 
                    this._$Trigger$_(t._$Plugins$_._$Mouse$_._$Cnds$_._$OnClick$_), 
                    this._$Trigger$_(t._$Plugins$_._$Mouse$_._$Cnds$_._$OnObjectClicked$_);
                }
                _$_OnMouseWheel$_(e) {
                    this._$_triggerDir$_ = e.deltaY < 0 ? 1 : 0, this._$_wheelDeltaX$_ = e.deltaX, 
                    this._$_wheelDeltaY$_ = e.deltaY, this._$_wheelDeltaZ$_ = e.deltaZ, 
                    this._$Trigger$_(t._$Plugins$_._$Mouse$_._$Cnds$_._$OnWheel$_);
                }
                _$_OnWindowBlur$_() {
                    for (let e = 0, s = this._$_buttonMap$_.length; e < s; ++e) {
                        if (!this._$_buttonMap$_[e]) return;
                        this._$_buttonMap$_[e] = !1, this._$_triggerButton$_ = e, 
                        this._$Trigger$_(t._$Plugins$_._$Mouse$_._$Cnds$_._$OnRelease$_);
                    }
                }
                _$GetMousePositionForLayer$_(t) {
                    const e = this._$_runtime$_._$GetMainRunningLayout$_(), s = this._$_mouseXcanvas$_, i = this._$_mouseYcanvas$_;
                    if (void 0 === t) {
                        const r = e._$GetLayerByIndex$_(0);
                        return r._$CanvasCssToLayer_DefaultTransform$_(s, i);
                    }
                    {
                        const n = e._$GetLayer$_(t);
                        return n ? n._$CanvasCssToLayer$_(s, i) : [ 0, 0 ];
                    }
                }
                _$IsMouseButtonDown$_(t) {
                    return t = Math.floor(t), !!this._$_buttonMap$_[t];
                }
                _$_IsMouseOverCanvas$_() {
                    return 0 <= this._$_mouseXcanvas$_ && 0 <= this._$_mouseYcanvas$_ && this._$_mouseXcanvas$_ < this._$_runtime$_._$GetCanvasCssWidth$_() && this._$_mouseYcanvas$_ < this._$_runtime$_._$GetCanvasCssHeight$_();
                }
                _$SetCursorStyle$_(t) {
                    a !== t && (a = t, this._$PostToDOM$_("cursor", t));
                }
                async _$SetCursorObjectClass$_(e) {
                    if (!t._$Platform$_._$IsMobile$_ && e) {
                        const s = e._$GetFirstPicked$_();
                        if (s) {
                            const i = s._$GetWorldInfo$_(), r = s._$GetCurrentImageInfo$_();
                            if (i && r && a !== r) {
                                const n = await (a = r)._$ExtractImageToBlobURL$_(), h = `url(${n}) ${Math.round(i._$GetOriginX$_() * r._$GetWidth$_())} ${Math.round(i._$GetOriginY$_() * r._$GetHeight$_())}, auto`;
                                this._$PostToDOM$_("cursor", h);
                            }
                        }
                    }
                }
                _$_OnPointerLockChange$_(t) {
                    this._$_UpdatePointerLockState$_(t["has-pointer-lock"]);
                }
                _$_OnPointerLockError$_(e) {
                    this._$_UpdatePointerLockState$_(e["has-pointer-lock"]), this._$Trigger$_(t._$Plugins$_._$Mouse$_._$Cnds$_._$OnPointerLockError$_);
                }
                _$_UpdatePointerLockState$_(e) {
                    this._$_hasPointerLock$_ !== e && (this._$_hasPointerLock$_ = e, 
                    this._$_hasPointerLock$_ ? this._$Trigger$_(t._$Plugins$_._$Mouse$_._$Cnds$_._$OnPointerLocked$_) : this._$Trigger$_(t._$Plugins$_._$Mouse$_._$Cnds$_._$OnPointerUnlocked$_));
                }
                _$GetDebuggerProperties$_() {
                    const t = "plugins.mouse";
                    return [ {
                        title: t + ".name",
                        properties: [ {
                            name: t + ".debugger.absolute-position",
                            value: this._$_mouseXcanvas$_ + "," + this._$_mouseYcanvas$_
                        }, {
                            name: t + ".debugger.left-button",
                            value: this._$_buttonMap$_[0]
                        }, {
                            name: t + ".debugger.middle-button",
                            value: this._$_buttonMap$_[1]
                        }, {
                            name: t + ".debugger.right-button",
                            value: this._$_buttonMap$_[2]
                        }, {
                            name: t + ".debugger.button-4",
                            value: this._$_buttonMap$_[3]
                        }, {
                            name: t + ".debugger.button-5",
                            value: this._$_buttonMap$_[4]
                        } ]
                    }, {
                        title: t + ".debugger.position-on-each-layer",
                        properties: this._$_runtime$_._$GetMainRunningLayout$_()._$GetLayers$_().map(t => ({
                            name: "$" + t._$GetName$_(),
                            value: t._$CanvasCssToLayer$_(this._$_mouseXcanvas$_, this._$_mouseYcanvas$_).join(", ")
                        }))
                    } ];
                }
            };
        }
        {
            const na = self._$C3$_;
            na._$Plugins$_._$Mouse$_._$Cnds$_ = {
                _$OnClick$_(t, e) {
                    return this._$_triggerButton$_ === t && this._$_triggerType$_ === e;
                },
                _$OnAnyClick$_() {
                    return !0;
                },
                _$IsButtonDown$_(t) {
                    return this._$_buttonMap$_[t];
                },
                _$OnRelease$_(t) {
                    return this._$_triggerButton$_ === t;
                },
                _$IsOverObject$_(t) {
                    const e = this._$_runtime$_._$GetCurrentCondition$_(), s = e._$IsInverted$_(), i = [];
                    return this._$_IsMouseOverCanvas$_() && i.push([ this._$_mouseXcanvas$_, this._$_mouseYcanvas$_ ]), 
                    na.xor(this._$_runtime$_._$GetCollisionEngine$_()._$TestAndSelectCanvasPointOverlap$_(t, i, s), s);
                },
                _$OnObjectClicked$_(t, e, s) {
                    if (t !== this._$_triggerButton$_ || e !== this._$_triggerType$_) return !1;
                    if (!this._$_IsMouseOverCanvas$_()) return !1;
                    const i = this._$_mouseXcanvas$_, r = this._$_mouseYcanvas$_;
                    return this._$_runtime$_._$GetCollisionEngine$_()._$TestAndSelectCanvasPointOverlap$_(s, [ [ i, r ] ], !1);
                },
                _$OnWheel$_(t) {
                    return 2 === t || this._$_triggerDir$_ === t;
                },
                _$OnPointerLocked$_() {
                    return !0;
                },
                _$OnPointerUnlocked$_() {
                    return !0;
                },
                _$OnPointerLockError$_() {
                    return !0;
                },
                _$HasPointerLock$_() {
                    return this._$_hasPointerLock$_;
                },
                _$OnMovement$_() {
                    return !0;
                }
            };
        }
        {
            const Ca = self._$C3$_, Da = [ "auto", "pointer", "text", "crosshair", "move", "help", "wait", "none" ], Ea = [ "auto", "all-scroll", "none", "help", "pointer", "progress", "wait", "cell", "crosshair", "text", "vertical-text", "alias", "copy", "move", "not-allowed", "grab", "grabbing", "col-resize", "row-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out" ];
            Ca._$Plugins$_._$Mouse$_._$Acts$_ = {
                _$SetCursor$_(t) {
                    this._$SetCursorStyle$_(Da[t]);
                },
                _$SetCursor2$_(t) {
                    this._$SetCursorStyle$_(Ea[t]);
                },
                _$SetCursorSprite$_(t) {
                    this._$SetCursorObjectClass$_(t);
                },
                _$RequestPointerLock$_(t) {
                    this._$_PostToDOMMaybeSync$_("request-pointer-lock", {
                        unadjustedMovement: t
                    });
                },
                _$ReleasePointerLock$_() {
                    this._$PostToDOM$_("release-pointer-lock");
                }
            };
        }
        {
            const Ja = self._$C3$_;
            Ja._$Plugins$_._$Mouse$_._$Exps$_ = {
                _$X$_(t) {
                    return this._$GetMousePositionForLayer$_(t)[0];
                },
                _$Y$_(t) {
                    return this._$GetMousePositionForLayer$_(t)[1];
                },
                _$AbsoluteX$_() {
                    return this._$_mouseXcanvas$_;
                },
                _$AbsoluteY$_() {
                    return this._$_mouseYcanvas$_;
                },
                _$MovementX$_() {
                    return this._$_movementX$_;
                },
                _$MovementY$_() {
                    return this._$_movementY$_;
                },
                _$WheelDeltaX$_() {
                    return this._$_wheelDeltaX$_;
                },
                _$WheelDeltaY$_() {
                    return this._$_wheelDeltaY$_;
                },
                _$WheelDeltaZ$_() {
                    return this._$_wheelDeltaZ$_;
                }
            };
        }
        {
            const C33 = self._$C3$_;
            C33._$Plugins$_._$Browser$_ = class BrowserPlugin extends C33._$SDKPluginBase$_ {
                constructor(t) {
                    super(t);
                }
                _$Release$_() {
                    super._$Release$_();
                }
            };
        }
        {
            const C33 = self._$C3$_;
            C33._$Plugins$_._$Browser$_._$Type$_ = class BrowserType extends C33._$SDKTypeBase$_ {
                constructor(t) {
                    super(t);
                }
                _$Release$_() {
                    super._$Release$_();
                }
                _$OnCreate$_() {}
            };
        }
        {
            const C33 = self._$C3$_, DOM_COMPONENT_ID = "browser";
            C33._$Plugins$_._$Browser$_.Instance = class BrowserInstance extends C33._$SDKInstanceBase$_ {
                constructor(t, e) {
                    super(t, DOM_COMPONENT_ID), this._$_initLocationStr$_ = "", 
                    this._$_isOnline$_ = !1, this._$_referrer$_ = "", this._$_docTitle$_ = "", 
                    this._$_isCookieEnabled$_ = !1, this._$_screenWidth$_ = 0, this._$_screenHeight$_ = 0, 
                    this._$_windowOuterWidth$_ = 0, this._$_windowOuterHeight$_ = 0, 
                    this._$_windowHasFocus$_ = !1, this._$_isConstructArcade$_ = !1, 
                    this._$_cssStyleMap$_ = new Map(), this._$_isInstallAvailable$_ = !1, 
                    this._$_installResult$_ = "", this._$_isWarnOnCloseEnabled$_ = !1, 
                    this._$AddDOMMessageHandlers$_([ [ "online-state", t => this._$_OnOnlineStateChanged$_(t) ], [ "backbutton", () => this._$_OnBackButton$_() ], [ "sw-message", t => this._$_OnSWMessage$_(t) ], [ "hashchange", t => this._$_OnHashChange$_(t) ], [ "install-available", () => this._$_OnInstallAvailable$_() ], [ "app-installed", t => this._$_OnAppInstalled$_(t) ] ]);
                    const s = this._$GetRuntime$_()._$Dispatcher$_();
                    this._$_disposables$_ = new C33._$CompositeDisposable$_(C33._$Disposable$_._$From$_(s, "afterfirstlayoutstart", () => this._$_OnAfterFirstLayoutStart$_()), C33._$Disposable$_._$From$_(s, "window-resize", () => this._$_OnWindowResize$_()), C33._$Disposable$_._$From$_(s, "window-focus", () => this._$_OnWindowFocus$_()), C33._$Disposable$_._$From$_(s, "window-blur", () => this._$_OnWindowBlur$_()), C33._$Disposable$_._$From$_(s, "suspend", () => this._$_OnSuspend$_()), C33._$Disposable$_._$From$_(s, "resume", () => this._$_OnResume$_())), 
                    this._$_runtime$_._$AddLoadPromise$_(this._$PostToDOMAsync$_("get-initial-state", {
                        exportType: this._$_runtime$_._$GetExportType$_()
                    }).then(t => {
                        this._$_initLocationStr$_ = t.location, this._$_isOnline$_ = t.isOnline, 
                        this._$_referrer$_ = t.referrer, this._$_docTitle$_ = t.title, 
                        this._$_isCookieEnabled$_ = t.isCookieEnabled, this._$_screenWidth$_ = t.screenWidth, 
                        this._$_screenHeight$_ = t.screenHeight, this._$_windowOuterWidth$_ = t.windowOuterWidth, 
                        this._$_windowOuterHeight$_ = t.windowOuterHeight, this._$_windowHasFocus$_ = t.windowHasFocus, 
                        this._$_isConstructArcade$_ = t.isConstructArcade;
                    }));
                }
                _$Release$_() {
                    super._$Release$_();
                }
                _$_OnAfterFirstLayoutStart$_() {
                    this._$PostToDOM$_("ready-for-sw-messages");
                }
                async _$_OnOnlineStateChanged$_(t) {
                    const e = !!t.isOnline;
                    this._$_isOnline$_ !== e && (this._$_isOnline$_ = e, this._$_isOnline$_ ? await this._$TriggerAsync$_(C33._$Plugins$_._$Browser$_._$Cnds$_._$OnOnline$_) : await this._$TriggerAsync$_(C33._$Plugins$_._$Browser$_._$Cnds$_._$OnOffline$_));
                }
                async _$_OnWindowResize$_() {
                    await this._$TriggerAsync$_(C33._$Plugins$_._$Browser$_._$Cnds$_._$OnResize$_);
                }
                async _$_OnWindowFocus$_() {
                    this._$_windowHasFocus$_ = !0, await this._$TriggerAsync$_(C33._$Plugins$_._$Browser$_._$Cnds$_._$OnWindowFocus$_);
                }
                async _$_OnWindowBlur$_() {
                    this._$_windowHasFocus$_ = !1, await this._$TriggerAsync$_(C33._$Plugins$_._$Browser$_._$Cnds$_._$OnWindowBlur$_);
                }
                _$_OnSuspend$_() {
                    this._$Trigger$_(C33._$Plugins$_._$Browser$_._$Cnds$_._$OnPageHidden$_);
                }
                _$_OnResume$_() {
                    this._$Trigger$_(C33._$Plugins$_._$Browser$_._$Cnds$_._$OnPageVisible$_);
                }
                async _$_OnBackButton$_() {
                    await this._$TriggerAsync$_(C33._$Plugins$_._$Browser$_._$Cnds$_._$OnBackButton$_);
                }
                _$_OnSWMessage$_(t) {
                    const e = t.type;
                    "downloading-update" === e ? this._$Trigger$_(C33._$Plugins$_._$Browser$_._$Cnds$_._$OnUpdateFound$_) : "update-ready" === e || "update-pending" === e ? this._$Trigger$_(C33._$Plugins$_._$Browser$_._$Cnds$_._$OnUpdateReady$_) : "offline-ready" === e && this._$Trigger$_(C33._$Plugins$_._$Browser$_._$Cnds$_._$OnOfflineReady$_);
                }
                _$_OnHashChange$_(t) {
                    this._$_initLocationStr$_ = t.location, this._$Trigger$_(C33._$Plugins$_._$Browser$_._$Cnds$_._$OnHashChange$_);
                }
                _$_OnInstallAvailable$_() {
                    this._$_isInstallAvailable$_ = !0, this._$Trigger$_(C33._$Plugins$_._$Browser$_._$Cnds$_._$OnInstallAvailable$_);
                }
                _$_OnAppInstalled$_(t) {
                    this._$_isInstallAvailable$_ = !1, this._$Trigger$_(C33._$Plugins$_._$Browser$_._$Cnds$_._$OnAppInstalled$_);
                }
                _$_IsWarnOnCloseEnabled$_() {
                    return this._$_isWarnOnCloseEnabled$_;
                }
                _$_SetWarnOnCloseEnabled$_(t) {
                    this._$_isWarnOnCloseEnabled$_ !== (t = !!t) && (this._$_isWarnOnCloseEnabled$_ = t, 
                    this._$PostToDOM$_("set-warn-on-close", {
                        enabled: t
                    }));
                }
                _$GetDebuggerProperties$_() {
                    const t = "plugins.browser.debugger";
                    return [ {
                        title: "plugins.browser.name",
                        properties: [ {
                            name: t + ".user-agent",
                            value: navigator.userAgent
                        }, {
                            name: t + ".is-online",
                            value: this._$_isOnline$_
                        }, {
                            name: t + ".is-fullscreen",
                            value: this._$_runtime$_._$GetCanvasManager$_()._$IsDocumentFullscreen$_()
                        } ]
                    } ];
                }
            };
        }
        {
            const C33 = self._$C3$_;
            C33._$Plugins$_._$Browser$_._$Cnds$_ = {
                _$IsOnline$_() {
                    return this._$_isOnline$_;
                },
                _$OnOnline$_() {
                    return !0;
                },
                _$OnOffline$_() {
                    return !0;
                },
                _$OnResize$_() {
                    return !0;
                },
                _$OnWindowFocus$_() {
                    return !0;
                },
                _$OnWindowBlur$_() {
                    return !0;
                },
                _$WindowHasFocus$_() {
                    return this._$_windowHasFocus$_;
                },
                _$CookiesEnabled$_() {
                    return this._$_isCookieEnabled$_;
                },
                _$IsFullscreen$_() {
                    return this._$_runtime$_._$GetCanvasManager$_()._$IsDocumentFullscreen$_();
                },
                _$OnBackButton$_() {
                    return !0;
                },
                _$IsPortraitLandscape$_(t) {
                    const e = this._$_runtime$_._$GetCanvasManager$_()._$GetLastWidth$_(), s = this._$_runtime$_._$GetCanvasManager$_()._$GetLastHeight$_(), i = e <= s ? 0 : 1;
                    return i === t;
                },
                _$OnUpdateFound$_() {
                    return !0;
                },
                _$OnUpdateReady$_() {
                    return !0;
                },
                _$OnOfflineReady$_() {
                    return !0;
                },
                _$OnHashChange$_() {
                    return !0;
                },
                _$OnInstallAvailable$_() {
                    return !0;
                },
                _$IsInstallAvailable$_() {
                    return this._$_isInstallAvailable$_;
                },
                _$OnInstallResult$_(t) {
                    switch (t) {
                      case 0:
                        return "accepted" === this._$_installResult$_;

                      case 1:
                        return "dismissed" === this._$_installResult$_;

                      case 2:
                        return "error" === this._$_installResult$_;

                      case 3:
                        return !0;

                      default:
                        return !1;
                    }
                },
                _$OnAppInstalled$_() {
                    return !0;
                },
                _$CompareDisplayMode$_(t) {
                    const e = this._$_runtime$_._$GetCanvasManager$_()._$GetCssDisplayMode$_();
                    switch (t) {
                      case 0:
                        return "browser" === e;

                      case 1:
                        return "minimal-ui" === e;

                      case 2:
                        return "standalone" === e;

                      case 3:
                        return "fullscreen" === e;

                      default:
                        return !1;
                    }
                },
                _$IsWarnOnCloseEnabled$_() {
                    return this._$_IsWarnOnCloseEnabled$_();
                },
                _$PageVisible$_() {
                    return !this._$_runtime$_._$IsSuspended$_();
                },
                _$OnPageHidden$_() {
                    return !0;
                },
                _$OnPageVisible$_() {
                    return !0;
                },
                _$HasJava$_() {
                    return !1;
                },
                _$IsDownloadingUpdate$_() {
                    return !1;
                },
                _$OnMenuButton$_() {
                    return !1;
                },
                _$OnSearchButton$_() {
                    return !1;
                },
                _$IsMetered$_() {
                    return !1;
                },
                _$IsCharging$_() {
                    return !0;
                },
                _$SupportsFullscreen$_() {
                    return !0;
                }
            };
        }
        {
            const C3 = self._$C3$_, ORIENTATIONS = [ "portrait", "landscape", "portrait-primary", "portrait-secondary", "landscape-primary", "landscape-secondary" ];
            C3._$Plugins$_._$Browser$_._$Acts$_ = {
                _$Alert$_(t) {
                    this._$PostToDOM$_("alert", {
                        message: t.toString()
                    });
                },
                _$Close$_() {
                    this._$_isConstructArcade$_ || (this._$_runtime$_._$IsDebug$_() ? self.C3Debugger.CloseWindow() : this._$PostToDOM$_("close"));
                },
                _$Focus$_() {
                    this._$PostToDOM$_("set-focus", {
                        isFocus: !0
                    });
                },
                _$Blur$_() {
                    this._$PostToDOM$_("set-focus", {
                        isFocus: !1
                    });
                },
                _$GoBack$_() {
                    this._$_isConstructArcade$_ || this._$PostToDOM$_("navigate", {
                        type: "back"
                    });
                },
                _$GoForward$_() {
                    this._$_isConstructArcade$_ || this._$PostToDOM$_("navigate", {
                        type: "forward"
                    });
                },
                _$GoHome$_() {},
                _$Reload$_() {
                    this._$_isConstructArcade$_ || (this._$_runtime$_._$IsDebug$_() ? this._$_runtime$_._$PostToDebugger$_({
                        type: "reload"
                    }) : this._$PostToDOM$_("navigate", {
                        type: "reload"
                    }));
                },
                _$GoToURL$_(t, e) {
                    this._$_PostToDOMMaybeSync$_("navigate", {
                        type: "url",
                        url: t,
                        target: e,
                        exportType: this._$_runtime$_._$GetExportType$_()
                    });
                },
                _$GoToURLWindow$_(t, e) {
                    this._$_PostToDOMMaybeSync$_("navigate", {
                        type: "new-window",
                        url: t,
                        tag: e,
                        exportType: this._$_runtime$_._$GetExportType$_()
                    });
                },
                _$RequestFullScreen$_(t, e) {
                    2 <= t && (t += 1), 1 === (t = 6 === t ? 2 : t) && (t = 0);
                    const s = C3._$CanvasManager$_._$_FullscreenModeNumberToString$_(t);
                    this._$_runtime$_._$GetCanvasManager$_()._$SetDocumentFullscreenMode$_(s), 
                    this._$_PostToDOMMaybeSync$_("request-fullscreen", {
                        navUI: e
                    });
                },
                _$CancelFullScreen$_() {
                    this._$_PostToDOMMaybeSync$_("exit-fullscreen");
                },
                _$Vibrate$_(t) {
                    const s = t.split(",");
                    for (let t = 0, e = s.length; t < e; ++t) s[t] = parseInt(s[t], 10);
                    this._$_PostToDOMMaybeSync$_("vibrate", {
                        pattern: s
                    });
                },
                async _$InvokeDownload$_(t, e) {
                    if (t && e) {
                        const s = await this._$_runtime$_._$GetAssetManager$_()._$GetProjectFileUrl$_(t);
                        this._$_runtime$_._$InvokeDownload$_(s, e);
                    }
                },
                _$InvokeDownloadString$_(t, e, s) {
                    if (s) {
                        const i = `data:${e},` + encodeURIComponent(t);
                        this._$_runtime$_._$InvokeDownload$_(i, s);
                    }
                },
                _$ConsoleLog$_(t, e) {
                    e = e.toString(), 0 === t ? console.log(e) : 1 === t ? console.warn(e) : 2 === t && console.error(e);
                },
                _$ConsoleGroup$_(t) {
                    console.group(t);
                },
                _$ConsoleGroupEnd$_() {
                    console.groupEnd();
                },
                _$ExecJs$_(jsStr) {
                    try {
                        eval(jsStr);
                    } catch (err) {
                        console.error("Error executing JavaScript: ", err);
                    }
                },
                _$LockOrientation$_(t) {
                    if (!((t = Math.floor(t)) < 0 || t >= ORIENTATIONS.length)) {
                        const e = ORIENTATIONS[t];
                        this._$_PostToDOMMaybeSync$_("lock-orientation", {
                            orientation: e
                        });
                    }
                },
                _$UnlockOrientation$_() {
                    this._$_PostToDOMMaybeSync$_("unlock-orientation");
                },
                _$LoadStyleSheet$_(t) {
                    this._$_runtime$_._$GetAssetManager$_()._$LoadStyleSheet$_(t);
                },
                async _$SetDocumentCSSStyle$_(t, e, s, i) {
                    await this._$PostToDOMAsync$_("set-document-css-style", {
                        prop: C3._$CSSToCamelCase$_(t),
                        value: e,
                        selector: s,
                        "is-all": 0 !== i
                    });
                },
                async _$GetDocumentCSSStyle$_(t, e, s) {
                    const i = await this._$PostToDOMAsync$_("get-document-css-style", {
                        prop: t,
                        selector: e
                    });
                    i.isOk && this._$_cssStyleMap$_.set(s.toLowerCase(), i.result.trim());
                },
                _$SetHash$_(t) {
                    this._$PostToDOM$_("set-hash", {
                        hash: t
                    });
                },
                _$SetWindowSize$_(t, e) {
                    this._$PostToDOM$_("set-window-size", {
                        windowWidth: t,
                        windowHeight: e
                    });
                },
                _$SetWindowPosition$_(t, e) {
                    this._$PostToDOM$_("set-window-position", {
                        windowX: t,
                        windowY: e
                    });
                },
                async _$RequestInstall$_() {
                    const t = await this._$PostToDOMAsync$_("request-install");
                    this._$_installResult$_ = t.result, this._$Trigger$_(C3._$Plugins$_._$Browser$_._$Cnds$_._$OnInstallResult$_);
                },
                _$SetWarnOnClose$_(t) {
                    this._$_SetWarnOnCloseEnabled$_(t);
                }
            };
        }
        {
            const C3 = self._$C3$_;
            C3._$Plugins$_._$Browser$_._$Exps$_ = {
                URL() {
                    return this._$_runtime$_._$IsInWorker$_() ? this._$_initLocationStr$_ : location.toString();
                },
                _$Protocol$_() {
                    return (this._$_runtime$_._$IsInWorker$_() ? new URL(this._$_initLocationStr$_) : location).protocol;
                },
                _$Domain$_() {
                    return (this._$_runtime$_._$IsInWorker$_() ? new URL(this._$_initLocationStr$_) : location).hostname;
                },
                _$Port$_() {
                    return (this._$_runtime$_._$IsInWorker$_() ? new URL(this._$_initLocationStr$_) : location).port;
                },
                _$PathName$_() {
                    return (this._$_runtime$_._$IsInWorker$_() ? new URL(this._$_initLocationStr$_) : location).pathname;
                },
                _$Hash$_() {
                    return (this._$_runtime$_._$IsInWorker$_() ? new URL(this._$_initLocationStr$_) : location).hash;
                },
                _$QueryString$_() {
                    return (this._$_runtime$_._$IsInWorker$_() ? new URL(this._$_initLocationStr$_) : location).search;
                },
                _$QueryParam$_(t) {
                    const e = (this._$_runtime$_._$IsInWorker$_() ? new URL(this._$_initLocationStr$_) : location).search, s = RegExp("[?&]" + t + "=([^&]*)").exec(e);
                    return s ? decodeURIComponent(s[1].replace(/\+/g, " ")) : "";
                },
                _$Referrer$_() {
                    return this._$_referrer$_;
                },
                _$Title$_() {
                    return this._$_docTitle$_;
                },
                _$Language$_() {
                    return navigator.language;
                },
                _$Platform$_() {
                    return navigator.platform;
                },
                _$UserAgent$_() {
                    return navigator.userAgent;
                },
                _$ExecJS$_(jsStr) {
                    let result = 0;
                    try {
                        result = eval(jsStr);
                    } catch (err) {
                        console.error("Error executing JavaScript: ", err);
                    }
                    return "number" == typeof result || "string" == typeof result ? result : "boolean" == typeof result && result ? 1 : 0;
                },
                CSSStyleValue(t) {
                    return this._$_cssStyleMap$_.get(t) || "";
                },
                _$Name$_() {
                    return navigator.appName;
                },
                _$Version$_() {
                    return navigator.appVersion;
                },
                _$Product$_() {
                    return navigator.product;
                },
                _$Vendor$_() {
                    return navigator.vendor;
                },
                _$BatteryLevel$_() {
                    return 1;
                },
                _$BatteryTimeLeft$_() {
                    return 1 / 0;
                },
                _$Bandwidth$_() {
                    const t = navigator.connection;
                    return t && (t.downlink || t.downlinkMax || t.bandwidth) || 1 / 0;
                },
                ConnectionType() {
                    const t = navigator.connection;
                    return t && t.type || "unknown";
                },
                _$DevicePixelRatio$_() {
                    return self.devicePixelRatio;
                },
                _$ScreenWidth$_() {
                    return this._$_screenWidth$_;
                },
                _$ScreenHeight$_() {
                    return this._$_screenHeight$_;
                },
                _$WindowInnerWidth$_() {
                    return this._$_runtime$_._$GetCanvasManager$_()._$GetLastWidth$_();
                },
                _$WindowInnerHeight$_() {
                    return this._$_runtime$_._$GetCanvasManager$_()._$GetLastHeight$_();
                },
                _$WindowOuterWidth$_() {
                    return this._$_windowOuterWidth$_;
                },
                _$WindowOuterHeight$_() {
                    return this._$_windowOuterWidth$_;
                },
                _$DisplayMode$_() {
                    return this._$_runtime$_._$GetCanvasManager$_()._$GetCssDisplayMode$_();
                },
                _$InstallResult$_() {
                    return this._$_installResult$_;
                }
            };
        }
        {
            const a = self._$C3$_;
            a._$Plugins$_.Keyboard = class extends a._$SDKPluginBase$_ {
                constructor(t) {
                    super(t);
                }
                _$Release$_() {
                    super._$Release$_();
                }
            };
        }
        {
            let GetKeyboardSdkInstance2 = function() {
                return r._$GetSingleGlobalInstance$_()._$GetSdkInstance$_();
            };
            GetKeyboardSdkInstance = GetKeyboardSdkInstance2;
            const d = self._$C3$_, e = self._$C3X$_;
            d._$Plugins$_.Keyboard._$Type$_ = class extends d._$SDKTypeBase$_ {
                constructor(t) {
                    super(t);
                }
                _$Release$_() {
                    super._$Release$_();
                }
                _$OnCreate$_() {}
                _$GetScriptInterfaceClass$_() {
                    return self._$IKeyboardObjectType$_;
                }
            };
            let r = null;
            self._$IKeyboardObjectType$_ = class extends self._$IObjectClass$_ {
                constructor(t) {
                    super(t), (r = t)._$GetRuntime$_()._$_GetCommonScriptInterfaces$_().keyboard = this;
                }
                _$isKeyDown$_(t) {
                    const e = GetKeyboardSdkInstance2();
                    if ("string" == typeof t) return e._$IsKeyDown$_(t);
                    if ("number" == typeof t) return e._$IsKeyCodeDown$_(t);
                    throw new TypeError("expected string or number");
                }
            };
        }
        {
            const m = self._$C3$_, n = "keyboard";
            m._$Plugins$_.Keyboard.Instance = class extends m._$SDKInstanceBase$_ {
                constructor(t, e) {
                    super(t, n), this._$_keysDownByString$_ = new Set(), this._$_keysDownByWhich$_ = new Set(), 
                    this._$_triggerWhich$_ = 0, this._$_triggerString$_ = "", this._$_triggerTypedKey$_ = "", 
                    this._$_isKeyboardLockSupported$_ = !1;
                    const s = this._$GetRuntime$_()._$Dispatcher$_();
                    this._$_disposables$_ = new m._$CompositeDisposable$_(m._$Disposable$_._$From$_(s, "keydown", t => this._$_OnKeyDown$_(t.data)), m._$Disposable$_._$From$_(s, "keyup", t => this._$_OnKeyUp$_(t.data)), m._$Disposable$_._$From$_(s, "window-blur", () => this._$_OnWindowOrKeyboardBlur$_()), m._$Disposable$_._$From$_(s, "keyboard-blur", () => this._$_OnWindowOrKeyboardBlur$_())), 
                    this._$_runtime$_._$AddLoadPromise$_(this._$_Init$_());
                }
                _$Release$_() {
                    super._$Release$_();
                }
                async _$_Init$_() {
                    const t = await this._$PostToDOMAsync$_("init");
                    this._$_isKeyboardLockSupported$_ = t.isKeyboardLockSupported;
                }
                _$_OnKeyDown$_(t) {
                    const e = t.which, s = t.code || e.toString(), i = t.key;
                    this._$_keysDownByString$_.has(s) || (this._$_keysDownByString$_.add(s), 
                    this._$_keysDownByWhich$_.add(e), this._$_triggerString$_ = s, 
                    this._$_triggerWhich$_ = e, this._$_triggerTypedKey$_ = i, this._$Trigger$_(m._$Plugins$_.Keyboard._$Cnds$_._$OnAnyKey$_), 
                    this._$Trigger$_(m._$Plugins$_.Keyboard._$Cnds$_._$OnKey$_), 
                    this._$Trigger$_(m._$Plugins$_.Keyboard._$Cnds$_._$OnLeftRightKeyPressed$_), 
                    this._$Trigger$_(m._$Plugins$_.Keyboard._$Cnds$_._$OnKeyCode$_));
                }
                _$_OnKeyUp$_(t) {
                    const e = t.which, s = t.code || e.toString(), i = t.key;
                    this._$_keysDownByString$_.delete(s), this._$_keysDownByWhich$_.delete(e), 
                    this._$_triggerString$_ = s, this._$_triggerWhich$_ = e, this._$_triggerTypedKey$_ = i, 
                    this._$Trigger$_(m._$Plugins$_.Keyboard._$Cnds$_._$OnAnyKeyReleased$_), 
                    this._$Trigger$_(m._$Plugins$_.Keyboard._$Cnds$_._$OnKeyReleased$_), 
                    this._$Trigger$_(m._$Plugins$_.Keyboard._$Cnds$_._$OnLeftRightKeyReleased$_), 
                    this._$Trigger$_(m._$Plugins$_.Keyboard._$Cnds$_._$OnKeyCodeReleased$_);
                }
                _$_OnWindowOrKeyboardBlur$_() {
                    for (const t of this._$_keysDownByWhich$_) this._$_keysDownByWhich$_.delete(t), 
                    this._$_triggerWhich$_ = t, this._$Trigger$_(m._$Plugins$_.Keyboard._$Cnds$_._$OnAnyKeyReleased$_), 
                    this._$Trigger$_(m._$Plugins$_.Keyboard._$Cnds$_._$OnKeyReleased$_), 
                    this._$Trigger$_(m._$Plugins$_.Keyboard._$Cnds$_._$OnKeyCodeReleased$_);
                    this._$_keysDownByString$_.clear();
                }
                _$IsKeyDown$_(t) {
                    return this._$_keysDownByString$_.has(t);
                }
                _$IsKeyCodeDown$_(t) {
                    return this._$_keysDownByWhich$_.has(t);
                }
                _$SaveToJson$_() {
                    return {
                        tk: this._$_triggerWhich$_,
                        tkk: this._$_triggerTypedKey$_
                    };
                }
                _$LoadFromJson$_(t) {
                    this._$_triggerWhich$_ = t.tk, t.hasOwnProperty("tkk") && (this._$_triggerTypedKey$_ = t.tkk);
                }
                _$GetDebuggerProperties$_() {
                    const t = "plugins.keyboard";
                    return [ {
                        title: t + ".name",
                        properties: [ {
                            name: t + ".debugger.last-key-code",
                            value: this._$_triggerWhich$_
                        }, {
                            name: t + ".debugger.last-key-string",
                            value: m._$Plugins$_.Keyboard._$Exps$_._$StringFromKeyCode$_(this._$_triggerWhich$_)
                        }, {
                            name: t + ".debugger.last-typed-key",
                            value: this._$_triggerTypedKey$_
                        } ]
                    } ];
                }
            };
        }
        {
            const I = self._$C3$_, J = [ "ShiftLeft", "ShiftRight", "ControlLeft", "ControlRight", "AltLeft", "AltRight", "MetaLeft", "MetaRight" ];
            I._$Plugins$_.Keyboard._$Cnds$_ = {
                _$IsKeyDown$_(t) {
                    return this._$_keysDownByWhich$_.has(t);
                },
                _$OnKey$_(t) {
                    return this._$_triggerWhich$_ === t;
                },
                _$OnAnyKey$_() {
                    return !0;
                },
                _$OnAnyKeyReleased$_() {
                    return !0;
                },
                _$OnKeyReleased$_(t) {
                    return this._$_triggerWhich$_ === t;
                },
                _$IsKeyCodeDown$_(t) {
                    return t = Math.floor(t), this._$_keysDownByWhich$_.has(t);
                },
                _$OnKeyCode$_(t) {
                    return this._$_triggerWhich$_ === t;
                },
                _$OnKeyCodeReleased$_(t) {
                    return this._$_triggerWhich$_ === t;
                },
                _$OnLeftRightKeyPressed$_(t) {
                    const e = J[t];
                    return this._$_triggerString$_ === e;
                },
                _$OnLeftRightKeyReleased$_(t) {
                    const e = J[t];
                    return this._$_triggerString$_ === e;
                },
                _$IsLeftRightKeyDown$_(t) {
                    const e = J[t];
                    return this._$_keysDownByString$_.has(e);
                },
                _$IsKeyboardLockSupported$_() {
                    return this._$_isKeyboardLockSupported$_;
                },
                _$OnKeyboardLocked$_() {
                    return !0;
                },
                _$OnKeyboardLockError$_() {
                    return !0;
                }
            };
        }
        {
            const W = self._$C3$_;
            W._$Plugins$_.Keyboard._$Acts$_ = {
                async _$LockKeyboard$_(e) {
                    if (this._$_isKeyboardLockSupported$_) {
                        let t = [];
                        e && (t = e.split(","));
                        const s = await this._$PostToDOMAsync$_("lock-keyboard", {
                            keysArr: t
                        });
                        s.isOk ? this._$Trigger$_(W._$Plugins$_.Keyboard._$Cnds$_._$OnKeyboardLocked$_) : this._$Trigger$_(W._$Plugins$_.Keyboard._$Cnds$_._$OnKeyboardLockError$_);
                    }
                },
                _$UnlockKeyboard$_() {
                    this._$_isKeyboardLockSupported$_ && this._$PostToDOMAsync$_("unlock-keyboard");
                }
            };
        }
        {
            let StringFromCharCode2 = function(t) {
                switch (t = Math.floor(t)) {
                  case 8:
                    return "backspace";

                  case 9:
                    return "tab";

                  case 13:
                    return "enter";

                  case 16:
                    return "shift";

                  case 17:
                    return "control";

                  case 18:
                    return "alt";

                  case 19:
                    return "pause";

                  case 20:
                    return "capslock";

                  case 27:
                    return "esc";

                  case 33:
                    return "pageup";

                  case 34:
                    return "pagedown";

                  case 35:
                    return "end";

                  case 36:
                    return "home";

                  case 37:
                    return "";

                  case 38:
                    return "";

                  case 39:
                    return "";

                  case 40:
                    return "";

                  case 45:
                    return "insert";

                  case 46:
                    return "del";

                  case 91:
                    return "left window key";

                  case 92:
                    return "right window key";

                  case 93:
                    return "select";

                  case 96:
                    return "numpad 0";

                  case 97:
                    return "numpad 1";

                  case 98:
                    return "numpad 2";

                  case 99:
                    return "numpad 3";

                  case 100:
                    return "numpad 4";

                  case 101:
                    return "numpad 5";

                  case 102:
                    return "numpad 6";

                  case 103:
                    return "numpad 7";

                  case 104:
                    return "numpad 8";

                  case 105:
                    return "numpad 9";

                  case 106:
                    return "numpad *";

                  case 107:
                    return "numpad +";

                  case 109:
                    return "numpad -";

                  case 110:
                    return "numpad .";

                  case 111:
                    return "numpad /";

                  case 112:
                    return "F1";

                  case 113:
                    return "F2";

                  case 114:
                    return "F3";

                  case 115:
                    return "F4";

                  case 116:
                    return "F5";

                  case 117:
                    return "F6";

                  case 118:
                    return "F7";

                  case 119:
                    return "F8";

                  case 120:
                    return "F9";

                  case 121:
                    return "F10";

                  case 122:
                    return "F11";

                  case 123:
                    return "F12";

                  case 144:
                    return "numlock";

                  case 145:
                    return "scroll lock";

                  case 186:
                    return ";";

                  case 187:
                    return "=";

                  case 188:
                    return ",";

                  case 189:
                    return "-";

                  case 190:
                    return ".";

                  case 191:
                    return "/";

                  case 192:
                    return "'";

                  case 219:
                    return "[";

                  case 220:
                    return "\\";

                  case 221:
                    return "]";

                  case 222:
                    return "#";

                  case 223:
                    return "`";

                  default:
                    return String.fromCharCode(t);
                }
            };
            StringFromCharCode = StringFromCharCode2;
            const $ = self._$C3$_;
            $._$Plugins$_.Keyboard._$Exps$_ = {
                _$LastKeyCode$_() {
                    return this._$_triggerWhich$_;
                },
                _$StringFromKeyCode$_(t) {
                    return StringFromCharCode2(t);
                },
                _$TypedKey$_() {
                    return this._$_triggerTypedKey$_;
                }
            };
        }
        {
            const a = self._$C3$_;
            a._$Plugins$_.Text = class extends a._$SDKPluginBase$_ {
                constructor(t) {
                    super(t);
                }
                _$Release$_() {
                    super._$Release$_();
                }
            };
        }
        {
            const d = self._$C3$_;
            d._$Plugins$_.Text._$Type$_ = class extends d._$SDKTypeBase$_ {
                constructor(t) {
                    super(t);
                }
                _$Release$_() {
                    super._$Release$_();
                }
                _$OnCreate$_() {}
                _$LoadTextures$_(t) {}
                _$ReleaseTextures$_() {}
            };
        }
        {
            const h = self._$C3$_, i = self._$C3X$_, j = [ 0, 0, 0 ], k = 0, l = 1, m = 2, n = 3, o = 4, p = 5, q = 6, r = 7, s = 8, t = 9, u = 10, v = 11, w = 12, x = 13, y = 14, z = 15, A = [ "left", "center", "right" ], B = [ "top", "center", "bottom" ], C = [ "ltr", "rtl" ], D = [ "word", "cjk", "character" ], E = new h.Rect(), F = new h._$Quad$_(), G = new h._$Color$_(), H = h._$New$_(h._$Vector2$_), I = new Map([ [ "b", "strong" ], [ "i", "em" ], [ "s", "s" ], [ "u", "u" ], [ "iconoffsety", null ] ]), J = (h._$Plugins$_.Text.Instance = class extends h._$SDKWorldInstanceBase$_ {
                constructor(e, i) {
                    if (super(e), this._$_text$_ = "", this._$_enableBBcode$_ = !0, 
                    this._$_faceName$_ = "Arial", this._$_ptSize$_ = 12, this._$_lineHeightOffset$_ = 0, 
                    this._$_isBold$_ = !1, this._$_isItalic$_ = !1, this._$_color$_ = h._$New$_(h._$Color$_), 
                    this._$_horizontalAlign$_ = 0, this._$_verticalAlign$_ = 0, 
                    this._$_wrapMode$_ = "word", this._$_textDirection$_ = 0, this._$_resolutionMode$_ = "auto", 
                    this._$_fixedScaleFactor$_ = 1, this._$_iconObjectClass$_ = null, 
                    this._$_htmlString$_ = "", this._$_isHtmlStringUpToDate$_ = !1, 
                    this._$_readAloud$_ = !1, this._$_screenReaderText$_ = null, 
                    this._$_typewriterStartTime$_ = -1, this._$_typewriterEndTime$_ = -1, 
                    this._$_typewriterLength$_ = 0, this._$_rendererText$_ = h._$New$_(h._$Gfx$_._$RendererText$_, this._$_runtime$_._$GetRenderer$_(), {
                        timeout: 5
                    }), this._$_rendererText$_._$ontextureupdate$_ = () => this._$_runtime$_._$UpdateRender$_(), 
                    this._$_animationframeimagechange_handler$_ = () => this._$_OnIconObjectClassImageChanged$_(), 
                    this._$_pendingUpdateIconSet$_ = !1, i) {
                        this._$_text$_ = i[k], this._$_enableBBcode$_ = !!i[l], 
                        this._$_faceName$_ = i[m], this._$_ptSize$_ = i[n], this._$_lineHeightOffset$_ = i[o], 
                        this._$_isBold$_ = !!i[p], this._$_isItalic$_ = !!i[q], 
                        this._$_horizontalAlign$_ = i[s], this._$_verticalAlign$_ = i[t], 
                        this._$_wrapMode$_ = D[i[u]], this._$_textDirection$_ = i[v], 
                        this._$_SetIconObjectClass$_(this._$_runtime$_._$GetObjectClassBySID$_(i[w]));
                        const a = i[r];
                        this._$_color$_._$setRgb$_(a[0], a[1], a[2]), this._$GetWorldInfo$_()._$SetVisible$_(i[x]), 
                        this._$_readAloud$_ = !!i[z];
                    }
                    this._$_UpdateTextSettings$_(), this._$_UpdateScreenReaderText$_();
                }
                _$Release$_() {
                    this._$_SetIconObjectClass$_(null), this._$_CancelTypewriter$_(), 
                    this._$_screenReaderText$_ && (this._$_screenReaderText$_._$Release$_(), 
                    this._$_screenReaderText$_ = null), this._$_rendererText$_._$Release$_(), 
                    this._$_rendererText$_ = null, super._$Release$_();
                }
                _$_UpdateTextSettings$_() {
                    const t = this._$_rendererText$_;
                    t._$SetText$_(this._$_text$_), t._$SetBBCodeEnabled$_(this._$_enableBBcode$_), 
                    this._$_rendererText$_._$IsBBCodeEnabled$_() && this._$_iconObjectClass$_ ? this._$_rendererText$_._$SetIconSet$_(this._$GetRuntime$_()._$GetTextIconSet$_(this._$_iconObjectClass$_)) : this._$_rendererText$_._$SetIconSet$_(null), 
                    t._$SetIconSmoothing$_("nearest" !== this._$_runtime$_._$GetSampling$_()), 
                    t._$SetFontName$_(this._$_faceName$_), t._$SetLineHeight$_(this._$_lineHeightOffset$_), 
                    t._$SetBold$_(this._$_isBold$_), t._$SetItalic$_(this._$_isItalic$_), 
                    t._$SetColor$_(this._$_color$_), t._$SetHorizontalAlignment$_(A[this._$_horizontalAlign$_]), 
                    t._$SetVerticalAlignment$_(B[this._$_verticalAlign$_]), t._$SetWordWrapMode$_(this._$_wrapMode$_), 
                    t._$SetTextDirection$_(C[this._$_textDirection$_]);
                }
                _$_UpdateTextSize$_() {
                    let t = this._$GetWorldInfo$_(), e = (this._$_rendererText$_._$SetFontSize$_(this._$_ptSize$_), 
                    this._$_rendererText$_._$SetFontSizeScale$_(t._$GetSceneGraphScale$_()), 
                    t._$GetLayer$_()), s;
                    "auto" === this._$_resolutionMode$_ ? s = e._$GetResolutionScaleFactorToZ$_(t._$GetTotalZElevation$_()) : "fixed" === this._$_resolutionMode$_ && (s = this._$_fixedScaleFactor$_), 
                    t._$HasMesh$_() && s !== this._$_rendererText$_._$GetZoom$_() && t._$SetMeshChanged$_(!0), 
                    this._$_rendererText$_._$SetSize$_(t._$GetWidth$_(), t._$GetHeight$_(), s);
                }
                _$_SetIconObjectClass$_(t) {
                    t && (t._$IsFamily$_() || t._$GetPlugin$_().constructor !== h._$Plugins$_._$Sprite$_) || t !== this._$_iconObjectClass$_ && (this._$_iconObjectClass$_ && this._$_iconObjectClass$_._$Dispatcher$_().removeEventListener("animationframeimagechange", this._$_animationframeimagechange_handler$_), 
                    this._$_iconObjectClass$_ = t, this._$_iconObjectClass$_ && this._$_iconObjectClass$_._$Dispatcher$_().addEventListener("animationframeimagechange", this._$_animationframeimagechange_handler$_), 
                    this._$_UpdateTextSettings$_(), this._$_isHtmlStringUpToDate$_ = !1, 
                    this._$_runtime$_._$UpdateRender$_());
                }
                _$_OnIconObjectClassImageChanged$_() {
                    this._$_runtime$_._$DeleteTextIconSet$_(this._$_iconObjectClass$_), 
                    this._$_runtime$_._$UpdateRender$_(), this._$_pendingUpdateIconSet$_ = !0;
                }
                _$_UpdateScreenReaderText$_() {
                    if (this._$_readAloud$_) {
                        let t = this._$_text$_;
                        this._$_enableBBcode$_ && (t = h._$BBString$_._$StripAnyTags$_(t)), 
                        this._$_screenReaderText$_ ? this._$_screenReaderText$_._$SetText$_(t) : this._$_screenReaderText$_ = h._$New$_(h._$ScreenReaderText$_, this._$_runtime$_, t);
                    } else this._$_screenReaderText$_ && (this._$_screenReaderText$_._$Release$_(), 
                    this._$_screenReaderText$_ = null);
                }
                _$Draw$_(t) {
                    const e = this._$GetWorldInfo$_(), s = (this._$_UpdateTextSize$_(), 
                    this._$_pendingUpdateIconSet$_ && (this._$_pendingUpdateIconSet$_ = !1, 
                    this._$_rendererText$_._$IsBBCodeEnabled$_()) && this._$_iconObjectClass$_ && this._$_rendererText$_._$SetIconSet$_(this._$GetRuntime$_()._$GetTextIconSet$_(this._$_iconObjectClass$_)), 
                    this._$_rendererText$_._$GetTexture$_());
                    if (s) {
                        const i = e._$GetLayer$_();
                        if (0 === e.GetAngle() && 0 === i.GetAngle() && 0 === e._$GetTotalZElevation$_() && !e._$HasMesh$_() && i._$RendersIn2DMode$_()) {
                            const r = e._$GetBoundingQuad$_(), [ n, h ] = i._$LayerToDrawSurface$_(r._$getTlx$_(), r._$getTly$_()), [ o, a ] = i._$LayerToDrawSurface$_(r._$getBrx$_(), r._$getBry$_()), l = n - Math.round(n), u = h - Math.round(h), [ c, f ] = (E.set(n, h, o, a), 
                            E.offset(-l, -u), F._$setFromRect$_(E), t._$GetRenderTargetSize$_(t._$GetRenderTarget$_()));
                            this._$_runtime$_._$GetCanvasManager$_()._$SetDeviceTransform$_(t, c, f), 
                            t._$SetTexture$_(s), t._$Quad3$_(F, this._$_rendererText$_._$GetTexRect$_()), 
                            i._$_SetTransform$_(t);
                        } else t._$SetTexture$_(s), e._$HasMesh$_() ? this._$_DrawMesh$_(e, t) : this._$_DrawStandard$_(e, t);
                    }
                }
                _$_DrawStandard$_(t, e) {
                    let s = t._$GetBoundingQuad$_();
                    this._$_runtime$_._$IsPixelRoundingEnabled$_() && (s = this._$_PixelRoundQuad$_(s)), 
                    e._$Quad3$_(s, this._$_rendererText$_._$GetTexRect$_());
                }
                _$_DrawMesh$_(e, t) {
                    const s = e._$GetTransformedMesh$_();
                    if (e._$IsMeshChanged$_()) {
                        e._$CalculateBbox$_(E, F, !1);
                        let t = F;
                        this._$_runtime$_._$IsPixelRoundingEnabled$_() && (t = this._$_PixelRoundQuad$_(t)), 
                        s._$CalculateTransformedMesh$_(e._$GetSourceMesh$_(), t, this._$_rendererText$_._$GetTexRect$_()), 
                        e._$SetMeshChanged$_(!1);
                    }
                    s._$Draw$_(t);
                }
                _$_PixelRoundQuad$_(t) {
                    const e = t._$getTlx$_() - Math.round(t._$getTlx$_()), s = t._$getTly$_() - Math.round(t._$getTly$_());
                    return 0 == e && 0 == s ? t : (F._$copy$_(t), F.offset(-e, -s), 
                    F);
                }
                _$GetCurrentSurfaceSize$_() {
                    const t = this._$_rendererText$_._$GetTexture$_();
                    return t ? [ t._$GetWidth$_(), t._$GetHeight$_() ] : [ 100, 100 ];
                }
                _$GetCurrentTexRect$_() {
                    return this._$_rendererText$_._$GetTexRect$_();
                }
                _$IsCurrentTexRotated$_() {
                    return !1;
                }
                _$SaveToJson$_() {
                    const t = {
                        t: this._$_text$_,
                        c: this._$_color$_.toJSON(),
                        fn: this._$_faceName$_,
                        ps: this._$_ptSize$_
                    };
                    return this._$_enableBBcode$_ && (t.bbc = this._$_enableBBcode$_), 
                    0 !== this._$_horizontalAlign$_ && (t.ha = this._$_horizontalAlign$_), 
                    0 !== this._$_verticalAlign$_ && (t.va = this._$_verticalAlign$_), 
                    "word" !== this._$_wrapMode$_ && (t.wr = this._$_wrapMode$_), 
                    0 !== this._$_lineHeightOffset$_ && (t.lho = this._$_lineHeightOffset$_), 
                    this._$_isBold$_ && (t.b = this._$_isBold$_), this._$_isItalic$_ && (t.i = this._$_isItalic$_), 
                    -1 !== this._$_typewriterEndTime$_ && (t.tw = {
                        st: this._$_typewriterStartTime$_,
                        en: this._$_typewriterEndTime$_,
                        l: this._$_typewriterLength$_
                    }), this._$_iconObjectClass$_ && (t.ioc = this._$_iconObjectClass$_._$GetSID$_()), 
                    "fixed" === this._$_resolutionMode$_ && (t.fs = this._$_fixedScaleFactor$_), 
                    t;
                }
                _$LoadFromJson$_(t) {
                    if (this._$_CancelTypewriter$_(), this._$_text$_ = t.t, this._$_color$_._$setFromJSON$_(t.c), 
                    this._$_faceName$_ = t.fn, this._$_ptSize$_ = t.ps, this._$_enableBBcode$_ = !!t.hasOwnProperty("bbc") && t.bbc, 
                    this._$_horizontalAlign$_ = t.hasOwnProperty("ha") ? t.ha : 0, 
                    this._$_verticalAlign$_ = t.hasOwnProperty("va") ? t.va : 0, 
                    t.hasOwnProperty("wr")) {
                        const e = t.wr;
                        this._$_wrapMode$_ = "boolean" == typeof e ? e ? "word" : "character" : e;
                    } else this._$_wrapMode$_ = "word";
                    if (this._$_lineHeightOffset$_ = t.hasOwnProperty("lho") ? t.lho : 0, 
                    this._$_isBold$_ = !!t.hasOwnProperty("b") && t.b, this._$_isItalic$_ = !!t.hasOwnProperty("i") && t.i, 
                    t.hasOwnProperty("tw")) {
                        const s = t.tw;
                        this._$_typewriterStartTime$_ = s.st, this._$_typewriterEndTime$_ = s.en, 
                        this._$_typewriterLength$_ = s.l;
                    }
                    if (t.hasOwnProperty("ioc")) {
                        const i = this._$GetRuntime$_()._$GetObjectClassBySID$_(t.ioc);
                        i && this._$_SetIconObjectClass$_(i);
                    } else this._$_SetIconObjectClass$_(null);
                    t.hasOwnProperty("fs") ? (this._$_resolutionMode$_ = "fixed", 
                    this._$_fixedScaleFactor$_ = t.fs) : this._$_resolutionMode$_ = "auto", 
                    this._$_UpdateTextSettings$_(), this._$_UpdateScreenReaderText$_(), 
                    this._$_isHtmlStringUpToDate$_ = !1, -1 !== this._$_typewriterEndTime$_ && this._$_StartTicking$_();
                }
                _$GetPropertyValueByIndex$_(e) {
                    switch (e) {
                      case k:
                        return this._$GetText$_();

                      case l:
                        return this._$_enableBBcode$_;

                      case m:
                        return this._$_GetFontFace$_();

                      case n:
                        return this._$_GetFontSize$_();

                      case o:
                        return this._$_GetLineHeight$_();

                      case p:
                        return this._$_IsBold$_();

                      case q:
                        return this._$_IsItalic$_();

                      case r:
                        return j[0] = this._$_color$_._$getR$_(), j[1] = this._$_color$_._$getG$_(), 
                        j[2] = this._$_color$_._$getB$_(), j;

                      case s:
                        return this._$_GetHAlign$_();

                      case t:
                        return this._$_GetVAlign$_();

                      case u:
                        return this._$_GetWrapMode$_();

                      case z:
                        return this._$_IsReadAloud$_();
                    }
                }
                _$SetPropertyValueByIndex$_(e, i) {
                    switch (e) {
                      case k:
                        this._$_SetText$_(i);
                        break;

                      case l:
                        this._$_enableBBcode$_ !== !!i && (this._$_enableBBcode$_ = !!i, 
                        this._$_UpdateTextSettings$_());
                        break;

                      case m:
                        this._$_SetFontFace$_(i);
                        break;

                      case n:
                        this._$_SetFontSize$_(i);
                        break;

                      case o:
                        this._$_SetLineHeight$_(i);
                        break;

                      case p:
                        this._$_SetBold$_(i);
                        break;

                      case q:
                        this._$_SetItalic$_(i);
                        break;

                      case r:
                        const h = this._$_color$_, a = i;
                        h._$getR$_() === a[0] && h._$getG$_() === a[1] && h._$getB$_() === a[2] || (this._$_color$_._$setRgb$_(a[0], a[1], a[2]), 
                        this._$_UpdateTextSettings$_());
                        break;

                      case s:
                        this._$_SetHAlign$_(i);
                        break;

                      case t:
                        this._$_SetVAlign$_(i);
                        break;

                      case u:
                        this._$_SetWrapMode$_(i);
                    }
                }
                _$SetPropertyColorOffsetValueByIndex$_(t, e, s, i) {
                    0 === e && 0 === s && 0 === i || t === r && (this._$_color$_._$addRgb$_(e, s, i), 
                    this._$_UpdateTextSettings$_());
                }
                _$_SetText$_(t) {
                    this._$_text$_ !== t && (this._$_text$_ = t, this._$_rendererText$_._$SetText$_(t), 
                    this._$_UpdateScreenReaderText$_(), this._$_isHtmlStringUpToDate$_ = !1, 
                    this._$_runtime$_._$UpdateRender$_());
                }
                _$GetText$_() {
                    return this._$_text$_;
                }
                _$_StartTypewriter$_(t, e) {
                    this._$_UpdateTextSize$_(), this._$_SetText$_(t), this._$_typewriterStartTime$_ = this._$_runtime$_._$GetWallTime$_(), 
                    this._$_typewriterEndTime$_ = this._$_typewriterStartTime$_ + e / this._$GetInstance$_()._$GetActiveTimeScale$_(), 
                    this._$_typewriterLength$_ = this._$_rendererText$_._$GetLengthInGraphemes$_(), 
                    this._$_rendererText$_._$SetDrawMaxCharacterCount$_(0), this._$_StartTicking$_();
                }
                _$_CancelTypewriter$_() {
                    this._$_typewriterStartTime$_ = -1, this._$_typewriterEndTime$_ = -1, 
                    this._$_typewriterLength$_ = 0, this._$_rendererText$_._$SetDrawMaxCharacterCount$_(-1), 
                    this._$_StopTicking$_();
                }
                _$_FinishTypewriter$_() {
                    -1 !== this._$_typewriterEndTime$_ && (this._$_CancelTypewriter$_(), 
                    this._$Trigger$_(h._$Plugins$_.Text._$Cnds$_._$OnTypewriterTextFinished$_), 
                    this._$_runtime$_._$UpdateRender$_());
                }
                _$_SetFontFace$_(t) {
                    this._$_faceName$_ !== t && (this._$_faceName$_ = t, this._$_rendererText$_._$SetFontName$_(t), 
                    this._$_runtime$_._$UpdateRender$_());
                }
                _$_GetFontFace$_() {
                    return this._$_faceName$_;
                }
                _$_SetBold$_(t) {
                    this._$_isBold$_ !== (t = !!t) && (this._$_isBold$_ = t, this._$_rendererText$_._$SetBold$_(t), 
                    this._$_runtime$_._$UpdateRender$_());
                }
                _$_IsBold$_() {
                    return this._$_isBold$_;
                }
                _$_SetItalic$_(t) {
                    this._$_isItalic$_ !== (t = !!t) && (this._$_isItalic$_ = t, 
                    this._$_rendererText$_._$SetItalic$_(t), this._$_runtime$_._$UpdateRender$_());
                }
                _$_IsItalic$_() {
                    return this._$_isItalic$_;
                }
                _$_SetFontSize$_(t) {
                    this._$_ptSize$_ !== t && (this._$_ptSize$_ = t, this._$_runtime$_._$UpdateRender$_());
                }
                _$_GetFontSize$_() {
                    return this._$_ptSize$_;
                }
                _$_SetFontColor$_(t) {
                    this._$_color$_._$equalsIgnoringAlpha$_(t) || (this._$_color$_._$copyRgb$_(t), 
                    this._$_rendererText$_._$SetColor$_(this._$_color$_), this._$_runtime$_._$UpdateRender$_());
                }
                _$_GetFontColor$_() {
                    return this._$_color$_;
                }
                _$_SetLineHeight$_(t) {
                    this._$_lineHeightOffset$_ !== t && (this._$_lineHeightOffset$_ = t, 
                    this._$_UpdateTextSettings$_(), this._$_runtime$_._$UpdateRender$_());
                }
                _$_GetLineHeight$_() {
                    return this._$_lineHeightOffset$_;
                }
                _$_SetHAlign$_(t) {
                    this._$_horizontalAlign$_ !== t && (this._$_horizontalAlign$_ = t, 
                    this._$_UpdateTextSettings$_(), this._$_runtime$_._$UpdateRender$_());
                }
                _$_GetHAlign$_() {
                    return this._$_horizontalAlign$_;
                }
                _$_SetVAlign$_(t) {
                    this._$_verticalAlign$_ !== t && (this._$_verticalAlign$_ = t, 
                    this._$_UpdateTextSettings$_(), this._$_runtime$_._$UpdateRender$_());
                }
                _$_GetVAlign$_() {
                    return this._$_verticalAlign$_;
                }
                _$_SetWrapModeByIndex$_(t) {
                    this._$_SetWrapMode$_(D[t]);
                }
                _$_SetWrapMode$_(t) {
                    this._$_wrapMode$_ !== t && (this._$_wrapMode$_ = t, this._$_UpdateTextSettings$_(), 
                    this._$_runtime$_._$UpdateRender$_());
                }
                _$_GetWrapMode$_() {
                    return this._$_wrapMode$_;
                }
                _$_SetTextDirection$_(t) {
                    this._$_textDirection$_ !== t && (this._$_textDirection$_ = t, 
                    this._$_UpdateTextSettings$_(), this._$_runtime$_._$UpdateRender$_());
                }
                _$_GetTextDirection$_() {
                    return this._$_textDirection$_;
                }
                _$_SetReadAloud$_(t) {
                    this._$_readAloud$_ = !!t, this._$_UpdateScreenReaderText$_();
                }
                _$_IsReadAloud$_() {
                    return this._$_readAloud$_;
                }
                _$_SetResolutionMode$_(t) {
                    this._$_resolutionMode$_ !== t && (this._$_resolutionMode$_ = t, 
                    this._$_runtime$_._$UpdateRender$_());
                }
                _$_GetResolutionMode$_() {
                    return this._$_resolutionMode$_;
                }
                _$_SetFixedScaleFactor$_(t) {
                    this._$_fixedScaleFactor$_ !== t && (this._$_fixedScaleFactor$_ = t, 
                    "fixed" === this._$_resolutionMode$_) && this._$_runtime$_._$UpdateRender$_();
                }
                _$_GetFixedScaleFactor$_() {
                    return this._$_fixedScaleFactor$_;
                }
                _$_GetTextWidth$_() {
                    return this._$_UpdateTextSize$_(), this._$_rendererText$_._$GetTextWidth$_();
                }
                _$_GetTextHeight$_() {
                    return this._$_UpdateTextSize$_(), this._$_rendererText$_._$GetTextHeight$_();
                }
                _$_GetTagAtPosition$_(t, e) {
                    this._$_UpdateTextSize$_();
                    const s = this._$GetWorldInfo$_(), i = (H.set(t - s._$GetX$_(), e - s._$GetY$_()), 
                    H.rotate(-s.GetAngle()), H.offset(s._$GetWidth$_() * s._$GetOriginX$_(), s._$GetHeight$_() * s._$GetOriginY$_()), 
                    H._$divide$_(s._$GetWidth$_(), s._$GetHeight$_()), H.scale(this._$_rendererText$_._$GetWidth$_(), this._$_rendererText$_._$GetHeight$_()), 
                    this._$_rendererText$_._$HitTestFragment$_(H._$getX$_(), H._$getY$_()));
                    if (i) {
                        const r = i._$GetStyleTag$_("tag");
                        if (r) return r.param;
                    }
                    return "";
                }
                _$_HasTagAtPosition$_(t, e, s) {
                    const i = this._$_GetTagAtPosition$_(e, s);
                    return i && h._$equalsNoCase$_(t, i);
                }
                _$_GetTagPosition$_(t, e) {
                    this._$_UpdateTextSize$_(), e = Math.floor(e);
                    const s = this._$_rendererText$_._$FindFragmentWithTag$_(t, e);
                    if (!s) return null;
                    const i = this._$GetWorldInfo$_(), r = this._$_rendererText$_._$GetDrawScale$_(), n = s._$GetPosX$_(), h = s._$GetPosY$_() - (s._$GetHeight$_() - s._$GetFontBoundingBoxDescent$_()) * r, o = s._$GetWidth$_() * r / this._$_rendererText$_._$GetWidth$_() * i._$GetWidth$_(), a = s._$GetHeight$_() * r / this._$_rendererText$_._$GetHeight$_() * i._$GetHeight$_();
                    return H.set(n, h), H._$divide$_(this._$_rendererText$_._$GetWidth$_(), this._$_rendererText$_._$GetHeight$_()), 
                    H.scale(i._$GetWidth$_(), i._$GetHeight$_()), H.offset(-i._$GetWidth$_() * i._$GetOriginX$_(), -i._$GetHeight$_() * i._$GetOriginY$_()), 
                    H.rotate(i.GetAngle()), H.offset(i._$GetX$_(), i._$GetY$_()), 
                    {
                        x: H._$getX$_(),
                        y: H._$getY$_(),
                        width: o,
                        height: a
                    };
                }
                _$_GetTagCount$_(t) {
                    return this._$_UpdateTextSize$_(), this._$_rendererText$_._$CountFragmentsWithTag$_(t);
                }
                _$_GetHTMLCloseTag$_(t) {
                    let e = I.get(t);
                    return null === e ? "" : `</${e || "span" || "span"}>`;
                }
                _$_GetHTMLOpenTag$_(t, e) {
                    let s = I.get(t);
                    if (null === s) return "";
                    switch (s = s || "span", t) {
                      case "color":
                        return `<${s} style="color: ${e}">`;

                      case "font":
                        return `<${s} style="font-family: '${e}'">`;

                      case "opacity":
                        return `<${s} style="opacity: ${e}%">`;

                      case "size":
                        return `<${s} style="font-size: ${e}pt">`;

                      case "background":
                        return `<${s} style="background-color: ${e}">`;

                      case "hide":
                        return `<${s} style="visibility: hidden">`;

                      case "class":
                        return `<${s} class="${e}">`;

                      case "tag":
                        return `<${s} data-tag="${e}">`;

                      default:
                        return `<${s}>`;
                    }
                }
                async _$_UpdateHTMLString$_() {
                    if (!this._$_isHtmlStringUpToDate$_) {
                        let t = new h._$BBString$_(this._$_text$_, {
                            _$noEscape$_: !0
                        })._$toFragmentList$_(), e = new Map(), r = '<span class="c3-text"', s = [], n = (s.push(`font-family: '${this._$_GetFontFace$_()}';`), 
                        this._$_IsBold$_() && s.push("font-weight: bold;"), this._$_IsItalic$_() && s.push("font-style: italic;"), 
                        "character" === this._$_GetWrapMode$_() && s.push("word-break: break-all;"), 
                        r += ` style="${s.join(" ")}">`, this._$_iconObjectClass$_ ? this._$GetRuntime$_()._$GetTextIconSet$_(this._$_iconObjectClass$_) : null);
                        if (this._$_iconObjectClass$_) {
                            const a = h._$New$_(h._$PromiseThrottle$_), l = [], u = new Map();
                            for (const f of t) if (f._$IsIcon$_()) {
                                const d = f._$GetTextIcon$_(n);
                                if (d) {
                                    const p = d._$GetSource$_(), m = p._$GetImageInfo$_()._$GetImageAsset$_();
                                    u.has(m) || (u.set(m, null), l.push(a._$Add$_(async () => {
                                        const t = await m._$LoadToDrawable$_();
                                        u.set(m, t);
                                    })));
                                }
                            }
                            await Promise.all(l);
                            const c = [];
                            for (const C of t) if (C._$IsIcon$_()) {
                                const g = C._$GetTextIcon$_(n);
                                if (g) {
                                    const S = g._$GetSource$_(), _ = S._$GetImageInfo$_()._$GetImageAsset$_();
                                    c.push(a._$Add$_(async () => {
                                        const t = await S._$GetImageInfo$_()._$ExtractImageToBlobURL$_(u.get(_));
                                        e.set(g, t);
                                    }));
                                }
                            }
                            await Promise.all(c);
                            for (const T of u.values()) T instanceof ImageBitmap && T.close && T.close();
                        }
                        const o = new Map();
                        for (const y of t) {
                            let i = y._$GetStyleMap$_(), t = [ ...o.keys() ];
                            t.reverse();
                            for (const E of t) i.has(E) && i.get(E) === o.get(E) || (o.delete(E), 
                            r += this._$_GetHTMLCloseTag$_(E));
                            for (const [ A, I ] of i) o.has(A) || (o.set(A, I), 
                            r += this._$_GetHTMLOpenTag$_(A, I));
                            if (y._$IsText$_() && (r += h._$ReplaceAll$_(h._$EscapeHTML$_(y._$GetCharacterArray$_().join("")), "\n", "<br>")), 
                            y._$IsIcon$_() && n) {
                                const M = y._$GetTextIcon$_(n);
                                if (M) {
                                    const w = e.get(M);
                                    if (w) {
                                        let t = [], e = "0.2em", s = i.get("iconoffsety");
                                        if (s) {
                                            let t = s.trim();
                                            e = t.endsWith("%") ? parseFloat(t) / 100 + "em" : t + "px";
                                        }
                                        t.push("top: " + e), "nearest" === this._$_runtime$_._$GetSampling$_() && t.push("image-rendering: pixelated"), 
                                        r += `<img class="c3-text-icon" data-icon="${y._$GetIconParameter$_()}" width="${M._$GetWidth$_()}" height="${M._$GetHeight$_()}" style="${t.join(";")}" src="${w}">`;
                                    }
                                }
                            }
                        }
                        const i = [ ...o.keys() ];
                        i.reverse();
                        for (const v of i) r += this._$_GetHTMLCloseTag$_(v);
                        r += "</span>", this._$_htmlString$_ = r, this._$_isHtmlStringUpToDate$_ = !0;
                    }
                    return this._$_htmlString$_;
                }
                _$Tick$_() {
                    const e = this._$_runtime$_._$GetWallTime$_();
                    if (e >= this._$_typewriterEndTime$_) this._$_CancelTypewriter$_(), 
                    this._$Trigger$_(h._$Plugins$_.Text._$Cnds$_._$OnTypewriterTextFinished$_), 
                    this._$_runtime$_._$UpdateRender$_(); else {
                        let t = h._$relerp$_(this._$_typewriterStartTime$_, this._$_typewriterEndTime$_, e, 0, this._$_typewriterLength$_);
                        (t = Math.floor(t)) !== this._$_rendererText$_._$GetDrawMaxCharacterCount$_() && (this._$_rendererText$_._$SetDrawMaxCharacterCount$_(t), 
                        this._$_runtime$_._$UpdateRender$_());
                    }
                }
                _$GetDebuggerProperties$_() {
                    const t = "plugins.text";
                    return [ {
                        title: t + ".name",
                        properties: [ {
                            name: t + ".properties.text.name",
                            value: this._$GetText$_(),
                            _$onedit$_: t => this._$_SetText$_(t)
                        }, {
                            name: t + ".properties.font.name",
                            value: this._$_GetFontFace$_(),
                            _$onedit$_: t => this._$_SetFontFace$_(t)
                        }, {
                            name: t + ".properties.size.name",
                            value: this._$_GetFontSize$_(),
                            _$onedit$_: t => this._$_SetFontSize$_(t)
                        }, {
                            name: t + ".properties.line-height.name",
                            value: this._$_GetLineHeight$_(),
                            _$onedit$_: t => this._$_SetLineHeight$_(t)
                        }, {
                            name: t + ".properties.bold.name",
                            value: this._$_IsBold$_(),
                            _$onedit$_: t => this._$_SetBold$_(t)
                        }, {
                            name: t + ".properties.italic.name",
                            value: this._$_IsItalic$_(),
                            _$onedit$_: t => this._$_SetItalic$_(t)
                        } ]
                    } ];
                }
                _$GetScriptInterfaceClass$_() {
                    return self._$ITextInstance$_;
                }
            }, new WeakMap()), K = new Map([ [ "left", 0 ], [ "center", 1 ], [ "right", 2 ] ]), L = new Map([ [ "top", 0 ], [ "center", 1 ], [ "bottom", 2 ] ]), M = [ "ltr", "rtl" ], N = new Set([ "auto", "fixed" ]);
            self._$ITextInstance$_ = class extends self._$IWorldInstance$_ {
                constructor() {
                    super(), J.set(this, self._$IInstance$_._$_GetInitInst$_()._$GetSdkInstance$_());
                }
                get text() {
                    return J.get(this)._$GetText$_();
                }
                set text(t) {
                    i._$RequireString$_(t);
                    const e = J.get(this);
                    e._$_CancelTypewriter$_(), e._$_SetText$_(t);
                }
                _$typewriterText$_(t, e) {
                    i._$RequireString$_(t), i._$RequireFiniteNumber$_(e);
                    const s = J.get(this);
                    s._$_CancelTypewriter$_(), s._$_StartTypewriter$_(t, e);
                }
                _$typewriterFinish$_() {
                    J.get(this)._$_FinishTypewriter$_();
                }
                set _$fontFace$_(t) {
                    i._$RequireString$_(t), J.get(this)._$_SetFontFace$_(t);
                }
                get _$fontFace$_() {
                    return J.get(this)._$_GetFontFace$_();
                }
                set _$isBold$_(t) {
                    J.get(this)._$_SetBold$_(t);
                }
                get _$isBold$_() {
                    return J.get(this)._$_IsBold$_();
                }
                set _$isItalic$_(t) {
                    J.get(this)._$_SetItalic$_(t);
                }
                get _$isItalic$_() {
                    return J.get(this)._$_IsItalic$_();
                }
                set _$sizePt$_(t) {
                    i._$RequireFiniteNumber$_(t), J.get(this)._$_SetFontSize$_(t);
                }
                get _$sizePt$_() {
                    return J.get(this)._$_GetFontSize$_();
                }
                set _$fontColor$_(t) {
                    if (i._$RequireArray$_(t), t.length < 3) throw new Error("expected 3 elements");
                    G._$setRgb$_(t[0], t[1], t[2]), J.get(this)._$_SetFontColor$_(G);
                }
                get _$fontColor$_() {
                    const t = J.get(this)._$_GetFontColor$_();
                    return [ t._$getR$_(), t._$getG$_(), t._$getB$_() ];
                }
                set lineHeight(t) {
                    i._$RequireFiniteNumber$_(t), J.get(this)._$_SetLineHeight$_(t);
                }
                get lineHeight() {
                    return J.get(this)._$_GetLineHeight$_();
                }
                set _$horizontalAlign$_(t) {
                    i._$RequireString$_(t);
                    const e = K.get(t);
                    if (void 0 === e) throw new Error("invalid mode");
                    J.get(this)._$_SetHAlign$_(e);
                }
                get _$horizontalAlign$_() {
                    return A[J.get(this)._$_GetHAlign$_()];
                }
                set verticalAlign(t) {
                    i._$RequireString$_(t);
                    const e = L.get(t);
                    if (void 0 === e) throw new Error("invalid mode");
                    J.get(this)._$_SetVAlign$_(e);
                }
                get verticalAlign() {
                    return B[J.get(this)._$_GetVAlign$_()];
                }
                set _$wordWrapMode$_(t) {
                    if (!D.includes(t)) throw new Error("invalid mode");
                    J.get(this)._$_SetWrapMode$_(t);
                }
                get _$wordWrapMode$_() {
                    return J.get(this)._$_GetWrapMode$_();
                }
                set _$textDirection$_(t) {
                    i._$RequireString$_(t);
                    const e = M.indexOf(t);
                    if (-1 === e) throw new Error("invalid text direction");
                    J.get(this)._$_SetTextDirection$_(e);
                }
                get _$textDirection$_() {
                    return M[J.get(this)._$_GetTextDirection$_()];
                }
                set _$readAloud$_(t) {
                    J.get(this)._$_SetReadAloud$_(!!t);
                }
                get _$readAloud$_() {
                    return J.get(this)._$_IsReadAloud$_();
                }
                _$setFixedResolutionMode$_(t) {
                    i._$RequireFiniteNumber$_(t);
                    const e = J.get(this);
                    e._$_SetResolutionMode$_("fixed"), e._$_SetFixedScaleFactor$_(t);
                }
                _$setAutoResolutionMode$_() {
                    J.get(this)._$_SetResolutionMode$_("auto");
                }
                get _$textWidth$_() {
                    return J.get(this)._$_GetTextWidth$_();
                }
                get _$textHeight$_() {
                    return J.get(this)._$_GetTextHeight$_();
                }
                _$getTextSize$_() {
                    const t = J.get(this);
                    return [ t._$_GetTextWidth$_(), t._$_GetTextHeight$_() ];
                }
                _$hasTagAtPosition$_(t, e, s) {
                    return i._$RequireString$_(t), i._$RequireFiniteNumber$_(e), 
                    i._$RequireFiniteNumber$_(s), J.get(this)._$_HasTagAtPosition$_(t, e, s);
                }
                _$getTagAtPosition$_(t, e) {
                    return i._$RequireFiniteNumber$_(t), i._$RequireFiniteNumber$_(e), 
                    J.get(this)._$_GetTagAtPosition$_(t, e);
                }
                _$getTagPositionAndSize$_(t, e = 0) {
                    return i._$RequireString$_(t), i._$RequireFiniteNumber$_(e), 
                    J.get(this)._$_GetTagPosition$_(t, e);
                }
                _$getTagCount$_(t) {
                    return i._$RequireString$_(t), J.get(this)._$_GetTagCount$_(t);
                }
                _$changeIconSet$_(t) {
                    const e = J.get(this), s = e._$GetRuntime$_()._$_UnwrapIObjectClass$_(t);
                    e._$_SetIconObjectClass$_(s);
                }
                _$getAsHtmlString$_() {
                    return J.get(this)._$_UpdateHTMLString$_();
                }
            };
        }
        {
            const Tb = self._$C3$_;
            Tb._$Plugins$_.Text._$Cnds$_ = {
                _$CompareText$_(t, e) {
                    return e ? this._$_text$_ === t : Tb._$equalsNoCase$_(this._$_text$_, t);
                },
                _$IsRunningTypewriterText$_() {
                    return -1 !== this._$_typewriterEndTime$_;
                },
                _$OnTypewriterTextFinished$_() {
                    return !0;
                },
                _$HasTagAtPosition$_(t, e, s) {
                    return this._$_HasTagAtPosition$_(t, e, s);
                }
            };
        }
        {
            const Zb = self._$C3$_, $b = Zb._$New$_(Zb._$Color$_);
            Zb._$Plugins$_.Text._$Acts$_ = {
                _$SetText$_(t) {
                    this._$_CancelTypewriter$_(), "number" == typeof t && t < 1e9 && (t = Math.round(1e10 * t) / 1e10), 
                    this._$_SetText$_(t.toString());
                },
                _$AppendText$_(t) {
                    this._$_CancelTypewriter$_(), (t = (t = "number" == typeof t && t < 1e9 ? Math.round(1e10 * t) / 1e10 : t).toString()) && this._$_SetText$_(this._$_text$_ + t);
                },
                _$TypewriterText$_(t, e) {
                    this._$_CancelTypewriter$_(), "number" == typeof t && t < 1e9 && (t = Math.round(1e10 * t) / 1e10), 
                    this._$_StartTypewriter$_(t.toString(), e);
                },
                _$SetFontFace$_(t, e) {
                    let s = !1, i = !1;
                    switch (e) {
                      case 1:
                        s = !0;
                        break;

                      case 2:
                        i = !0;
                        break;

                      case 3:
                        s = !0, i = !0;
                    }
                    t === this._$_faceName$_ && s === this._$_isBold$_ && i === this._$_isItalic$_ || (this._$_SetFontFace$_(t), 
                    this._$_SetBold$_(s), this._$_SetItalic$_(i));
                },
                _$SetFontSize$_(t) {
                    this._$_SetFontSize$_(t);
                },
                _$SetFontColor$_(t) {
                    $b._$setFromRgbValue$_(t), $b._$clamp$_(), this._$_SetFontColor$_($b);
                },
                _$SetWebFont$_(t, e) {
                    console.warn("[Text] 'Set web font' action is deprecated and no longer has any effect");
                },
                _$SetEffect$_(t) {
                    this._$GetWorldInfo$_()._$SetBlendMode$_(t), this._$_runtime$_._$UpdateRender$_();
                },
                _$TypewriterFinish$_() {
                    this._$_FinishTypewriter$_();
                },
                _$SetLineHeight$_(t) {
                    this._$_SetLineHeight$_(t);
                },
                _$SetHAlign$_(t) {
                    this._$_SetHAlign$_(t);
                },
                _$SetVAlign$_(t) {
                    this._$_SetVAlign$_(t);
                },
                _$SetWrapping$_(t) {
                    this._$_SetWrapModeByIndex$_(t);
                },
                _$SetTextDirection$_(t) {
                    this._$_SetTextDirection$_(t);
                },
                _$ChangeIconSet$_(t) {
                    this._$_SetIconObjectClass$_(t);
                },
                _$UpdateHTML$_() {
                    return this._$_UpdateHTMLString$_();
                },
                _$SetReadAloud$_(t) {
                    this._$_SetReadAloud$_(t);
                },
                _$SetResolutionMode$_(t, e) {
                    this._$_SetResolutionMode$_([ "auto", "fixed" ][t]), this._$_SetFixedScaleFactor$_(e);
                }
            };
        }
        {
            const v1 = self._$C3$_;
            v1._$Plugins$_.Text._$Exps$_ = {
                Text() {
                    return this._$_text$_;
                },
                _$PlainText$_() {
                    return this._$_enableBBcode$_ ? v1._$BBString$_._$StripAnyTags$_(this._$_text$_) : this._$_text$_;
                },
                _$FaceName$_() {
                    return this._$_faceName$_;
                },
                _$FaceSize$_() {
                    return this._$_ptSize$_;
                },
                _$TextWidth$_() {
                    return this._$_GetTextWidth$_();
                },
                _$TextHeight$_() {
                    return this._$_GetTextHeight$_();
                },
                _$LineHeight$_() {
                    return this._$_lineHeightOffset$_;
                },
                _$TagAtPosition$_(t, e) {
                    return this._$_GetTagAtPosition$_(t, e);
                },
                _$TagCount$_(t) {
                    return this._$_GetTagCount$_(t);
                },
                _$TagX$_(t, e) {
                    const s = this._$_GetTagPosition$_(t, e);
                    return s ? s.x : 0;
                },
                _$TagY$_(t, e) {
                    const s = this._$_GetTagPosition$_(t, e);
                    return s ? s.y : 0;
                },
                _$TagWidth$_(t, e) {
                    const s = this._$_GetTagPosition$_(t, e);
                    return s ? s.width : 0;
                },
                _$TagHeight$_(t, e) {
                    const s = this._$_GetTagPosition$_(t, e);
                    return s ? s.height : 0;
                },
                _$AsHTML$_() {
                    return this._$_htmlString$_;
                }
            };
        }
        {
            const a = self._$C3$_;
            a._$Plugins$_._$Spritefont2$_ = class extends a._$SDKPluginBase$_ {
                constructor(t) {
                    super(t);
                }
                _$Release$_() {
                    super._$Release$_();
                }
            };
        }
        {
            const d = self._$C3$_;
            d._$Plugins$_._$Spritefont2$_._$Type$_ = class extends d._$SDKTypeBase$_ {
                constructor(t) {
                    super(t), this._$_spriteFont$_ = d._$New$_(self._$SpriteFont$_);
                }
                _$Release$_() {
                    super._$Release$_();
                }
                _$OnCreate$_() {
                    this._$GetImageInfo$_()._$LoadAsset$_(this._$_runtime$_);
                }
                _$LoadTextures$_(t) {
                    return this._$GetImageInfo$_()._$LoadStaticTexture$_(t, {
                        _$sampling$_: this._$_runtime$_._$GetSampling$_()
                    });
                }
                _$ReleaseTextures$_() {
                    this._$GetImageInfo$_()._$ReleaseTexture$_();
                }
                _$GetSpriteFont$_() {
                    return this._$_spriteFont$_;
                }
                _$UpdateSettings$_(t, e, s, i) {
                    const r = this._$GetImageInfo$_(), n = this._$_spriteFont$_;
                    n._$SetWidth$_(r._$GetWidth$_()), n._$SetHeight$_(r._$GetHeight$_()), 
                    n._$SetCharacterWidth$_(t), n._$SetCharacterHeight$_(e), n._$SetCharacterSet$_(s), 
                    n._$SetSpacingData$_(i), n._$UpdateCharacterMap$_();
                }
            };
        }
        {
            const n = self._$C3$_, o = self._$C3X$_, p = n._$New$_(n._$Vector2$_), q = 0, r = 1, s = 2, t = 3, u = 4, v = 5, w = 6, x = 7, y = 8, z = 9, A = 10, B = 11, C = 12, D = 13, E = 14, F = [ "left", "center", "right" ], G = [ "top", "center", "bottom" ], H = [ "word", "cjk", "character" ], I = (n._$Plugins$_._$Spritefont2$_.Instance = class extends n._$SDKWorldInstanceBase$_ {
                constructor(t, e) {
                    super(t), this._$_text$_ = "", this._$_enableBBcode$_ = !0, 
                    this._$_characterWidth$_ = 16, this._$_characterHeight$_ = 16, 
                    this._$_characterSet$_ = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789.,;:?!-_~#\"'&()[]|`\\/@+=*$<>";
                    let s = "";
                    if (this._$_characterScale$_ = 1, this._$_characterSpacing$_ = 0, 
                    this._$_lineHeight$_ = 0, this._$_horizontalAlign$_ = 0, this._$_verticalAlign$_ = 0, 
                    this._$_wrapMode$_ = "word", this._$_needsTextLayout$_ = !0, 
                    this._$_readAloud$_ = !1, this._$_screenReaderText$_ = null, 
                    this._$_spriteFontText$_ = null, this._$_typewriterStartTime$_ = -1, 
                    this._$_typewriterEndTime$_ = -1, this._$_typewriterLength$_ = 0, 
                    e) {
                        this._$_text$_ = e[0], this._$_enableBBcode$_ = e[1], this._$_characterWidth$_ = e[2], 
                        this._$_characterHeight$_ = e[3], this._$_characterSet$_ = e[4], 
                        s = e[5], this._$_characterScale$_ = e[6], this._$_characterSpacing$_ = e[7], 
                        this._$_lineHeight$_ = e[8], this._$_horizontalAlign$_ = e[9], 
                        this._$_verticalAlign$_ = e[10], this._$_wrapMode$_ = H[e[11]];
                        const r = this._$GetWorldInfo$_();
                        r._$SetVisible$_(e[12]), this._$_readAloud$_ = !!e[E];
                    }
                    this._$_sdkType$_._$UpdateSettings$_(this._$_characterWidth$_, this._$_characterHeight$_, this._$_characterSet$_, s), 
                    this._$_spriteFontText$_ = n._$New$_(self._$SpriteFontText$_, this._$_sdkType$_._$GetSpriteFont$_());
                    const i = this._$GetWorldInfo$_();
                    this._$_spriteFontText$_._$SetSize$_(i._$GetWidth$_(), i._$GetHeight$_()), 
                    this._$_UpdateSettings$_(), this._$_UpdateScreenReaderText$_(), 
                    this._$_inst$_._$SetMustMitigateZFighting$_();
                }
                _$Release$_() {
                    this._$_CancelTypewriter$_(), this._$_screenReaderText$_ && (this._$_screenReaderText$_._$Release$_(), 
                    this._$_screenReaderText$_ = null), this._$_spriteFontText$_._$Release$_(), 
                    this._$_spriteFontText$_ = null, super._$Release$_();
                }
                _$_UpdateSettings$_() {
                    const t = this._$_spriteFontText$_;
                    t && (t._$SetBBCodeEnabled$_(this._$_enableBBcode$_), t._$SetText$_(this._$_text$_), 
                    t._$SetWordWrapMode$_(this._$_wrapMode$_), t._$SetHorizontalAlign$_(F[this._$_horizontalAlign$_]), 
                    t._$SetVerticalAlign$_(G[this._$_verticalAlign$_]), t._$SetSpacing$_(this._$_characterSpacing$_), 
                    t._$SetLineHeight$_(this._$_lineHeight$_));
                }
                _$_UpdateTextSize$_() {
                    const t = this._$GetWorldInfo$_();
                    this._$_spriteFontText$_._$SetSize$_(t._$GetWidth$_(), t._$GetHeight$_()), 
                    this._$_spriteFontText$_._$SetScale$_(this._$_characterScale$_);
                }
                _$_UpdateScreenReaderText$_() {
                    if (this._$_readAloud$_) {
                        let t = this._$_text$_;
                        this._$_enableBBcode$_ && (t = n._$BBString$_._$StripAnyTags$_(t)), 
                        this._$_screenReaderText$_ ? this._$_screenReaderText$_._$SetText$_(t) : this._$_screenReaderText$_ = n._$New$_(n._$ScreenReaderText$_, this._$_runtime$_, t);
                    } else this._$_screenReaderText$_ && (this._$_screenReaderText$_._$Release$_(), 
                    this._$_screenReaderText$_ = null);
                }
                _$Draw$_(i) {
                    const r = this._$_objectClass$_._$GetImageInfo$_(), n = r._$GetTexture$_();
                    if (n) {
                        i._$SetTexture$_(n);
                        let t = this._$GetWorldInfo$_(), e = t._$GetBoundingQuad$_(), s = this._$_spriteFontText$_;
                        s._$SetScale$_(this._$_characterScale$_), s._$SetSceneGraphScale$_(t._$GetSceneGraphScale$_()), 
                        this._$_runtime$_._$IsPixelRoundingEnabled$_() && (e = t._$PixelRoundQuad$_(e)), 
                        s._$SetSize$_(t._$GetWidth$_(), t._$GetHeight$_()), s._$GetSpriteFont$_()._$SetTexRect$_(r._$GetTexRect$_()), 
                        s._$SetColor$_(t._$GetUnpremultipliedColor$_()), s._$Draw$_(i, e._$getTlx$_(), e._$getTly$_(), t.GetAngle()), 
                        this._$_needsTextLayout$_ = !1;
                    }
                }
                _$SaveToJson$_() {
                    const t = {
                        t: this._$_text$_,
                        ebbc: this._$_enableBBcode$_,
                        csc: this._$_characterScale$_,
                        csp: this._$_characterSpacing$_,
                        lh: this._$_lineHeight$_,
                        ha: this._$_horizontalAlign$_,
                        va: this._$_verticalAlign$_,
                        w: this._$_wrapMode$_,
                        cw: this._$_sdkType$_._$GetSpriteFont$_()._$GetCharacterWidth$_(),
                        ch: this._$_sdkType$_._$GetSpriteFont$_()._$GetCharacterHeight$_(),
                        cs: this._$_sdkType$_._$GetSpriteFont$_()._$GetCharacterSet$_(),
                        sd: this._$_sdkType$_._$GetSpriteFont$_()._$GetSpacingData$_()
                    };
                    return -1 !== this._$_typewriterEndTime$_ && (t.tw = {
                        st: this._$_typewriterStartTime$_,
                        en: this._$_typewriterEndTime$_,
                        l: this._$_typewriterLength$_
                    }), t;
                }
                _$LoadFromJson$_(t) {
                    if (this._$_CancelTypewriter$_(), this._$_text$_ = t.t, this._$_enableBBcode$_ = t.ebbc, 
                    this._$_characterScale$_ = t.csc, this._$_characterSpacing$_ = t.csp, 
                    this._$_lineHeight$_ = t.lh, this._$_horizontalAlign$_ = t.ha, 
                    this._$_verticalAlign$_ = t.va, t.hasOwnProperty("w")) {
                        const s = t.w;
                        this._$_wrapMode$_ = "boolean" == typeof s ? s ? "word" : "character" : s;
                    } else this._$_wrapMode$_ = "word";
                    if (t.hasOwnProperty("tw")) {
                        const i = t.tw;
                        this._$_typewriterStartTime$_ = i.st, this._$_typewriterEndTime$_ = i.en, 
                        this._$_typewriterLength$_ = t.l;
                    }
                    const e = this._$_sdkType$_._$GetSpriteFont$_();
                    e._$SetCharacterWidth$_(t.cw), e._$SetCharacterHeight$_(t.ch), 
                    e._$SetCharacterSet$_(t.cs), e._$SetSpacingData$_(t.sd), this._$_UpdateSettings$_(), 
                    this._$_UpdateScreenReaderText$_(), -1 !== this._$_typewriterEndTime$_ && this._$_StartTicking$_();
                }
                _$GetPropertyValueByIndex$_(e) {
                    switch (e) {
                      case q:
                        return this._$GetText$_();

                      case r:
                        return this._$_enableBBcode$_;

                      case s:
                        return this._$_sdkType$_._$GetSpriteFont$_()._$GetCharacterWidth$_();

                      case t:
                        return this._$_sdkType$_._$GetSpriteFont$_()._$GetCharacterHeight$_();

                      case u:
                        return this._$_sdkType$_._$GetSpriteFont$_()._$GetCharacterSet$_();

                      case v:
                        return this._$_sdkType$_._$GetSpriteFont$_()._$GetSpacingData$_();

                      case w:
                        return this._$_GetScale$_();

                      case x:
                        return this._$_GetCharacterSpacing$_();

                      case y:
                        return this._$_GetLineHeight$_();

                      case z:
                        return this._$_GetHAlign$_();

                      case A:
                        return this._$_GetVAlign$_();

                      case B:
                        return this._$_GetWrapMode$_();
                    }
                }
                _$SetPropertyValueByIndex$_(e, i) {
                    switch (e) {
                      case q:
                        this._$_SetText$_(i);
                        break;

                      case r:
                        this._$_enableBBcode$_ !== !!i && (this._$_enableBBcode$_ = !!i, 
                        this._$_UpdateSettings$_());
                        break;

                      case s:
                        this._$_sdkType$_._$GetSpriteFont$_()._$SetCharacterWidth$_(i);
                        break;

                      case t:
                        this._$_sdkType$_._$GetSpriteFont$_()._$SetCharacterHeight$_(i);
                        break;

                      case u:
                        this._$_sdkType$_._$GetSpriteFont$_()._$SetCharacterSet$_(i);
                        break;

                      case v:
                        this._$_sdkType$_._$GetSpriteFont$_()._$SetSpacingData$_(i);
                        break;

                      case w:
                        this._$_SetScale$_(i);
                        break;

                      case x:
                        this._$_SetCharacterSpacing$_(i);
                        break;

                      case y:
                        this._$_SetLineHeight$_(i);
                        break;

                      case z:
                        this._$_SetHAlign$_(i);
                        break;

                      case A:
                        this._$_SetVAlign$_(i);
                        break;

                      case B:
                        this._$_SetWrapMode$_(i);
                    }
                }
                _$_SetText$_(t) {
                    this._$_text$_ !== t && (this._$_text$_ = t, this._$_spriteFontText$_._$SetText$_(t), 
                    this._$_UpdateScreenReaderText$_(), this._$_runtime$_._$UpdateRender$_());
                }
                _$GetText$_() {
                    return this._$_text$_;
                }
                _$_StartTypewriter$_(t, e) {
                    this._$_SetText$_(t), this._$_typewriterStartTime$_ = this._$_runtime$_._$GetWallTime$_(), 
                    this._$_typewriterEndTime$_ = this._$_typewriterStartTime$_ + e / this._$GetInstance$_()._$GetActiveTimeScale$_(), 
                    this._$_typewriterLength$_ = n._$CountGraphemes$_(n._$BBString$_._$StripAnyTags$_(t)), 
                    this._$_spriteFontText$_._$SetDrawMaxCharacterCount$_(0), this._$_StartTicking$_();
                }
                _$_CancelTypewriter$_() {
                    this._$_typewriterStartTime$_ = -1, this._$_typewriterEndTime$_ = -1, 
                    this._$_typewriterLength$_ = 0, this._$_spriteFontText$_._$SetDrawMaxCharacterCount$_(-1), 
                    this._$_StopTicking$_();
                }
                _$_FinishTypewriter$_() {
                    -1 !== this._$_typewriterEndTime$_ && (this._$_CancelTypewriter$_(), 
                    this._$Trigger$_(n._$Plugins$_._$Spritefont2$_._$Cnds$_._$OnTypewriterTextFinished$_), 
                    this._$_runtime$_._$UpdateRender$_());
                }
                _$_SetScale$_(t) {
                    this._$_characterScale$_ !== t && (this._$_characterScale$_ = t, 
                    this._$_spriteFontText$_._$SetScale$_(this._$_characterScale$_), 
                    this._$_runtime$_._$UpdateRender$_());
                }
                _$_GetScale$_() {
                    return this._$_characterScale$_;
                }
                _$_SetCharacterSpacing$_(t) {
                    this._$_characterSpacing$_ !== t && (this._$_characterSpacing$_ = t, 
                    this._$_spriteFontText$_._$SetSpacing$_(this._$_characterSpacing$_), 
                    this._$_runtime$_._$UpdateRender$_());
                }
                _$_GetCharacterSpacing$_() {
                    return this._$_characterSpacing$_;
                }
                _$_SetLineHeight$_(t) {
                    this._$_lineHeight$_ !== t && (this._$_lineHeight$_ = t, this._$_spriteFontText$_._$SetLineHeight$_(this._$_lineHeight$_), 
                    this._$_runtime$_._$UpdateRender$_());
                }
                _$_GetLineHeight$_() {
                    return this._$_lineHeight$_;
                }
                _$_SetHAlign$_(t) {
                    this._$_horizontalAlign$_ !== t && (this._$_horizontalAlign$_ = t, 
                    this._$_UpdateSettings$_(), this._$_runtime$_._$UpdateRender$_());
                }
                _$_GetHAlign$_() {
                    return this._$_horizontalAlign$_;
                }
                _$_SetVAlign$_(t) {
                    this._$_verticalAlign$_ !== t && (this._$_verticalAlign$_ = t, 
                    this._$_UpdateSettings$_(), this._$_runtime$_._$UpdateRender$_());
                }
                _$_GetVAlign$_() {
                    return this._$_verticalAlign$_;
                }
                _$_SetWrapModeByIndex$_(t) {
                    this._$_SetWrapMode$_(H[t]);
                }
                _$_SetWrapMode$_(t) {
                    this._$_wrapMode$_ !== t && (this._$_wrapMode$_ = t, this._$_UpdateSettings$_(), 
                    this._$_runtime$_._$UpdateRender$_());
                }
                _$_GetWrapMode$_() {
                    return this._$_wrapMode$_;
                }
                _$_SetReadAloud$_(t) {
                    this._$_readAloud$_ = !!t, this._$_UpdateScreenReaderText$_();
                }
                _$_IsReadAloud$_() {
                    return this._$_readAloud$_;
                }
                _$_GetTextWidth$_() {
                    return this._$_UpdateTextSize$_(), this._$_spriteFontText$_._$GetTextWidth$_();
                }
                _$_GetTextHeight$_() {
                    return this._$_UpdateTextSize$_(), this._$_spriteFontText$_._$GetTextHeight$_();
                }
                _$_GetTagAtPosition$_(t, e) {
                    this._$_UpdateTextSize$_();
                    const s = this._$GetWorldInfo$_(), i = (p.set(t - s._$GetX$_(), e - s._$GetY$_()), 
                    p.rotate(-s.GetAngle()), p.offset(s._$GetWidth$_() * s._$GetOriginX$_(), s._$GetHeight$_() * s._$GetOriginY$_()), 
                    this._$_spriteFontText$_._$HitTestFragment$_(p._$getX$_(), p._$getY$_()));
                    if (i) {
                        const r = i._$GetStyleTag$_("tag");
                        if (r) return r.param;
                    }
                    return "";
                }
                _$_HasTagAtPosition$_(t, e, s) {
                    const i = this._$_GetTagAtPosition$_(e, s);
                    return i && n._$equalsNoCase$_(t, i);
                }
                _$_GetTagPosition$_(t, e) {
                    this._$_UpdateTextSize$_(), e = Math.floor(e);
                    const s = this._$_spriteFontText$_._$FindFragmentWithTag$_(t, e);
                    if (!s) return null;
                    const i = this._$GetWorldInfo$_();
                    return p.set(s._$GetPosX$_(), s._$GetPosY$_()), p.offset(-i._$GetWidth$_() * i._$GetOriginX$_(), -i._$GetHeight$_() * i._$GetOriginY$_()), 
                    p.rotate(i.GetAngle()), p.offset(i._$GetX$_(), i._$GetY$_()), 
                    {
                        x: p._$getX$_(),
                        y: p._$getY$_(),
                        width: s._$GetWidth$_(),
                        height: s._$GetHeight$_()
                    };
                }
                _$_GetTagCount$_(t) {
                    return this._$_UpdateTextSize$_(), this._$_spriteFontText$_._$CountFragmentsWithTag$_(t);
                }
                _$Tick$_() {
                    const e = this._$_runtime$_._$GetWallTime$_();
                    if (e >= this._$_typewriterEndTime$_) this._$_CancelTypewriter$_(), 
                    this._$Trigger$_(n._$Plugins$_._$Spritefont2$_._$Cnds$_._$OnTypewriterTextFinished$_), 
                    this._$_runtime$_._$UpdateRender$_(); else {
                        let t = n._$relerp$_(this._$_typewriterStartTime$_, this._$_typewriterEndTime$_, e, 0, this._$_typewriterLength$_);
                        (t = Math.floor(t)) !== this._$_spriteFontText$_._$GetDrawMaxCharacterCount$_() && (this._$_spriteFontText$_._$SetDrawMaxCharacterCount$_(t), 
                        this._$_runtime$_._$UpdateRender$_());
                    }
                }
                _$GetDebuggerProperties$_() {
                    const t = "plugins.spritefont2";
                    return [ {
                        title: t + ".name",
                        properties: [ {
                            name: t + ".properties.text.name",
                            value: this._$GetText$_(),
                            _$onedit$_: t => this._$_SetText$_(t)
                        }, {
                            name: t + ".properties.scale.name",
                            value: this._$_GetScale$_(),
                            _$onedit$_: t => this._$_SetScale$_(t)
                        }, {
                            name: t + ".properties.character-spacing.name",
                            value: this._$_GetCharacterSpacing$_(),
                            _$onedit$_: t => this._$_SetCharacterSpacing$_(t)
                        }, {
                            name: t + ".properties.line-height.name",
                            value: this._$_GetLineHeight$_(),
                            _$onedit$_: t => this._$_SetLineHeight$_(t)
                        } ]
                    } ];
                }
                _$GetScriptInterfaceClass$_() {
                    return self._$ISpriteFontInstance$_;
                }
            }, new WeakMap()), J = new Map([ [ "left", 0 ], [ "center", 1 ], [ "right", 2 ] ]), K = new Map([ [ "top", 0 ], [ "center", 1 ], [ "bottom", 2 ] ]);
            self._$ISpriteFontInstance$_ = class extends self._$IWorldInstance$_ {
                constructor() {
                    super(), I.set(this, self._$IInstance$_._$_GetInitInst$_()._$GetSdkInstance$_());
                }
                get text() {
                    return I.get(this)._$GetText$_();
                }
                set text(t) {
                    o._$RequireString$_(t);
                    const e = I.get(this);
                    e._$_CancelTypewriter$_(), e._$_SetText$_(t);
                }
                _$typewriterText$_(t, e) {
                    o._$RequireString$_(t), o._$RequireFiniteNumber$_(e);
                    const s = I.get(this);
                    s._$_CancelTypewriter$_(), s._$_StartTypewriter$_(t, e);
                }
                _$typewriterFinish$_() {
                    I.get(this)._$_FinishTypewriter$_();
                }
                set _$characterScale$_(t) {
                    o._$RequireFiniteNumber$_(t), I.get(this)._$_SetScale$_(t);
                }
                get _$characterScale$_() {
                    return I.get(this)._$_GetScale$_();
                }
                set _$characterSpacing$_(t) {
                    o._$RequireFiniteNumber$_(t), I.get(this)._$_SetCharacterSpacing$_(t);
                }
                get _$characterSpacing$_() {
                    return I.get(this)._$_GetCharacterSpacing$_();
                }
                set lineHeight(t) {
                    o._$RequireFiniteNumber$_(t), I.get(this)._$_SetLineHeight$_(t);
                }
                get lineHeight() {
                    return I.get(this)._$_GetLineHeight$_();
                }
                set _$horizontalAlign$_(t) {
                    o._$RequireString$_(t);
                    const e = J.get(t);
                    if (void 0 === e) throw new Error("invalid mode");
                    I.get(this)._$_SetHAlign$_(e);
                }
                get _$horizontalAlign$_() {
                    return F[I.get(this)._$_GetHAlign$_()];
                }
                set verticalAlign(t) {
                    o._$RequireString$_(t);
                    const e = K.get(t);
                    if (void 0 === e) throw new Error("invalid mode");
                    I.get(this)._$_SetVAlign$_(e);
                }
                get verticalAlign() {
                    return G[I.get(this)._$_GetVAlign$_()];
                }
                set _$wordWrapMode$_(t) {
                    if (!H.includes(t)) throw new Error("invalid mode");
                    I.get(this)._$_SetWrapMode$_(t);
                }
                get _$wordWrapMode$_() {
                    return I.get(this)._$_GetWrapMode$_();
                }
                set _$readAloud$_(t) {
                    I.get(this)._$_SetReadAloud$_(!!t);
                }
                get _$readAloud$_() {
                    return I.get(this)._$_IsReadAloud$_();
                }
                get _$textWidth$_() {
                    return I.get(this)._$_GetTextWidth$_();
                }
                get _$textHeight$_() {
                    return I.get(this)._$_GetTextHeight$_();
                }
                _$getTextSize$_() {
                    const t = I.get(this);
                    return [ t._$_GetTextWidth$_(), t._$_GetTextHeight$_() ];
                }
                _$hasTagAtPosition$_(t, e, s) {
                    return o._$RequireString$_(t), o._$RequireFiniteNumber$_(e), 
                    o._$RequireFiniteNumber$_(s), I.get(this)._$_HasTagAtPosition$_(t, e, s);
                }
                _$getTagAtPosition$_(t, e) {
                    return o._$RequireFiniteNumber$_(t), o._$RequireFiniteNumber$_(e), 
                    I.get(this)._$_GetTagAtPosition$_(t, e);
                }
                _$getTagPositionAndSize$_(t, e = 0) {
                    return o._$RequireString$_(t), o._$RequireFiniteNumber$_(e), 
                    I.get(this)._$_GetTagPosition$_(t, e);
                }
                _$getTagCount$_(t) {
                    return o._$RequireString$_(t), I.get(this)._$_GetTagCount$_(t);
                }
            };
        }
        {
            const h0 = self._$C3$_;
            h0._$Plugins$_._$Spritefont2$_._$Cnds$_ = {
                _$CompareText$_(t, e) {
                    return e ? this._$_text$_ === t : h0._$equalsNoCase$_(this._$_text$_, t);
                },
                _$IsRunningTypewriterText$_() {
                    return -1 !== this._$_typewriterEndTime$_;
                },
                _$OnTypewriterTextFinished$_() {
                    return !0;
                },
                _$HasTagAtPosition$_(t, e, s) {
                    return this._$_HasTagAtPosition$_(t, e, s);
                }
            };
        }
        {
            const n0 = self._$C3$_;
            n0._$Plugins$_._$Spritefont2$_._$Acts$_ = {
                _$SetText$_(t) {
                    this._$_CancelTypewriter$_(), "number" == typeof t && t < 1e9 && (t = Math.round(1e10 * t) / 1e10), 
                    this._$_SetText$_(t.toString());
                },
                _$AppendText$_(t) {
                    this._$_CancelTypewriter$_(), (t = (t = "number" == typeof t && t < 1e9 ? Math.round(1e10 * t) / 1e10 : t).toString()) && this._$_SetText$_(this._$_text$_ + t);
                },
                _$TypewriterText$_(t, e) {
                    this._$_CancelTypewriter$_(), "number" == typeof t && t < 1e9 && (t = Math.round(1e10 * t) / 1e10), 
                    this._$_StartTypewriter$_(t.toString(), e);
                },
                _$TypewriterFinish$_() {
                    this._$_FinishTypewriter$_();
                },
                _$SetScale$_(t) {
                    this._$_SetScale$_(t);
                },
                _$SetCharacterSpacing$_(t) {
                    this._$_SetCharacterSpacing$_(t);
                },
                _$SetLineHeight$_(t) {
                    this._$_SetLineHeight$_(t);
                },
                _$SetCharacterWidth$_(t, e) {
                    let s = !1, i = this._$_sdkType$_._$GetSpriteFont$_();
                    for (const r of t) if (" " === r) i._$SetSpaceWidth$_(e), s = !0; else {
                        const n = i._$GetCharacter$_(r);
                        n && (n._$SetDisplayWidth$_(e), s = !0);
                    }
                    s && i._$SetCharacterWidthsChanged$_(), this._$_runtime$_._$UpdateRender$_();
                },
                _$SetEffect$_(t) {
                    this._$GetWorldInfo$_()._$SetBlendMode$_(t), this._$_runtime$_._$UpdateRender$_();
                },
                _$SetHAlign$_(t) {
                    this._$_SetHAlign$_(t);
                },
                _$SetVAlign$_(t) {
                    this._$_SetVAlign$_(t);
                },
                _$SetWrapping$_(t) {
                    this._$_SetWrapModeByIndex$_(t);
                },
                _$SetReadAloud$_(t) {
                    this._$_SetReadAloud$_(t);
                }
            };
        }
        {
            const G0 = self._$C3$_;
            G0._$Plugins$_._$Spritefont2$_._$Exps$_ = {
                _$CharacterWidth$_(t) {
                    const e = this._$_sdkType$_._$GetSpriteFont$_()._$GetCharacter$_(t);
                    return e ? e._$GetDisplayWidth$_() : this._$_sdkType$_._$GetSpriteFont$_()._$GetCharacterWidth$_();
                },
                _$CharacterHeight$_() {
                    return this._$_characterHeight$_;
                },
                _$CharacterScale$_() {
                    return this._$_characterScale$_;
                },
                _$CharacterSpacing$_() {
                    return this._$_characterSpacing$_;
                },
                _$LineHeight$_() {
                    return this._$_lineHeight$_;
                },
                Text() {
                    return this._$_text$_;
                },
                _$PlainText$_() {
                    return this._$_enableBBcode$_ ? G0._$BBString$_._$StripAnyTags$_(this._$_text$_) : this._$_text$_;
                },
                _$TextWidth$_() {
                    return this._$_GetTextWidth$_();
                },
                _$TextHeight$_() {
                    return this._$_GetTextHeight$_();
                },
                _$TagAtPosition$_(t, e) {
                    return this._$_GetTagAtPosition$_(t, e);
                },
                _$TagCount$_(t) {
                    return this._$_GetTagCount$_(t);
                },
                _$TagX$_(t, e) {
                    const s = this._$_GetTagPosition$_(t, e);
                    return s ? s.x : 0;
                },
                _$TagY$_(t, e) {
                    const s = this._$_GetTagPosition$_(t, e);
                    return s ? s.y : 0;
                },
                _$TagWidth$_(t, e) {
                    const s = this._$_GetTagPosition$_(t, e);
                    return s ? s.width : 0;
                },
                _$TagHeight$_(t, e) {
                    const s = this._$_GetTagPosition$_(t, e);
                    return s ? s.height : 0;
                }
            };
        }
        {
            const C33 = self._$C3$_;
            self._$SpriteFontCharacter$_ = class {
                constructor(t, e, s, i) {
                    let r = t._$GetCharacterWidth$_(), n = t._$GetCharacterHeight$_();
                    this._$_spriteFont$_ = t, this._$_char$_ = e, this._$_pxRect$_ = new C33.Rect(s, i, s + r, i + n), 
                    this._$_texRect$_ = new C33.Rect(), this._$_displayWidth$_ = -1, 
                    this._$_UpdateTexRect$_();
                }
                _$Release$_() {
                    this._$_spriteFont$_ = null, this._$_pxRect$_ = null, this._$_texRect$_ = null;
                }
                _$_UpdateTexRect$_() {
                    let t = this._$_spriteFont$_._$GetWidth$_(), e = this._$_spriteFont$_._$GetHeight$_();
                    this._$_texRect$_._$copy$_(this._$_pxRect$_), this._$_texRect$_._$divide$_(t, e), 
                    this._$_texRect$_._$lerpInto$_(this._$_spriteFont$_._$GetTexRect$_());
                }
                _$GetSpriteFont$_() {
                    return this._$_spriteFont$_;
                }
                _$GetChar$_() {
                    return this._$_char$_;
                }
                _$GetTexRect$_() {
                    return this._$_texRect$_;
                }
                _$SetDisplayWidth$_(t) {
                    this._$_displayWidth$_ = t;
                }
                _$GetDisplayWidth$_() {
                    return this._$_displayWidth$_ < 0 ? this._$_spriteFont$_._$GetCharacterWidth$_() : this._$_displayWidth$_;
                }
            };
        }
        {
            let getOffsetParam2 = function(t, e) {
                t = t.trim();
                const s = parseFloat(t);
                return isFinite(s) ? t.endsWith("%") ? e * s / 100 : s : 0;
            }, normalizeCssColorString2 = function(t) {
                return (canvasColorCtx = canvasColorCtx || C33._$CreateCanvas$_(32, 32).getContext("2d")).fillStyle = "#FFFFFF", 
                canvasColorCtx.fillStyle = t, canvasColorCtx.fillStyle;
            }, C33 = (getOffsetParam = getOffsetParam2, normalizeCssColorString = normalizeCssColorString2, 
            self._$C3$_), tmpRect = new C33.Rect(), tmpQuad = new C33._$Quad$_(), tmpColor = new C33._$Color$_(), VALID_HORIZ_ALIGNMENTS = new Set([ "left", "center", "right" ]), VALID_VERT_ALIGNMENTS = new Set([ "top", "center", "bottom" ]), VALID_WORD_WRAP_MODES = new Set([ "word", "cjk", "character" ]), canvasColorCtx = null;
            self._$SpriteFontText$_ = class {
                constructor(t) {
                    this._$_spriteFont$_ = t, this._$_cssWidth$_ = 0, this._$_cssHeight$_ = 0, 
                    this._$_text$_ = "", this._$_isBBcodeEnabled$_ = !1, this._$_bbString$_ = null, 
                    this._$_wrappedText$_ = C33._$New$_(C33._$WordWrap$_), this._$_wrapMode$_ = "word", 
                    this._$_wordWrapChanged$_ = !1, this._$_textLayoutChanged$_ = !1, 
                    this._$_horizontalAlign$_ = "left", this._$_verticalAlign$_ = "top", 
                    this._$_scale$_ = 1, this._$_sceneGraphScale$_ = 1, this._$_spacing$_ = 0, 
                    this._$_lineHeight$_ = 0, this._$_color$_ = C33._$New$_(C33._$Color$_), 
                    this._$_drawMaxCharCount$_ = -1, this._$_drawCharCount$_ = 0, 
                    this._$_measureTextCallback$_ = t => this._$_MeasureText$_(t), 
                    this._$_spriteFont$_._$_AddSpriteFontText$_(this);
                }
                _$Release$_() {
                    this._$_spriteFont$_._$_RemoveSpriteFontText$_(this), this._$_color$_ = null, 
                    this._$_measureTextCallback$_ = null, this._$_wrappedText$_._$Clear$_(), 
                    this._$_wrappedText$_ = null, this._$_spriteFont$_ = null, this._$_bbString$_ = null;
                }
                _$_MeasureText$_(t) {
                    if (t._$IsIcon$_()) return {
                        width: 0,
                        height: 0
                    };
                    const e = t._$GetCharacterArray$_(), s = t._$GetStyleTag$_("scale"), i = (s ? parseFloat(s.param) : this._$_scale$_) * this._$_sceneGraphScale$_, r = t._$GetStyleTag$_("scalex"), n = (r ? parseFloat(r.param) : 1) * i, h = t._$GetStyleTag$_("scaley"), o = (h ? parseFloat(h.param) : 1) * i, a = this._$_spriteFont$_._$GetCharacterHeight$_() * o + this._$_lineHeight$_, l = this._$GetSpriteFont$_(), u = l._$GetCharacterWidth$_() * n, c = this._$GetSpacing$_();
                    if (l._$HasAnyCustomWidths$_()) {
                        let s = 0, i = 0;
                        for (const f of e) {
                            let t = u, e = l._$GetCharacter$_(f);
                            e ? t = e._$GetDisplayWidth$_() * n : " " === f && (t = l._$GetSpaceWidth$_() * n), 
                            i += t, ++s;
                        }
                        return {
                            width: i + s * c,
                            height: a
                        };
                    }
                    {
                        const d = e.length, p = Math.max(d, 0);
                        return {
                            width: u * d + p * c,
                            height: a
                        };
                    }
                }
                _$_SetTextLayoutChanged$_() {
                    this._$_textLayoutChanged$_ = !0;
                }
                _$_SetWordWrapChanged$_() {
                    this._$_SetTextLayoutChanged$_(), this._$_wordWrapChanged$_ = !0, 
                    this._$_wrappedText$_._$Clear$_();
                }
                _$SetSize$_(t, e) {
                    t <= 0 || e <= 0 || this._$_cssWidth$_ === t && this._$_cssHeight$_ === e || (this._$_cssWidth$_ !== t ? this._$_SetWordWrapChanged$_() : this._$_SetTextLayoutChanged$_(), 
                    this._$_cssWidth$_ = t, this._$_cssHeight$_ = e);
                }
                _$SetDrawMaxCharacterCount$_(t) {
                    this._$_drawMaxCharCount$_ = Math.floor(t);
                }
                _$GetDrawMaxCharacterCount$_() {
                    return this._$_drawMaxCharCount$_;
                }
                _$HitTestFragment$_(t, e) {
                    this._$_UpdateTextMeasurements$_();
                    const s = this._$_wrappedText$_._$GetLines$_();
                    for (const i of s) if (e > i._$GetPosY$_() && e < i._$GetPosY$_() + i._$GetHeight$_()) for (const r of i._$fragments$_()) if (t >= r._$GetPosX$_() && t < r._$GetPosX$_() + r._$GetWidth$_()) return r;
                    return null;
                }
                *_$fragmentsWithTag$_(t) {
                    this._$_UpdateTextMeasurements$_();
                    const e = this._$_wrappedText$_._$GetLines$_();
                    for (const s of e) for (const i of s._$fragments$_()) {
                        const r = i._$GetStyleTag$_("tag");
                        r && C33._$equalsNoCase$_(r.param, t) && (yield i);
                    }
                }
                _$FindFragmentWithTag$_(t, e) {
                    for (const s of this._$fragmentsWithTag$_(t)) {
                        if (0 === e) return s;
                        --e;
                    }
                    return null;
                }
                _$CountFragmentsWithTag$_(t) {
                    let e = 0;
                    for (const s of this._$fragmentsWithTag$_(t)) ++e;
                    return e;
                }
                _$_UpdateTextMeasurements$_() {
                    this._$_UpdateWordWrap$_(), this._$_UpdateTextLayout$_();
                }
                _$_UpdateWordWrap$_() {
                    if (this._$_wordWrapChanged$_) {
                        !this._$_isBBcodeEnabled$_ || this._$_bbString$_ && this._$_bbString$_.toString() === this._$_text$_ || (this._$_bbString$_ = new C33._$BBString$_(this._$_text$_, {
                            _$noEscape$_: !0
                        }));
                        const t = -this._$GetSpacing$_();
                        this._$_wrappedText$_._$WordWrap$_(this._$_isBBcodeEnabled$_ ? this._$_bbString$_._$toFragmentList$_() : this._$_text$_, this._$_measureTextCallback$_, this._$_cssWidth$_, this._$_wrapMode$_, t), 
                        this._$_wordWrapChanged$_ = !1;
                    }
                }
                _$_UpdateTextLayout$_() {
                    this._$_textLayoutChanged$_ && (this._$_LayoutText$_(), this._$_textLayoutChanged$_ = !1);
                }
                _$_LayoutText$_() {
                    let s = 0, i = this._$_lineHeight$_, r = C33._$cloneArray$_(this._$_wrappedText$_._$GetLines$_());
                    for (const e of r) {
                        e._$SetPosX$_(NaN), e._$SetPosY$_(NaN);
                        for (const n of e._$fragments$_()) n._$SetPosX$_(NaN), n._$SetPosY$_(NaN);
                    }
                    const t = r.reduce((t, e) => t + e._$GetHeight$_(), 0) - i;
                    "center" === this._$_verticalAlign$_ ? s = Math.max(Math.floor(this._$_cssHeight$_ / 2 - t / 2), 0) : "bottom" === this._$_verticalAlign$_ && (s = Math.floor(this._$_cssHeight$_ - t));
                    for (let t = 0, e = r.length; t < e; ++t) {
                        const h = r[t], o = h._$GetHeight$_();
                        if (0 < t && s > this._$_cssHeight$_ - (o - i)) break;
                        0 <= s && this._$_LayoutTextLine$_(h, s), s += o;
                    }
                }
                _$_LayoutTextLine$_(t, e) {
                    let s = 0;
                    "center" === this._$_horizontalAlign$_ ? s = Math.max(Math.floor((this._$_cssWidth$_ - t._$GetWidth$_()) / 2), 0) : "right" === this._$_horizontalAlign$_ && (s = Math.max(Math.floor(this._$_cssWidth$_ - t._$GetWidth$_()), 0)), 
                    t._$SetPosX$_(s), t._$SetPosY$_(e);
                    for (const i of t._$fragments$_()) i._$IsIcon$_() || (this._$_LayoutTextFragment$_(i, s, e), 
                    s += i._$GetWidth$_());
                }
                _$_LayoutTextFragment$_(t, e, s) {
                    const i = t._$GetStyleTag$_("offsetx"), r = (e += i ? getOffsetParam2(i.param, t._$GetHeight$_()) : 0, 
                    t._$GetStyleTag$_("offsety"));
                    s += r ? getOffsetParam2(r.param, t._$GetHeight$_()) : 0, t._$SetPosX$_(e), 
                    t._$SetPosY$_(s);
                }
                _$Draw$_(t, e, s, i) {
                    this._$_UpdateTextMeasurements$_(), this._$_drawCharCount$_ = 0;
                    const r = C33._$cloneArray$_(this._$_wrappedText$_._$GetLines$_()), n = Math.sin(i), h = Math.cos(i);
                    for (const o of r) this._$_DrawLine$_(t, o, e, s, n, h);
                }
                _$_DrawLine$_(t, e, s, i, r, n) {
                    const h = e._$GetPosX$_(), o = e._$GetPosY$_();
                    if (Number.isFinite(h) && Number.isFinite(o)) {
                        const a = e._$GetHeight$_();
                        for (const l of e._$fragments$_()) this._$_DrawFragment$_(t, l, s, i, r, n, a);
                    }
                }
                _$_DrawFragment$_(o, a, l, u, c, f, d) {
                    let p = a._$GetPosX$_(), m = a._$GetPosY$_();
                    if (Number.isFinite(p) && Number.isFinite(m)) {
                        let n = a._$GetCharacterArray$_(), h = a._$GetWidth$_();
                        if (-1 !== this._$_drawMaxCharCount$_) {
                            if (this._$_drawCharCount$_ >= this._$_drawMaxCharCount$_) return;
                            this._$_drawCharCount$_ + n.length > this._$_drawMaxCharCount$_ && (n = n.slice(0, this._$_drawMaxCharCount$_ - this._$_drawCharCount$_), 
                            h = this._$_MeasureText$_(a).width), this._$_drawCharCount$_ += n.length;
                        }
                        const C = a._$GetStyleTag$_("background");
                        if (!(C33._$IsCharArrayAllWhitespace$_(n) && !C || a._$HasStyleTag$_("hide"))) {
                            const g = a._$GetStyleTag$_("scale"), S = (g ? parseFloat(g.param) : this._$_scale$_) * this._$_sceneGraphScale$_, _ = a._$GetStyleTag$_("scalex"), T = (_ ? parseFloat(_.param) : 1) * S, y = a._$GetStyleTag$_("scaley"), E = (y ? parseFloat(y.param) : 1) * S, A = this._$_spriteFont$_._$GetCharacterHeight$_() * E, I = this._$_lineHeight$_;
                            m += d - I - A;
                            let t = 1, e = a._$GetStyleTag$_("opacity"), s = (e && (t = parseFloat(e.param) / 100), 
                            C && (o._$SetColorFillMode$_(), tmpColor._$parseString$_(normalizeCssColorString2(C.param)), 
                            tmpColor._$setA$_(tmpColor._$getA$_() * t * this._$_color$_._$getA$_()), 
                            tmpColor._$premultiply$_(), o._$SetColor$_(tmpColor), 
                            tmpRect.set(p, m, p + h, m + A), tmpRect._$getRight$_() > this._$_cssWidth$_ && tmpRect._$setRight$_(this._$_cssWidth$_), 
                            tmpQuad._$setFromRotatedRectPrecalc$_(tmpRect, c, f), 
                            tmpQuad.offset(l, u), o._$Quad$_(tmpQuad), o._$SetTextureFillMode$_()), 
                            a._$GetStyleTag$_("color")), i = (s ? (tmpColor._$parseString$_(normalizeCssColorString2(s.param)), 
                            tmpColor._$setA$_(this._$_color$_._$getA$_())) : tmpColor._$copy$_(this._$_color$_), 
                            tmpColor._$setA$_(tmpColor._$getA$_() * t), tmpColor._$premultiply$_(), 
                            o._$SetColor$_(tmpColor), this._$_spriteFont$_._$GetCharacterWidth$_() * T), r = Math.abs(this._$GetSpacing$_());
                            for (const M of n) {
                                const w = this._$_spriteFont$_._$GetCharacter$_(M);
                                if (w) {
                                    const v = w._$GetDisplayWidth$_() * T;
                                    if (p + v > this._$_cssWidth$_ + r + 1e-5) return;
                                    tmpRect.set(p, m, p + i, m + A), tmpQuad._$setFromRotatedRectPrecalc$_(tmpRect, c, f), 
                                    tmpQuad.offset(l, u), o._$Quad3$_(tmpQuad, w._$GetTexRect$_()), 
                                    p += v + this._$_spacing$_;
                                } else p += this._$_spriteFont$_._$GetSpaceWidth$_() * T + this._$_spacing$_;
                            }
                        }
                    }
                }
                _$GetSpriteFont$_() {
                    return this._$_spriteFont$_;
                }
                _$SetBBCodeEnabled$_(t) {
                    this._$_isBBcodeEnabled$_ !== (t = !!t) && (this._$_isBBcodeEnabled$_ = t, 
                    this._$_SetWordWrapChanged$_());
                }
                _$IsBBCodeEnabled$_() {
                    return this._$_isBBcodeEnabled$_;
                }
                _$SetText$_(t) {
                    this._$_text$_ !== t && (this._$_text$_ = t, this._$_SetWordWrapChanged$_());
                }
                _$SetWordWrapMode$_(t) {
                    if (!VALID_WORD_WRAP_MODES.has(t)) throw new Error("invalid word wrap mode");
                    this._$_wrapMode$_ !== t && (this._$_wrapMode$_ = t, this._$_SetWordWrapChanged$_());
                }
                _$SetHorizontalAlign$_(t) {
                    if (!VALID_HORIZ_ALIGNMENTS.has(t)) throw new Error("invalid alignment");
                    this._$_horizontalAlign$_ !== t && (this._$_horizontalAlign$_ = t, 
                    this._$_SetTextLayoutChanged$_());
                }
                _$SetVerticalAlign$_(t) {
                    if (!VALID_VERT_ALIGNMENTS.has(t)) throw new Error("invalid alignment");
                    this._$_verticalAlign$_ !== t && (this._$_verticalAlign$_ = t, 
                    this._$_SetTextLayoutChanged$_());
                }
                _$SetScale$_(t) {
                    this._$_scale$_ !== t && (this._$_scale$_ = t, this._$_SetWordWrapChanged$_());
                }
                _$GetScale$_() {
                    return this._$_scale$_;
                }
                _$SetSceneGraphScale$_(t) {
                    this._$_sceneGraphScale$_ !== t && (this._$_sceneGraphScale$_ = t, 
                    this._$_SetWordWrapChanged$_());
                }
                _$GetSceneGraphScale$_() {
                    return this._$_sceneGraphScale$_;
                }
                _$SetSpacing$_(t) {
                    this._$_spacing$_ !== t && (this._$_spacing$_ = t, this._$_SetWordWrapChanged$_());
                }
                _$GetSpacing$_() {
                    return this._$_spacing$_;
                }
                _$SetLineHeight$_(t) {
                    this._$_lineHeight$_ = t, this._$_SetWordWrapChanged$_();
                }
                _$GetLineHeight$_() {
                    return this._$_lineHeight$_;
                }
                _$SetOpacity$_(t) {
                    t = C33._$clamp$_(t, 0, 1), this._$_color$_.a = t;
                }
                _$SetColor$_(t) {
                    this._$_color$_.equals(t) || this._$_color$_._$copy$_(t);
                }
                _$GetColor$_() {
                    return this._$_color$_;
                }
                _$GetTextWidth$_() {
                    return this._$_UpdateTextMeasurements$_(), this._$_wrappedText$_._$GetMaxLineWidth$_();
                }
                _$GetTextHeight$_() {
                    this._$_UpdateTextMeasurements$_();
                    const t = this._$_spriteFont$_._$GetCharacterHeight$_() * this._$_scale$_, e = this._$_lineHeight$_, s = t + e;
                    return this._$_wrappedText$_._$GetLineCount$_() * s - e;
                }
            };
        }
        {
            const C33 = self._$C3$_, SpriteFontText = self._$SpriteFontText$_, DEFAULT_SPRITEFONT_OPTS = {
                width: 256,
                height: 256,
                _$characterWidth$_: 16,
                _$characterHeight$_: 16,
                characterSet: ""
            };
            self._$SpriteFont$_ = class {
                constructor(t) {
                    if ((t = Object.assign({}, DEFAULT_SPRITEFONT_OPTS, t)).width <= 0 || t.height <= 0 || t._$characterWidth$_ <= 0 || t._$characterHeight$_ <= 0) throw new Error("invalid size");
                    this._$_width$_ = t.width, this._$_height$_ = t.height, this._$_characterWidth$_ = t._$characterWidth$_, 
                    this._$_characterHeight$_ = t._$characterHeight$_, this._$_characterSet$_ = t.characterSet, 
                    this._$_spacingData$_ = "", this._$_spacingParsed$_ = null, 
                    this._$_hasAnyCustomWidths$_ = !1, this._$_spaceWidth$_ = -1, 
                    this._$_texRect$_ = new C33.Rect(0, 0, 1, 1), this._$_characterMap$_ = new Map(), 
                    this._$_mapChanged$_ = !0, this._$_allTexts$_ = new Set();
                }
                _$Release$_() {
                    this._$_texRect$_ = null, this._$_ReleaseCharacters$_(), this._$_characterMap$_ = null, 
                    this._$_allTexts$_ && this._$_allTexts$_.clear(), this._$_allTexts$_ = null;
                }
                _$_ReleaseCharacters$_() {
                    for (let t of this._$_characterMap$_.values()) t._$Release$_();
                    this._$_characterMap$_.clear();
                }
                _$_AddSpriteFontText$_(t) {
                    this._$_allTexts$_.add(t);
                }
                _$_RemoveSpriteFontText$_(t) {
                    this._$_allTexts$_.delete(t);
                }
                _$UpdateCharacterMap$_() {
                    if (this._$_mapChanged$_) {
                        this._$_ReleaseCharacters$_();
                        let e = C33._$SplitGraphemes$_(this._$_characterSet$_), r = Math.floor(this._$_width$_ / this._$_characterWidth$_), t = Math.floor(this._$_height$_ / this._$_characterHeight$_), s = r * t;
                        for (let i = 0, t = e.length; i < t && !(i >= s); ++i) {
                            let s = e[i];
                            if (!this._$_characterMap$_.has(s)) {
                                let t = i % r, e = Math.floor(i / r);
                                this._$_characterMap$_.set(s, C33._$New$_(self._$SpriteFontCharacter$_, this, s, t * this._$_characterWidth$_, e * this._$_characterHeight$_));
                            }
                        }
                        if (this._$_hasAnyCustomWidths$_ = !1, this._$_spaceWidth$_ = -1, 
                        Array.isArray(this._$_spacingParsed$_)) for (let e of this._$_spacingParsed$_) if (Array.isArray(e) && 2 === e.length) {
                            let s = e[0], t = e[1];
                            if ("number" == typeof s && isFinite(s) && "string" == typeof t && s !== this._$_characterWidth$_) for (let e of t) {
                                let t = this._$_characterMap$_.get(e);
                                t ? (t._$SetDisplayWidth$_(s), this._$_hasAnyCustomWidths$_ = !0) : " " === e && (this._$_spaceWidth$_ = s, 
                                this._$_hasAnyCustomWidths$_ = !0);
                            }
                        }
                        this._$_mapChanged$_ = !1;
                        for (let t of this._$_allTexts$_) t._$_SetWordWrapChanged$_();
                    }
                }
                _$SetCharacterWidthsChanged$_() {
                    this._$_hasAnyCustomWidths$_ = !0;
                    for (const t of this._$_allTexts$_) t._$_SetWordWrapChanged$_();
                }
                _$GetCharacter$_(t) {
                    return this._$UpdateCharacterMap$_(), this._$_characterMap$_.get(t) || null;
                }
                _$HasAnyCustomWidths$_() {
                    return this._$_hasAnyCustomWidths$_;
                }
                _$SetWidth$_(t) {
                    if ((t = Math.floor(t)) <= 0) throw new Error("invalid size");
                    this._$_width$_ !== t && (this._$_width$_ = t, this._$_mapChanged$_ = !0);
                }
                _$GetWidth$_() {
                    return this._$_width$_;
                }
                _$SetHeight$_(t) {
                    if ((t = Math.floor(t)) <= 0) throw new Error("invalid size");
                    this._$_height$_ !== t && (this._$_height$_ = t, this._$_mapChanged$_ = !0);
                }
                _$GetHeight$_() {
                    return this._$_height$_;
                }
                _$SetTexRect$_(t) {
                    if (!this._$_texRect$_.equals(t)) {
                        this._$_texRect$_._$copy$_(t);
                        for (const e of this._$_characterMap$_.values()) e._$_UpdateTexRect$_();
                    }
                }
                _$GetTexRect$_() {
                    return this._$_texRect$_;
                }
                _$SetCharacterWidth$_(t) {
                    if ((t = Math.floor(t)) <= 0) throw new Error("invalid size");
                    this._$_characterWidth$_ !== t && (this._$_characterWidth$_ = t, 
                    this._$_mapChanged$_ = !0);
                }
                _$GetCharacterWidth$_() {
                    return this._$_characterWidth$_;
                }
                _$SetCharacterHeight$_(t) {
                    if ((t = Math.floor(t)) <= 0) throw new Error("invalid size");
                    this._$_characterHeight$_ !== t && (this._$_characterHeight$_ = t, 
                    this._$_mapChanged$_ = !0);
                }
                _$GetCharacterHeight$_() {
                    return this._$_characterHeight$_;
                }
                _$SetCharacterSet$_(t) {
                    this._$_characterSet$_ !== t && (this._$_characterSet$_ = t, 
                    this._$_mapChanged$_ = !0);
                }
                _$GetCharacterSet$_() {
                    return this._$_characterSet$_;
                }
                _$SetSpacingData$_(t) {
                    if (this._$_spacingData$_ !== t && (this._$_spacingData$_ = t, 
                    this._$_mapChanged$_ = !0, this._$_spacingParsed$_ = null, this._$_spacingData$_.length)) try {
                        this._$_spacingParsed$_ = JSON.parse(this._$_spacingData$_);
                    } catch (t) {
                        this._$_spacingParsed$_ = null;
                    }
                }
                _$GetSpacingData$_() {
                    return this._$_spacingData$_;
                }
                _$SetSpaceWidth$_(t) {
                    this._$_spaceWidth$_ !== (t = t < 0 ? -1 : t) && (this._$_spaceWidth$_ = t, 
                    0 <= this._$_spaceWidth$_) && (this._$_hasAnyCustomWidths$_ = !0);
                }
                _$GetSpaceWidth$_() {
                    return this._$_spaceWidth$_ < 0 ? this._$_characterWidth$_ : this._$_spaceWidth$_;
                }
            };
        }
        {
            const a = self._$C3$_;
            a._$Plugins$_.Touch = class extends a._$SDKPluginBase$_ {
                constructor(t) {
                    super(t);
                }
                _$Release$_() {
                    super._$Release$_();
                }
            };
        }
        {
            let GetTouchSdkInstance2 = function() {
                return s._$GetSingleGlobalInstance$_()._$GetSdkInstance$_();
            };
            GetTouchSdkInstance = GetTouchSdkInstance2;
            const d = self._$C3$_, e = self._$C3X$_;
            d._$Plugins$_.Touch._$Type$_ = class extends d._$SDKTypeBase$_ {
                constructor(t) {
                    super(t);
                }
                _$Release$_() {
                    super._$Release$_();
                }
                _$OnCreate$_() {}
                _$GetScriptInterfaceClass$_() {
                    return self._$ITouchObjectType$_;
                }
            };
            let s = null;
            self._$ITouchObjectType$_ = class extends self._$IObjectClass$_ {
                constructor(t) {
                    super(t), (s = t)._$GetRuntime$_()._$_GetCommonScriptInterfaces$_()._$touch$_ = this;
                }
                requestPermission(t) {
                    e._$RequireString$_(t);
                    const s = GetTouchSdkInstance2();
                    if ("orientation" === t) return s._$_RequestPermission$_(0);
                    if ("motion" === t) return s._$_RequestPermission$_(1);
                    throw new Error("invalid type");
                }
            };
        }
        {
            const m = self._$C3$_, n = "touch";
            m._$Plugins$_.Touch.Instance = class extends m._$SDKInstanceBase$_ {
                constructor(t, e) {
                    super(t, n), this._$_touches$_ = new Map(), this._$_useMouseInput$_ = !1, 
                    this._$_isMouseDown$_ = !1, this._$_orientCompassHeading$_ = 0, 
                    this._$_orientAlpha$_ = 0, this._$_orientBeta$_ = 0, this._$_orientGamma$_ = 0, 
                    this._$_accX$_ = 0, this._$_accY$_ = 0, this._$_accZ$_ = 0, 
                    this._$_accWithGX$_ = 0, this._$_accWithGY$_ = 0, this._$_accWithGZ$_ = 0, 
                    this._$_triggerIndex$_ = 0, this._$_triggerId$_ = 0, this._$_triggerPermission$_ = 0, 
                    this._$_curTouchX$_ = 0, this._$_curTouchY$_ = 0, this._$_getTouchIndex$_ = 0, 
                    this._$_triggerType$_ = 0, this._$_permissionPromises$_ = [], 
                    e && (this._$_useMouseInput$_ = e[0]), this._$AddDOMMessageHandler$_("permission-result", t => this._$_OnPermissionResult$_(t));
                    const s = this._$GetRuntime$_()._$Dispatcher$_();
                    this._$_disposables$_ = new m._$CompositeDisposable$_(m._$Disposable$_._$From$_(s, "pointerdown", t => this._$_OnPointerDown$_(t.data)), m._$Disposable$_._$From$_(s, "pointermove", t => this._$_OnPointerMove$_(t.data)), m._$Disposable$_._$From$_(s, "pointerup", t => this._$_OnPointerUp$_(t.data, !1)), m._$Disposable$_._$From$_(s, "pointercancel", t => this._$_OnPointerUp$_(t.data, !0)), m._$Disposable$_._$From$_(s, "deviceorientation", t => this._$_OnDeviceOrientation$_(t.data)), m._$Disposable$_._$From$_(s, "deviceorientationabsolute", t => this._$_OnDeviceOrientationAbsolute$_(t.data)), m._$Disposable$_._$From$_(s, "devicemotion", t => this._$_OnDeviceMotion$_(t.data)), m._$Disposable$_._$From$_(s, "tick2", t => this._$_OnTick2$_()));
                }
                _$Release$_() {
                    this._$_touches$_.clear(), super._$Release$_();
                }
                _$_OnPointerDown$_(t) {
                    if ("mouse" === t.pointerType) {
                        if (!this._$_useMouseInput$_) return;
                        this._$_isMouseDown$_ = !0;
                    }
                    const e = t.pointerId;
                    if (!this._$_touches$_.has(e)) {
                        const s = t.pageX - this._$_runtime$_._$GetCanvasClientX$_(), i = t.pageY - this._$_runtime$_._$GetCanvasClientY$_(), r = performance.now(), n = this._$_touches$_.size, h = (this._$_triggerIndex$_ = n, 
                        this._$_triggerId$_ = e, m._$New$_(m._$Plugins$_.Touch._$TouchInfo$_));
                        h._$Init$_(r, s, i, e, n), this._$_touches$_.set(e, h), 
                        this._$Trigger$_(m._$Plugins$_.Touch._$Cnds$_._$OnNthTouchStart$_), 
                        this._$Trigger$_(m._$Plugins$_.Touch._$Cnds$_._$OnTouchStart$_), 
                        this._$_curTouchX$_ = s, this._$_curTouchY$_ = i, this._$_triggerType$_ = 0, 
                        this._$Trigger$_(m._$Plugins$_.Touch._$Cnds$_._$OnTouchObject$_);
                    }
                }
                _$_OnPointerMove$_(t) {
                    if ("mouse" !== t.pointerType || this._$_isMouseDown$_) {
                        const e = this._$_touches$_.get(t.pointerId);
                        if (e) {
                            const s = performance.now();
                            if (!(s - e._$GetTime$_() < 2)) {
                                const i = t.pageX - this._$_runtime$_._$GetCanvasClientX$_(), r = t.pageY - this._$_runtime$_._$GetCanvasClientY$_();
                                e._$Update$_(s, i, r, t.width, t.height, t.pressure);
                            }
                        }
                    }
                }
                _$_OnPointerUp$_(t, e) {
                    if ("mouse" === t.pointerType) {
                        if (!this._$_isMouseDown$_) return;
                        this._$_isMouseDown$_ = !1;
                    }
                    const s = performance.now(), i = t.pointerId, r = this._$_touches$_.get(i);
                    if (r) {
                        if (this._$_triggerIndex$_ = r._$GetStartIndex$_(), this._$_triggerId$_ = r._$GetId$_(), 
                        !e) {
                            const n = t.pageX - this._$_runtime$_._$GetCanvasClientX$_(), h = t.pageY - this._$_runtime$_._$GetCanvasClientY$_();
                            this._$_curTouchX$_ = n, this._$_curTouchY$_ = h, this._$_triggerType$_ = 1, 
                            this._$Trigger$_(m._$Plugins$_.Touch._$Cnds$_._$OnTouchObject$_);
                        }
                        if (this._$Trigger$_(m._$Plugins$_.Touch._$Cnds$_._$OnNthTouchEnd$_), 
                        this._$Trigger$_(m._$Plugins$_.Touch._$Cnds$_._$OnTouchEnd$_), 
                        !e) {
                            const o = r._$ShouldTriggerTap$_(s);
                            "single-tap" === o ? (this._$Trigger$_(m._$Plugins$_.Touch._$Cnds$_._$OnTapGesture$_), 
                            this._$_curTouchX$_ = r._$GetX$_(), this._$_curTouchY$_ = r._$GetY$_(), 
                            this._$Trigger$_(m._$Plugins$_.Touch._$Cnds$_._$OnTapGestureObject$_)) : "double-tap" === o && (this._$Trigger$_(m._$Plugins$_.Touch._$Cnds$_._$OnDoubleTapGesture$_), 
                            this._$_curTouchX$_ = r._$GetX$_(), this._$_curTouchY$_ = r._$GetY$_(), 
                            this._$Trigger$_(m._$Plugins$_.Touch._$Cnds$_._$OnDoubleTapGestureObject$_));
                        }
                        r._$Release$_(), this._$_touches$_.delete(i);
                    }
                }
                _$_RequestPermission$_(s) {
                    return this._$_PostToDOMMaybeSync$_("request-permission", {
                        type: s
                    }), new Promise((t, e) => {
                        this._$_permissionPromises$_.push({
                            type: s,
                            resolve: t,
                            reject: e
                        });
                    });
                }
                _$_OnPermissionResult$_(t) {
                    const e = t.result, s = t.type, i = (this._$_triggerPermission$_ = s, 
                    this._$_permissionPromises$_.filter(t => t.type === s));
                    for (const r of i) r.resolve(e ? "granted" : "denied");
                    this._$_permissionPromises$_ = this._$_permissionPromises$_.filter(t => t.type !== s), 
                    e ? (this._$Trigger$_(m._$Plugins$_.Touch._$Cnds$_._$OnPermissionGranted$_), 
                    0 === s ? this._$_runtime$_._$RequestDeviceOrientationEvent$_() : this._$_runtime$_._$RequestDeviceMotionEvent$_()) : this._$Trigger$_(m._$Plugins$_.Touch._$Cnds$_._$OnPermissionDenied$_);
                }
                _$_OnDeviceOrientation$_(t) {
                    "number" == typeof t.webkitCompassHeading ? this._$_orientCompassHeading$_ = t.webkitCompassHeading : t.absolute && (this._$_orientCompassHeading$_ = t.alpha), 
                    this._$_orientAlpha$_ = t.alpha, this._$_orientBeta$_ = t.beta, 
                    this._$_orientGamma$_ = t.gamma;
                }
                _$_OnDeviceOrientationAbsolute$_(t) {
                    this._$_orientCompassHeading$_ = t.alpha;
                }
                _$_OnDeviceMotion$_(t) {
                    const e = t.acceleration, s = (e && (this._$_accX$_ = e.x, this._$_accY$_ = e.y, 
                    this._$_accZ$_ = e.z), t.accelerationIncludingGravity);
                    s && (this._$_accWithGX$_ = s.x, this._$_accWithGY$_ = s.y, 
                    this._$_accWithGZ$_ = s.z);
                }
                _$_OnTick2$_() {
                    let t = performance.now(), e = 0;
                    for (const s of this._$_touches$_.values()) s._$GetTime$_() <= t - 50 && s._$_SetLastTime$_(t), 
                    s._$ShouldTriggerHold$_(t) && (this._$_triggerIndex$_ = s._$GetStartIndex$_(), 
                    this._$_triggerId$_ = s._$GetId$_(), this._$_getTouchIndex$_ = e, 
                    this._$Trigger$_(m._$Plugins$_.Touch._$Cnds$_._$OnHoldGesture$_), 
                    this._$_curTouchX$_ = s._$GetX$_(), this._$_curTouchY$_ = s._$GetY$_(), 
                    this._$Trigger$_(m._$Plugins$_.Touch._$Cnds$_._$OnHoldGestureObject$_), 
                    this._$_getTouchIndex$_ = 0), ++e;
                }
                _$_GetTouchByIndex$_(t) {
                    t = Math.floor(t);
                    for (const e of this._$_touches$_.values()) {
                        if (0 === t) return e;
                        --t;
                    }
                    return null;
                }
                _$_IsClientPosOnCanvas$_(t, e) {
                    return 0 <= t && 0 <= e && t < this._$_runtime$_._$GetCanvasCssWidth$_() && e < this._$_runtime$_._$GetCanvasCssHeight$_();
                }
                _$GetDebuggerProperties$_() {
                    return [ {
                        title: "plugins.touch.debugger.touches",
                        properties: [ ...this._$_touches$_.values() ].map(t => ({
                            name: "$" + t._$GetId$_(),
                            value: t._$GetX$_() + ", " + t._$GetY$_()
                        }))
                    } ];
                }
            };
        }
        {
            const ra = self._$C3$_, sa = [];
            ra._$Plugins$_.Touch._$Cnds$_ = {
                _$OnTouchStart$_() {
                    return !0;
                },
                _$OnTouchEnd$_() {
                    return !0;
                },
                _$IsInTouch$_() {
                    return 0 < this._$_touches$_.size;
                },
                _$OnTouchObject$_(t, e) {
                    return !!t && e === this._$_triggerType$_ && !!this._$_IsClientPosOnCanvas$_(this._$_curTouchX$_, this._$_curTouchY$_) && this._$_runtime$_._$GetCollisionEngine$_()._$TestAndSelectCanvasPointOverlap$_(t, [ [ this._$_curTouchX$_, this._$_curTouchY$_ ] ], !1);
                },
                _$IsTouchingObject$_(t) {
                    if (!t) return !1;
                    const e = this._$_runtime$_._$GetCurrentCondition$_(), s = e._$IsInverted$_(), i = [ ...this._$_touches$_.values() ].filter(t => this._$_IsClientPosOnCanvas$_(t._$GetX$_(), t._$GetY$_())).map(t => [ t._$GetX$_(), t._$GetY$_() ]);
                    return ra.xor(this._$_runtime$_._$GetCollisionEngine$_()._$TestAndSelectCanvasPointOverlap$_(t, i, s), s);
                },
                _$CompareTouchSpeed$_(t, e, s) {
                    const i = this._$_GetTouchByIndex$_(t);
                    return !!i && ra.compare(i._$GetSpeed$_(), e, s);
                },
                _$OrientationSupported$_() {
                    return !0;
                },
                _$MotionSupported$_() {
                    return !0;
                },
                _$CompareOrientation$_(t, e, s) {
                    this._$_runtime$_._$RequestDeviceOrientationEvent$_();
                    let i;
                    return i = 0 === t ? this._$_orientAlpha$_ : 1 === t ? this._$_orientBeta$_ : this._$_orientGamma$_, 
                    ra.compare(i, e, s);
                },
                _$CompareAcceleration$_(t, e, s) {
                    this._$_runtime$_._$RequestDeviceMotionEvent$_();
                    let i;
                    return i = 0 === t ? this._$_accWithGX$_ : 1 === t ? this._$_accWithGY$_ : 2 === t ? this._$_accWithGZ$_ : 3 === t ? this._$_accX$_ : 4 === t ? this._$_accY$_ : this._$_accZ$_, 
                    ra.compare(i, e, s);
                },
                _$OnNthTouchStart$_(t) {
                    return (t = Math.floor(t)) === this._$_triggerIndex$_;
                },
                _$OnNthTouchEnd$_(t) {
                    return (t = Math.floor(t)) === this._$_triggerIndex$_;
                },
                _$HasNthTouch$_(t) {
                    return t = Math.floor(t), this._$_touches$_.size >= t + 1;
                },
                _$OnHoldGesture$_() {
                    return !0;
                },
                _$OnTapGesture$_() {
                    return !0;
                },
                _$OnDoubleTapGesture$_() {
                    return !0;
                },
                _$OnHoldGestureObject$_(t) {
                    return !!t && !!this._$_IsClientPosOnCanvas$_(this._$_curTouchX$_, this._$_curTouchY$_) && this._$_runtime$_._$GetCollisionEngine$_()._$TestAndSelectCanvasPointOverlap$_(t, [ [ this._$_curTouchX$_, this._$_curTouchY$_ ] ], !1);
                },
                _$OnTapGestureObject$_(t) {
                    return !!t && !!this._$_IsClientPosOnCanvas$_(this._$_curTouchX$_, this._$_curTouchY$_) && this._$_runtime$_._$GetCollisionEngine$_()._$TestAndSelectCanvasPointOverlap$_(t, [ [ this._$_curTouchX$_, this._$_curTouchY$_ ] ], !1);
                },
                _$OnDoubleTapGestureObject$_(t) {
                    return !!t && !!this._$_IsClientPosOnCanvas$_(this._$_curTouchX$_, this._$_curTouchY$_) && this._$_runtime$_._$GetCollisionEngine$_()._$TestAndSelectCanvasPointOverlap$_(t, [ [ this._$_curTouchX$_, this._$_curTouchY$_ ] ], !1);
                },
                _$OnPermissionGranted$_(t) {
                    return this._$_triggerPermission$_ === t;
                },
                _$OnPermissionDenied$_(t) {
                    return this._$_triggerPermission$_ === t;
                }
            };
        }
        {
            const Va = self._$C3$_;
            Va._$Plugins$_.Touch._$Acts$_ = {
                _$RequestPermission$_(t) {
                    this._$_RequestPermission$_(t);
                }
            };
        }
        {
            const Xa = self._$C3$_;
            Xa._$Plugins$_.Touch._$Exps$_ = {
                _$TouchCount$_() {
                    return this._$_touches$_.size;
                },
                _$X$_(t) {
                    const e = this._$_GetTouchByIndex$_(this._$_getTouchIndex$_);
                    return e ? e._$GetPositionForLayer$_(this._$_runtime$_._$GetCurrentLayout$_(), t, !0) : 0;
                },
                _$Y$_(t) {
                    const e = this._$_GetTouchByIndex$_(this._$_getTouchIndex$_);
                    return e ? e._$GetPositionForLayer$_(this._$_runtime$_._$GetCurrentLayout$_(), t, !1) : 0;
                },
                _$XAt$_(t, e) {
                    const s = this._$_GetTouchByIndex$_(t);
                    return s ? s._$GetPositionForLayer$_(this._$_runtime$_._$GetCurrentLayout$_(), e, !0) : 0;
                },
                _$YAt$_(t, e) {
                    const s = this._$_GetTouchByIndex$_(t);
                    return s ? s._$GetPositionForLayer$_(this._$_runtime$_._$GetCurrentLayout$_(), e, !1) : 0;
                },
                _$XForID$_(t, e) {
                    const s = this._$_touches$_.get(t);
                    return s ? s._$GetPositionForLayer$_(this._$_runtime$_._$GetCurrentLayout$_(), e, !0) : 0;
                },
                _$YForID$_(t, e) {
                    const s = this._$_touches$_.get(t);
                    return s ? s._$GetPositionForLayer$_(this._$_runtime$_._$GetCurrentLayout$_(), e, !1) : 0;
                },
                _$AbsoluteX$_() {
                    const t = this._$_GetTouchByIndex$_(0);
                    return t ? t._$GetX$_() : 0;
                },
                _$AbsoluteY$_() {
                    const t = this._$_GetTouchByIndex$_(0);
                    return t ? t._$GetY$_() : 0;
                },
                _$AbsoluteXAt$_(t) {
                    const e = this._$_GetTouchByIndex$_(t);
                    return e ? e._$GetX$_() : 0;
                },
                _$AbsoluteYAt$_(t) {
                    const e = this._$_GetTouchByIndex$_(t);
                    return e ? e._$GetY$_() : 0;
                },
                _$AbsoluteXForID$_(t) {
                    const e = this._$_touches$_.get(t);
                    return e ? e._$GetX$_() : 0;
                },
                _$AbsoluteYForID$_(t) {
                    const e = this._$_touches$_.get(t);
                    return e ? e._$GetY$_() : 0;
                },
                _$SpeedAt$_(t) {
                    const e = this._$_GetTouchByIndex$_(t);
                    return e ? e._$GetSpeed$_() : 0;
                },
                _$SpeedForID$_(t) {
                    const e = this._$_touches$_.get(t);
                    return e ? e._$GetSpeed$_() : 0;
                },
                _$AngleAt$_(t) {
                    const e = this._$_GetTouchByIndex$_(t);
                    return e ? Xa._$toDegrees$_(e.GetAngle()) : 0;
                },
                _$AngleForID$_(t) {
                    const e = this._$_touches$_.get(t);
                    return e ? Xa._$toDegrees$_(e.GetAngle()) : 0;
                },
                _$CompassHeading$_() {
                    return this._$_runtime$_._$RequestDeviceOrientationEvent$_(), 
                    this._$_orientCompassHeading$_;
                },
                _$Alpha$_() {
                    return this._$_runtime$_._$RequestDeviceOrientationEvent$_(), 
                    this._$_orientAlpha$_;
                },
                _$Beta$_() {
                    return this._$_runtime$_._$RequestDeviceOrientationEvent$_(), 
                    this._$_orientBeta$_;
                },
                _$Gamma$_() {
                    return this._$_runtime$_._$RequestDeviceOrientationEvent$_(), 
                    this._$_orientGamma$_;
                },
                _$AccelerationXWithG$_() {
                    return this._$_runtime$_._$RequestDeviceMotionEvent$_(), this._$_accWithGX$_;
                },
                _$AccelerationYWithG$_() {
                    return this._$_runtime$_._$RequestDeviceMotionEvent$_(), this._$_accWithGY$_;
                },
                _$AccelerationZWithG$_() {
                    return this._$_runtime$_._$RequestDeviceMotionEvent$_(), this._$_accWithGZ$_;
                },
                _$AccelerationX$_() {
                    return this._$_runtime$_._$RequestDeviceMotionEvent$_(), this._$_accX$_;
                },
                _$AccelerationY$_() {
                    return this._$_runtime$_._$RequestDeviceMotionEvent$_(), this._$_accY$_;
                },
                _$AccelerationZ$_() {
                    return this._$_runtime$_._$RequestDeviceMotionEvent$_(), this._$_accZ$_;
                },
                _$TouchIndex$_() {
                    return this._$_triggerIndex$_;
                },
                _$TouchID$_() {
                    return this._$_triggerId$_;
                },
                _$WidthForID$_(t) {
                    const e = this._$_touches$_.get(t);
                    return e ? e._$GetWidth$_() : 0;
                },
                _$HeightForID$_(t) {
                    const e = this._$_touches$_.get(t);
                    return e ? e._$GetHeight$_() : 0;
                },
                _$PressureForID$_(t) {
                    const e = this._$_touches$_.get(t);
                    return e ? e._$GetPressure$_() : 0;
                }
            };
        }
        {
            let C33 = self._$C3$_, GESTURE_HOLD_THRESHOLD = 15, GESTURE_HOLD_TIMEOUT = 500, GESTURE_TAP_TIMEOUT = 333, GESTURE_DOUBLETAP_THRESHOLD = 25, lastTapX = -1e3, lastTapY = -1e3, lastTapTime = -1e4;
            C33._$Plugins$_.Touch._$TouchInfo$_ = class extends C33._$DefendedBase$_ {
                constructor() {
                    super(), this._$_pointerId$_ = 0, this._$_startIndex$_ = 0, 
                    this._$_startTime$_ = 0, this._$_time$_ = 0, this._$_lastTime$_ = 0, 
                    this._$_startX$_ = 0, this._$_startY$_ = 0, this._$_x$_ = 0, 
                    this._$_y$_ = 0, this._$_lastX$_ = 0, this._$_lastY$_ = 0, this._$_width$_ = 0, 
                    this._$_height$_ = 0, this._$_pressure$_ = 0, this._$_hasTriggeredHold$_ = !1, 
                    this._$_isTooFarForHold$_ = !1;
                }
                _$Release$_() {}
                _$Init$_(t, e, s, i, r) {
                    this._$_pointerId$_ = i, this._$_startIndex$_ = r, this._$_time$_ = t, 
                    this._$_lastTime$_ = t, this._$_startTime$_ = t, this._$_startX$_ = e, 
                    this._$_startY$_ = s, this._$_x$_ = e, this._$_y$_ = s, this._$_lastX$_ = e, 
                    this._$_lastY$_ = s;
                }
                _$Update$_(t, e, s, i, r, n) {
                    this._$_lastTime$_ = this._$_time$_, this._$_time$_ = t, this._$_lastX$_ = this._$_x$_, 
                    this._$_lastY$_ = this._$_y$_, this._$_x$_ = e, this._$_y$_ = s, 
                    this._$_width$_ = i, this._$_height$_ = r, this._$_pressure$_ = n, 
                    !this._$_isTooFarForHold$_ && C33._$distanceTo$_(this._$_startX$_, this._$_startY$_, this._$_x$_, this._$_y$_) >= GESTURE_HOLD_THRESHOLD && (this._$_isTooFarForHold$_ = !0);
                }
                _$GetId$_() {
                    return this._$_pointerId$_;
                }
                _$GetStartIndex$_() {
                    return this._$_startIndex$_;
                }
                _$GetTime$_() {
                    return this._$_time$_;
                }
                _$_SetLastTime$_(t) {
                    this._$_lastTime$_ = t;
                }
                _$GetX$_() {
                    return this._$_x$_;
                }
                _$GetY$_() {
                    return this._$_y$_;
                }
                _$GetSpeed$_() {
                    const t = C33._$distanceTo$_(this._$_x$_, this._$_y$_, this._$_lastX$_, this._$_lastY$_), e = (this._$_time$_ - this._$_lastTime$_) / 1e3;
                    return 0 < e ? t / e : 0;
                }
                GetAngle() {
                    return C33._$angleTo$_(this._$_lastX$_, this._$_lastY$_, this._$_x$_, this._$_y$_);
                }
                _$GetWidth$_() {
                    return this._$_width$_;
                }
                _$GetHeight$_() {
                    return this._$_height$_;
                }
                _$GetPressure$_() {
                    return this._$_pressure$_;
                }
                _$ShouldTriggerHold$_(t) {
                    return !this._$_hasTriggeredHold$_ && t - this._$_startTime$_ >= GESTURE_HOLD_TIMEOUT && !this._$_isTooFarForHold$_ && C33._$distanceTo$_(this._$_startX$_, this._$_startY$_, this._$_x$_, this._$_y$_) < GESTURE_HOLD_THRESHOLD && (this._$_hasTriggeredHold$_ = !0);
                }
                _$ShouldTriggerTap$_(t) {
                    return !this._$_hasTriggeredHold$_ && t - this._$_startTime$_ <= GESTURE_TAP_TIMEOUT && !this._$_isTooFarForHold$_ && C33._$distanceTo$_(this._$_startX$_, this._$_startY$_, this._$_x$_, this._$_y$_) < GESTURE_HOLD_THRESHOLD ? t - lastTapTime <= 2 * GESTURE_TAP_TIMEOUT && C33._$distanceTo$_(lastTapX, lastTapY, this._$_x$_, this._$_y$_) < GESTURE_DOUBLETAP_THRESHOLD ? (lastTapX = -1e3, 
                    lastTapY = -1e3, lastTapTime = -1e4, "double-tap") : (lastTapX = this._$_x$_, 
                    lastTapY = this._$_y$_, lastTapTime = t, "single-tap") : "";
                }
                _$GetPositionForLayer$_(t, e, s) {
                    if (void 0 === e) {
                        const i = t._$GetLayerByIndex$_(0);
                        return i._$CanvasCssToLayer_DefaultTransform$_(this._$_x$_, this._$_y$_)[s ? 0 : 1];
                    }
                    {
                        const r = t._$GetLayer$_(e);
                        return r ? r._$CanvasCssToLayer$_(this._$_x$_, this._$_y$_)[s ? 0 : 1] : 0;
                    }
                }
            };
        }
        {
            const a = self._$C3$_;
            a._$Plugins$_._$TiledBg$_ = class extends a._$SDKPluginBase$_ {
                constructor(t) {
                    super(t);
                }
                _$Release$_() {
                    super._$Release$_();
                }
            };
        }
        {
            let WrapModeToStr2 = function(t) {
                switch (t) {
                  case 0:
                    return "clamp-to-edge";

                  case 1:
                    return "repeat";

                  case 2:
                    return "mirror-repeat";
                }
                return "repeat";
            };
            WrapModeToStr = WrapModeToStr2;
            const d = self._$C3$_;
            d._$Plugins$_._$TiledBg$_._$Type$_ = class extends d._$SDKTypeBase$_ {
                constructor(t, e) {
                    super(t), this._$_wrapX$_ = "repeat", this._$_wrapY$_ = "repeat", 
                    e && (this._$_wrapX$_ = WrapModeToStr2(e[0]), this._$_wrapY$_ = WrapModeToStr2(e[1]));
                }
                _$Release$_() {
                    super._$Release$_();
                }
                _$OnCreate$_() {
                    this._$GetImageInfo$_()._$LoadAsset$_(this._$_runtime$_);
                }
                _$LoadTextures$_(t) {
                    return this._$GetImageInfo$_()._$LoadStaticTexture$_(t, {
                        _$sampling$_: this._$_runtime$_._$GetSampling$_(),
                        _$wrapX$_: this._$_wrapX$_,
                        _$wrapY$_: this._$_wrapY$_
                    });
                }
                _$ReleaseTextures$_() {
                    this._$GetImageInfo$_()._$ReleaseTexture$_();
                }
                _$GetWrapModeX$_() {
                    return this._$_wrapX$_;
                }
                _$GetWrapModeY$_() {
                    return this._$_wrapY$_;
                }
            };
        }
        {
            const j = self._$C3$_, k = self._$C3X$_, l = 0, m = 1, n = 4, o = 5, p = 6, q = 7, r = 8, s = 9, t = 10, u = 11, v = 12, w = 13, x = 14, y = j._$New$_(j.Rect), z = j._$New$_(j._$Quad$_), A = j._$New$_(j.Rect), B = j._$New$_(j._$Quad$_), C = (j._$Plugins$_._$TiledBg$_.Instance = class extends j._$SDKWorldInstanceBase$_ {
                constructor(e, i) {
                    super(e), this._$_imageOffsetX$_ = 0, this._$_imageOffsetY$_ = 0, 
                    this._$_imageScaleX$_ = 1, this._$_imageScaleY$_ = 1, this._$_imageAngle$_ = 0, 
                    this._$_enableTileRandomization$_ = !1, this._$_tileXRandom$_ = 0, 
                    this._$_tileYRandom$_ = 0, this._$_tileAngleRandom$_ = 0, this._$_tileBlendMarginX$_ = 0, 
                    this._$_tileBlendMarginY$_ = 0, this._$_ownImageInfo$_ = null, 
                    i && (this._$GetWorldInfo$_()._$SetVisible$_(!!i[l]), this._$_imageOffsetX$_ = i[n], 
                    this._$_imageOffsetY$_ = i[o], this._$_imageScaleX$_ = i[p], 
                    this._$_imageScaleY$_ = i[q], this._$_imageAngle$_ = j._$toRadians$_(i[r]), 
                    this._$_enableTileRandomization$_ = !!i[s], this._$_tileXRandom$_ = i[t], 
                    this._$_tileYRandom$_ = i[u], this._$_tileAngleRandom$_ = i[v], 
                    this._$_tileBlendMarginX$_ = i[w], this._$_tileBlendMarginY$_ = i[x]);
                }
                _$Release$_() {
                    this._$_ReleaseOwnImage$_(), super._$Release$_();
                }
                _$_ReleaseOwnImage$_() {
                    this._$_ownImageInfo$_ && (this._$_ownImageInfo$_._$Release$_(), 
                    this._$_ownImageInfo$_ = null);
                }
                _$CalculateTextureCoordsFor3DFace$_(t, e, s) {
                    const i = this._$GetCurrentImageInfo$_(), r = i._$GetWidth$_(), n = i._$GetHeight$_(), h = this._$_imageOffsetX$_ / r, o = this._$_imageOffsetY$_ / n, a = this._$_imageAngle$_;
                    A.set(0, 0, t / (r * this._$_imageScaleX$_), e / (n * this._$_imageScaleY$_)), 
                    A.offset(-h, -o), 0 === a ? s._$setFromRect$_(A) : s._$setFromRotatedRect$_(A, -a);
                }
                _$SetTilingShaderProgram$_(t, e = !0) {
                    if (this._$_enableTileRandomization$_) {
                        const s = this._$GetCurrentImageInfo$_();
                        t._$SetTileRandomizationMode$_(), t._$SetTileRandomizationInfo$_(s._$GetWidth$_() * this._$_imageScaleX$_, s._$GetHeight$_() * this._$_imageScaleY$_, this._$_tileXRandom$_, this._$_tileYRandom$_, this._$_tileAngleRandom$_, this._$_tileBlendMarginX$_, this._$_tileBlendMarginY$_);
                    } else e && t._$SetTextureFillMode$_();
                }
                _$Draw$_(t) {
                    const e = this._$GetCurrentImageInfo$_(), s = e._$GetTexture$_();
                    if (null !== s) {
                        this._$SetTilingShaderProgram$_(t), t._$SetTexture$_(s);
                        const i = e._$GetWidth$_(), r = e._$GetHeight$_(), n = this._$_imageOffsetX$_ / i, h = this._$_imageOffsetY$_ / r, o = this._$GetWorldInfo$_();
                        A.set(0, 0, o._$GetWidth$_() / (i * this._$_imageScaleX$_), o._$GetHeight$_() / (r * this._$_imageScaleY$_)), 
                        A.offset(-n, -h), o._$HasMesh$_() ? this._$_DrawMesh$_(o, t) : this._$_DrawStandard$_(o, t);
                    }
                }
                _$_DrawStandard$_(t, e) {
                    let s = t._$GetBoundingQuad$_();
                    this._$_runtime$_._$IsPixelRoundingEnabled$_() && (s = t._$PixelRoundQuad$_(s)), 
                    0 === this._$_imageAngle$_ ? e._$Quad3$_(s, A) : (B._$setFromRotatedRect$_(A, -this._$_imageAngle$_), 
                    e._$Quad4$_(s, B));
                }
                _$_DrawMesh$_(s, t) {
                    const i = s._$GetTransformedMesh$_();
                    if (s._$IsMeshChanged$_()) {
                        s._$CalculateBbox$_(y, z, !1);
                        let t = z, e = (this._$_runtime$_._$IsPixelRoundingEnabled$_() && (t = s._$PixelRoundQuad$_(t)), 
                        A);
                        0 !== this._$_imageAngle$_ && (B._$setFromRotatedRect$_(A, -this._$_imageAngle$_), 
                        e = B), i._$CalculateTransformedMesh$_(s._$GetSourceMesh$_(), t, e), 
                        s._$SetMeshChanged$_(!1);
                    }
                    i._$Draw$_(t);
                }
                _$GetCurrentImageInfo$_() {
                    return this._$_ownImageInfo$_ || this._$_objectClass$_._$GetImageInfo$_();
                }
                _$IsOriginalSizeKnown$_() {
                    return !0;
                }
                _$GetTexture$_() {
                    return this._$GetCurrentImageInfo$_()._$GetTexture$_();
                }
                _$_SetMeshChanged$_() {
                    this._$GetWorldInfo$_()._$SetMeshChanged$_(!0);
                }
                _$_SetImageOffsetX$_(t) {
                    this._$_imageOffsetX$_ !== t && (this._$_imageOffsetX$_ = t, 
                    this._$_runtime$_._$UpdateRender$_(), this._$_SetMeshChanged$_());
                }
                _$_GetImageOffsetX$_() {
                    return this._$_imageOffsetX$_;
                }
                _$_SetImageOffsetY$_(t) {
                    this._$_imageOffsetY$_ !== t && (this._$_imageOffsetY$_ = t, 
                    this._$_runtime$_._$UpdateRender$_(), this._$_SetMeshChanged$_());
                }
                _$_GetImageOffsetY$_() {
                    return this._$_imageOffsetY$_;
                }
                _$_SetImageScaleX$_(t) {
                    this._$_imageScaleX$_ !== t && (this._$_imageScaleX$_ = t, this._$_runtime$_._$UpdateRender$_(), 
                    this._$_SetMeshChanged$_());
                }
                _$_GetImageScaleX$_() {
                    return this._$_imageScaleX$_;
                }
                _$_SetImageScaleY$_(t) {
                    this._$_imageScaleY$_ !== t && (this._$_imageScaleY$_ = t, this._$_runtime$_._$UpdateRender$_(), 
                    this._$_SetMeshChanged$_());
                }
                _$_GetImageScaleY$_() {
                    return this._$_imageScaleY$_;
                }
                _$_SetImageAngle$_(t) {
                    this._$_imageAngle$_ !== t && (this._$_imageAngle$_ = t, this._$_runtime$_._$UpdateRender$_(), 
                    this._$_SetMeshChanged$_());
                }
                _$_GetImageAngle$_() {
                    return this._$_imageAngle$_;
                }
                _$_SetTileRandomizationEnabled$_(t) {
                    this._$_enableTileRandomization$_ !== (t = !!t) && (this._$_enableTileRandomization$_ = t, 
                    this._$_runtime$_._$UpdateRender$_());
                }
                _$_IsTileRandomizationEnabled$_() {
                    return this._$_enableTileRandomization$_;
                }
                _$_SetTileXRandom$_(t) {
                    this._$_tileXRandom$_ !== t && (this._$_tileXRandom$_ = t, this._$_IsTileRandomizationEnabled$_()) && this._$_runtime$_._$UpdateRender$_();
                }
                _$_GetTileXRandom$_() {
                    return this._$_tileXRandom$_;
                }
                _$_SetTileYRandom$_(t) {
                    this._$_tileYRandom$_ !== t && (this._$_tileYRandom$_ = t, this._$_IsTileRandomizationEnabled$_()) && this._$_runtime$_._$UpdateRender$_();
                }
                _$_GetTileYRandom$_() {
                    return this._$_tileYRandom$_;
                }
                _$_SetTileAngleRandom$_(t) {
                    this._$_tileAngleRandom$_ !== t && (this._$_tileAngleRandom$_ = t, 
                    this._$_IsTileRandomizationEnabled$_()) && this._$_runtime$_._$UpdateRender$_();
                }
                _$_GetTileAngleRandom$_() {
                    return this._$_tileAngleRandom$_;
                }
                _$_SetTileBlendMarginX$_(t) {
                    this._$_tileBlendMarginX$_ !== t && (this._$_tileBlendMarginX$_ = t, 
                    this._$_IsTileRandomizationEnabled$_()) && this._$_runtime$_._$UpdateRender$_();
                }
                _$_GetTileBlendMarginX$_() {
                    return this._$_tileBlendMarginX$_;
                }
                _$_SetTileBlendMarginY$_(t) {
                    this._$_tileBlendMarginY$_ !== t && (this._$_tileBlendMarginY$_ = t, 
                    this._$_IsTileRandomizationEnabled$_()) && this._$_runtime$_._$UpdateRender$_();
                }
                _$_GetTileBlendMarginY$_() {
                    return this._$_tileBlendMarginY$_;
                }
                _$SaveToJson$_() {
                    const t = {};
                    return 0 !== this._$_imageOffsetX$_ && (t.iox = this._$_imageOffsetX$_), 
                    0 !== this._$_imageOffsetY$_ && (t.ioy = this._$_imageOffsetY$_), 
                    1 !== this._$_imageScaleX$_ && (t.isx = this._$_imageScaleX$_), 
                    1 !== this._$_imageScaleY$_ && (t.isy = this._$_imageScaleY$_), 
                    0 !== this._$_imageAngle$_ && (t.ia = this._$_imageAngle$_), 
                    this._$_enableTileRandomization$_ && (t.tr = !0), 1 !== this._$_tileXRandom$_ && (t.trx = this._$_tileXRandom$_), 
                    1 !== this._$_tileYRandom$_ && (t.try = this._$_tileYRandom$_), 
                    1 !== this._$_tileAngleRandom$_ && (t.tra = this._$_tileAngleRandom$_), 
                    .1 !== this._$_tileBlendMarginX$_ && (t.trbmx = this._$_tileBlendMarginX$_), 
                    .1 !== this._$_tileBlendMarginY$_ && (t.trbmy = this._$_tileBlendMarginY$_), 
                    t;
                }
                _$LoadFromJson$_(t) {
                    this._$_imageOffsetX$_ = t.iox || 0, this._$_imageOffsetY$_ = t.ioy || 0, 
                    this._$_imageScaleX$_ = t.hasOwnProperty("isx") ? t.isx : 1, 
                    this._$_imageScaleY$_ = t.hasOwnProperty("isy") ? t.isy : 1, 
                    this._$_imageAngle$_ = t.ia || 0, this._$_enableTileRandomization$_ = !!t.tr, 
                    this._$_tileXRandom$_ = t.hasOwnProperty("trx") ? t.trx : 1, 
                    this._$_tileYRandom$_ = t.hasOwnProperty("try") ? t.try : 1, 
                    this._$_tileAngleRandom$_ = t.hasOwnProperty("tra") ? t.tra : 1, 
                    this._$_tileBlendMarginX$_ = t.hasOwnProperty("trbmx") ? t.trbmx : .1, 
                    this._$_tileBlendMarginY$_ = t.hasOwnProperty("trbmy") ? t.trbmy : .1;
                }
                _$GetDebuggerProperties$_() {
                    const t = "plugins.tiledbg.properties";
                    return [ {
                        title: t + ".image-transform.name",
                        properties: [ {
                            name: t + ".image-offset-x.name",
                            value: this._$_GetImageOffsetX$_(),
                            _$onedit$_: t => this._$_SetImageOffsetX$_(t)
                        }, {
                            name: t + ".image-offset-y.name",
                            value: this._$_GetImageOffsetY$_(),
                            _$onedit$_: t => this._$_SetImageOffsetY$_(t)
                        }, {
                            name: t + ".image-scale-x.name",
                            value: 100 * this._$_GetImageScaleX$_(),
                            _$onedit$_: t => this._$_SetImageScaleX$_(t / 100)
                        }, {
                            name: t + ".image-scale-y.name",
                            value: 100 * this._$_GetImageScaleY$_(),
                            _$onedit$_: t => this._$_SetImageScaleY$_(t / 100)
                        }, {
                            name: t + ".image-angle.name",
                            value: j._$toDegrees$_(this._$_GetImageAngle$_()),
                            _$onedit$_: t => this._$_SetImageAngle$_(j._$toRadians$_(t))
                        } ]
                    }, {
                        title: t + ".tile-randomization.name",
                        properties: [ {
                            name: t + ".enable-tile-randomization.name",
                            value: this._$_IsTileRandomizationEnabled$_(),
                            _$onedit$_: t => this._$_SetTileRandomizationEnabled$_(t)
                        }, {
                            name: t + ".x-random.name",
                            value: 100 * this._$_GetTileXRandom$_(),
                            _$onedit$_: t => this._$_SetTileXRandom$_(t / 100)
                        }, {
                            name: t + ".y-random.name",
                            value: 100 * this._$_GetTileYRandom$_(),
                            _$onedit$_: t => this._$_SetTileYRandom$_(t / 100)
                        }, {
                            name: t + ".angle-random.name",
                            value: 100 * this._$_GetTileAngleRandom$_(),
                            _$onedit$_: t => this._$_SetTileAngleRandom$_(t / 100)
                        }, {
                            name: t + ".blend-margin-x.name",
                            value: 100 * this._$_GetTileBlendMarginX$_(),
                            _$onedit$_: t => this._$_SetTileBlendMarginX$_(t / 100)
                        }, {
                            name: t + ".blend-margin-y.name",
                            value: 100 * this._$_GetTileBlendMarginY$_(),
                            _$onedit$_: t => this._$_SetTileBlendMarginY$_(t / 100)
                        } ]
                    } ];
                }
                _$GetPropertyValueByIndex$_(e) {
                    switch (e) {
                      case n:
                        return this._$_GetImageOffsetX$_();

                      case o:
                        return this._$_GetImageOffsetY$_();

                      case p:
                        return this._$_GetImageScaleX$_();

                      case q:
                        return this._$_GetImageScaleY$_();

                      case r:
                        return this._$_GetImageAngle$_();

                      case s:
                        return this._$_IsTileRandomizationEnabled$_();

                      case t:
                        return this._$_GetTileXRandom$_();

                      case u:
                        return this._$_GetTileYRandom$_();

                      case v:
                        return this._$_GetTileAngleRandom$_();

                      case w:
                        return this._$_GetTileBlendMarginX$_();

                      case x:
                        return this._$_GetTileBlendMarginY$_();
                    }
                }
                _$SetPropertyValueByIndex$_(e, i) {
                    switch (e) {
                      case n:
                        this._$_SetImageOffsetX$_(i);
                        break;

                      case o:
                        this._$_SetImageOffsetY$_(i);
                        break;

                      case p:
                        this._$_SetImageScaleX$_(i);
                        break;

                      case q:
                        this._$_SetImageScaleY$_(i);
                        break;

                      case r:
                        this._$_SetImageAngle$_(i);
                        break;

                      case s:
                        this._$_SetTileRandomizationEnabled$_(!!i);
                        break;

                      case t:
                        this._$_SetTileXRandom$_(i);
                        break;

                      case u:
                        this._$_SetTileYRandom$_(i);
                        break;

                      case v:
                        this._$_SetTileAngleRandom$_(i);
                        break;

                      case w:
                        this._$_SetTileBlendMarginX$_(i);
                        break;

                      case x:
                        this._$_SetTileBlendMarginY$_(i);
                    }
                }
                _$GetScriptInterfaceClass$_() {
                    return self._$ITiledBackgroundInstance$_;
                }
            }, new WeakMap());
            self._$ITiledBackgroundInstance$_ = class extends self._$IWorldInstance$_ {
                constructor() {
                    super(), C.set(this, self._$IInstance$_._$_GetInitInst$_()._$GetSdkInstance$_());
                }
                set _$imageOffsetX$_(t) {
                    k._$RequireFiniteNumber$_(t), C.get(this)._$_SetImageOffsetX$_(t);
                }
                get _$imageOffsetX$_() {
                    return C.get(this)._$_GetImageOffsetX$_();
                }
                set _$imageOffsetY$_(t) {
                    k._$RequireFiniteNumber$_(t), C.get(this)._$_SetImageOffsetY$_(t);
                }
                get _$imageOffsetY$_() {
                    return C.get(this)._$_GetImageOffsetY$_();
                }
                _$setImageOffset$_(t, e) {
                    k._$RequireFiniteNumber$_(t), k._$RequireFiniteNumber$_(e);
                    const s = C.get(this);
                    s._$_SetImageOffsetX$_(t), s._$_SetImageOffsetY$_(e);
                }
                _$getImageOffset$_() {
                    const t = C.get(this);
                    return [ t._$_GetImageOffsetX$_(), t._$_GetImageOffsetY$_() ];
                }
                set _$imageScaleX$_(t) {
                    k._$RequireFiniteNumber$_(t), C.get(this)._$_SetImageScaleX$_(t);
                }
                get _$imageScaleX$_() {
                    return C.get(this)._$_GetImageScaleX$_();
                }
                set _$imageScaleY$_(t) {
                    k._$RequireFiniteNumber$_(t), C.get(this)._$_SetImageScaleY$_(t);
                }
                get _$imageScaleY$_() {
                    return C.get(this)._$_GetImageScaleY$_();
                }
                _$setImageScale$_(t, e) {
                    k._$RequireFiniteNumber$_(t), k._$RequireFiniteNumber$_(e);
                    const s = C.get(this);
                    s._$_SetImageScaleX$_(t), s._$_SetImageScaleY$_(e);
                }
                _$getImageScale$_() {
                    const t = C.get(this);
                    return [ t._$_GetImageScaleX$_(), t._$_GetImageScaleY$_() ];
                }
                set _$imageAngle$_(t) {
                    k._$RequireFiniteNumber$_(t), C.get(this)._$_SetImageAngle$_(t);
                }
                get _$imageAngle$_() {
                    return C.get(this)._$_GetImageAngle$_();
                }
                set _$imageAngleDegrees$_(t) {
                    k._$RequireFiniteNumber$_(t), C.get(this)._$_SetImageAngle$_(j._$toRadians$_(t));
                }
                get _$imageAngleDegrees$_() {
                    return j._$toDegrees$_(C.get(this)._$_GetImageAngle$_());
                }
                get imageWidth() {
                    return C.get(this)._$GetCurrentImageInfo$_()._$GetWidth$_();
                }
                get imageHeight() {
                    return C.get(this)._$GetCurrentImageInfo$_()._$GetHeight$_();
                }
                _$getImageSize$_() {
                    const t = C.get(this)._$GetCurrentImageInfo$_();
                    return [ t._$GetWidth$_(), t._$GetHeight$_() ];
                }
                set _$enableTileRandomization$_(t) {
                    C.get(this)._$_SetTileRandomizationEnabled$_(!!t);
                }
                get _$enableTileRandomization$_() {
                    return C.get(this)._$_IsTileRandomizationEnabled$_();
                }
                set _$tileXRandom$_(t) {
                    k._$RequireFiniteNumber$_(t), C.get(this)._$_SetTileXRandom$_(t);
                }
                get _$tileXRandom$_() {
                    return C.get(this)._$_GetTileXRandom$_();
                }
                set _$tileYRandom$_(t) {
                    k._$RequireFiniteNumber$_(t), C.get(this)._$_SetTileYRandom$_(t);
                }
                get _$tileYRandom$_() {
                    return C.get(this)._$_GetTileYRandom$_();
                }
                _$setTileRandom$_(t, e) {
                    k._$RequireFiniteNumber$_(t), k._$RequireFiniteNumber$_(e);
                    const s = C.get(this);
                    s._$_SetTileXRandom$_(t), s._$_SetTileYRandom$_(e);
                }
                _$getTileRandom$_() {
                    const t = C.get(this);
                    return [ t._$_GetTileXRandom$_(), t._$_GetTileYRandom$_() ];
                }
                set _$tileAngleRandom$_(t) {
                    k._$RequireFiniteNumber$_(t), C.get(this)._$_SetTileAngleRandom$_(t);
                }
                get _$tileAngleRandom$_() {
                    return C.get(this)._$_GetTileAngleRandom$_();
                }
                set _$tileBlendMarginX$_(t) {
                    k._$RequireFiniteNumber$_(t), C.get(this)._$_SetTileBlendMarginX$_(t);
                }
                get _$tileBlendMarginX$_() {
                    return C.get(this)._$_GetTileBlendMarginX$_();
                }
                set _$tileBlendMarginY$_(t) {
                    k._$RequireFiniteNumber$_(t), C.get(this)._$_SetTileBlendMarginY$_(t);
                }
                get _$tileBlendMarginY$_() {
                    return C.get(this)._$_GetTileBlendMarginY$_();
                }
                _$setTileBlendMargin$_(t, e) {
                    k._$RequireFiniteNumber$_(t), k._$RequireFiniteNumber$_(e);
                    const s = C.get(this);
                    s._$_SetTileBlendMarginX$_(t), s._$_SetTileBlendMarginY$_(e);
                }
                _$getTileBlendMargin$_() {
                    const t = C.get(this);
                    return [ t._$_GetTileBlendMarginX$_(), t._$_GetTileBlendMarginY$_() ];
                }
                async _$replaceImage$_(t) {
                    k._$RequireInstanceOf$_(t, Blob);
                    const e = C.get(this), s = e._$GetRuntime$_(), i = j._$New$_(j._$ImageInfo$_);
                    i._$LoadDynamicBlobAsset$_(s, t), await i._$LoadStaticTexture$_(s._$GetRenderer$_(), {
                        _$sampling$_: s._$GetSampling$_(),
                        _$wrapX$_: e._$GetSdkType$_()._$GetWrapModeX$_(),
                        _$wrapY$_: e._$GetSdkType$_()._$GetWrapModeY$_()
                    }), e._$WasReleased$_() ? i._$Release$_() : (e._$_ReleaseOwnImage$_(), 
                    e._$_ownImageInfo$_ = i, s._$UpdateRender$_());
                }
            };
        }
        {
            const o0 = self._$C3$_;
            o0._$Plugins$_._$TiledBg$_._$Cnds$_ = {
                _$OnURLLoaded$_() {
                    return !0;
                },
                _$OnURLFailed$_() {
                    return !0;
                },
                _$IsTileRandomizationEnabled$_() {
                    return this._$_IsTileRandomizationEnabled$_();
                }
            };
        }
        {
            const p0 = self._$C3$_;
            p0._$Plugins$_._$TiledBg$_._$Acts$_ = {
                _$SetImageOffsetX$_(t) {
                    this._$_SetImageOffsetX$_(t);
                },
                _$SetImageOffsetY$_(t) {
                    this._$_SetImageOffsetY$_(t);
                },
                _$SetImageScaleX$_(t) {
                    this._$_SetImageScaleX$_(t / 100);
                },
                _$SetImageScaleY$_(t) {
                    this._$_SetImageScaleY$_(t / 100);
                },
                _$SetImageAngle$_(t) {
                    this._$_SetImageAngle$_(p0._$toRadians$_(t));
                },
                _$SetTileRandomizationEnabled$_(t) {
                    this._$_SetTileRandomizationEnabled$_(t);
                },
                _$SetTilePosRandom$_(t, e) {
                    this._$_SetTileXRandom$_(t / 100), this._$_SetTileYRandom$_(e / 100);
                },
                _$SetTileAngleRandom$_(t) {
                    this._$_SetTileAngleRandom$_(t / 100);
                },
                _$SetTileBlendMargin$_(t, e) {
                    this._$_SetTileBlendMarginX$_(t / 100), this._$_SetTileBlendMarginY$_(e / 100);
                },
                _$SetEffect$_(t) {
                    this._$GetWorldInfo$_()._$SetBlendMode$_(t), this._$_runtime$_._$UpdateRender$_();
                },
                async _$LoadURL$_(t, e) {
                    if (!this._$_ownImageInfo$_ || this._$_ownImageInfo$_._$GetURL$_() !== t) {
                        const s = this._$_runtime$_, i = p0._$New$_(p0._$ImageInfo$_);
                        try {
                            if (await i._$LoadDynamicAsset$_(s, t), !i._$IsLoaded$_()) throw new Error("image failed to load");
                            if (this._$WasReleased$_()) return i._$Release$_(), 
                            null;
                            const r = await i._$LoadStaticTexture$_(s._$GetRenderer$_(), {
                                _$sampling$_: s._$GetSampling$_(),
                                _$wrapX$_: this._$GetSdkType$_()._$GetWrapModeX$_(),
                                _$wrapY$_: this._$GetSdkType$_()._$GetWrapModeY$_()
                            });
                            if (!r) return;
                        } catch (t) {
                            return console.error("Load image from URL failed: ", t), 
                            void (this._$WasReleased$_() || this._$Trigger$_(p0._$Plugins$_._$TiledBg$_._$Cnds$_._$OnURLFailed$_));
                        }
                        this._$WasReleased$_() ? i._$Release$_() : (this._$_ReleaseOwnImage$_(), 
                        this._$_ownImageInfo$_ = i, s._$UpdateRender$_(), await this._$TriggerAsync$_(p0._$Plugins$_._$TiledBg$_._$Cnds$_._$OnURLLoaded$_));
                    }
                }
            };
        }
        {
            const I0 = self._$C3$_;
            I0._$Plugins$_._$TiledBg$_._$Exps$_ = {
                _$ImageWidth$_() {
                    return this._$GetCurrentImageInfo$_()._$GetWidth$_();
                },
                _$ImageHeight$_() {
                    return this._$GetCurrentImageInfo$_()._$GetHeight$_();
                },
                _$ImageOffsetX$_() {
                    return this._$_imageOffsetX$_;
                },
                _$ImageOffsetY$_() {
                    return this._$_imageOffsetY$_;
                },
                _$ImageScaleX$_() {
                    return 100 * this._$_imageScaleX$_;
                },
                _$ImageScaleY$_() {
                    return 100 * this._$_imageScaleY$_;
                },
                _$ImageAngle$_() {
                    return I0._$toDegrees$_(this._$_imageAngle$_);
                },
                _$TileXRandom$_() {
                    return 100 * this._$_GetTileXRandom$_();
                },
                _$TileYRandom$_() {
                    return 100 * this._$_GetTileYRandom$_();
                },
                _$TileAngleRandom$_() {
                    return 100 * this._$_GetTileAngleRandom$_();
                },
                _$TileBlendMarginX$_() {
                    return 100 * this._$_GetTileBlendMarginX$_();
                },
                _$TileBlendMarginY$_() {
                    return 100 * this._$_GetTileBlendMarginY$_();
                }
            };
        }
        {
            const a = self._$C3$_;
            a._$Plugins$_._$NinePatch$_ = class extends a._$SDKPluginBase$_ {
                constructor(t) {
                    super(t);
                }
                _$Release$_() {
                    super._$Release$_();
                }
            };
        }
        {
            const d = self._$C3$_;
            d._$Plugins$_._$NinePatch$_._$Type$_ = class extends d._$SDKTypeBase$_ {
                constructor(t) {
                    super(t), this._$_textureSet$_ = null, this._$_drawable$_ = null;
                }
                _$Release$_() {
                    this._$ReleaseTextures$_(), super._$Release$_();
                }
                _$OnCreate$_() {
                    this._$GetImageInfo$_()._$LoadAsset$_(this._$_runtime$_);
                }
                async _$LoadTextures$_(t) {
                    const e = this._$GetImageInfo$_();
                    this._$_drawable$_ = await e._$ExtractImageToCanvas$_();
                }
                _$CreatePatch$_(t, e, s, i) {
                    !this._$_textureSet$_ && this._$_drawable$_ && (this._$_textureSet$_ = new self._$NinePatchTextureSet$_(this), 
                    this._$_textureSet$_._$CreateTextures$_(this._$_drawable$_, t, e, s, i));
                }
                _$ReleaseTextures$_() {
                    this._$_textureSet$_ && (this._$_textureSet$_._$Release$_(), 
                    this._$_textureSet$_ = null);
                }
                _$GetTextureSet$_() {
                    return this._$_textureSet$_;
                }
            };
        }
        {
            const m = self._$C3$_, n = 0, o = 1, p = 2, q = 3, r = 4, s = 5, t = 6, u = 7, v = 8, w = m._$New$_(m.Rect), x = m._$New$_(m.Rect), y = m._$New$_(m._$Quad$_);
            m._$Plugins$_._$NinePatch$_.Instance = class extends m._$SDKWorldInstanceBase$_ {
                constructor(e, i) {
                    super(e), this._$_leftMargin$_ = 16, this._$_rightMargin$_ = 16, 
                    this._$_topMargin$_ = 16, this._$_bottomMargin$_ = 16, this._$_edges$_ = 1, 
                    this._$_fill$_ = 1, this._$_isSeamless$_ = !0, this._$_callback3d$_ = null, 
                    i && (this._$_leftMargin$_ = i[n], this._$_rightMargin$_ = i[o], 
                    this._$_topMargin$_ = i[p], this._$_bottomMargin$_ = i[q], this._$_edges$_ = i[r], 
                    this._$_fill$_ = i[s], this._$_isSeamless$_ = !!i[v], this._$GetWorldInfo$_()._$SetVisible$_(!!i[t])), 
                    this._$_sdkType$_._$CreatePatch$_(this._$_leftMargin$_, this._$_rightMargin$_, this._$_topMargin$_, this._$_bottomMargin$_);
                }
                _$Release$_() {
                    super._$Release$_();
                }
                _$_Set3DCallback$_(t) {
                    this._$_callback3d$_ = t;
                }
                _$Draw$_(t) {
                    const e = this._$GetWorldInfo$_(), s = e._$GetBoundingQuad$_();
                    this._$_Draw$_(t, s._$getTlx$_(), s._$getTly$_(), e._$GetWidth$_(), e._$GetHeight$_());
                }
                _$_Draw$_(t, e, s, i, r) {
                    let n = this._$_sdkType$_._$GetTextureSet$_();
                    if (n || (this._$_sdkType$_._$CreatePatch$_(this._$_leftMargin$_, this._$_rightMargin$_, this._$_topMargin$_, this._$_bottomMargin$_), 
                    n = this._$_sdkType$_._$GetTextureSet$_())) {
                        const h = n._$GetImageWidth$_(), o = n._$GetImageHeight$_(), a = Math.min(this._$_leftMargin$_, h), l = Math.min(this._$_rightMargin$_, h), u = Math.min(this._$_topMargin$_, o), c = Math.min(this._$_bottomMargin$_, o), f = h - l, d = o - c, p = this._$_isSeamless$_ ? 1 : 0, m = this._$_edges$_, C = this._$_fill$_;
                        if (0 < a && 0 < u && this._$_DrawPatch$_(t, n._$GetTexture$_(), 0, 0, a + p, u + p, e, s, a + p, u + p), 
                        0 < l && 0 < u && this._$_DrawPatch$_(t, n._$GetTexture$_(), f - p, 0, l + p, u + p, e + i - l - p, s, l + p, u + p), 
                        0 < l && 0 < c && this._$_DrawPatch$_(t, n._$GetTexture$_(), f - p, d - p, l + p, c + p, e + i - l - p, s + r - c - p, l + p, c + p), 
                        0 < a && 0 < c && this._$_DrawPatch$_(t, n._$GetTexture$_(), 0, d - p, a + p, c + p, e, s + r - c - p, a + p, c + p), 
                        0 === m) {
                            const g = 2 === C ? 0 : p;
                            0 < a && u < d && this._$_TilePatch$_(t, n._$GetLeftTexture$_(), e, s + u, a + g, r - u - c, 0, 0), 
                            0 < l && u < d && this._$_TilePatch$_(t, n._$GetRightTexture$_(), e + i - l - g, s + u, l + g, r - u - c, g, 0), 
                            0 < u && a < f && this._$_TilePatch$_(t, n._$GetTopTexture$_(), e + a, s, i - a - l, u + g, 0, 0), 
                            0 < c && a < f && this._$_TilePatch$_(t, n._$GetBottomTexture$_(), e + a, s + r - c - g, i - a - l, c + g, 0, g);
                        } else 1 === m && (0 < a && u < d && this._$_DrawPatch$_(t, n._$GetTexture$_(), 0, u, a, d - u, e, s + u, a, r - u - c), 
                        0 < l && u < d && this._$_DrawPatch$_(t, n._$GetTexture$_(), f, u, l, d - u, e + i - l, s + u, l, r - u - c), 
                        0 < u && a < f && this._$_DrawPatch$_(t, n._$GetTexture$_(), a, 0, f - a, u, e + a, s, i - a - l, u), 
                        0 < c) && a < f && this._$_DrawPatch$_(t, n._$GetTexture$_(), a, d, f - a, c, e + a, s + r - c, i - a - l, c);
                        u < d && a < f && (0 === C ? this._$_TilePatch$_(t, n._$GetFillTexture$_(), e + a, s + u, i - a - l, r - u - c, 0, 0) : 1 === C && this._$_DrawPatch$_(t, n._$GetTexture$_(), a, u, f - a, d - u, e + a, s + u, i - a - l, r - u - c));
                    }
                }
                _$_DrawPatch$_(t, e, s, i, r, n, h, o, a, l) {
                    const u = e._$GetWidth$_(), c = e._$GetHeight$_();
                    if (t._$SetTexture$_(e), w.set(h, o, h + a, o + l), x.set(s / u, i / c, (s + r) / u, (i + n) / c), 
                    null === this._$_callback3d$_) {
                        const f = this._$GetWorldInfo$_(), d = f._$GetBoundingQuad$_(), p = d._$getTlx$_(), m = d._$getTly$_();
                        w.offset(-p, -m), y._$setFromRotatedRect$_(w, f.GetAngle()), 
                        y.offset(p, m), t._$Quad3$_(y, x);
                    } else this._$_callback3d$_(w, x);
                }
                _$_TilePatch$_(t, e, s, i, r, n, h, o) {
                    const a = e._$GetWidth$_(), l = e._$GetHeight$_();
                    if (t._$SetTexture$_(e), w.set(s, i, s + r, i + n), x.set(-h / a, -o / l, (r - h) / a, (n - o) / l), 
                    null === this._$_callback3d$_) {
                        const u = this._$GetWorldInfo$_(), c = u._$GetBoundingQuad$_(), f = c._$getTlx$_(), d = c._$getTly$_();
                        w.offset(-f, -d), y._$setFromRotatedRect$_(w, u.GetAngle()), 
                        y.offset(f, d), t._$Quad3$_(y, x);
                    } else this._$_callback3d$_(w, x);
                }
                _$GetCurrentImageInfo$_() {
                    this._$_objectClass$_._$GetImageInfo$_();
                }
                _$GetPropertyValueByIndex$_(t) {}
                _$SetPropertyValueByIndex$_(t, e) {}
            };
        }
        {
            const Da = self._$C3$_;
            Da._$Plugins$_._$NinePatch$_._$Cnds$_ = {};
        }
        {
            const Ea = self._$C3$_;
            Ea._$Plugins$_._$NinePatch$_._$Acts$_ = {
                _$SetEffect$_(t) {
                    this._$GetWorldInfo$_()._$SetBlendMode$_(t), this._$_runtime$_._$UpdateRender$_();
                }
            };
        }
        {
            const Ga = self._$C3$_;
            Ga._$Plugins$_._$NinePatch$_._$Exps$_ = {};
        }
        {
            let CloneDrawable2 = function(t) {
                const e = C33._$CreateCanvas$_(t.width, t.height), s = e.getContext("2d");
                return s.drawImage(t, 0, 0), e;
            };
            CloneDrawable = CloneDrawable2;
            const C33 = self._$C3$_;
            self._$NinePatchTextureSet$_ = class {
                constructor(t) {
                    this._$_sdkType$_ = t, this._$_runtime$_ = this._$_sdkType$_._$GetRuntime$_(), 
                    this._$_texture$_ = null, this._$_fillTexture$_ = null, this._$_leftTexture$_ = null, 
                    this._$_rightTexture$_ = null, this._$_topTexture$_ = null, 
                    this._$_bottomTexture$_ = null, this._$_imageWidth$_ = 0, this._$_imageHeight$_ = 0, 
                    this._$_renderer$_ = this._$_runtime$_._$GetRenderer$_(), this._$_isLoading$_ = !1, 
                    this._$_wasReleased$_ = !1;
                }
                _$Release$_() {
                    this._$_renderer$_._$IsContextLost$_() || (this._$_renderer$_._$DeleteTexture$_(this._$_texture$_), 
                    this._$_renderer$_._$DeleteTexture$_(this._$_fillTexture$_), 
                    this._$_renderer$_._$DeleteTexture$_(this._$_leftTexture$_), 
                    this._$_renderer$_._$DeleteTexture$_(this._$_rightTexture$_), 
                    this._$_renderer$_._$DeleteTexture$_(this._$_topTexture$_), 
                    this._$_renderer$_._$DeleteTexture$_(this._$_bottomTexture$_)), 
                    this._$_texture$_ = null, this._$_fillTexture$_ = null, this._$_leftTexture$_ = null, 
                    this._$_rightTexture$_ = null, this._$_topTexture$_ = null, 
                    this._$_bottomTexture$_ = null, this._$_sdkType$_ = null, this._$_renderer$_ = null, 
                    this._$_wasReleased$_ = !0;
                }
                _$WasReleased$_() {
                    return this._$_wasReleased$_;
                }
                _$CreateTextures$_(t, e, s, i, r) {
                    this._$_SliceImage$_(t, e, s, i, r);
                }
                _$HasCreatedTextures$_() {
                    return !!this._$_texture$_;
                }
                _$_SliceImage$_(t, e, s, i, r) {
                    if (!this._$_wasReleased$_) {
                        const n = t.width, h = t.height, o = (this._$_imageWidth$_ = n, 
                        this._$_imageHeight$_ = h, e = Math.min(Math.floor(e), n), 
                        s = Math.min(Math.floor(s), n), i = Math.min(Math.floor(i), h), 
                        n - s), a = h - (r = Math.min(Math.floor(r), h)), l = this._$_runtime$_._$GetSampling$_(), u = this._$_runtime$_._$GetCanvasManager$_()._$GetTextureAnisotropy$_();
                        this._$_texture$_ = this._$_renderer$_._$CreateStaticTexture$_(CloneDrawable2(t), {
                            _$sampling$_: l,
                            _$anisotropy$_: u
                        }), e < o && i < a && (this._$_fillTexture$_ = this._$_renderer$_._$CreateStaticTexture$_(this._$_SliceSubImage$_(CloneDrawable2(t), e, i, o, a), {
                            _$wrapX$_: "repeat",
                            _$wrapY$_: "repeat",
                            _$sampling$_: l,
                            _$anisotropy$_: u
                        })), 0 < e && i < a && (this._$_leftTexture$_ = this._$_renderer$_._$CreateStaticTexture$_(this._$_SliceSubImage$_(CloneDrawable2(t), 0, i, e, a), {
                            _$wrapY$_: "repeat",
                            _$sampling$_: l,
                            _$anisotropy$_: u
                        })), 0 < s && i < a && (this._$_rightTexture$_ = this._$_renderer$_._$CreateStaticTexture$_(this._$_SliceSubImage$_(CloneDrawable2(t), o, i, n, a), {
                            _$wrapY$_: "repeat",
                            _$sampling$_: l,
                            _$anisotropy$_: u
                        })), 0 < i && e < o && (this._$_topTexture$_ = this._$_renderer$_._$CreateStaticTexture$_(this._$_SliceSubImage$_(CloneDrawable2(t), e, 0, o, i), {
                            _$wrapX$_: "repeat",
                            _$sampling$_: l,
                            _$anisotropy$_: u
                        })), 0 < r && e < o && (this._$_bottomTexture$_ = this._$_renderer$_._$CreateStaticTexture$_(this._$_SliceSubImage$_(CloneDrawable2(t), e, a, o, h), {
                            _$wrapX$_: "repeat",
                            _$sampling$_: l,
                            _$anisotropy$_: u
                        }));
                    }
                }
                _$_SliceSubImage$_(t, e, s, i, r) {
                    const n = i - e, h = r - s, o = C33._$CreateCanvas$_(n, h), a = o.getContext("2d");
                    return a.drawImage(t, e, s, n, h, 0, 0, n, h), o;
                }
                _$GetImageWidth$_() {
                    return this._$_imageWidth$_;
                }
                _$GetImageHeight$_() {
                    return this._$_imageHeight$_;
                }
                _$GetTexture$_() {
                    return this._$_texture$_;
                }
                _$GetFillTexture$_() {
                    return this._$_fillTexture$_;
                }
                _$GetLeftTexture$_() {
                    return this._$_leftTexture$_;
                }
                _$GetRightTexture$_() {
                    return this._$_rightTexture$_;
                }
                _$GetTopTexture$_() {
                    return this._$_topTexture$_;
                }
                _$GetBottomTexture$_() {
                    return this._$_bottomTexture$_;
                }
            };
        }
        {
            const a = self._$C3$_, b = "list";
            a._$Plugins$_._$List$_ = class extends a._$SDKDOMPluginBase$_ {
                constructor(t) {
                    super(t, b), this._$AddElementMessageHandler$_("click", (t, e) => t._$_OnClick$_(e)), 
                    this._$AddElementMessageHandler$_("dblclick", (t, e) => t._$_OnDoubleClick$_(e)), 
                    this._$AddElementMessageHandler$_("change", (t, e) => t._$_OnChange$_(e));
                }
                _$Release$_() {
                    super._$Release$_();
                }
            };
        }
        {
            const k = self._$C3$_;
            k._$Plugins$_._$List$_._$Type$_ = class extends k._$SDKTypeBase$_ {
                constructor(t) {
                    super(t);
                }
                _$Release$_() {
                    super._$Release$_();
                }
                _$OnCreate$_() {}
            };
        }
        {
            const n = self._$C3$_, o = self._$C3X$_, p = 0, q = 1, r = 2, s = 3, t = 4, u = 5, v = 6, w = 7, x = 8, y = 0, z = 1, A = "list", B = (n._$Plugins$_._$List$_.Instance = class extends n._$SDKDOMInstanceBase$_ {
                constructor(e, i) {
                    if (super(e, A), this._$_items$_ = [], this._$_stringItems$_ = "", 
                    this._$_title$_ = "", this._$_isEnabled$_ = !0, this._$_isDropdown$_ = !0, 
                    this._$_isMultiSelect$_ = !1, this._$_autoFontSize$_ = !0, this._$_id$_ = "", 
                    this._$_className$_ = "", this._$_selectedIndex$_ = -1, this._$_selectedIndices$_ = [], 
                    i) {
                        const n = i[p];
                        this._$_items$_ = n ? n.split("\n") : [], this._$_stringItems$_ = i[p], 
                        this._$_title$_ = i[q], this._$GetWorldInfo$_()._$SetVisible$_(!!i[r]), 
                        this._$_isEnabled$_ = !!i[s], this._$_isDropdown$_ = i[t] === z, 
                        this._$_isMultiSelect$_ = !!i[u], this._$_autoFontSize$_ = !!i[v], 
                        this._$_id$_ = i[w], this._$_className$_ = i[x], this._$_isDropdown$_ && (this._$_selectedIndex$_ = 0);
                    }
                    this._$CreateElement$_({
                        id: this._$_id$_,
                        className: this._$_className$_,
                        isDropdown: this._$_isDropdown$_,
                        isMultiSelect: this._$_isMultiSelect$_,
                        items: this._$_items$_
                    });
                }
                _$Release$_() {
                    n._$clearArray$_(this._$_items$_), this._$_items$_ = null, n._$clearArray$_(this._$_selectedIndices$_), 
                    this._$_selectedIndices$_ = null, super._$Release$_();
                }
                _$GetElementState$_() {
                    return {
                        title: this._$_title$_,
                        isEnabled: this._$_isEnabled$_,
                        isMultiSelect: this._$_isMultiSelect$_
                    };
                }
                _$_UpdateSelectedIndex$_() {
                    this._$PostToDOMElement$_("set-selected-index", {
                        selectedIndex: this._$_selectedIndex$_
                    });
                }
                _$_ReadSelectionState$_(t) {
                    this._$_selectedIndex$_ = t.selectedIndex, this._$_selectedIndices$_ = t.selectedIndices;
                }
                async _$_OnClick$_(t) {
                    this._$_ReadSelectionState$_(t), this._$DispatchScriptEvent$_("click"), 
                    await this._$TriggerAsync$_(n._$Plugins$_._$List$_._$Cnds$_._$OnClicked$_);
                }
                async _$_OnDoubleClick$_(t) {
                    this._$_ReadSelectionState$_(t), this._$DispatchScriptEvent$_("dblclick"), 
                    await this._$TriggerAsync$_(n._$Plugins$_._$List$_._$Cnds$_._$OnDoubleClicked$_);
                }
                async _$_OnChange$_(t) {
                    this._$_ReadSelectionState$_(t), this._$DispatchScriptEvent$_("selectionchange"), 
                    await this._$TriggerAsync$_(n._$Plugins$_._$List$_._$Cnds$_._$OnSelectionChanged$_);
                }
                _$_GetItemCount$_() {
                    return this._$_items$_.length;
                }
                _$_SetSelectedIndex$_(t) {
                    (t = (t = Math.floor(t)) < 0 ? -1 : t) >= this._$_items$_.length || this._$_selectedIndex$_ !== t && (this._$_selectedIndex$_ = t, 
                    this._$_selectedIndices$_ = [ t ], this._$_UpdateSelectedIndex$_());
                }
                _$_GetSelectedIndex$_() {
                    return this._$_selectedIndex$_;
                }
                _$_GetSelectedCount$_() {
                    return this._$_selectedIndices$_.length;
                }
                _$_GetSelectedIndexAt$_(t) {
                    return (t = Math.floor(t)) < 0 || t >= this._$_selectedIndices$_.length ? 0 : this._$_selectedIndices$_[t];
                }
                _$_GetSelectedTextAt$_(t) {
                    return (t = Math.floor(t)) < 0 || t >= this._$_selectedIndices$_.length || (t = this._$_selectedIndices$_[t]) < 0 || t >= this._$_items$_.length ? "" : this._$_items$_[t];
                }
                _$_SetTooltip$_(t) {
                    this._$_title$_ !== t && (this._$_title$_ = t, this._$UpdateElementState$_());
                }
                _$_GetTooltip$_() {
                    return this._$_title$_;
                }
                _$_AddItem$_(t) {
                    this._$_items$_.push(t), this._$PostToDOMElement$_("add-item", {
                        text: t,
                        index: -1
                    });
                }
                _$_AddItemAt$_(s, t) {
                    if ((s = Math.max(Math.floor(s), 0)) >= this._$_items$_.length) this._$_items$_.push(t), 
                    s = -1; else {
                        this._$_items$_.splice(s, 0, t), this._$_selectedIndex$_ >= s && this._$_selectedIndex$_++;
                        for (let t = 0, e = this._$_selectedIndices$_.length; t < e; ++t) this._$_selectedIndices$_[t] >= s && this._$_selectedIndices$_[t]++;
                    }
                    this._$PostToDOMElement$_("add-item", {
                        index: s,
                        text: t
                    });
                }
                _$_RemoveItem$_(s) {
                    if (!((s = Math.floor(s)) < 0 || s >= this._$_items$_.length)) {
                        this._$_items$_.splice(s, 1), this._$_selectedIndex$_ >= s && this._$_selectedIndex$_--;
                        let e = this._$_selectedIndices$_.indexOf(s);
                        -1 !== e && this._$_selectedIndices$_.splice(e, 1), e = 0;
                        for (let t = this._$_selectedIndices$_.length; e < t; ++e) this._$_selectedIndices$_[e] >= s && this._$_selectedIndices$_[e]--;
                        this._$PostToDOMElement$_("remove-item", {
                            index: s
                        });
                    }
                }
                _$_SetItemText$_(t, e) {
                    (t = Math.floor(t)) < 0 || t >= this._$_items$_.length || (this._$_items$_[t] = e, 
                    this._$PostToDOMElement$_("set-item", {
                        index: t,
                        text: e
                    }));
                }
                _$_GetItemText$_(t) {
                    return (t = Math.floor(t)) < 0 || t >= this._$_items$_.length ? "" : this._$_items$_[t];
                }
                _$_Clear$_() {
                    n._$clearArray$_(this._$_items$_), this._$_selectedIndex$_ = -1, 
                    n._$clearArray$_(this._$_selectedIndices$_), this._$PostToDOMElement$_("clear");
                }
                _$_SetMultiSelect$_(t) {
                    this._$_isMultiSelect$_ !== (t = !!t) && (this._$_isMultiSelect$_ = t, 
                    this._$UpdateElementState$_());
                }
                _$_IsMultiSelect$_() {
                    return this._$_isMultiSelect$_;
                }
                _$_SetEnabled$_(t) {
                    this._$_isEnabled$_ !== (t = !!t) && (this._$_isEnabled$_ = t, 
                    this._$UpdateElementState$_());
                }
                _$_IsEnabled$_() {
                    return this._$_isEnabled$_;
                }
                _$Draw$_(t) {}
                _$SaveToJson$_() {
                    return {
                        title: this._$_title$_,
                        isEnabled: this._$_isEnabled$_,
                        id: this._$_id$_,
                        items: n._$cloneArray$_(this._$_items$_),
                        selectedIndex: this._$_selectedIndex$_,
                        selectedIndices: this._$_selectedIndices$_
                    };
                }
                _$LoadFromJson$_(t) {
                    this._$_title$_ = t.title, this._$_isEnabled$_ = t.isEnabled, 
                    this._$_id$_ = t.id, this._$_items$_ = n._$cloneArray$_(t.items), 
                    this._$_stringItems$_ = this._$_items$_.join("/n"), this._$_selectedIndex$_ = t.selectedIndex, 
                    this._$_selectedIndices$_ = t.selectedIndices, this._$UpdateElementState$_(), 
                    this._$PostToDOMElement$_("load-state", {
                        items: this._$_items$_,
                        selectedIndex: this._$_selectedIndex$_,
                        selectedIndices: this._$_selectedIndices$_
                    });
                }
                _$GetPropertyValueByIndex$_(t) {
                    switch (t) {
                      case p:
                        return this._$_stringItems$_;

                      case q:
                        return this._$_GetTooltip$_();

                      case s:
                        return this._$_IsEnabled$_();

                      case u:
                        return this._$_IsMultiSelect$_();

                      case v:
                        return this._$_autoFontSize$_;
                    }
                }
                _$SetPropertyValueByIndex$_(t, e) {
                    switch (t) {
                      case p:
                        this._$_stringItems$_ !== e && (this._$_items$_ = e.split("\n"), 
                        this._$_stringItems$_ = e, this._$_selectedIndex$_ = n._$clamp$_(this._$_selectedIndex$_, 0, this._$_items$_.length - 1), 
                        this._$UpdateElementState$_(), this._$PostToDOMElement$_("load-state", {
                            items: this._$_items$_,
                            selectedIndex: this._$_selectedIndex$_,
                            selectedIndices: this._$_selectedIndices$_
                        }));
                        break;

                      case q:
                        this._$_SetTooltip$_(e);
                        break;

                      case s:
                        this._$_SetEnabled$_(e);
                        break;

                      case u:
                        this._$_SetMultiSelect$_(e);
                        break;

                      case v:
                        this._$_autoFontSize$_ !== !!e && (this._$_autoFontSize$_ = !!e, 
                        this._$UpdateElementState$_());
                    }
                }
                _$GetDebuggerProperties$_() {
                    const t = "plugins.list";
                    return [ {
                        title: t + ".name",
                        properties: [ {
                            name: t + ".debugger.item-count",
                            value: this._$_GetItemCount$_()
                        }, {
                            name: t + ".properties.enabled.name",
                            value: this._$_IsEnabled$_(),
                            _$onedit$_: t => this._$_SetEnabled$_(t)
                        }, {
                            name: t + ".debugger.selected-index",
                            value: this._$_GetSelectedIndex$_()
                        } ]
                    }, {
                        title: t + ".properties.items.name",
                        properties: this._$_items$_.map((t, e) => ({
                            name: "$" + e,
                            value: t,
                            _$onedit$_: t => this._$_SetItemText$_(e, t)
                        }))
                    } ];
                }
                _$GetScriptInterfaceClass$_() {
                    return self._$IListInstance$_;
                }
            }, new WeakMap());
            self._$IListInstance$_ = class extends self._$IDOMInstance$_ {
                constructor() {
                    super(), B.set(this, self._$IInstance$_._$_GetInitInst$_()._$GetSdkInstance$_());
                }
                set selectedIndex(t) {
                    o._$RequireFiniteNumber$_(t), B.get(this)._$_SetSelectedIndex$_(t);
                }
                get selectedIndex() {
                    return B.get(this)._$_GetSelectedIndex$_();
                }
                get _$selectedCount$_() {
                    return B.get(this)._$_GetSelectedCount$_();
                }
                _$getSelectedIndexAt$_(t) {
                    return o._$RequireFiniteNumber$_(t), B.get(this)._$_GetSelectedIndexAt$_(t);
                }
                _$getSelectedTextAt$_(t) {
                    return o._$RequireFiniteNumber$_(t), B.get(this)._$_GetSelectedTextAt$_(t);
                }
                set _$tooltip$_(t) {
                    o._$RequireString$_(t), B.get(this)._$_SetTooltip$_(t);
                }
                get _$tooltip$_() {
                    return B.get(this)._$_GetTooltip$_();
                }
                _$addItem$_(t) {
                    o._$RequireString$_(t), B.get(this)._$_AddItem$_(t);
                }
                _$insertItem$_(t, e) {
                    o._$RequireFiniteNumber$_(t), o._$RequireString$_(e), B.get(this)._$_AddItemAt$_(t, e);
                }
                _$setItemText$_(t, e) {
                    o._$RequireFiniteNumber$_(t), o._$RequireString$_(e), B.get(this)._$_SetItemText$_(t, e);
                }
                _$getItemText$_(t) {
                    return o._$RequireFiniteNumber$_(t), B.get(this)._$_GetItemText$_(t);
                }
                removeItem(t) {
                    o._$RequireFiniteNumber$_(t), B.get(this)._$_RemoveItem$_(t);
                }
                clear() {
                    B.get(this)._$_Clear$_();
                }
                get _$itemCount$_() {
                    return B.get(this)._$_GetItemCount$_();
                }
            };
        }
        {
            const va = self._$C3$_;
            va._$Plugins$_._$List$_._$Cnds$_ = {
                _$CompareSelection$_(t, e) {
                    return va.compare(this._$_selectedIndex$_, t, e);
                },
                _$OnSelectionChanged$_() {
                    return !0;
                },
                _$OnClicked$_() {
                    return !0;
                },
                _$OnDoubleClicked$_() {
                    return !0;
                },
                _$CompareSelectedText$_(t, e) {
                    const s = this._$_selectedIndex$_;
                    if (s < 0 || s >= this._$_items$_.length) return !1;
                    const i = this._$_items$_[s];
                    return e ? i === t : va._$equalsNoCase$_(i, t);
                },
                _$CompareTextAt$_(t, e, s) {
                    if ((t = Math.floor(t)) < 0 || t >= this._$_items$_.length) return !1;
                    const i = this._$_items$_[t];
                    return s ? i === e : va._$equalsNoCase$_(i, e);
                }
            };
        }
        {
            const Ga = self._$C3$_;
            Ga._$Plugins$_._$List$_._$Acts$_ = {
                _$Select$_(t) {
                    this._$_SetSelectedIndex$_(t);
                },
                _$SetTooltip$_(t) {
                    this._$_SetTooltip$_(t);
                },
                _$SetVisible$_(t) {
                    const e = this._$GetWorldInfo$_();
                    t = 0 !== t, e._$IsVisible$_() !== t && e._$SetVisible$_(t);
                },
                _$AddItem$_(t) {
                    this._$_AddItem$_(t);
                },
                _$AddItemAt$_(t, e) {
                    this._$_AddItemAt$_(t, e);
                },
                _$Remove$_(t) {
                    this._$_RemoveItem$_(t);
                },
                _$SetItemText$_(t, e) {
                    this._$_SetItemText$_(t, e);
                },
                _$Clear$_() {
                    this._$_Clear$_();
                }
            };
        }
        {
            const Ra = self._$C3$_;
            Ra._$Plugins$_._$List$_._$Exps$_ = {
                _$ItemCount$_() {
                    return this._$_GetItemCount$_();
                },
                _$ItemTextAt$_(t) {
                    return this._$_GetItemText$_(t);
                },
                _$SelectedIndex$_() {
                    return this._$_GetSelectedIndex$_();
                },
                _$SelectedText$_() {
                    return this._$_GetItemText$_(this._$_GetSelectedIndex$_());
                },
                _$SelectedCount$_() {
                    return this._$_GetSelectedCount$_();
                },
                _$SelectedIndexAt$_(t) {
                    return this._$_GetSelectedIndexAt$_(t);
                },
                _$SelectedTextAt$_(t) {
                    return this._$_GetSelectedTextAt$_(t);
                }
            };
        }
        {
            const a = self._$C3$_;
            a._$Plugins$_._$Tilemap$_ = class extends a._$SDKPluginBase$_ {
                constructor(t) {
                    super(t);
                }
                _$Release$_() {
                    super._$Release$_();
                }
            }, a._$Plugins$_._$Tilemap$_._$TILE_FLIPPED_HORIZONTAL$_ = -2147483648, 
            a._$Plugins$_._$Tilemap$_._$TILE_FLIPPED_VERTICAL$_ = 1073741824, a._$Plugins$_._$Tilemap$_._$TILE_FLIPPED_DIAGONAL$_ = 536870912, 
            a._$Plugins$_._$Tilemap$_._$TILE_FLAGS_MASK$_ = 3758096384, a._$Plugins$_._$Tilemap$_._$TILE_ID_MASK$_ = 536870911;
        }
        {
            const d = self._$C3$_, e = d._$Plugins$_._$Tilemap$_._$TILE_FLIPPED_HORIZONTAL$_, f = d._$Plugins$_._$Tilemap$_._$TILE_FLIPPED_VERTICAL$_, g = d._$Plugins$_._$Tilemap$_._$TILE_FLIPPED_DIAGONAL$_, h = d._$Plugins$_._$Tilemap$_._$TILE_ID_MASK$_;
            d._$Plugins$_._$Tilemap$_._$Type$_ = class extends d._$SDKTypeBase$_ {
                constructor(t) {
                    super(t), this._$_tilePolys$_ = [], this._$_areTilePolysCached$_ = !1, 
                    this._$_maxTileIndex$_ = 0, this._$_brushesData$_ = [], this._$_nameToIndexMap$_ = null;
                }
                _$Release$_() {
                    this._$_nameToIndexMap$_.clear(), this._$_nameToIndexMap$_ = null, 
                    super._$Release$_();
                }
                _$OnCreate$_() {
                    this._$GetImageInfo$_()._$LoadAsset$_(this._$_runtime$_);
                }
                _$LoadTextures$_(t) {
                    return this._$GetImageInfo$_()._$LoadStaticTexture$_(t, {
                        _$sampling$_: this._$_runtime$_._$GetSampling$_()
                    });
                }
                _$ReleaseTextures$_() {
                    this._$GetImageInfo$_()._$ReleaseTexture$_();
                }
                _$OnDynamicTextureLoadComplete$_() {
                    for (const t of this._$GetObjectClass$_()._$instancesIncludingPendingCreate$_()) t._$GetSdkInstance$_()._$_OnDynamicTextureLoadComplete$_();
                }
                _$LoadTilemapData$_(t, e, s) {
                    this._$_maxTileIndex$_ = e;
                    for (const i of t) if (i) {
                        const r = i[0], n = !!i[1];
                        this._$_tilePolys$_.push({
                            _$poly$_: r,
                            use: n,
                            _$flipmap$_: [ [ [ null, null ], [ null, null ] ], [ [ null, null ], [ null, null ] ] ]
                        });
                    } else this._$_tilePolys$_.push(null);
                    for (const h of s) {
                        const o = h[0], a = h[1], l = h[2];
                        this._$_brushesData$_.push({
                            name: o,
                            type: a,
                            _$tileData$_: l
                        });
                    }
                }
                _$_ForceCacheOfTileCollisionPolys$_(t, e) {
                    this._$_areTilePolysCached$_ = !1, this._$_MaybeCacheTileCollisionPolys$_(t, e);
                }
                _$_MaybeCacheTileCollisionPolys$_(s, i) {
                    if (!this._$_areTilePolysCached$_) {
                        this._$_areTilePolysCached$_ = !0;
                        for (let t = 0, e = this._$_tilePolys$_.length; t < e; ++t) this._$_tilePolys$_[t] && (this._$_CacheTilePoly$_(t, s, i, !1, !1, !1), 
                        this._$_CacheTilePoly$_(t, s, i, !1, !1, !0), this._$_CacheTilePoly$_(t, s, i, !1, !0, !1), 
                        this._$_CacheTilePoly$_(t, s, i, !1, !0, !0), this._$_CacheTilePoly$_(t, s, i, !0, !1, !1), 
                        this._$_CacheTilePoly$_(t, s, i, !0, !1, !0), this._$_CacheTilePoly$_(t, s, i, !0, !0, !1), 
                        this._$_CacheTilePoly$_(t, s, i, !0, !0, !0));
                    }
                }
                _$_CacheTilePoly$_(t, e, s, i, r, n) {
                    if (!(t < 0 || t >= this._$_tilePolys$_.length)) {
                        const h = this._$_tilePolys$_[t];
                        if (h) {
                            const o = d._$New$_(d._$CollisionPoly$_, h._$poly$_, h.use);
                            o.transform(e, s, 0), n && o._$diag$_(), i && o._$mirror$_(e / 2), 
                            r && o._$flip$_(s / 2), h._$flipmap$_[i ? 1 : 0][r ? 1 : 0][n ? 1 : 0] = null, 
                            h._$flipmap$_[i ? 1 : 0][r ? 1 : 0][n ? 1 : 0] = o;
                        }
                    }
                }
                _$GetTilePoly$_(t) {
                    if (-1 === t) return null;
                    const s = t & h;
                    if (s < 0 || s >= this._$_tilePolys$_.length) return null;
                    const i = this._$_tilePolys$_[s];
                    if (!i) return null;
                    const r = t & e ? 1 : 0, n = t & f ? 1 : 0, o = t & g ? 1 : 0;
                    return i._$flipmap$_[r][n][o];
                }
                _$IsTilePolyEnabled$_(t) {
                    return !t || t._$IsEnabled$_();
                }
                _$GetMaxTileIndex$_() {
                    return this._$_maxTileIndex$_;
                }
                _$GetBrushData$_(e) {
                    this._$_nameToIndexMap$_ || (this._$_nameToIndexMap$_ = new Map());
                    const t = this._$_nameToIndexMap$_.get(e);
                    if ("number" == typeof t && 0 <= t) return this._$_brushesData$_[t];
                    for (let t = 0; t < this._$_brushesData$_.length; t++) if (this._$_brushesData$_[t].name === e) return this._$_nameToIndexMap$_.set(e, t), 
                    this._$_brushesData$_[t];
                }
            };
        }
        {
            let RunLengthDecode2 = function(t) {
                const i = [], s = t.split(",");
                for (let t = 0, e = s.length; t < e; ++t) {
                    const r = s[t], n = r.indexOf("x");
                    if (-1 < n) {
                        let t = parseInt(r.substring(0, n), 10), e = r.substring(n + 1), s = parseInt(e, 10);
                        for (e.includes("h") && (s |= ba), e.includes("v") && (s |= ca), 
                        e.includes("d") && (s |= da); 0 < t; --t) i.push(s);
                    } else {
                        let t = parseInt(r, 10);
                        r.includes("h") && (t |= ba), r.includes("v") && (t |= ca), 
                        r.includes("d") && (t |= da), i.push(t);
                    }
                }
                return i;
            };
            RunLengthDecode = RunLengthDecode2;
            const U = self._$C3$_, V = self._$C3X$_, W = 0, X = 1, Y = 2, Z = 3, $ = 4, _ = 5, aa = 6, ba = U._$Plugins$_._$Tilemap$_._$TILE_FLIPPED_HORIZONTAL$_, ca = U._$Plugins$_._$Tilemap$_._$TILE_FLIPPED_VERTICAL$_, da = U._$Plugins$_._$Tilemap$_._$TILE_FLIPPED_DIAGONAL$_, ea = U._$Plugins$_._$Tilemap$_._$TILE_FLAGS_MASK$_, fa = U._$Plugins$_._$Tilemap$_._$TILE_ID_MASK$_, ga = U._$New$_(U.Rect), ha = U._$New$_(U.Rect), ia = U._$New$_(U.Rect), ja = (U._$Plugins$_._$Tilemap$_.Instance = class extends U._$SDKWorldInstanceBase$_ {
                constructor(t, e) {
                    super(t);
                    const s = this._$GetWorldInfo$_();
                    this._$_tileWidth$_ = 32, this._$_tileHeight$_ = 32, this._$_tileXoffset$_ = 0, 
                    this._$_tileYoffset$_ = 0, this._$_tileXspacing$_ = 0, this._$_tileYspacing$_ = 0, 
                    this._$_mapWidth$_ = 0, this._$_mapHeight$_ = 0, this._$_lastWidth$_ = s._$GetWidth$_(), 
                    this._$_lastHeight$_ = s._$GetHeight$_(), this._$_cellWidth$_ = 0, 
                    this._$_cellHeight$_ = 0, this._$_tileCells$_ = [], this._$_tileTexQuads$_ = new Map(), 
                    this._$_isAnyQuadMapChanged$_ = !0, this._$_ownImageInfo$_ = null, 
                    e && (s._$SetVisible$_(e[W]), this._$_tileWidth$_ = Math.max(e[X], 1), 
                    this._$_tileHeight$_ = Math.max(e[Y], 1), this._$_tileXoffset$_ = e[Z], 
                    this._$_tileYoffset$_ = e[$], this._$_tileXspacing$_ = e[_], 
                    this._$_tileYspacing$_ = e[aa]), this._$_cellWidth$_ = Math.ceil(this._$_runtime$_._$GetOriginalViewportWidth$_() / this._$_tileWidth$_), 
                    this._$_cellHeight$_ = Math.ceil(this._$_runtime$_._$GetOriginalViewportHeight$_() / this._$_tileHeight$_), 
                    this._$_sdkType$_._$_MaybeCacheTileCollisionPolys$_(this._$_tileWidth$_, this._$_tileHeight$_), 
                    this._$_autoTiling$_ = null;
                }
                _$Release$_() {
                    this._$_ReleaseOwnImage$_(), U._$clearArray$_(this._$_tileCells$_), 
                    this._$_tileCells$_ = null, this._$_tileTexQuads$_.clear(), 
                    this._$_tileTexQuads$_ = null, super._$Release$_();
                }
                _$_ReleaseOwnImage$_() {
                    this._$_ownImageInfo$_ && (this._$_ownImageInfo$_._$Release$_(), 
                    this._$_ownImageInfo$_ = null);
                }
                _$LoadTilemapData$_(t, e, s) {
                    this._$_mapWidth$_ = e, this._$_mapHeight$_ = s, this._$_MaybeResizeTilemap$_(!0), 
                    this._$SetTilesFromRLECSV$_(t), this._$_MaybeBuildAllQuadMap$_();
                }
                _$_MaybeResizeTilemap$_(t) {
                    const [ e, r ] = this._$GetMapDisplaySize$_();
                    if (!(e <= this._$_mapWidth$_ && r <= this._$_mapHeight$_) || t) {
                        let s = 0, i = 0;
                        t ? (s = Math.ceil(this._$_mapHeight$_ / this._$_cellHeight$_), 
                        i = Math.ceil(this._$_mapWidth$_ / this._$_cellWidth$_)) : (s = this._$_tileCells$_.length, 
                        i = Math.ceil(this._$_mapWidth$_ / this._$_cellWidth$_), 
                        r > this._$_mapHeight$_ && (this._$_mapHeight$_ = r, s = Math.ceil(this._$_mapHeight$_ / this._$_cellHeight$_)), 
                        e > this._$_mapWidth$_ && (this._$_mapWidth$_ = e, i = Math.ceil(this._$_mapWidth$_ / this._$_cellWidth$_)), 
                        this._$_SetAllQuadMapChanged$_(), this._$_SetPhysicsChanged$_(), 
                        this._$_runtime$_._$UpdateRender$_());
                        const n = this._$_tileCells$_;
                        if (n.length < s) for (let t = n.length; t < s; ++t) n.push([]);
                        for (let e = 0; e < s; ++e) {
                            const h = n[e];
                            for (let t = h.length; t < i; ++t) h.push(U._$New$_(U._$Plugins$_._$Tilemap$_._$TileCell$_, this, t, e));
                        }
                    }
                }
                _$SetTilesFromRLECSV$_(t) {
                    let s = RunLengthDecode2(t), i = 0, r = this._$_mapWidth$_, n = this._$_cellWidth$_, h = this._$_cellHeight$_;
                    for (let e = 0, t = this._$_mapHeight$_; e < t; ++e) for (let t = 0; t < r; ++t) {
                        const o = s[i++], a = this._$GetCellAt$_(t, e);
                        a && a._$SetTileAt$_(t % n, e % h, o);
                    }
                }
                _$GetTilesAsRLECSV$_() {
                    let l = "";
                    if (!(this._$_mapWidth$_ <= 0 || this._$_mapHeight$_ <= 0)) {
                        let s = 1, i = this._$GetTileAt$_(0, 0), [ r, t ] = this._$GetMapDisplaySize$_(), n = -1, h = !1, o = !1, a = !1;
                        for (let e = 0; e < t; ++e) for (let t = 0 === e ? 1 : 0; t < r; ++t) {
                            const u = this._$GetTileAt$_(t, e);
                            u === i ? ++s : (a = -1 === i ? (n = -1, h = !1, o = !1) : (n = i & fa, 
                            h = 0 != (i & ba), o = 0 != (i & ca), 0 != (i & da)), 
                            1 === s ? l += "" + n : l += s + "x" + n, h && (l += "h"), 
                            o && (l += "v"), a && (l += "d"), l += ",", s = 1, i = u);
                        }
                        a = -1 === i ? (n = -1, h = !1, o = !1) : (n = i & fa, h = 0 != (i & ba), 
                        o = 0 != (i & ca), 0 != (i & da)), 1 === s ? l += "" + n : l += s + "x" + n, 
                        h && (l += "h"), o && (l += "v"), a && (l += "d");
                    }
                    return l;
                }
                _$_SetAllQuadMapChanged$_() {
                    const s = this._$_tileCells$_;
                    for (let t = 0, e = s.length; t < e; ++t) {
                        const i = s[t];
                        for (let t = 0, e = i.length; t < e; ++t) i[t]._$_SetQuadMapChanged$_();
                    }
                    this._$_isAnyQuadMapChanged$_ = !0;
                }
                _$_MaybeBuildAllQuadMap$_() {
                    if (this._$_isAnyQuadMapChanged$_) {
                        this._$_isAnyQuadMapChanged$_ = !1;
                        const s = this._$_tileCells$_;
                        for (let t = 0, e = s.length; t < e; ++t) {
                            const i = s[t];
                            for (let t = 0, e = i.length; t < e; ++t) i[t]._$MaybeBuildQuadMap$_();
                        }
                    }
                }
                _$SetTileChanged$_() {
                    this._$_isAnyQuadMapChanged$_ = !0, this._$_SetPhysicsChanged$_(), 
                    this._$_runtime$_._$UpdateRender$_();
                }
                _$_SetPhysicsChanged$_() {
                    this._$GetWorldInfo$_()._$SetPhysicsBodyChanged$_(!0);
                }
                _$GetCellAt$_(t, e) {
                    if (t < 0 || e < 0) return null;
                    const s = Math.floor(e / this._$_cellHeight$_);
                    if (s >= this._$_tileCells$_.length) return null;
                    const i = this._$_tileCells$_[s], r = Math.floor(t / this._$_cellWidth$_);
                    return r >= i.length ? null : i[r];
                }
                _$GetCellAtIndex$_(t, e) {
                    if (t < 0 || e < 0 || e >= this._$_tileCells$_.length) return null;
                    const s = this._$_tileCells$_[e];
                    return t >= s.length ? null : s[t];
                }
                _$GetTileAt$_(t, e) {
                    if (t = Math.floor(t), e = Math.floor(e), t < 0 || e < 0 || t >= this._$_mapWidth$_ || e >= this._$_mapHeight$_) return -1;
                    const s = this._$GetCellAt$_(t, e);
                    return s ? s._$GetTilesArr$_()[e % this._$_cellHeight$_][t % this._$_cellWidth$_] : -1;
                }
                _$SetTileAt$_(t, e, s) {
                    if (t = Math.floor(t), e = Math.floor(e), !(t < 0 || e < 0 || t >= this._$_mapWidth$_ || e >= this._$_mapHeight$_ || -1 !== s && (s & fa) > this._$GetMaxTileIndex$_())) {
                        const i = this._$GetCellAt$_(t, e);
                        i && i._$SetTileAt$_(t % this._$_cellWidth$_, e % this._$_cellHeight$_, s);
                    }
                }
                _$GetMaxTileIndex$_() {
                    return this._$_sdkType$_._$GetMaxTileIndex$_();
                }
                _$WorldToCellX$_(t) {
                    return Math.floor((t - this._$GetWorldInfo$_()._$GetX$_()) / (this._$_cellWidth$_ * this._$_tileWidth$_));
                }
                _$WorldToCellY$_(t) {
                    return Math.floor((t - this._$GetWorldInfo$_()._$GetY$_()) / (this._$_cellHeight$_ * this._$_tileHeight$_));
                }
                _$WorldToTileX$_(t) {
                    return Math.floor((t - this._$GetWorldInfo$_()._$GetX$_()) / this._$_tileWidth$_);
                }
                _$WorldToTileY$_(t) {
                    return Math.floor((t - this._$GetWorldInfo$_()._$GetY$_()) / this._$_tileHeight$_);
                }
                _$GetMapWidth$_() {
                    return this._$_mapWidth$_;
                }
                _$GetMapHeight$_() {
                    return this._$_mapHeight$_;
                }
                _$GetMapDisplayWidth$_() {
                    return Math.floor(this._$GetWorldInfo$_()._$GetWidth$_() / this._$GetTileWidth$_());
                }
                _$GetMapDisplayHeight$_() {
                    return Math.floor(this._$GetWorldInfo$_()._$GetHeight$_() / this._$GetTileHeight$_());
                }
                _$GetMapDisplaySize$_() {
                    const t = this._$GetWorldInfo$_();
                    return [ Math.floor(t._$GetWidth$_() / this._$GetTileWidth$_()), Math.floor(t._$GetHeight$_() / this._$GetTileHeight$_()) ];
                }
                _$GetTileWidth$_() {
                    return this._$_tileWidth$_;
                }
                _$GetTileHeight$_() {
                    return this._$_tileHeight$_;
                }
                _$GetCellWidth$_() {
                    return this._$_cellWidth$_;
                }
                _$GetCellHeight$_() {
                    return this._$_cellHeight$_;
                }
                _$GetCollisionRectCandidates$_(t, s) {
                    const i = this._$WorldToCellX$_(t._$getLeft$_()), r = this._$WorldToCellY$_(t._$getTop$_()), n = this._$WorldToCellX$_(t._$getRight$_()), h = this._$WorldToCellY$_(t._$getBottom$_());
                    for (let e = i; e <= n; ++e) for (let t = r; t <= h; ++t) {
                        const o = this._$GetCellAtIndex$_(e, t);
                        o && (o._$MaybeBuildQuadMap$_(), U._$appendArray$_(s, o._$GetCollisionRects$_()));
                    }
                }
                _$TestPointOverlapTile$_(t, e) {
                    const s = this._$WorldToTileX$_(t), i = this._$WorldToTileY$_(e), r = this._$GetTileAt$_(s, i);
                    if (-1 === r) return !1;
                    const n = this._$_sdkType$_._$GetTilePoly$_(r);
                    if (!n) return !0;
                    if (!this._$_sdkType$_._$IsTilePolyEnabled$_(n)) return !1;
                    const h = this._$GetWorldInfo$_(), o = Math.floor((t - h._$GetX$_()) / this._$_tileWidth$_) * this._$_tileWidth$_ + h._$GetX$_(), a = Math.floor((e - h._$GetY$_()) / this._$_tileHeight$_) * this._$_tileHeight$_ + h._$GetY$_();
                    return t -= o, e -= a, n._$containsPoint$_(t, e);
                }
                _$GetAllCollisionRects$_(s) {
                    const i = this._$_tileCells$_;
                    for (let t = 0, e = i.length; t < e; ++t) {
                        const r = i[t];
                        for (let t = 0, e = r.length; t < e; ++t) {
                            const n = r[t];
                            n._$MaybeBuildQuadMap$_(), U._$appendArray$_(s, n._$GetCollisionRects$_());
                        }
                    }
                }
                _$GetCurrentImageInfo$_() {
                    return this._$_ownImageInfo$_ || this._$_objectClass$_._$GetImageInfo$_();
                }
                _$GetTileUvQuad$_(t) {
                    const e = this._$_tileTexQuads$_, s = e.get(t);
                    if (s) return s;
                    const i = t & fa, r = 0 != (t & ba), n = 0 != (t & ca), h = 0 != (t & da), o = this._$GetCurrentImageInfo$_(), a = o._$GetWidth$_(), l = this._$_tileWidth$_, u = this._$_tileXoffset$_, c = this._$_tileXspacing$_, f = Math.floor((a - u) / (l + c) * l) + c, d = Math.floor(f / l), p = i % d, m = Math.floor(i / d), C = o._$GetOffsetX$_() + this._$_tileXoffset$_ + (this._$_tileWidth$_ + this._$_tileXspacing$_) * p, g = o._$GetOffsetY$_() + this._$_tileYoffset$_ + (this._$_tileHeight$_ + this._$_tileYspacing$_) * m, S = (ga._$setWH$_(C, g, this._$_tileWidth$_, this._$_tileHeight$_), 
                    ga._$divide$_(o._$GetSheetWidth$_(), o._$GetSheetHeight$_()), 
                    U._$New$_(U._$Quad$_));
                    return S._$setFromRect$_(ga), h && S._$diag$_(), r && S._$mirror$_(), 
                    n && S._$flip$_(), S.offset(p, m), e.set(t, S), S;
                }
                _$_OnDynamicTextureLoadComplete$_() {
                    this._$_tileTexQuads$_.clear(), this._$_SetAllQuadMapChanged$_();
                }
                _$Draw$_(r) {
                    const t = this._$GetCurrentImageInfo$_(), e = t._$GetTexture$_();
                    if (e) {
                        ga._$copy$_(t._$GetTexRect$_()), ga.offsetLeft(this._$_tileXoffset$_ / e._$GetWidth$_()), 
                        ga.offsetTop(this._$_tileYoffset$_ / e._$GetHeight$_()), 
                        r._$SetTilemapFillMode$_(), r._$SetTilemapInfo$_(ga, e._$GetWidth$_(), e._$GetHeight$_(), this._$_tileWidth$_, this._$_tileHeight$_, this._$_tileXspacing$_, this._$_tileYspacing$_), 
                        r._$SetTexture$_(e);
                        const n = this._$GetWorldInfo$_(), h = n._$GetLayer$_();
                        n._$GetWidth$_() === this._$_lastWidth$_ && n._$GetHeight$_() === this._$_lastHeight$_ || (this._$_SetPhysicsChanged$_(), 
                        this._$_SetAllQuadMapChanged$_(), this._$_lastWidth$_ = n._$GetWidth$_(), 
                        this._$_lastHeight$_ = n._$GetHeight$_());
                        let s = n._$GetX$_(), i = n._$GetY$_();
                        this._$_runtime$_._$IsPixelRoundingEnabled$_() && (s = Math.round(s), 
                        i = Math.round(i));
                        const o = this._$_cellWidth$_ * this._$_tileWidth$_, a = this._$_cellHeight$_ * this._$_tileHeight$_, l = n._$GetTotalZElevation$_(), u = ha;
                        if (h._$Has3DCamera$_()) {
                            u.set(-1 / 0, -1 / 0, 1 / 0, 1 / 0);
                            const c = ia, f = h._$_GetViewFrustum$_();
                            for (const d of this._$_tileCells$_) for (const p of d) p._$GetLayoutRect$_(c), 
                            f._$ContainsAABB$_(c._$getLeft$_(), c._$getTop$_(), l, c._$getRight$_(), c._$getBottom$_(), l) && (p._$MaybeBuildQuadMap$_(), 
                            p._$Draw$_(r, u, s, i));
                        } else {
                            h._$GetViewportForZ$_(l, u);
                            const m = Math.floor((u._$getLeft$_() - s) / o), C = Math.floor((u._$getRight$_() - s) / o), g = Math.floor((u._$getTop$_() - i) / a), S = Math.floor((u._$getBottom$_() - i) / a);
                            for (let e = m; e <= C; ++e) for (let t = g; t <= S; ++t) {
                                const _ = this._$GetCellAtIndex$_(e, t);
                                _ && (_._$MaybeBuildQuadMap$_(), _._$Draw$_(r, u, s, i));
                            }
                        }
                    }
                }
                _$SaveToJson$_() {
                    this._$_MaybeResizeTilemap$_();
                    const [ t, e ] = this._$GetMapDisplaySize$_();
                    return {
                        tw: this._$_tileWidth$_,
                        th: this._$_tileHeight$_,
                        tox: this._$_tileXoffset$_,
                        toy: this._$_tileYoffset$_,
                        tsx: this._$_tileXspacing$_,
                        tsy: this._$_tileYspacing$_,
                        w: t,
                        h: e,
                        d: this._$GetTilesAsRLECSV$_()
                    };
                }
                _$LoadFromJson$_(t) {
                    this._$_tileWidth$_ = t.tw, this._$_tileHeight$_ = t.th, this._$_tileXoffset$_ = t.tox, 
                    this._$_tileYoffset$_ = t.toy, this._$_tileXspacing$_ = t.tsx, 
                    this._$_tileYspacing$_ = t.tsy, this._$_mapWidth$_ = t.w, this._$_mapHeight$_ = t.h, 
                    this._$_MaybeResizeTilemap$_(!0), this._$SetTilesFromRLECSV$_(t.d), 
                    this._$_SetPhysicsChanged$_(), this._$_SetAllQuadMapChanged$_();
                }
                _$GetAsJsonString$_() {
                    this._$_MaybeResizeTilemap$_();
                    const [ t, e ] = this._$GetMapDisplaySize$_();
                    return JSON.stringify({
                        c2tilemap: !0,
                        width: t,
                        height: e,
                        data: this._$GetTilesAsRLECSV$_()
                    });
                }
                _$StateComboToFlags$_(t) {
                    switch (t) {
                      case 0:
                        return 0;

                      case 1:
                        return ba;

                      case 2:
                        return ca;

                      case 3:
                        return ba | da;

                      case 4:
                        return ba | ca;

                      case 5:
                        return ca | da;

                      case 6:
                        return ba | ca | da;

                      case 7:
                        return da;

                      default:
                        return 0;
                    }
                }
                _$GetPropertyValueByIndex$_(t) {
                    switch (t) {
                      case X:
                        return this._$_tileWidth$_;

                      case Y:
                        return this._$_tileHeight$_;

                      case Z:
                        return this._$_tileXoffset$_;

                      case $:
                        return this._$_tileYoffset$_;

                      case _:
                        return this._$_tileXspacing$_;

                      case aa:
                        return this._$_tileYspacing$_;
                    }
                }
                _$SetPropertyValueByIndex$_(t, e) {
                    switch (t) {
                      case X:
                        this._$_tileWidth$_ !== e && (this._$_tileWidth$_ = Math.max(e, 1), 
                        this._$_cellWidth$_ = Math.ceil(this._$_runtime$_._$GetOriginalViewportWidth$_() / this._$_tileWidth$_), 
                        this._$_sdkType$_._$_ForceCacheOfTileCollisionPolys$_(), 
                        this._$_UpdateQuadMaps$_());
                        break;

                      case Y:
                        this._$_tileHeight$_ !== e && (this._$_tileHeight$_ = Math.max(e, 1), 
                        this._$_cellHeight$_ = Math.ceil(this._$_runtime$_._$GetOriginalViewportHeight$_() / this._$_tileHeight$_), 
                        this._$_sdkType$_._$_ForceCacheOfTileCollisionPolys$_(), 
                        this._$_UpdateQuadMaps$_());
                        break;

                      case Z:
                        this._$_tileXoffset$_ !== e && (this._$_tileXoffset$_ = e, 
                        this._$_UpdateQuadMaps$_());
                        break;

                      case $:
                        this._$_tileYoffset$_ !== e && (this._$_tileYoffset$_ = e, 
                        this._$_UpdateQuadMaps$_());
                        break;

                      case _:
                        this._$_tileXspacing$_ !== e && (this._$_tileXspacing$_ = e, 
                        this._$_UpdateQuadMaps$_());
                        break;

                      case aa:
                        this._$_tileYspacing$_ !== e && (this._$_tileYspacing$_ = e, 
                        this._$_UpdateQuadMaps$_());
                    }
                }
                _$_UpdateQuadMaps$_() {
                    this._$_tileTexQuads$_.clear(), this._$_SetAllQuadMapChanged$_(), 
                    this._$_MaybeBuildAllQuadMap$_();
                }
                _$GetScriptInterfaceClass$_() {
                    return ka;
                }
            }, new WeakMap()), ka = self._$ITilemapInstance$_ = class extends self._$IWorldInstance$_ {
                constructor() {
                    super(), ja.set(this, self._$IInstance$_._$_GetInitInst$_()._$GetSdkInstance$_());
                }
                get _$mapWidth$_() {
                    return ja.get(this)._$GetMapWidth$_();
                }
                get _$mapHeight$_() {
                    return ja.get(this)._$GetMapHeight$_();
                }
                _$getMapSize$_() {
                    const t = ja.get(this);
                    return [ t._$GetMapWidth$_(), t._$GetMapHeight$_() ];
                }
                get _$mapDisplayWidth$_() {
                    return ja.get(this)._$GetMapDisplayWidth$_();
                }
                get _$mapDisplayHeight$_() {
                    return ja.get(this)._$GetMapDisplayHeight$_();
                }
                _$getMapDisplaySize$_() {
                    const t = ja.get(this);
                    return [ t._$GetMapDisplayWidth$_(), t._$GetMapDisplayHeight$_() ];
                }
                get _$tileWidth$_() {
                    return ja.get(this)._$GetTileWidth$_();
                }
                get _$tileHeight$_() {
                    return ja.get(this)._$GetTileHeight$_();
                }
                _$getTileSize$_() {
                    const t = ja.get(this);
                    return [ t._$GetTileWidth$_(), t._$GetTileHeight$_() ];
                }
                _$getTileAt$_(t, e) {
                    return V._$RequireFiniteNumber$_(t), V._$RequireFiniteNumber$_(e), 
                    ja.get(this)._$GetTileAt$_(t, e);
                }
                _$setTileAt$_(t, e, s) {
                    V._$RequireFiniteNumber$_(t), V._$RequireFiniteNumber$_(e), 
                    V._$RequireFiniteNumber$_(s);
                    const i = ja.get(this);
                    i._$_MaybeResizeTilemap$_(), i._$SetTileAt$_(t, e, s);
                }
                async _$replaceImage$_(t) {
                    V._$RequireInstanceOf$_(t, Blob);
                    const e = ja.get(this), s = e._$GetRuntime$_(), i = U._$New$_(U._$ImageInfo$_);
                    i._$LoadDynamicBlobAsset$_(s, t), await i._$LoadStaticTexture$_(s._$GetRenderer$_(), {
                        _$sampling$_: s._$GetSampling$_()
                    }), e._$WasReleased$_() ? i._$Release$_() : (e._$_ReleaseOwnImage$_(), 
                    e._$_ownImageInfo$_ = i, e._$_tileTexQuads$_.clear(), e._$_SetAllQuadMapChanged$_(), 
                    s._$UpdateRender$_());
                }
            };
            ka._$TILE_FLIPPED_HORIZONTAL$_ = ba, ka._$TILE_FLIPPED_VERTICAL$_ = ca, 
            ka._$TILE_FLIPPED_DIAGONAL$_ = da, ka._$TILE_FLAGS_MASK$_ = ea, ka._$TILE_ID_MASK$_ = fa;
        }
        {
            const w1 = self._$C3$_, x1 = w1._$Plugins$_._$Tilemap$_._$TILE_FLAGS_MASK$_, y1 = w1._$Plugins$_._$Tilemap$_._$TILE_ID_MASK$_;
            w1._$Plugins$_._$Tilemap$_._$Cnds$_ = {
                _$CompareTileAt$_(t, e, s, i) {
                    let r = this._$GetTileAt$_(t, e);
                    return -1 !== r && (r &= y1), w1.compare(r, s, i);
                },
                _$CompareTileStateAt$_(t, e, s) {
                    let i = this._$GetTileAt$_(t, e);
                    return (-1 !== i ? i & x1 : 0) === this._$StateComboToFlags$_(s);
                },
                _$OnURLLoaded$_() {
                    return !0;
                },
                _$OnURLFailed$_() {
                    return !0;
                },
                _$BrushExists$_(t) {
                    return this._$_autoTiling$_ || (this._$_autoTiling$_ = new w1._$Plugins$_._$Tilemap$_._$AutoTiling$_(this, this._$_sdkType$_)), 
                    this._$_autoTiling$_._$BrushExists$_(t);
                }
            };
        }
        {
            const K1 = self._$C3$_, L1 = K1._$Plugins$_._$Tilemap$_._$TILE_ID_MASK$_;
            K1._$Plugins$_._$Tilemap$_._$Acts$_ = {
                _$EraseTile$_(t, e) {
                    this._$_MaybeResizeTilemap$_(), this._$SetTileAt$_(t, e, -1);
                },
                _$SetTile$_(t, e, s, i) {
                    this._$_MaybeResizeTilemap$_(), this._$SetTileAt$_(t, e, s & L1 | this._$StateComboToFlags$_(i));
                },
                _$SetTileState$_(t, e, s) {
                    const i = this._$GetTileAt$_(t, e);
                    -1 !== i && (this._$_MaybeResizeTilemap$_(), this._$SetTileAt$_(t, e, i & L1 | this._$StateComboToFlags$_(s)));
                },
                _$EraseTileRange$_(t, e, s, i) {
                    const r = Math.floor(Math.max(t, 0)), n = Math.floor(Math.max(e, 0)), h = Math.floor(Math.min(t + s, this._$_mapWidth$_)), o = Math.floor(Math.min(e + i, this._$_mapHeight$_));
                    for (let e = n; e < o; ++e) for (let t = r; t < h; ++t) this._$SetTileAt$_(t, e, -1);
                },
                _$SetTileRange$_(t, e, s, i, r, n) {
                    this._$_MaybeResizeTilemap$_();
                    const h = Math.floor(Math.max(t, 0)), o = Math.floor(Math.max(e, 0)), a = Math.floor(Math.min(t + s, this._$_mapWidth$_)), l = Math.floor(Math.min(e + i, this._$_mapHeight$_)), u = r & L1 | this._$StateComboToFlags$_(n);
                    for (let e = o; e < l; ++e) for (let t = h; t < a; ++t) this._$SetTileAt$_(t, e, u);
                },
                _$SetTileStateRange$_(t, e, s, i, r) {
                    this._$_MaybeResizeTilemap$_();
                    const n = Math.floor(Math.max(t, 0)), h = Math.floor(Math.max(e, 0)), o = Math.floor(Math.min(t + s, this._$_mapWidth$_)), a = Math.floor(Math.min(e + i, this._$_mapHeight$_)), l = this._$StateComboToFlags$_(r);
                    for (let e = h; e < a; ++e) for (let t = n; t < o; ++t) {
                        const u = this._$GetTileAt$_(t, e);
                        -1 !== u && this._$SetTileAt$_(t, e, u & L1 | l);
                    }
                },
                _$LoadFromJSON$_(t) {
                    let e = null;
                    try {
                        e = JSON.parse(t);
                    } catch (t) {
                        return void console.error("[Construct] Failed to parse tilemap JSON: ", t);
                    }
                    e.c2tilemap ? (this._$_mapWidth$_ = e.width, this._$_mapHeight$_ = e.height, 
                    this._$_MaybeResizeTilemap$_(!0), this._$SetTilesFromRLECSV$_(e.data), 
                    this._$_SetAllQuadMapChanged$_(), this._$_SetPhysicsChanged$_()) : console.error("[Construct] Unrecognized JSON data format");
                },
                _$JSONDownload$_(t) {
                    const e = URL.createObjectURL(new Blob([ this._$GetAsJsonString$_() ], {
                        type: "application/json"
                    }));
                    this._$_runtime$_._$InvokeDownload$_(e, t);
                },
                async _$LoadURL$_(t, e) {
                    if (!this._$_ownImageInfo$_ || this._$_ownImageInfo$_._$GetURL$_() !== t) {
                        const s = this._$_runtime$_, i = K1._$New$_(K1._$ImageInfo$_);
                        try {
                            if (await i._$LoadDynamicAsset$_(s, t), !i._$IsLoaded$_()) throw new Error("image failed to load");
                            if (this._$WasReleased$_()) return i._$Release$_(), 
                            null;
                            const r = await i._$LoadStaticTexture$_(s._$GetRenderer$_(), {
                                _$sampling$_: s._$GetSampling$_()
                            });
                            if (!r) return;
                        } catch (t) {
                            return console.error("Load image from URL failed: ", t), 
                            void (this._$WasReleased$_() || this._$Trigger$_(K1._$Plugins$_._$Tilemap$_._$Cnds$_._$OnURLFailed$_));
                        }
                        this._$WasReleased$_() ? i._$Release$_() : (this._$_ReleaseOwnImage$_(), 
                        this._$_ownImageInfo$_ = i, s._$UpdateRender$_(), this._$_tileTexQuads$_.clear(), 
                        this._$_SetAllQuadMapChanged$_(), await this._$TriggerAsync$_(K1._$Plugins$_._$Tilemap$_._$Cnds$_._$OnURLLoaded$_));
                    }
                },
                _$SetEffect$_(t) {
                    2 <= t && t++, this._$GetWorldInfo$_()._$SetBlendMode$_(t), 
                    this._$_runtime$_._$UpdateRender$_();
                },
                _$SetTileWithBrush$_(t, e, s) {
                    this._$_MaybeResizeTilemap$_(), this._$_autoTiling$_ || (this._$_autoTiling$_ = new K1._$Plugins$_._$Tilemap$_._$AutoTiling$_(this, this._$_sdkType$_)), 
                    this._$_autoTiling$_._$SetAutoTile$_(t, e, s);
                },
                _$EraseTileWithBrush$_(t, e, s) {
                    this._$_MaybeResizeTilemap$_(), this._$_autoTiling$_ || (this._$_autoTiling$_ = new K1._$Plugins$_._$Tilemap$_._$AutoTiling$_(this, this._$_sdkType$_)), 
                    this._$_autoTiling$_._$EraseAutoTile$_(t, e, s);
                },
                _$SetTileWithBrushByName$_(t, e, s) {
                    K1._$Plugins$_._$Tilemap$_._$Acts$_._$SetTileWithBrush$_.call(this, t, e, s);
                },
                _$EraseTileWithBrushByName$_(t, e, s) {
                    K1._$Plugins$_._$Tilemap$_._$Acts$_._$EraseTileWithBrush$_.call(this, t, e, s);
                }
            };
        }
        {
            const a2 = self._$C3$_, b2 = a2._$Plugins$_._$Tilemap$_._$TILE_ID_MASK$_;
            a2._$Plugins$_._$Tilemap$_._$Exps$_ = {
                _$TileAt$_(t, e) {
                    const s = this._$GetTileAt$_(t, e);
                    return -1 === s ? -1 : s & b2;
                },
                _$PositionToTileX$_(t) {
                    return this._$WorldToTileX$_(t);
                },
                _$PositionToTileY$_(t) {
                    return this._$WorldToTileY$_(t);
                },
                _$TileToPositionX$_(t) {
                    return t * this._$_tileWidth$_ + this._$GetWorldInfo$_()._$GetX$_() + this._$_tileWidth$_ / 2;
                },
                _$TileToPositionY$_(t) {
                    return t * this._$_tileHeight$_ + this._$GetWorldInfo$_()._$GetY$_() + this._$_tileHeight$_ / 2;
                },
                _$SnapX$_(t) {
                    const e = this._$GetWorldInfo$_()._$GetX$_();
                    return Math.floor((t - e) / this._$_tileWidth$_) * this._$_tileWidth$_ + e + this._$_tileWidth$_ / 2;
                },
                _$SnapY$_(t) {
                    const e = this._$GetWorldInfo$_()._$GetY$_();
                    return Math.floor((t - e) / this._$_tileHeight$_) * this._$_tileHeight$_ + e + this._$_tileHeight$_ / 2;
                },
                _$TilesJSON$_() {
                    return this._$GetAsJsonString$_();
                },
                _$TileWidth$_() {
                    return this._$GetTileWidth$_();
                },
                _$TileHeight$_() {
                    return this._$GetTileHeight$_();
                },
                _$MapDisplayWidth$_() {
                    return this._$GetMapDisplayWidth$_();
                },
                _$MapDisplayHeight$_() {
                    return this._$GetMapDisplayHeight$_();
                }
            };
        }
        {
            const C33 = self._$C3$_, TILE_FLIPPED_HORIZONTAL = C33._$Plugins$_._$Tilemap$_._$TILE_FLIPPED_HORIZONTAL$_, TILE_FLIPPED_VERTICAL = C33._$Plugins$_._$Tilemap$_._$TILE_FLIPPED_VERTICAL$_, TILE_FLIPPED_DIAGONAL = C33._$Plugins$_._$Tilemap$_._$TILE_FLIPPED_DIAGONAL$_, TILE_ID_MASK = C33._$Plugins$_._$Tilemap$_._$TILE_ID_MASK$_, tempRect = C33._$New$_(C33.Rect), tempQuad = C33._$New$_(C33._$Quad$_);
            C33._$Plugins$_._$Tilemap$_._$TileQuad$_ = class extends C33._$DefendedBase$_ {
                constructor() {
                    super(), this._$_id$_ = -1, this._$_tileId$_ = -1, this._$_isHorizFlip$_ = !1, 
                    this._$_isVertFlip$_ = !1, this._$_isDiagFlip$_ = !1, this._$_rc$_ = C33._$New$_(C33.Rect), 
                    this._$_uv$_ = null;
                }
                _$Update$_(t, e, s, i, r, n, h, o) {
                    this._$_id$_ = t, this._$_tileId$_ = t & TILE_ID_MASK, this._$_isHorizFlip$_ = 0 != (t & TILE_FLIPPED_HORIZONTAL), 
                    this._$_isVertFlip$_ = 0 != (t & TILE_FLIPPED_VERTICAL), this._$_isDiagFlip$_ = 0 != (t & TILE_FLIPPED_DIAGONAL), 
                    this._$_rc$_._$setWH$_(i * e + n, r * s + h, e, s), this._$_uv$_ = o._$GetTileUvQuad$_(this._$_id$_);
                }
                _$Draw$_(t, e, s, i, r) {
                    tempRect._$copy$_(this._$_rc$_), tempRect.offset(s, i), tempRect._$intersectsRect$_(e) && (tempQuad._$setFromRect$_(tempRect), 
                    t._$Quad4$_(tempQuad, this._$_uv$_));
                }
            };
        }
        {
            const C33 = self._$C3$_;
            C33._$Plugins$_._$Tilemap$_._$TileCollisionRect$_ = class extends C33._$DefendedBase$_ {
                constructor() {
                    super(), this._$_id$_ = -1, this._$_poly$_ = null, this._$_rc$_ = C33._$New$_(C33.Rect);
                }
                _$Update$_(t, e, s, i, r, n, h, o) {
                    this._$_id$_ = t, this._$_poly$_ = e, this._$_rc$_._$setWH$_(r * s + h, n * i + o, s, i);
                }
                _$ExtendRight$_(t) {
                    this._$_rc$_._$setRight$_(this._$_rc$_._$getRight$_() + t);
                }
                _$GetTileId$_() {
                    return this._$_id$_;
                }
                _$HasPoly$_() {
                    return !!this._$_poly$_;
                }
                _$GetPoly$_() {
                    return this._$_poly$_;
                }
                _$GetRect$_() {
                    return this._$_rc$_;
                }
            };
        }
        {
            const C33 = self._$C3$_, TILE_ID_MASK = C33._$Plugins$_._$Tilemap$_._$TILE_ID_MASK$_;
            C33._$Plugins$_._$Tilemap$_._$TileCell$_ = class extends C33._$DefendedBase$_ {
                constructor(t, e, s) {
                    super();
                    const i = t._$GetCellWidth$_(), r = t._$GetCellHeight$_();
                    this._$_sdkInst$_ = t, this._$_x$_ = e, this._$_y$_ = s, this._$_left$_ = this._$_x$_ * i * t._$GetTileWidth$_(), 
                    this._$_top$_ = this._$_y$_ * r * t._$GetTileHeight$_(), this._$_tiles$_ = [], 
                    this._$_quads$_ = [], this._$_collisionRects$_ = [], this._$_isQuadMapValid$_ = !1;
                    for (let t = 0; t < r; ++t) {
                        const n = new Int32Array(i);
                        n.fill(-1), this._$_tiles$_.push(n);
                    }
                }
                _$Clear$_() {
                    const s = this._$_sdkInst$_._$GetCellWidth$_(), e = this._$_sdkInst$_._$GetCellHeight$_(), i = this._$_tiles$_;
                    if (i.length < e) for (let t = i.length; t < e; ++t) i.push(new Int32Array(s)); else i.length > e && C33._$truncateArray$_(i, e);
                    for (let e = 0, t = i.length; e < t; ++e) {
                        let t = i[e];
                        t.length !== s && (t = new Int32Array(s), i[e] = t), t.fill(-1);
                    }
                }
                _$GetLayoutRect$_(t) {
                    const e = this._$_sdkInst$_, s = e._$GetWorldInfo$_(), i = e._$GetCellWidth$_() * e._$GetTileWidth$_(), r = e._$GetCellHeight$_() * e._$GetTileHeight$_(), n = s._$GetX$_() + this._$_left$_, h = s._$GetY$_() + this._$_top$_;
                    t.set(n, h, n + i, h + r);
                }
                _$_SetQuadMapChanged$_() {
                    this._$_isQuadMapValid$_ = !1;
                }
                _$MaybeBuildQuadMap$_() {
                    if (!this._$_isQuadMapValid$_) {
                        const u = this._$_sdkInst$_, c = u._$GetSdkType$_(), e = u._$GetWorldInfo$_(), f = u._$GetTileWidth$_(), d = u._$GetTileHeight$_(), p = u._$GetCellWidth$_(), m = u._$GetCellHeight$_(), C = this._$_left$_, g = this._$_top$_;
                        if (!(f <= 0 || d <= 0)) {
                            let i = Math.min(u._$GetMapWidth$_(), Math.floor(e._$GetWidth$_() / f)), t = Math.min(u._$GetMapHeight$_(), Math.floor(e._$GetHeight$_() / d)), r = (i -= C / f, 
                            t -= g / d, i > p && (i = p), t > m && (t = m), this._$_tiles$_), n = this._$_quads$_, h = 0;
                            for (let s = 0; s < t; ++s) {
                                const S = r[s];
                                for (let e = 0; e < i; ++e) {
                                    const _ = S[e];
                                    if (-1 !== _) {
                                        let t = null;
                                        h < n.length ? t = n[h] : (t = C33._$New$_(C33._$Plugins$_._$Tilemap$_._$TileQuad$_), 
                                        n.push(t)), t._$Update$_(_, f, d, e, s, C, g, u), 
                                        ++h;
                                    }
                                }
                            }
                            h < n.length && C33._$truncateArray$_(n, h);
                            let s = null, o = !1, a = this._$_collisionRects$_;
                            C33._$clearArray$_(a);
                            for (let e = 0; e < t; ++e) {
                                const T = r[e];
                                for (let t = 0; t < i; ++t) {
                                    const y = T[t], E = (TILE_ID_MASK, c._$GetTilePoly$_(y)), A = c._$IsTilePolyEnabled$_(E);
                                    -1 !== y && A ? !s || E || o ? (s && a.push(s), 
                                    (s = C33._$New$_(C33._$Plugins$_._$Tilemap$_._$TileCollisionRect$_))._$Update$_(y, E, f, d, t, e, C, g), 
                                    o = !!E) : s._$ExtendRight$_(f) : s && (a.push(s), 
                                    s = null, o = !1);
                                }
                                s && (a.push(s), s = null, o = !1);
                            }
                            let l = a.length;
                            for (let e = 0; e < l; ++e) {
                                const I = a[e];
                                if (!I._$HasPoly$_()) {
                                    const M = I._$GetRect$_();
                                    for (let t = e + 1; t < l; ++t) {
                                        const w = a[t], v = w._$GetRect$_();
                                        v._$getTop$_() < M._$getBottom$_() || v._$getTop$_() > M._$getBottom$_() || v._$getRight$_() > M._$getRight$_() || v._$getLeft$_() > M._$getLeft$_() || w._$HasPoly$_() || v._$getLeft$_() === M._$getLeft$_() && v._$getRight$_() === M._$getRight$_() && (a.splice(t, 1), 
                                        --l, M._$setBottom$_(M._$getBottom$_() + d), 
                                        --t);
                                    }
                                }
                            }
                            this._$_isQuadMapValid$_ = !0;
                        }
                    }
                }
                _$SetTileAt$_(t, e, s) {
                    this._$_tiles$_[e][t] !== s && (this._$_tiles$_[e][t] = s, this._$_isQuadMapValid$_ = !1, 
                    this._$_sdkInst$_._$SetTileChanged$_());
                }
                _$GetTilesArr$_() {
                    return this._$_tiles$_;
                }
                _$GetCollisionRects$_() {
                    return this._$_collisionRects$_;
                }
                _$Draw$_(s, i, r, n) {
                    const h = this._$_sdkInst$_, o = this._$_quads$_;
                    for (let t = 0, e = o.length; t < e; ++t) o[t]._$Draw$_(s, i, r, n, h);
                }
            };
        }
        {
            const C33 = self._$C3$_, IGNORE_INDEX = -999, FORCE_INDEX = -998, EMPTY_INDEX = -1, PAINT_MODE = 0, ERASE_MODE = 1, AUTO_TILING_PATCH = Object.freeze([ [ 0, 0, 0 ], [ 0, 0, 0 ], [ 0, 0, 0 ] ]);
            C33._$Plugins$_._$Tilemap$_._$AutoTiling$_ = class {
                constructor(t, e) {
                    this._$_sdkInst$_ = t, this._$_sdkType$_ = e, this._$_brushAdapterInstances$_ = [ null, null ], 
                    this._$_brushAdapterConstructors$_ = [ C33._$Plugins$_._$Tilemap$_._$AutoTiling16$_, C33._$Plugins$_._$Tilemap$_._$AutoTiling47$_ ], 
                    this._$_probabilityTable$_ = new C33._$ProbabilityTable$_();
                }
                get _$AUTO_TILING_PATCH$_() {
                    return AUTO_TILING_PATCH;
                }
                get _$IGNORE_INDEX$_() {
                    return IGNORE_INDEX;
                }
                get _$FORCE_INDEX$_() {
                    return FORCE_INDEX;
                }
                get _$EMPTY_INDEX$_() {
                    return EMPTY_INDEX;
                }
                get _$PAINT_MODE$_() {
                    return PAINT_MODE;
                }
                get _$ERASE_MODE$_() {
                    return ERASE_MODE;
                }
                _$GetSdkIntance$_() {
                    return this._$_sdkInst$_;
                }
                _$GetSdkType$_() {
                    return this._$_sdkType$_;
                }
                _$SetAutoTile$_(t, e, s) {
                    this._$BrushExists$_(s) && (this._$_SetAutoTileMode$_(s, PAINT_MODE), 
                    this._$_SetAutoTilePatch$_(t, e, this._$_GetAutoTilePatch$_(t, e, s)));
                }
                _$EraseAutoTile$_(t, e, s) {
                    this._$BrushExists$_(s) && (this._$_SetAutoTileMode$_(s, ERASE_MODE), 
                    this._$_EraseTile$_(t, e), this._$_SetAutoTilePatch$_(t, e, this._$_GetAutoTilePatch$_(t, e, s)));
                }
                _$BrushExists$_(t) {
                    return !!this._$GetSdkType$_()._$GetBrushData$_(t);
                }
                _$GetTile$_(t, e) {
                    return this._$GetSdkIntance$_()._$GetTileAt$_(t, e);
                }
                _$DoesTileExist$_(t, e, s) {
                    const i = this._$GetTile$_(t, e);
                    return !!this._$IsTileValid$_(i, !0, i, s);
                }
                _$IsTileValid$_(t, e, s, i) {
                    return t === EMPTY_INDEX || (!e || t !== FORCE_INDEX) && e && i && !this._$_IsTileIndexInBrush$_(s, i) ? 0 : 1;
                }
                _$GetTileIndex$_(t, e, s, i) {
                    const r = i._$tileData$_[t];
                    if (!r.length) return EMPTY_INDEX;
                    if (1 === r.length) return r[0][0];
                    const n = this._$GetTile$_(e, s);
                    if (this._$IsTileValid$_(n)) {
                        const h = r.some(t => n === t[0]);
                        if (h) return n;
                    }
                    this._$_probabilityTable$_._$Clear$_();
                    for (let [ t, e ] of r) "number" != typeof e && (e = 1), this._$_probabilityTable$_._$AddItem$_(e, t);
                    return this._$_probabilityTable$_._$Sample$_();
                }
                _$_SetTile$_(t, e, s) {
                    t !== EMPTY_INDEX && this._$GetSdkIntance$_()._$SetTileAt$_(t, e, s);
                }
                _$_EraseTile$_(t, e) {
                    this._$GetSdkIntance$_()._$SetTileAt$_(t, e, EMPTY_INDEX);
                }
                _$_IsTileIndexInBrush$_(t, e) {
                    for (const s of e._$tileData$_) for (const [ i ] of s) if (i === t) return !0;
                    return !1;
                }
                _$_SetAutoTilePatch$_(t, e, s) {
                    s && (this._$_SetTile$_(t - 1, e - 1, s[0][0]), this._$_SetTile$_(t, e - 1, s[1][0]), 
                    this._$_SetTile$_(t + 1, e - 1, s[2][0]), this._$_SetTile$_(t - 1, e, s[0][1]), 
                    this._$_SetTile$_(t, e, s[1][1]), this._$_SetTile$_(t + 1, e, s[2][1]), 
                    this._$_SetTile$_(t - 1, e + 1, s[0][2]), this._$_SetTile$_(t, e + 1, s[1][2]), 
                    this._$_SetTile$_(t + 1, e + 1, s[2][2]));
                }
                _$_GetBrushType$_(t) {
                    const e = this._$GetSdkType$_()._$GetBrushData$_(t);
                    return e.type;
                }
                _$_MaybeCreateBrushAdapter$_(t) {
                    const e = this._$_GetBrushType$_(t);
                    this._$_brushAdapterInstances$_[e] || (this._$_brushAdapterInstances$_[e] = new this._$_brushAdapterConstructors$_[e](this));
                }
                _$_SetAutoTileMode$_(t, e) {
                    this._$_MaybeCreateBrushAdapter$_(t);
                    const s = this._$_GetBrushType$_(t);
                    this._$_brushAdapterInstances$_[s] && this._$_brushAdapterInstances$_[s]._$SetMode$_(e);
                }
                _$_GetAutoTilePatch$_(t, e, s) {
                    this._$_MaybeCreateBrushAdapter$_(s);
                    const i = this._$GetSdkType$_()._$GetBrushData$_(s);
                    if (this._$_brushAdapterInstances$_[i.type]) return this._$_brushAdapterInstances$_[i.type]._$BuildPatch$_(t, e, i);
                }
            };
        }
        {
            const C33 = self._$C3$_;
            C33._$Plugins$_._$Tilemap$_._$AutoTiling16$_ = class {
                constructor(t) {
                    this._$_auto$_ = t, this._$_mode$_ = t._$PAINT_MODE$_;
                }
                _$SetMode$_(t) {
                    this._$_mode$_ = t;
                }
                _$BuildPatch$_(t, e, s) {
                    return this._$_Build4BitAutoTilePatch$_(t, e, s);
                }
                _$_Build4BitAutoTilePatch$_(t, e, s) {
                    const i = this._$_mode$_ === this._$_auto$_._$PAINT_MODE$_ ? this._$_4BitAutoTiling$_(t, e, void 0, s) : this._$_auto$_._$EMPTY_INDEX$_, r = this._$_Get4BitAutoTile$_(t, e - 1, "s", s), n = this._$_Get4BitAutoTile$_(t - 1, e, "e", s), h = this._$_Get4BitAutoTile$_(t + 1, e, "w", s), o = this._$_Get4BitAutoTile$_(t, e + 1, "n", s), a = this._$_auto$_._$AUTO_TILING_PATCH$_;
                    return a[0][0] = this._$_auto$_._$IGNORE_INDEX$_, a[1][0] = this._$_Get4BitTileIndex$_(r, t, e - 1, s), 
                    a[2][0] = this._$_auto$_._$IGNORE_INDEX$_, a[0][1] = this._$_Get4BitTileIndex$_(n, t - 1, e, s), 
                    a[1][1] = this._$_Get4BitTileIndex$_(i, t, e, s), a[2][1] = this._$_Get4BitTileIndex$_(h, t + 1, e, s), 
                    a[0][2] = this._$_auto$_._$IGNORE_INDEX$_, a[1][2] = this._$_Get4BitTileIndex$_(o, t, e + 1, s), 
                    a[2][2] = this._$_auto$_._$IGNORE_INDEX$_, a;
                }
                _$_Get4BitAutoTile$_(t, e, s, i) {
                    return this._$_auto$_._$DoesTileExist$_(t, e, i) ? this._$_4BitAutoTiling$_(t, e, s, i) : this._$_auto$_._$IGNORE_INDEX$_;
                }
                _$_4BitAutoTiling$_(t, e, s, i) {
                    this._$_mode$_ === this._$_auto$_._$ERASE_MODE$_ && (s = void 0);
                    const r = this._$_auto$_._$GetTile$_(t, e - 1), n = this._$_auto$_._$GetTile$_(t - 1, e), h = this._$_auto$_._$GetTile$_(t + 1, e), o = this._$_auto$_._$GetTile$_(t, e + 1), a = "n" === s ? this._$_auto$_._$FORCE_INDEX$_ : r, l = "w" === s ? this._$_auto$_._$FORCE_INDEX$_ : n, u = "e" === s ? this._$_auto$_._$FORCE_INDEX$_ : h, c = "s" === s ? this._$_auto$_._$FORCE_INDEX$_ : o, f = this._$_auto$_._$IsTileValid$_(a, !0, r, i), d = this._$_auto$_._$IsTileValid$_(l, !0, n, i), p = this._$_auto$_._$IsTileValid$_(u, !0, h, i), m = this._$_auto$_._$IsTileValid$_(c, !0, o, i);
                    return +f + 2 * d + 4 * p + 8 * m;
                }
                _$_Get4BitTileIndex$_(t, e, s, i) {
                    return t === this._$_auto$_._$IGNORE_INDEX$_ || t === this._$_auto$_._$EMPTY_INDEX$_ ? t : this._$_auto$_._$GetTileIndex$_(t, e, s, i);
                }
            };
        }
        {
            const C33 = self._$C3$_, TILE_INDEX_MAP = new Map([ [ 2, 1 ], [ 8, 2 ], [ 10, 3 ], [ 11, 4 ], [ 16, 5 ], [ 18, 6 ], [ 22, 7 ], [ 24, 8 ], [ 26, 9 ], [ 27, 10 ], [ 30, 11 ], [ 31, 12 ], [ 64, 13 ], [ 66, 14 ], [ 72, 15 ], [ 74, 16 ], [ 75, 17 ], [ 80, 18 ], [ 82, 19 ], [ 86, 20 ], [ 88, 21 ], [ 90, 22 ], [ 91, 23 ], [ 94, 24 ], [ 95, 25 ], [ 104, 26 ], [ 106, 27 ], [ 107, 28 ], [ 120, 29 ], [ 122, 30 ], [ 123, 31 ], [ 126, 32 ], [ 127, 33 ], [ 208, 34 ], [ 210, 35 ], [ 214, 36 ], [ 216, 37 ], [ 218, 38 ], [ 219, 39 ], [ 222, 40 ], [ 223, 41 ], [ 248, 42 ], [ 250, 43 ], [ 251, 44 ], [ 254, 45 ], [ 255, 46 ], [ 0, 47 ] ]);
            C33._$Plugins$_._$Tilemap$_._$AutoTiling47$_ = class {
                constructor(t) {
                    this._$_auto$_ = t, this._$_mode$_ = t._$PAINT_MODE$_;
                }
                _$SetMode$_(t) {
                    this._$_mode$_ = t;
                }
                _$BuildPatch$_(t, e, s) {
                    return this._$_Build8BitAutoTilePatch$_(t, e, s);
                }
                _$_Build8BitAutoTilePatch$_(t, e, s) {
                    const i = this._$_mode$_ === this._$_auto$_._$PAINT_MODE$_ ? this._$_8BitAutoTiling$_(t, e, void 0, s) : this._$_auto$_._$EMPTY_INDEX$_, r = this._$_Get8BitAutoTile$_(t - 1, e - 1, "se", s), n = this._$_Get8BitAutoTile$_(t, e - 1, "s", s), h = this._$_Get8BitAutoTile$_(t + 1, e - 1, "sw", s), o = this._$_Get8BitAutoTile$_(t - 1, e, "e", s), a = this._$_Get8BitAutoTile$_(t + 1, e, "w", s), l = this._$_Get8BitAutoTile$_(t - 1, e + 1, "ne", s), u = this._$_Get8BitAutoTile$_(t, e + 1, "n", s), c = this._$_Get8BitAutoTile$_(t + 1, e + 1, "nw", s), f = this._$_auto$_._$AUTO_TILING_PATCH$_;
                    return f[0][0] = this._$_Get8BitTileIndex$_(r, t - 1, e - 1, s), 
                    f[1][0] = this._$_Get8BitTileIndex$_(n, t, e - 1, s), f[2][0] = this._$_Get8BitTileIndex$_(h, t + 1, e - 1, s), 
                    f[0][1] = this._$_Get8BitTileIndex$_(o, t - 1, e, s), f[1][1] = this._$_Get8BitTileIndex$_(i, t, e, s), 
                    f[2][1] = this._$_Get8BitTileIndex$_(a, t + 1, e, s), f[0][2] = this._$_Get8BitTileIndex$_(l, t - 1, e + 1, s), 
                    f[1][2] = this._$_Get8BitTileIndex$_(u, t, e + 1, s), f[2][2] = this._$_Get8BitTileIndex$_(c, t + 1, e + 1, s), 
                    f;
                }
                _$_Get8BitAutoTile$_(t, e, s, i) {
                    return this._$_auto$_._$DoesTileExist$_(t, e, i) ? this._$_8BitAutoTiling$_(t, e, s, i) : this._$_auto$_._$IGNORE_INDEX$_;
                }
                _$_8BitAutoTiling$_(t, e, s, i) {
                    this._$_mode$_ === this._$_auto$_._$ERASE_MODE$_ && (s = void 0);
                    const r = this._$_auto$_._$GetTile$_(t, e - 1), n = this._$_auto$_._$GetTile$_(t - 1, e), h = this._$_auto$_._$GetTile$_(t + 1, e), o = this._$_auto$_._$GetTile$_(t, e + 1), a = this._$_auto$_._$GetTile$_(t - 1, e - 1), l = this._$_auto$_._$GetTile$_(t + 1, e - 1), u = this._$_auto$_._$GetTile$_(t - 1, e + 1), c = this._$_auto$_._$GetTile$_(t + 1, e + 1), f = "n" === s ? this._$_auto$_._$FORCE_INDEX$_ : r, d = "w" === s ? this._$_auto$_._$FORCE_INDEX$_ : n, p = "e" === s ? this._$_auto$_._$FORCE_INDEX$_ : h, m = "s" === s ? this._$_auto$_._$FORCE_INDEX$_ : o, C = "nw" === s ? this._$_auto$_._$FORCE_INDEX$_ : a, g = "ne" === s ? this._$_auto$_._$FORCE_INDEX$_ : l, S = "sw" === s ? this._$_auto$_._$FORCE_INDEX$_ : u, _ = "se" === s ? this._$_auto$_._$FORCE_INDEX$_ : c, T = this._$_auto$_._$IsTileValid$_(f, !0, r, i), y = this._$_auto$_._$IsTileValid$_(d, !0, n, i), E = this._$_auto$_._$IsTileValid$_(p, !0, h, i), A = this._$_auto$_._$IsTileValid$_(m, !0, o, i), I = T && y ? this._$_auto$_._$IsTileValid$_(C, !0, a, i) : 0, M = T && E ? this._$_auto$_._$IsTileValid$_(g, !0, l, i) : 0, w = A && y ? this._$_auto$_._$IsTileValid$_(S, !0, u, i) : 0, v = A && E ? this._$_auto$_._$IsTileValid$_(_, !0, c, i) : 0;
                    return +I + 2 * T + 4 * M + 8 * y + 16 * E + 32 * w + 64 * A + 128 * v;
                }
                _$_Get8BitTileIndex$_(t, e, s, i) {
                    return t === this._$_auto$_._$IGNORE_INDEX$_ || t === this._$_auto$_._$EMPTY_INDEX$_ ? t : this._$_auto$_._$GetTileIndex$_(TILE_INDEX_MAP.get(t), e, s, i);
                }
            };
        }
        {
            const a = self._$C3$_;
            a._$Plugins$_._$LocalStorage$_ = class extends a._$SDKPluginBase$_ {
                constructor(t) {
                    super(t);
                }
                _$Release$_() {
                    super._$Release$_();
                }
            };
        }
        {
            const d = self._$C3$_;
            d._$Plugins$_._$LocalStorage$_._$Type$_ = class extends d._$SDKTypeBase$_ {
                constructor(t) {
                    super(t);
                }
                _$Release$_() {
                    super._$Release$_();
                }
                _$OnCreate$_() {}
            };
        }
        {
            const g = self._$C3$_, h = "localstorage";
            g._$Plugins$_._$LocalStorage$_.Instance = class extends g._$SDKInstanceBase$_ {
                constructor(t, e) {
                    super(t, h), this._$_currentKey$_ = "", this._$_lastValue$_ = "", 
                    this._$_keyNamesList$_ = [], this._$_errorMessage$_ = "", this._$_isPersistent$_ = !1, 
                    this._$_pendingGets$_ = 0, this._$_pendingSets$_ = 0, this._$_isInMemoryOnly$_ = !1, 
                    e && (this._$_isInMemoryOnly$_ = e[0]);
                    const s = this._$_runtime$_._$_GetProjectStorage$_();
                    this._$_storage$_ = null, this._$_isInMemoryOnly$_ ? this._$_storage$_ = s._$createInstance$_({
                        _$forceInMemoryFallback$_: !0
                    }) : this._$_storage$_ = s, this._$_debugCache$_ = new Map(), 
                    this._$_isLoadingDebugCache$_ = !1, this._$_runtime$_._$AddLoadPromise$_(this._$_Init$_());
                }
                async _$_Init$_() {
                    const t = await Promise.race([ this._$PostToDOMAsync$_("init"), g._$Wait$_(3e3) ]);
                    t && (this._$_isPersistent$_ = t.isPersistent);
                }
                _$Release$_() {
                    super._$Release$_();
                }
                async _$_TriggerStorageError$_(t) {
                    this._$_errorMessage$_ = this._$_GetErrorString$_(t), await this._$TriggerAsync$_(g._$Plugins$_._$LocalStorage$_._$Cnds$_._$OnError$_);
                }
                _$_GetErrorString$_(t) {
                    return t ? "string" == typeof t ? t : "string" == typeof t.message ? t.message : "string" == typeof t.name ? t.name : "string" == typeof t.data ? t.data : "unknown error" : "unknown error";
                }
                _$GetDebuggerProperties$_() {
                    return this._$_isLoadingDebugCache$_ || this._$_DebugCacheStorage$_(), 
                    [ {
                        title: "plugins.localstorage.name",
                        properties: [ ...this._$_debugCache$_.entries() ].map(e => ({
                            name: "$" + e[0],
                            value: e[1],
                            _$onedit$_: t => this._$_storage$_.setItem(e[0], t)
                        }))
                    } ];
                }
                async _$_DebugCacheStorage$_() {
                    this._$_isLoadingDebugCache$_ = !0;
                    try {
                        const s = await this._$_storage$_.keys(), i = (s.sort((t, e) => {
                            const s = t.toLowerCase(), i = e.toLowerCase();
                            return s < i ? -1 : i < s ? 1 : 0;
                        }), await Promise.all(s.map(t => this._$_storage$_.getItem(t))));
                        this._$_debugCache$_.clear();
                        for (let t = 0, e = s.length; t < e; ++t) this._$_debugCache$_.set(s[t], i[t]);
                    } catch (t) {
                        console.warn("[C3 debugger] Error displaying local storage: ", t);
                    } finally {
                        this._$_isLoadingDebugCache$_ = !1;
                    }
                }
            };
        }
        {
            const B = self._$C3$_;
            B._$Plugins$_._$LocalStorage$_._$Cnds$_ = {
                _$OnItemSet$_(t) {
                    return this._$_currentKey$_ === t;
                },
                _$OnAnyItemSet$_() {
                    return !0;
                },
                _$OnItemGet$_(t) {
                    return this._$_currentKey$_ === t;
                },
                _$OnAnyItemGet$_() {
                    return !0;
                },
                _$OnItemRemoved$_(t) {
                    return this._$_currentKey$_ === t;
                },
                _$OnAnyItemRemoved$_() {
                    return !0;
                },
                _$OnCleared$_() {
                    return !0;
                },
                _$OnAllKeyNamesLoaded$_() {
                    return !0;
                },
                _$OnError$_() {
                    return !0;
                },
                _$OnItemExists$_(t) {
                    return this._$_currentKey$_ === t;
                },
                _$OnItemMissing$_(t) {
                    return this._$_currentKey$_ === t;
                },
                _$CompareKey$_(t, e) {
                    return B.compare(this._$_currentKey$_, t, e);
                },
                _$CompareValue$_(t, e) {
                    return B.compare(this._$_lastValue$_, t, e);
                },
                _$IsProcessingSets$_() {
                    return 0 < this._$_pendingSets$_;
                },
                _$IsProcessingGets$_() {
                    return 0 < this._$_pendingGets$_;
                },
                _$OnAllSetsComplete$_() {
                    return !0;
                },
                _$OnAllGetsComplete$_() {
                    return !0;
                },
                _$IsPersistent$_() {
                    return this._$_isPersistent$_;
                }
            };
        }
        {
            let IsExpressionType2 = function(t) {
                return "string" == typeof t || "number" == typeof t;
            };
            IsExpressionType = IsExpressionType2;
            const L = self._$C3$_;
            L._$Plugins$_._$LocalStorage$_._$Acts$_ = {
                async _$SetItem$_(t, e) {
                    this._$_pendingSets$_++;
                    try {
                        const s = await this._$_storage$_.setItem(t, e);
                        await this._$ScheduleTriggers$_(async () => {
                            this._$_currentKey$_ = t, this._$_lastValue$_ = s, await this._$TriggerAsync$_(L._$Plugins$_._$LocalStorage$_._$Cnds$_._$OnAnyItemSet$_), 
                            await this._$TriggerAsync$_(L._$Plugins$_._$LocalStorage$_._$Cnds$_._$OnItemSet$_);
                        });
                    } catch (t) {
                        await this._$_TriggerStorageError$_(t);
                    } finally {
                        this._$_pendingSets$_--, 0 === this._$_pendingSets$_ && await this._$TriggerAsync$_(L._$Plugins$_._$LocalStorage$_._$Cnds$_._$OnAllSetsComplete$_);
                    }
                },
                async _$SetBinaryItem$_(t, e) {
                    if (e) {
                        const s = e._$GetFirstPicked$_(this._$_inst$_);
                        if (s) {
                            const i = s._$GetSdkInstance$_();
                            if (i) {
                                const r = i.GetArrayBufferReadOnly();
                                this._$_pendingSets$_++;
                                try {
                                    await this._$_storage$_.setItem(t, r), await this._$ScheduleTriggers$_(async () => {
                                        this._$_currentKey$_ = t, this._$_lastValue$_ = "", 
                                        await this._$TriggerAsync$_(L._$Plugins$_._$LocalStorage$_._$Cnds$_._$OnAnyItemSet$_), 
                                        await this._$TriggerAsync$_(L._$Plugins$_._$LocalStorage$_._$Cnds$_._$OnItemSet$_);
                                    });
                                } catch (t) {
                                    await this._$_TriggerStorageError$_(t);
                                } finally {
                                    this._$_pendingSets$_--, 0 === this._$_pendingSets$_ && await this._$TriggerAsync$_(L._$Plugins$_._$LocalStorage$_._$Cnds$_._$OnAllSetsComplete$_);
                                }
                            }
                        }
                    }
                },
                async _$GetItem$_(t) {
                    this._$_pendingGets$_++;
                    try {
                        const e = await this._$_storage$_.getItem(t);
                        await this._$ScheduleTriggers$_(async () => {
                            this._$_currentKey$_ = t, this._$_lastValue$_ = IsExpressionType2(e) ? e : "", 
                            await this._$TriggerAsync$_(L._$Plugins$_._$LocalStorage$_._$Cnds$_._$OnAnyItemGet$_), 
                            await this._$TriggerAsync$_(L._$Plugins$_._$LocalStorage$_._$Cnds$_._$OnItemGet$_);
                        });
                    } catch (t) {
                        await this._$_TriggerStorageError$_(t);
                    } finally {
                        this._$_pendingGets$_--, 0 === this._$_pendingGets$_ && await this._$TriggerAsync$_(L._$Plugins$_._$LocalStorage$_._$Cnds$_._$OnAllGetsComplete$_);
                    }
                },
                async _$GetBinaryItem$_(e, t) {
                    if (t) {
                        const s = t._$GetFirstPicked$_(this._$_inst$_);
                        if (s) {
                            const i = s._$GetSdkInstance$_();
                            this._$_pendingGets$_++;
                            try {
                                let t = await this._$_storage$_.getItem(e);
                                t = t instanceof ArrayBuffer ? t : new ArrayBuffer(0), 
                                await this._$ScheduleTriggers$_(async () => {
                                    this._$_lastValue$_ = "", this._$_currentKey$_ = e, 
                                    i.SetArrayBufferTransfer(t), await this._$TriggerAsync$_(L._$Plugins$_._$LocalStorage$_._$Cnds$_._$OnAnyItemGet$_), 
                                    await this._$TriggerAsync$_(L._$Plugins$_._$LocalStorage$_._$Cnds$_._$OnItemGet$_);
                                });
                            } catch (t) {
                                await this._$_TriggerStorageError$_(t);
                            } finally {
                                this._$_pendingGets$_--, 0 === this._$_pendingGets$_ && await this._$TriggerAsync$_(L._$Plugins$_._$LocalStorage$_._$Cnds$_._$OnAllGetsComplete$_);
                            }
                        }
                    }
                },
                async _$CheckItemExists$_(t) {
                    try {
                        const e = await this._$_storage$_.getItem(t);
                        await this._$ScheduleTriggers$_(async () => {
                            this._$_currentKey$_ = t, null == e ? (this._$_lastValue$_ = "", 
                            await this._$TriggerAsync$_(L._$Plugins$_._$LocalStorage$_._$Cnds$_._$OnItemMissing$_)) : (this._$_lastValue$_ = IsExpressionType2(e) ? e : "", 
                            await this._$TriggerAsync$_(L._$Plugins$_._$LocalStorage$_._$Cnds$_._$OnItemExists$_));
                        });
                    } catch (t) {
                        await this._$_TriggerStorageError$_(t);
                    }
                },
                async _$RemoveItem$_(t) {
                    try {
                        await this._$_storage$_.removeItem(t), await this._$ScheduleTriggers$_(async () => {
                            this._$_currentKey$_ = t, this._$_lastValue$_ = "", 
                            await this._$TriggerAsync$_(L._$Plugins$_._$LocalStorage$_._$Cnds$_._$OnAnyItemRemoved$_), 
                            await this._$TriggerAsync$_(L._$Plugins$_._$LocalStorage$_._$Cnds$_._$OnItemRemoved$_);
                        });
                    } catch (t) {
                        await this._$_TriggerStorageError$_(t);
                    }
                },
                async _$ClearStorage$_() {
                    try {
                        await this._$_storage$_.clear(), await this._$ScheduleTriggers$_(async () => {
                            this._$_currentKey$_ = "", this._$_lastValue$_ = "", 
                            L._$clearArray$_(this._$_keyNamesList$_), await this._$TriggerAsync$_(L._$Plugins$_._$LocalStorage$_._$Cnds$_._$OnCleared$_);
                        });
                    } catch (t) {
                        await this._$_TriggerStorageError$_(t);
                    }
                },
                async _$GetAllKeyNames$_() {
                    try {
                        const t = await this._$_storage$_.keys();
                        await this._$ScheduleTriggers$_(async () => {
                            this._$_keyNamesList$_ = t, await this._$TriggerAsync$_(L._$Plugins$_._$LocalStorage$_._$Cnds$_._$OnAllKeyNamesLoaded$_);
                        });
                    } catch (t) {
                        await this._$_TriggerStorageError$_(t);
                    }
                },
                async _$RequestPersistent$_() {
                    const t = await this._$PostToDOMAsync$_("request-persistent");
                    t.isOk && (this._$_isPersistent$_ = t.isPersistent);
                },
                _$LoadMemoryFromJSON$_(e) {
                    if (this._$_isInMemoryOnly$_) {
                        let t;
                        try {
                            t = JSON.parse(e);
                        } catch (t) {
                            return void console.error("[Local Storage] Failed to parse memory storage JSON: ", t);
                        }
                        t && t["is-c3-storage"] && Array.isArray(t.items) || console.error("[Local Storage] Failed to load memory storage JSON: invalid data"), 
                        this._$_storage$_._$SetMemoryStorage$_(new Map(t.items));
                    }
                }
            };
        }
        {
            const qa = self._$C3$_;
            qa._$Plugins$_._$LocalStorage$_._$Exps$_ = {
                _$ItemValue$_() {
                    return this._$_lastValue$_;
                },
                Key() {
                    return this._$_currentKey$_;
                },
                _$KeyCount$_() {
                    return this._$_keyNamesList$_.length;
                },
                _$KeyAt$_(t) {
                    return (t = Math.floor(t)) < 0 || t >= this._$_keyNamesList$_.length ? "" : this._$_keyNamesList$_[t];
                },
                _$ErrorMessage$_() {
                    return this._$_errorMessage$_;
                },
                _$MemoryStorageAsJSON$_() {
                    return this._$_isInMemoryOnly$_ ? JSON.stringify({
                        "is-c3-storage": !0,
                        items: [ ...this._$_storage$_._$GetMemoryStorage$_() ]
                    }) : "";
                }
            };
        }
        {
            const a = self._$C3$_;
            a._$Plugins$_._$PlatformInfo$_ = class extends a._$SDKPluginBase$_ {
                constructor(t) {
                    super(t);
                }
                _$Release$_() {
                    super._$Release$_();
                }
            };
        }
        {
            const d = self._$C3$_;
            d._$Plugins$_._$PlatformInfo$_._$Type$_ = class extends d._$SDKTypeBase$_ {
                constructor(t) {
                    super(t);
                }
                _$Release$_() {
                    super._$Release$_();
                }
                _$OnCreate$_() {}
            };
        }
        {
            const g = self._$C3$_, h = "platform-info";
            g._$Plugins$_._$PlatformInfo$_.Instance = class extends g._$SDKInstanceBase$_ {
                constructor(t, e) {
                    super(t, h), this._$_screenWidth$_ = 0, this._$_screenHeight$_ = 0, 
                    this._$_windowOuterWidth$_ = 0, this._$_windowOuterHeight$_ = 0, 
                    this._$_safeAreaInset$_ = [ 0, 0, 0, 0 ], this._$_supportsWakeLock$_ = !1, 
                    this._$_isWakeLockActive$_ = !1, this._$AddDOMMessageHandlers$_([ [ "window-resize", t => this._$_OnWindowResize$_(t) ], [ "wake-lock-acquired", t => this._$_OnWakeLockAcquired$_(t) ], [ "wake-lock-error", t => this._$_OnWakeLockError$_(t) ], [ "wake-lock-released", t => this._$_OnWakeLockReleased$_(t) ] ]), 
                    navigator.connection && navigator.connection.addEventListener("change", () => this._$_OnNetworkChange$_()), 
                    this._$_runtime$_._$AddLoadPromise$_(this._$PostToDOMAsync$_("get-initial-state").then(t => {
                        this._$_screenWidth$_ = t.screenWidth, this._$_screenHeight$_ = t.screenHeight, 
                        this._$_windowOuterWidth$_ = t.windowOuterWidth, this._$_windowOuterHeight$_ = t.windowOuterHeight, 
                        this._$_safeAreaInset$_ = t.safeAreaInset, this._$_supportsWakeLock$_ = t.supportsWakeLock;
                    }));
                }
                _$Release$_() {
                    super._$Release$_();
                }
                _$_OnWindowResize$_(t) {
                    this._$_windowOuterWidth$_ = t.windowOuterWidth, this._$_windowOuterHeight$_ = t.windowOuterHeight, 
                    this._$_safeAreaInset$_ = t.safeAreaInset;
                }
                async _$_OnNetworkChange$_() {
                    await this._$TriggerAsync$_(g._$Plugins$_._$PlatformInfo$_._$Cnds$_._$OnNetworkChange$_);
                }
                async _$_OnWakeLockAcquired$_() {
                    this._$_isWakeLockActive$_ = !0, await this._$TriggerAsync$_(g._$Plugins$_._$PlatformInfo$_._$Cnds$_._$OnWakeLockAcquired$_);
                }
                async _$_OnWakeLockError$_() {
                    this._$_isWakeLockActive$_ = !1, await this._$TriggerAsync$_(g._$Plugins$_._$PlatformInfo$_._$Cnds$_._$OnWakeLockError$_);
                }
                async _$_OnWakeLockReleased$_() {
                    this._$_isWakeLockActive$_ = !1, await this._$TriggerAsync$_(g._$Plugins$_._$PlatformInfo$_._$Cnds$_._$OnWakeLockReleased$_);
                }
            };
        }
        {
            const r = self._$C3$_;
            r._$Plugins$_._$PlatformInfo$_._$Cnds$_ = {
                _$IsOnMobile$_() {
                    return r._$Platform$_._$IsMobile$_;
                },
                _$IsOnWindows$_() {
                    return "Windows" === r._$Platform$_._$OS$_;
                },
                _$IsOnMacOS$_() {
                    return "macOS" === r._$Platform$_._$OS$_;
                },
                _$IsOnLinux$_() {
                    return "Linux" === r._$Platform$_._$OS$_;
                },
                _$IsOnChromeOS$_() {
                    return "Chrome OS" === r._$Platform$_._$OS$_;
                },
                _$IsOnAndroid$_() {
                    return "Android" === r._$Platform$_._$OS$_;
                },
                _$IsOniOS$_() {
                    return "iOS" === r._$Platform$_._$OS$_;
                },
                _$IsWebExport$_() {
                    const t = this._$_runtime$_._$GetExportType$_();
                    return "html5" === t || "scirra-arcade" === t || "preview" === t || "instant-games" === t;
                },
                _$IsCordovaExport$_() {
                    return this._$_runtime$_._$IsCordova$_();
                },
                _$IsNWjsExport$_() {
                    return this._$_runtime$_._$IsNWjs$_();
                },
                _$IsWindowsUWPExport$_() {
                    return "windows-uwp" === this._$_runtime$_._$GetExportType$_();
                },
                _$IsWindowsWebView2Export$_() {
                    return this._$_runtime$_._$IsWindowsWebView2$_();
                },
                _$IsMacOSWKWebView2Export$_() {
                    return "macos-wkwebview" === this._$_runtime$_._$GetExportType$_();
                },
                _$IsLinuxCEFExport$_() {
                    return "linux-cef" === this._$_runtime$_._$GetExportType$_();
                },
                _$OnNetworkChange$_() {
                    return !0;
                },
                _$OnWakeLockAcquired$_() {
                    return !0;
                },
                _$OnWakeLockError$_() {
                    return !0;
                },
                _$OnWakeLockReleased$_() {
                    return !0;
                },
                _$IsWakeLockActive$_() {
                    return this._$_isWakeLockActive$_;
                },
                _$IsWakeLockSupported$_() {
                    return this._$_supportsWakeLock$_;
                }
            };
        }
        {
            const t = self._$C3$_;
            t._$Plugins$_._$PlatformInfo$_._$Acts$_ = {
                _$RequestWakeLock$_() {
                    this._$_supportsWakeLock$_ && this._$_PostToDOMMaybeSync$_("request-wake-lock");
                },
                _$ReleaseWakeLock$_() {
                    this._$_supportsWakeLock$_ && (this._$_isWakeLockActive$_ = !1, 
                    this._$PostToDOM$_("release-wake-lock"));
                }
            };
        }
        {
            const u = self._$C3$_;
            u._$Plugins$_._$PlatformInfo$_._$Exps$_ = {
                _$Renderer$_() {
                    return this._$_runtime$_._$GetCanvasManager$_()._$GetRendererString$_();
                },
                _$RendererDetail$_() {
                    return this._$_runtime$_._$GetCanvasManager$_()._$GetRendererDetailString$_();
                },
                _$DevicePixelRatio$_() {
                    return this._$_runtime$_._$GetDevicePixelRatio$_();
                },
                _$ScreenWidth$_() {
                    return this._$_screenWidth$_;
                },
                _$ScreenHeight$_() {
                    return this._$_screenHeight$_;
                },
                _$WindowInnerWidth$_() {
                    return this._$_runtime$_._$GetCanvasManager$_()._$GetLastWidth$_();
                },
                _$WindowInnerHeight$_() {
                    return this._$_runtime$_._$GetCanvasManager$_()._$GetLastHeight$_();
                },
                _$WindowOuterWidth$_() {
                    return this._$_windowOuterWidth$_;
                },
                _$WindowOuterHeight$_() {
                    return this._$_windowOuterHeight$_;
                },
                _$CanvasCssWidth$_() {
                    return this._$_runtime$_._$GetCanvasManager$_()._$GetCssWidth$_();
                },
                _$CanvasCssHeight$_() {
                    return this._$_runtime$_._$GetCanvasManager$_()._$GetCssHeight$_();
                },
                _$CanvasDeviceWidth$_() {
                    return this._$_runtime$_._$GetCanvasManager$_()._$GetDeviceWidth$_();
                },
                _$CanvasDeviceHeight$_() {
                    return this._$_runtime$_._$GetCanvasManager$_()._$GetDeviceHeight$_();
                },
                _$Downlink$_() {
                    return navigator.connection && navigator.connection.downlink || 0;
                },
                _$DownlinkMax$_() {
                    return navigator.connection && navigator.connection.downlinkMax || 0;
                },
                ConnectionType() {
                    return navigator.connection && navigator.connection.type || "unknown";
                },
                _$ConnectionEffectiveType$_() {
                    return navigator.connection && navigator.connection.effectiveType || "unknown";
                },
                _$ConnectionRTT$_() {
                    return navigator.connection && navigator.connection.rtt || 0;
                },
                _$HardwareConcurrency$_() {
                    return navigator.hardwareConcurrency || 0;
                },
                _$DeviceMemory$_() {
                    return navigator.deviceMemory || 0;
                },
                _$SafeAreaInsetTop$_() {
                    return this._$_safeAreaInset$_[0];
                },
                _$SafeAreaInsetRight$_() {
                    return this._$_safeAreaInset$_[1];
                },
                _$SafeAreaInsetBottom$_() {
                    return this._$_safeAreaInset$_[2];
                },
                _$SafeAreaInsetLeft$_() {
                    return this._$_safeAreaInset$_[3];
                },
                _$FramesPerSecond$_() {
                    return this._$_runtime$_._$GetFramesPerSecond$_();
                },
                _$TicksPerSecond$_() {
                    return this._$_runtime$_._$GetTicksPerSecond$_();
                }
            };
        }
        {
            const a = self._$C3$_, b = "text-input";
            a._$Plugins$_._$TextBox$_ = class extends a._$SDKDOMPluginBase$_ {
                constructor(t) {
                    super(t, b), this._$AddElementMessageHandler$_("click", (t, e) => t._$_OnClick$_(e)), 
                    this._$AddElementMessageHandler$_("dblclick", (t, e) => t._$_OnDoubleClick$_(e)), 
                    this._$AddElementMessageHandler$_("change", (t, e) => t._$_OnChange$_(e));
                }
                _$Release$_() {
                    super._$Release$_();
                }
            };
        }
        {
            const k = self._$C3$_;
            k._$Plugins$_._$TextBox$_._$Type$_ = class extends k._$SDKTypeBase$_ {
                constructor(t) {
                    super(t);
                }
                _$Release$_() {
                    super._$Release$_();
                }
                _$OnCreate$_() {}
            };
        }
        {
            const n = self._$C3$_, o = self._$C3X$_, p = 0, q = 1, r = 2, s = 3, t = 4, u = 5, v = 6, w = 7, x = 8, y = 9, z = 10, A = "text-input", B = [ "text", "password", "email", "number", "tel", "url", "textarea", "search" ], C = (n._$Plugins$_._$TextBox$_.Instance = class extends n._$SDKDOMInstanceBase$_ {
                constructor(e, i) {
                    super(e, A), this._$_text$_ = "", this._$_placeholder$_ = "", 
                    this._$_title$_ = "", this._$_isEnabled$_ = !0, this._$_isReadOnly$_ = !1, 
                    this._$_spellCheck$_ = !1, this._$_type$_ = "text", this._$_autoFontSize$_ = !0, 
                    this._$_maxLength$_ = -1, this._$_id$_ = "", this._$_className$_ = "", 
                    i && (this._$_text$_ = i[p], this._$_placeholder$_ = i[q], this._$_title$_ = i[r], 
                    this._$GetWorldInfo$_()._$SetVisible$_(i[s]), this._$_isEnabled$_ = i[t], 
                    this._$_isReadOnly$_ = i[u], this._$_spellCheck$_ = i[v], this._$_type$_ = B[i[w]], 
                    this._$_autoFontSize$_ = i[x], this._$_id$_ = i[y], this._$_className$_ = i[z]), 
                    this._$CreateElement$_({
                        type: this._$_type$_,
                        id: this._$_id$_,
                        className: this._$_className$_
                    });
                }
                _$Release$_() {
                    super._$Release$_();
                }
                _$GetElementState$_() {
                    return {
                        text: this._$_text$_,
                        placeholder: this._$_placeholder$_,
                        title: this._$_title$_,
                        isEnabled: this._$_isEnabled$_,
                        isReadOnly: this._$_isReadOnly$_,
                        spellCheck: this._$_spellCheck$_,
                        maxLength: this._$_maxLength$_
                    };
                }
                async _$_OnClick$_(t) {
                    this._$DispatchScriptEvent$_("click", !0), await this._$TriggerAsync$_(n._$Plugins$_._$TextBox$_._$Cnds$_._$OnClicked$_);
                }
                async _$_OnDoubleClick$_(t) {
                    this._$DispatchScriptEvent$_("dblclick", !0), await this._$TriggerAsync$_(n._$Plugins$_._$TextBox$_._$Cnds$_._$OnDoubleClicked$_);
                }
                async _$_OnChange$_(t) {
                    this._$_text$_ = t.text, this._$DispatchScriptEvent$_("change", !0), 
                    await this._$TriggerAsync$_(n._$Plugins$_._$TextBox$_._$Cnds$_._$OnTextChanged$_);
                }
                _$_SetText$_(t) {
                    this._$_text$_ !== t && (this._$_text$_ = t, this._$UpdateElementState$_());
                }
                _$_GetText$_() {
                    return this._$_text$_;
                }
                _$_SetPlaceholder$_(t) {
                    this._$_placeholder$_ !== t && (this._$_placeholder$_ = t, this._$UpdateElementState$_());
                }
                _$_GetPlaceholder$_() {
                    return this._$_placeholder$_;
                }
                _$_SetTooltip$_(t) {
                    this._$_title$_ !== t && (this._$_title$_ = t, this._$UpdateElementState$_());
                }
                _$_GetTooltip$_() {
                    return this._$_title$_;
                }
                _$_SetEnabled$_(t) {
                    this._$_isEnabled$_ !== (t = !!t) && (this._$_isEnabled$_ = t, 
                    this._$UpdateElementState$_());
                }
                _$_IsEnabled$_() {
                    return this._$_isEnabled$_;
                }
                _$_SetReadOnly$_(t) {
                    this._$_isReadOnly$_ !== (t = !!t) && (this._$_isReadOnly$_ = t, 
                    this._$UpdateElementState$_());
                }
                _$_IsReadOnly$_() {
                    return this._$_isReadOnly$_;
                }
                _$_SetMaxLength$_(t) {
                    t = Math.max(+t, -1), this._$_maxLength$_ !== t && (this._$_maxLength$_ = t, 
                    this._$UpdateElementState$_());
                }
                _$_GetMaxLength$_() {
                    return this._$_maxLength$_;
                }
                _$_ScrollToBottom$_() {
                    Promise.resolve().then(() => this._$PostToDOMElement$_("scroll-to-bottom"));
                }
                _$Draw$_(t) {}
                _$SaveToJson$_() {
                    return {
                        t: this._$_text$_,
                        p: this._$_placeholder$_,
                        ti: this._$_title$_,
                        e: this._$_isEnabled$_,
                        r: this._$_isReadOnly$_,
                        sp: this._$_spellCheck$_,
                        ml: this._$_maxLength$_,
                        type: this._$_type$_,
                        id: this._$_id$_
                    };
                }
                _$LoadFromJson$_(t) {
                    this._$_text$_ = t.t, this._$_placeholder$_ = t.p, this._$_title$_ = t.ti, 
                    this._$_isEnabled$_ = t.e, this._$_isReadOnly$_ = t.r, this._$_spellCheck$_ = t.sp, 
                    this._$_maxLength$_ = t.hasOwnProperty("ml") ? t.ml : -1, this._$_type$_ = t.type, 
                    this._$_id$_ = t.id, this._$UpdateElementState$_();
                }
                _$GetPropertyValueByIndex$_(e) {
                    switch (e) {
                      case p:
                        return this._$_text$_;

                      case q:
                        return this._$_placeholder$_;

                      case r:
                        return this._$_title$_;

                      case t:
                        return this._$_isEnabled$_;

                      case u:
                        return this._$_isReadOnly$_;

                      case v:
                        return this._$_spellCheck$_;

                      case x:
                        return this._$_autoFontSize$_;
                    }
                }
                _$SetPropertyValueByIndex$_(e, s) {
                    switch (e) {
                      case p:
                        this._$_text$_ !== s && (this._$_text$_ = s, this._$UpdateElementState$_());
                        break;

                      case q:
                        this._$_placeholder$_ !== s && (this._$_placeholder$_ = s, 
                        this._$UpdateElementState$_());
                        break;

                      case r:
                        this._$_title$_ !== s && (this._$_title$_ = s, this._$UpdateElementState$_());
                        break;

                      case t:
                        this._$_isEnabled$_ !== !!s && (this._$_isEnabled$_ = !!s, 
                        this._$UpdateElementState$_());
                        break;

                      case u:
                        this._$_isReadOnly$_ !== !!s && (this._$_isReadOnly$_ = !!s, 
                        this._$UpdateElementState$_());
                        break;

                      case v:
                        this._$_spellCheck$_ !== !!s && (this._$_spellCheck$_ = !!s, 
                        this._$UpdateElementState$_());
                        break;

                      case x:
                        this._$_autoFontSize$_ = !!s;
                    }
                }
                _$GetDebuggerProperties$_() {
                    const e = n._$Plugins$_._$TextBox$_._$Acts$_, t = "plugins.textbox";
                    return [ {
                        title: t + ".name",
                        properties: [ {
                            name: t + ".properties.text.name",
                            value: this._$_text$_,
                            _$onedit$_: t => this._$CallAction$_(e._$SetText$_, t)
                        }, {
                            name: t + ".properties.enabled.name",
                            value: this._$_isEnabled$_,
                            _$onedit$_: t => this._$CallAction$_(e._$SetEnabled$_, t)
                        }, {
                            name: t + ".properties.read-only.name",
                            value: this._$_isReadOnly$_,
                            _$onedit$_: t => this._$CallAction$_(e._$SetReadOnly$_, t)
                        } ]
                    } ];
                }
                _$GetScriptInterfaceClass$_() {
                    return self._$ITextInputInstance$_;
                }
            }, new WeakMap());
            self._$ITextInputInstance$_ = class extends self._$IDOMInstance$_ {
                constructor() {
                    super(), C.set(this, self._$IInstance$_._$_GetInitInst$_()._$GetSdkInstance$_());
                }
                set text(t) {
                    o._$RequireString$_(t), C.get(this)._$_SetText$_(t);
                }
                get text() {
                    return C.get(this)._$_GetText$_();
                }
                set placeholder(t) {
                    o._$RequireString$_(t), C.get(this)._$_SetPlaceholder$_(t);
                }
                get placeholder() {
                    return C.get(this)._$_GetPlaceholder$_();
                }
                set _$tooltip$_(t) {
                    o._$RequireString$_(t), C.get(this)._$_SetTooltip$_(t);
                }
                get _$tooltip$_() {
                    return C.get(this)._$_GetTooltip$_();
                }
                set isEnabled(t) {
                    C.get(this)._$_SetEnabled$_(t);
                }
                get isEnabled() {
                    return C.get(this)._$_IsEnabled$_();
                }
                set isReadOnly(t) {
                    C.get(this)._$_SetReadOnly$_(t);
                }
                get isReadOnly() {
                    return C.get(this)._$_IsReadOnly$_();
                }
                set maxLength(t) {
                    o._$RequireFiniteNumber$_(t), C.get(this)._$_SetMaxLength$_(t);
                }
                get maxLength() {
                    return C.get(this)._$_GetMaxLength$_();
                }
                _$scrollToBottom$_() {
                    C.get(this)._$_ScrollToBottom$_();
                }
            };
        }
        {
            const ea = self._$C3$_;
            ea._$Plugins$_._$TextBox$_._$Cnds$_ = {
                _$CompareText$_(t, e) {
                    return 0 === e ? ea._$equalsNoCase$_(this._$_text$_, t) : this._$_text$_ === t;
                },
                _$OnTextChanged$_() {
                    return !0;
                },
                _$OnClicked$_() {
                    return !0;
                },
                _$OnDoubleClicked$_() {
                    return !0;
                }
            };
        }
        {
            const ha = self._$C3$_;
            ha._$Plugins$_._$TextBox$_._$Acts$_ = {
                _$SetText$_(t) {
                    this._$_SetText$_(t.toString());
                },
                _$AppendText$_(t) {
                    "" !== t && this._$_SetText$_(this._$_GetText$_() + t);
                },
                _$SetPlaceholder$_(t) {
                    this._$_SetPlaceholder$_(t);
                },
                _$SetTooltip$_(t) {
                    this._$_SetTooltip$_(t);
                },
                _$SetReadOnly$_(t) {
                    this._$_SetReadOnly$_(0 === t);
                },
                _$ScrollToBottom$_() {
                    this._$_ScrollToBottom$_();
                },
                _$SetMaxLength$_(t) {
                    this._$_SetMaxLength$_(t);
                }
            };
        }
        {
            const oa = self._$C3$_;
            oa._$Plugins$_._$TextBox$_._$Exps$_ = {
                Text() {
                    return this._$_GetText$_();
                },
                _$MaxLength$_() {
                    return this._$_GetMaxLength$_();
                }
            };
        }
        {
            const a = self._$C3$_;
            a._$Plugins$_._$Shape3D$_ = class extends a._$SDKPluginBase$_ {
                constructor(t) {
                    super(t);
                }
                _$Release$_() {
                    super._$Release$_();
                }
            };
        }
        {
            const d = self._$C3$_;
            d._$Plugins$_._$Shape3D$_._$Type$_ = class extends d._$SDKTypeBase$_ {
                constructor(t) {
                    super(t), this._$_animations$_ = t._$GetAnimations$_();
                }
                _$Release$_() {
                    d._$clearArray$_(this._$_animations$_), super._$Release$_();
                }
                _$OnCreate$_() {
                    for (const t of this._$_animations$_) t._$LoadAllAssets$_(this._$_runtime$_);
                }
                _$LoadTextures$_(e) {
                    const s = {
                        _$sampling$_: this._$_runtime$_._$GetSampling$_()
                    };
                    return Promise.all(this._$_animations$_.map(t => t._$LoadAllTextures$_(e, s)));
                }
                _$ReleaseTextures$_() {
                    for (const t of this._$_animations$_) t._$ReleaseAllTextures$_();
                }
                _$FinishCondition$_(t) {
                    d._$Plugins$_._$Shape3D$_._$FinishCollisionCondition$_(this, t);
                }
            };
        }
        {
            let SortFacesToDrawByDist2 = function(t, e) {
                return t._$minCamDist$_ === e._$minCamDist$_ ? e._$midCamDist$_ - t._$midCamDist$_ : e._$minCamDist$_ - t._$minCamDist$_;
            }, sqDistanceTo3D2 = function(t, e, s, i, r, n) {
                const h = i - t, o = r - e, a = n - s;
                return h * h + o * o + a * a;
            }, distanceTo3D2 = function(t, e, s, i, r, n, h) {
                return m._$hypot3DFast$_(i - t, r - e, (n - s) * h);
            }, lerp3d3 = function(t, e, s, i, r, n, h) {
                return [ m._$lerp$_(t, i, h), m._$lerp$_(e, r, h), m._$lerp$_(s, n, h) ];
            }, lerp3d22 = function(t, e, s, i, r, n, h, o, a, l, u) {
                const [ c, f, d ] = lerp3d3(t, e, s, i, r, n, l);
                return lerp3d3(c, f, d, c + (h - t), f + (o - e), d + (a - s), u);
            }, m = (SortFacesToDrawByDist = SortFacesToDrawByDist2, sqDistanceTo3D = sqDistanceTo3D2, 
            distanceTo3D = distanceTo3D2, lerp3d = lerp3d3, lerp3d2 = lerp3d22, 
            self._$C3$_), n = self._$C3X$_, o = 0, p = 1, q = 2, r = 3, s = 4, t = 5, u = 6, v = 7, w = 8, x = 9, y = 10, z = 11, A = 12, B = 13, C = 14, D = 15, E = [], O = 0;
            for (let e = 0; e < 6; e++) E.push({
                i: 0,
                _$tlx$_: NaN,
                _$tly$_: NaN,
                _$tlz$_: NaN,
                trx: NaN,
                _$try_$_: NaN,
                _$trz$_: NaN,
                _$brx$_: NaN,
                _$bry$_: NaN,
                _$brz$_: NaN,
                _$blx$_: NaN,
                _$bly$_: NaN,
                _$blz$_: NaN,
                shape: 0,
                _$minCamDist$_: NaN,
                _$midCamDist$_: NaN,
                enable: !1
            });
            const G = m._$New$_(m._$Quad$_), H = m._$New$_(m._$Vector2$_), I = (m._$Plugins$_._$Shape3D$_.Instance = class extends m._$SDKWorldInstanceBase$_ {
                constructor(e, i) {
                    super(e), this._$_shape$_ = 0, this._$_zHeight$_ = 15;
                    let n = !0;
                    this._$_showBackFace$_ = !1, this._$_showFrontFace$_ = !0, this._$_showLeftFace$_ = !0, 
                    this._$_showRightFace$_ = !0, this._$_showTopFace$_ = !0, this._$_showBottomFace$_ = !0, 
                    this._$_animation$_ = this._$_objectClass$_._$GetAnimations$_()[0], 
                    this._$_faceVisibility$_ = [ !1, !0, !0, !0, !0, !0 ], this._$_faceImages$_ = [ 0, 1, 2, 3, 4, 5 ], 
                    this._$_zTilingFactor$_ = 8, this._$_faceObjects$_ = [ null, null, null, null, null, null ], 
                    i && (this._$_shape$_ = i[o], this._$_zHeight$_ = i[p], n = !!i[q], 
                    this._$_faceVisibility$_[0] = !!i[r], this._$_faceVisibility$_[1] = !!i[s], 
                    this._$_faceVisibility$_[2] = !!i[t], this._$_faceVisibility$_[3] = !!i[u], 
                    this._$_faceVisibility$_[4] = !!i[v], this._$_faceVisibility$_[5] = !!i[w], 
                    this._$_zTilingFactor$_ = i[x], this._$_SetFaceObjectClass$_(0, this._$_runtime$_._$GetObjectClassBySID$_(i[y])), 
                    this._$_SetFaceObjectClass$_(1, this._$_runtime$_._$GetObjectClassBySID$_(i[z])), 
                    this._$_SetFaceObjectClass$_(2, this._$_runtime$_._$GetObjectClassBySID$_(i[A])), 
                    this._$_SetFaceObjectClass$_(3, this._$_runtime$_._$GetObjectClassBySID$_(i[B])), 
                    this._$_SetFaceObjectClass$_(4, this._$_runtime$_._$GetObjectClassBySID$_(i[C])), 
                    this._$_SetFaceObjectClass$_(5, this._$_runtime$_._$GetObjectClassBySID$_(i[D])));
                    const h = this._$GetWorldInfo$_(), a = (h._$SetDepth$_(this._$_zHeight$_), 
                    this._$_bquadRef$_ = h._$GetBoundingQuad$_(), h._$SetVisible$_(n), 
                    this._$GetBaseAnimationFrame$_());
                    h._$SetOriginX$_(a._$GetOriginX$_()), h._$SetOriginY$_(a._$GetOriginY$_()), 
                    h._$SetBboxChanged$_();
                }
                _$Release$_() {
                    super._$Release$_();
                }
                _$GetBaseAnimationFrame$_() {
                    return this._$_animation$_._$GetFrameAt$_(0);
                }
                _$GetCurrentImageInfo$_() {
                    return this._$GetBaseAnimationFrame$_()._$GetImageInfo$_();
                }
                _$IsOriginalSizeKnown$_() {
                    return !0;
                }
                _$_AddFaceToDraw$_(t, e, s, i, r, n, h, o, a, l, u, c, f, d) {
                    const p = E[t];
                    p.i = t, p._$tlx$_ = e, p._$tly$_ = s, p._$tlz$_ = i, p.trx = r, 
                    p._$try_$_ = n, p._$trz$_ = h, p._$brx$_ = o, p._$bry$_ = a, 
                    p._$brz$_ = l, p._$blx$_ = u, p._$bly$_ = c, p._$blz$_ = f, 
                    p.shape = d, p.enable = !0, O++;
                }
                _$Draw$_(c) {
                    let f = this._$GetWorldInfo$_(), t = this._$_faceVisibility$_, d = t[0], p = t[1], m = t[2], C = t[3], g = t[4], S = t[5];
                    if (f._$IsDrawBackFaceOnly$_() ? (p = !1, m = !1, C = !1, g = !1, 
                    S = !1) : f._$IsDrawNonBackFacesOnly$_() && (d = !1), d || p || m || C || g || S) {
                        let t = this._$_bquadRef$_, e = (t = this._$_runtime$_._$IsPixelRoundingEnabled$_() ? f._$PixelRoundQuad$_(t) : t)._$getTlx$_(), s = t._$getTly$_(), i = t._$getTrx$_(), r = t._$getTry$_(), n = t._$getBrx$_(), h = t._$getBry$_(), o = t._$getBlx$_(), a = t._$getBly$_(), l = this._$_shape$_, u = this._$_zHeight$_;
                        for (let t = O = 0; t < 6; t++) E[t].enable = !1;
                        if (d && this._$_AddFaceToDraw$_(0, e, s, 0, i, r, 0, n, h, 0, o, a, 0, 0), 
                        0 === l) m && this._$_AddFaceToDraw$_(2, e, s, u, o, a, u, o, a, 0, e, s, 0, 0), 
                        C && this._$_AddFaceToDraw$_(3, n, h, u, i, r, u, i, r, 0, n, h, 0, 0), 
                        g && this._$_AddFaceToDraw$_(4, i, r, u, e, s, u, e, s, 0, i, r, 0, 0), 
                        S && this._$_AddFaceToDraw$_(5, o, a, u, n, h, u, n, h, 0, o, a, 0, 0), 
                        p && this._$_AddFaceToDraw$_(1, e, s, u, i, r, u, n, h, u, o, a, u, 0); else if (1 === l) {
                            const T = (e + o) / 2, y = (s + a) / 2, A = (i + n) / 2, I = (r + h) / 2;
                            m && this._$_AddFaceToDraw$_(2, T, y, u, T, y, u, o, a, 0, e, s, 0, 4), 
                            C && this._$_AddFaceToDraw$_(3, A, I, u, A, I, u, i, r, 0, n, h, 0, 4), 
                            g && this._$_AddFaceToDraw$_(4, A, I, u, T, y, u, e, s, 0, i, r, 0, 0), 
                            S && this._$_AddFaceToDraw$_(5, T, y, u, A, I, u, n, h, 0, o, a, 0, 0);
                        } else if (2 === l) m && this._$_AddFaceToDraw$_(2, i, r, u, n, h, u, o, a, 0, e, s, 0, 0), 
                        C && this._$_AddFaceToDraw$_(3, n, h, u, i, r, u, i, r, 0, n, h, 0, 0), 
                        g && this._$_AddFaceToDraw$_(4, i, r, u, i, r, u, e, s, 0, i, r, 0, 2), 
                        S && this._$_AddFaceToDraw$_(5, n, h, u, n, h, u, n, h, 0, o, a, 0, 3); else if (3 === l) {
                            const M = t._$midX$_(), w = t._$midY$_();
                            m && this._$_AddFaceToDraw$_(2, M, w, u, M, w, u, o, a, 0, e, s, 0, 4), 
                            C && this._$_AddFaceToDraw$_(3, M, w, u, M, w, u, i, r, 0, n, h, 0, 4), 
                            g && this._$_AddFaceToDraw$_(4, M, w, u, M, w, u, e, s, 0, i, r, 0, 4), 
                            S && this._$_AddFaceToDraw$_(5, M, w, u, M, w, u, n, h, 0, o, a, 0, 4);
                        } else 4 === l ? (m && this._$_AddFaceToDraw$_(2, i, r, u, i, r, u, o, a, 0, e, s, 0, 2), 
                        C && this._$_AddFaceToDraw$_(3, i, r, u, i, r, u, i, r, 0, n, h, 0, 3), 
                        g && this._$_AddFaceToDraw$_(4, i, r, u, i, r, u, e, s, 0, i, r, 0, 2), 
                        S && this._$_AddFaceToDraw$_(5, i, r, u, i, r, u, n, h, 0, o, a, 0, 3)) : 5 === l && (m && this._$_AddFaceToDraw$_(2, e, s, u, e, s, u, o, a, 0, e, s, 0, 2), 
                        C && this._$_AddFaceToDraw$_(3, n, h, u, i, r, u, i, r, 0, n, h, 0, 0), 
                        g && this._$_AddFaceToDraw$_(4, i, r, u, e, s, u, e, s, 0, i, r, 0, 0), 
                        S && this._$_AddFaceToDraw$_(5, n, h, u, n, h, u, n, h, 0, o, a, 0, 3), 
                        p) && this._$_AddFaceToDraw$_(1, e, s, u, i, r, u, n, h, u, o, a, 0, 1);
                        if (1 < O) {
                            const [ v, R, b ] = f._$GetLayer$_()._$GetCameraPosition$_();
                            for (let t = 0; t < 6; ++t) {
                                const G = E[t];
                                G.enable && (G._$minCamDist$_ = Math.min(sqDistanceTo3D2(v, R, b, G._$tlx$_, G._$tly$_, G._$tlz$_), sqDistanceTo3D2(v, R, b, G.trx, G._$try_$_, G._$trz$_), sqDistanceTo3D2(v, R, b, G._$brx$_, G._$bry$_, G._$brz$_), sqDistanceTo3D2(v, R, b, G._$blx$_, G._$bly$_, G._$blz$_)), 
                                G._$midCamDist$_ = sqDistanceTo3D2(v, R, b, (G._$tlx$_ + G.trx + G._$brx$_ + G._$blx$_) / 4, (G._$tly$_ + G._$try_$_ + G._$bry$_ + G._$bly$_) / 4, (G._$tlz$_ + G._$trz$_ + G._$brz$_ + G._$blz$_) / 4));
                            }
                            E.sort(SortFacesToDrawByDist2);
                        }
                        const _ = c._$GetProgram$_();
                        for (let t = 0; t < 6; ++t) {
                            const x = E[t];
                            x.enable && (c._$SetProgram$_(_), this._$_DrawFace$_(c, x.i, x._$tlx$_, x._$tly$_, x._$tlz$_, x.trx, x._$try_$_, x._$trz$_, x._$brx$_, x._$bry$_, x._$brz$_, x._$blx$_, x._$bly$_, x._$blz$_, x.shape));
                        }
                    }
                }
                _$_DrawFace$_(T, t, y, E, A, I, M, w, e, s, i, v, R, b, r) {
                    let n = null, h = null, o = !1, a = this._$_faceObjects$_[t];
                    if (null !== a) {
                        const l = a._$GetPairedInstance$_(this._$GetInstance$_());
                        if (!l) return;
                        const u = l._$GetSdkInstance$_();
                        if (m._$Plugins$_._$Sprite$_ && u instanceof m._$Plugins$_._$Sprite$_.Instance) {
                            if (null === (n = u._$GetTexture$_())) return;
                            h = u._$GetTexQuad$_();
                        } else {
                            if (!(m._$Plugins$_._$TiledBg$_ && u instanceof m._$Plugins$_._$TiledBg$_.Instance || m._$Plugins$_._$NinePatch$_ && u instanceof m._$Plugins$_._$NinePatch$_.Instance)) return;
                            {
                                let S = 0, _ = 0, t = this._$_zTilingFactor$_;
                                switch (r) {
                                  case 0:
                                  case 1:
                                    S = distanceTo3D2(y, E, A, I, M, w, t), _ = distanceTo3D2(I, M, w, e, s, i, t);
                                    break;

                                  case 2:
                                    S = distanceTo3D2(v, R, b, e, s, i, t), _ = distanceTo3D2(y, E, A, v, R, b, t);
                                    break;

                                  case 3:
                                    S = distanceTo3D2(v, R, b, e, s, i, t), _ = distanceTo3D2(I, M, w, e, s, i, t);
                                    break;

                                  case 4:
                                    S = distanceTo3D2(v, R, b, e, s, i, t), _ = distanceTo3D2(y, E, A, (v + e) / 2, (R + s) / 2, (b + i) / 2, t);
                                }
                                if (!(m._$Plugins$_._$TiledBg$_ && u instanceof m._$Plugins$_._$TiledBg$_.Instance)) return 0 !== r ? void 0 : (u._$_Set3DCallback$_((t, e) => {
                                    t._$divide$_(S, _);
                                    const s = t._$getLeft$_(), i = t._$getTop$_(), r = t._$getRight$_(), n = t._$getBottom$_(), [ h, o, a ] = lerp3d22(y, E, A, I, M, w, v, R, b, s, i), [ l, u, c ] = lerp3d22(y, E, A, I, M, w, v, R, b, r, i), [ f, d, p ] = lerp3d22(y, E, A, I, M, w, v, R, b, r, n), [ m, C, g ] = lerp3d22(y, E, A, I, M, w, v, R, b, s, n);
                                    T._$Quad3D$_(h, o, a, l, u, c, f, d, p, m, C, g, e);
                                }), u._$_Draw$_(T, 0, 0, S, _), void u._$_Set3DCallback$_(null));
                                if (null === (n = u._$GetTexture$_())) return;
                                u._$CalculateTextureCoordsFor3DFace$_(S, _, G), 
                                o = !0, u._$SetTilingShaderProgram$_(T, !1);
                            }
                        }
                    } else {
                        t = this._$_faceImages$_[t];
                        const c = this._$_animation$_._$GetFrameAt$_(t), f = c._$GetImageInfo$_();
                        if (null === (n = f._$GetTexture$_())) return;
                        h = f._$GetTexQuad$_();
                    }
                    T._$SetTexture$_(n), 3 <= r || o ? (o || G._$copy$_(h), 3 === r ? (G._$setTlx$_(G._$getTrx$_()), 
                    G._$setTly$_(G._$getTly$_())) : 4 === r && (G._$setTlx$_((G._$getTlx$_() + G._$getTrx$_()) / 2), 
                    G._$setTly$_((G._$getTly$_() + G._$getTry$_()) / 2)), T._$Quad3D2$_(y, E, A, I, M, w, e, s, i, v, R, b, G)) : T._$Quad3D2$_(y, E, A, I, M, w, e, s, i, v, R, b, h);
                }
                _$MustPreDraw$_() {
                    for (const t of this._$_faceObjects$_) if (t) {
                        const e = t._$GetPairedInstance$_(this._$GetInstance$_());
                        if (e) {
                            const s = e._$GetSdkInstance$_();
                            if (m._$Plugins$_._$TiledBg$_ && s instanceof m._$Plugins$_._$TiledBg$_.Instance && s._$_IsTileRandomizationEnabled$_()) return !0;
                        }
                    }
                    return !1;
                }
                _$RendersToOwnZPlane$_() {
                    return this._$_IsFaceVisible$_(0);
                }
                _$GetImagePointCount$_() {
                    return this._$_GetFaceImagePointCount$_(0);
                }
                _$GetImagePoint$_(t) {
                    return this._$_GetFaceImagePoint$_(0, t);
                }
                _$_GetFaceQuad3DForImagePoint$_(r) {
                    const t = this._$_bquadRef$_, n = t._$getTlx$_(), h = t._$getTly$_(), o = t._$getTrx$_(), a = t._$getTry$_(), l = t._$getBrx$_(), u = t._$getBry$_(), c = t._$getBlx$_(), f = t._$getBly$_(), d = this._$_shape$_, p = this._$GetWorldInfo$_()._$GetTotalZElevation$_(), m = p + this._$_zHeight$_;
                    if (1 === d || 3 === d) {
                        let t = (n + c) / 2, e = (h + f) / 2, s = (o + l) / 2, i = (a + u) / 2;
                        switch (r) {
                          case 4:
                            return [ s, i, m, t, e, m, n, h, p, o, a, p ];

                          case 5:
                            return [ t, e, m, s, i, m, l, u, p, c, f, p ];
                        }
                        if (3 === d) switch (t = (n + o) / 2, e = (h + a) / 2, s = (c + l) / 2, 
                        i = (f + u) / 2, r) {
                          case 2:
                            return [ t, e, m, s, i, m, c, f, p, n, h, p ];

                          case 3:
                            return [ s, i, m, t, e, m, o, a, p, l, u, p ];
                        }
                    } else if (2 === d && 2 === r) return [ o, a, m, l, u, m, c, f, p, n, h, p ];
                    switch (r) {
                      case 0:
                        return [ n, h, p, o, a, p, l, u, p, c, f, p ];

                      case 1:
                        return [ n, h, m, o, a, m, l, u, m, c, f, m ];

                      case 2:
                        return [ n, h, m, c, f, m, c, f, p, n, h, p ];

                      case 3:
                        return [ l, u, m, o, a, m, o, a, p, l, u, p ];

                      case 4:
                        return [ o, a, m, n, h, m, n, h, p, o, a, p ];

                      case 5:
                        return [ c, f, m, l, u, m, l, u, p, c, f, p ];

                      default:
                        return [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ];
                    }
                }
                _$_GetFaceImagePoint$_(t, e) {
                    const s = this._$GetWorldInfo$_();
                    if ((t = Math.floor(t)) < 0 || 5 < t) return [ s._$GetX$_(), s._$GetY$_(), s._$GetZElevation$_() ];
                    let i = this._$_animation$_._$GetFrameAt$_(t), r = null, n = ("string" == typeof e ? r = i._$GetImagePointByName$_(e) : "number" == typeof e && (r = i._$GetImagePointByIndex$_(e - 1)), 
                    .5), h = .5;
                    r ? (n = r._$GetX$_(), h = r._$GetY$_()) : 0 === t && (n = i._$GetOriginX$_(), 
                    h = i._$GetOriginY$_()), s._$GetBoundingBox$_();
                    const o = this._$_GetFaceQuad3DForImagePoint$_(t);
                    return lerp3d22(o[0], o[1], o[2], o[3], o[4], o[5], o[9], o[10], o[11], n, h);
                }
                _$_GetFaceImagePointCount$_(t) {
                    if (this._$GetWorldInfo$_(), (t = Math.floor(t)) < 0 || 5 < t) return 0;
                    const e = this._$_animation$_._$GetFrameAt$_(t);
                    return e._$GetImagePointCount$_();
                }
                _$_SetShape$_(t) {
                    this._$_shape$_ !== t && (this._$_shape$_ = t, this._$_runtime$_._$UpdateRender$_());
                }
                _$_GetShape$_() {
                    return this._$_shape$_;
                }
                _$_SetZHeight$_(t) {
                    t = Math.max(t, 0), this._$_zHeight$_ !== t && (this._$_zHeight$_ = t, 
                    this._$GetWorldInfo$_()._$SetDepth$_(t), this._$_runtime$_._$UpdateRender$_());
                }
                _$_GetZHeight$_() {
                    return this._$_zHeight$_;
                }
                _$_SetFaceVisible$_(t, e) {
                    this._$_faceVisibility$_[t] !== (e = !!e) && (this._$_faceVisibility$_[t] = e, 
                    this._$_runtime$_._$UpdateRender$_());
                }
                _$_IsFaceVisible$_(t) {
                    return this._$_faceVisibility$_[t];
                }
                _$_SetFaceImage$_(t, e) {
                    const s = this._$_faceImages$_, i = this._$_faceObjects$_;
                    s[t] === e && null === i[t] || (s[t] = e, i[t] = null, this._$_runtime$_._$UpdateRender$_());
                }
                _$_SetFaceObjectClass$_(t, e) {
                    null !== e && e._$IsFamily$_() && (e = e._$GetFamilyMembers$_()[0]);
                    const s = this._$_faceObjects$_;
                    s[t] !== e && (s[t] = e, this._$_runtime$_._$UpdateRender$_());
                }
                _$_SetZTilingFactor$_(t) {
                    this._$_zTilingFactor$_ !== t && (this._$_zTilingFactor$_ = t, 
                    this._$_runtime$_._$UpdateRender$_());
                }
                _$_GetZTilingFactor$_() {
                    return this._$_zTilingFactor$_;
                }
                _$SaveToJson$_() {
                    const t = {
                        s: this._$_shape$_,
                        zh: this._$_zHeight$_,
                        fv: this._$_faceVisibility$_,
                        fi: this._$_faceImages$_,
                        fo: this._$_faceObjects$_.map(t => t ? t._$GetSID$_() : -1),
                        zf: this._$_zTilingFactor$_
                    };
                    return t;
                }
                _$LoadFromJson$_(t) {
                    this._$_shape$_ = t.s, this._$_zHeight$_ = t.zh, this._$GetWorldInfo$_()._$SetDepth$_(this._$_zHeight$_), 
                    this._$_faceVisibility$_ = t.fv.slice(0), this._$_faceImages$_ = t.fi.slice(0), 
                    t.hasOwnProperty("fo") && (this._$_faceObjects$_ = t.fo.map(t => this._$_runtime$_._$GetObjectClassBySID$_(t))), 
                    t.hasOwnProperty("zf") && (this._$_zTilingFactor$_ = t.zf);
                }
                _$GetPropertyValueByIndex$_(t) {}
                _$SetPropertyValueByIndex$_(t, e) {}
                _$GetDebuggerProperties$_() {
                    const t = "plugins.shape3d";
                    return [ {
                        title: t + ".name",
                        properties: [ {
                            name: t + ".properties.z-height.name",
                            value: this._$_GetZHeight$_(),
                            _$onedit$_: t => this._$_SetZHeight$_(t)
                        } ]
                    } ];
                }
                _$GetScriptInterfaceClass$_() {
                    return self._$I3DShapeInstance$_;
                }
            }, new WeakMap()), J = [ "box", "prism", "wedge", "pyramid", "corner-out", "corner-in" ], K = [ "back", "front", "left", "right", "top", "bottom" ];
            self._$I3DShapeInstance$_ = class extends self._$IWorldInstance$_ {
                constructor() {
                    super(), I.set(this, self._$IInstance$_._$_GetInitInst$_()._$GetSdkInstance$_());
                }
                _$getImagePointCount$_() {
                    return I.get(this)._$GetImagePointCount$_();
                }
                _$getImagePointX$_(t) {
                    return this._$getImagePoint$_(t)[0];
                }
                _$getImagePointY$_(t) {
                    return this._$getImagePoint$_(t)[1];
                }
                _$getImagePoint$_(t) {
                    if ("string" != typeof t && "number" != typeof t) throw new TypeError("expected string or number");
                    return I.get(this)._$GetImagePoint$_(t);
                }
                _$getFaceImagePointCount$_(t) {
                    const e = K.indexOf(t);
                    if (e < 0) throw new Error("invalid face");
                    return I.get(this)._$_GetFaceImagePointCount$_(e);
                }
                _$getFaceImagePointX$_(t, e) {
                    return this._$getFaceImagePoint$_(t, e)[0];
                }
                _$getFaceImagePointY$_(t, e) {
                    return this._$getFaceImagePoint$_(t, e)[1];
                }
                _$getFaceImagePointZ$_(t, e) {
                    return this._$getFaceImagePoint$_(t, e)[2];
                }
                _$getFaceImagePoint$_(t, e) {
                    const s = K.indexOf(t);
                    if (s < 0) throw new Error("invalid face");
                    if ("string" != typeof e && "number" != typeof e) throw new TypeError("expected string or number");
                    return I.get(this)._$_GetFaceImagePoint$_(s, e);
                }
                set _$zHeight$_(t) {
                    n._$RequireFiniteNumber$_(t), I.get(this)._$_SetZHeight$_(t);
                }
                get _$zHeight$_() {
                    return I.get(this)._$_GetZHeight$_();
                }
                set shape(t) {
                    n._$RequireString$_(t);
                    const e = J.indexOf(t);
                    if (-1 === e) throw new TypeError("invalid shape");
                    I.get(this)._$_SetShape$_(e);
                }
                get shape() {
                    return J[I.get(this)._$_GetShape$_()];
                }
                _$setFaceVisible$_(t, e) {
                    const s = K.indexOf(t);
                    if (s < 0) throw new Error("invalid face");
                    I.get(this)._$_SetFaceVisible$_(s, !!e);
                }
                _$isFaceVisible$_(t) {
                    const e = K.indexOf(t);
                    if (e < 0) throw new Error("invalid face");
                    return I.get(this)._$_IsFaceVisible$_(e);
                }
                _$setFaceImage$_(t, e) {
                    const s = K.indexOf(t), i = K.indexOf(e);
                    if (s < 0 || i < 0) throw new Error("invalid face");
                    I.get(this)._$_SetFaceImage$_(s, i);
                }
                get _$zTilingFactor$_() {
                    return I.get(this)._$_GetZTilingFactor$_();
                }
                set _$zTilingFactor$_(t) {
                    n._$RequireFiniteNumber$_(t), I.get(this)._$_SetZTilingFactor$_(t);
                }
                _$setFaceObject$_(t, e) {
                    const s = K.indexOf(t);
                    if (s < 0) throw new Error("invalid face");
                    const i = I.get(this), r = i._$GetRuntime$_()._$_UnwrapIObjectClass$_(e);
                    i._$_SetFaceObjectClass$_(s, r);
                }
            };
        }
        {
            const W1 = self._$C3$_;
            W1._$Plugins$_._$Shape3D$_._$Cnds$_ = {
                _$CompareShape$_(t) {
                    return this._$_GetShape$_() === t;
                },
                _$CompareZHeight$_(t, e) {
                    return W1.compare(this._$_GetZHeight$_(), t, e);
                },
                _$IsFaceVisible$_(t) {
                    return this._$_IsFaceVisible$_(t);
                }
            };
        }
        {
            const _1 = self._$C3$_;
            _1._$Plugins$_._$Shape3D$_._$Acts$_ = {
                _$SetShape$_(t) {
                    this._$_SetShape$_(t);
                },
                _$SetZHeight$_(t) {
                    this._$_SetZHeight$_(t);
                },
                _$SetFaceVisible$_(t, e) {
                    this._$_SetFaceVisible$_(t, e);
                },
                _$SetFaceImage$_(t, e) {
                    this._$_SetFaceImage$_(t, e);
                },
                _$SetZTilingFactor$_(t) {
                    this._$_SetZTilingFactor$_(t);
                },
                _$SetFaceObject$_(t, e) {
                    this._$_SetFaceObjectClass$_(t, e);
                }
            };
        }
        {
            const jc = self._$C3$_;
            jc._$Plugins$_._$Shape3D$_._$Exps$_ = {
                _$ZHeight$_() {
                    return this._$_GetZHeight$_();
                },
                _$ZTilingFactor$_() {
                    return this._$_GetZTilingFactor$_();
                },
                _$FaceImagePointX$_(t, e) {
                    return this._$_GetFaceImagePoint$_(t, e)[0];
                },
                _$FaceImagePointY$_(t, e) {
                    return this._$_GetFaceImagePoint$_(t, e)[1];
                },
                _$FaceImagePointZ$_(t, e) {
                    return this._$_GetFaceImagePoint$_(t, e)[2];
                },
                _$FaceImagePointCount$_(t) {
                    return this._$_GetFaceImagePointCount$_(t);
                }
            };
        }
        {
            const a = self._$C3$_, b = "sliderbar";
            a._$Plugins$_._$sliderbar$_ = class extends a._$SDKDOMPluginBase$_ {
                constructor(t) {
                    super(t, b), this._$AddElementMessageHandler$_("click", (t, e) => t._$_OnClick$_(e)), 
                    this._$AddElementMessageHandler$_("change", (t, e) => t._$_OnChange$_(e)), 
                    this._$AddElementMessageHandler$_("input", (t, e) => t._$_OnInput$_(e));
                }
                _$Release$_() {
                    super._$Release$_();
                }
            };
        }
        {
            const k = self._$C3$_;
            k._$Plugins$_._$sliderbar$_._$Type$_ = class extends k._$SDKTypeBase$_ {
                constructor(t) {
                    super(t);
                }
                _$Release$_() {
                    super._$Release$_();
                }
                _$OnCreate$_() {}
            };
        }
        {
            const n = self._$C3$_, o = self._$C3X$_, p = 0, q = 1, r = 2, s = 3, t = 4, u = 5, v = 6, w = 7, x = 8, y = "sliderbar", z = (n._$Plugins$_._$sliderbar$_.Instance = class extends n._$SDKDOMInstanceBase$_ {
                constructor(e, i) {
                    super(e, y), this._$_value$_ = 0, this._$_min$_ = 0, this._$_max$_ = 100, 
                    this._$_step$_ = 1, this._$_title$_ = "", this._$_isEnabled$_ = !0, 
                    this._$_id$_ = "", this._$_className$_ = "", i && (this._$_value$_ = i[p], 
                    this._$_min$_ = i[q], this._$_max$_ = i[r], this._$_step$_ = i[s], 
                    this._$_title$_ = i[t], this._$GetWorldInfo$_()._$SetVisible$_(i[u]), 
                    this._$_isEnabled$_ = i[v], this._$_id$_ = i[w], this._$_className$_ = i[x]), 
                    this._$CreateElement$_({
                        id: this._$_id$_,
                        className: this._$_className$_
                    });
                }
                _$Release$_() {
                    super._$Release$_();
                }
                _$GetElementState$_() {
                    return {
                        value: this._$_value$_,
                        min: this._$_min$_,
                        max: this._$_max$_,
                        step: this._$_step$_,
                        title: this._$_title$_,
                        isEnabled: this._$_isEnabled$_
                    };
                }
                async _$_OnClick$_(t) {
                    this._$DispatchScriptEvent$_("click", !0), await this._$TriggerAsync$_(n._$Plugins$_._$sliderbar$_._$Cnds$_._$OnClicked$_);
                }
                async _$_OnChange$_(t) {
                    this._$_value$_ = t.value, this._$DispatchScriptEvent$_("change", !0), 
                    await this._$TriggerAsync$_(n._$Plugins$_._$sliderbar$_._$Cnds$_._$OnChanged$_);
                }
                async _$_OnInput$_(t) {
                    this._$_value$_ = t.value, this._$DispatchScriptEvent$_("input", !0), 
                    await this._$TriggerAsync$_(n._$Plugins$_._$sliderbar$_._$Cnds$_._$OnChanging$_);
                }
                _$Draw$_(t) {}
                _$_SetValue$_(t) {
                    this._$_value$_ !== t && (this._$_value$_ = t, this._$UpdateElementState$_());
                }
                _$_GetValue$_() {
                    return this._$_value$_;
                }
                _$_SetMaximum$_(t) {
                    this._$_max$_ !== t && (this._$_max$_ = t, this._$UpdateElementState$_());
                }
                _$_GetMaximum$_() {
                    return this._$_max$_;
                }
                _$_SetMinimum$_(t) {
                    this._$_min$_ !== t && (this._$_min$_ = t, this._$UpdateElementState$_());
                }
                _$_GetMinimum$_() {
                    return this._$_min$_;
                }
                _$_SetTooltip$_(t) {
                    this._$_title$_ !== t && (this._$_title$_ = t, this._$UpdateElementState$_());
                }
                _$_GetTooltip$_() {
                    return this._$_title$_;
                }
                _$_SetStep$_(t) {
                    this._$_step$_ !== t && (this._$_step$_ = t, this._$UpdateElementState$_());
                }
                _$_GetStep$_() {
                    return this._$_step$_;
                }
                _$_SetEnabled$_(t) {
                    this._$_isEnabled$_ !== (t = !!t) && (this._$_isEnabled$_ = t, 
                    this._$UpdateElementState$_());
                }
                _$_IsEnabled$_() {
                    return this._$_isEnabled$_;
                }
                _$SaveToJson$_() {
                    return {
                        v: this._$_value$_,
                        min: this._$_min$_,
                        max: this._$_max$_,
                        s: this._$_step$_,
                        t: this._$_title$_,
                        e: this._$_isEnabled$_,
                        id: this._$_id$_
                    };
                }
                _$LoadFromJson$_(t) {
                    this._$_value$_ = t.v, this._$_min$_ = t.min, this._$_max$_ = t.max, 
                    this._$_step$_ = t.s, this._$_title$_ = t.t, this._$_isEnabled$_ = t.e, 
                    this._$_id$_ = t.id, this._$UpdateElementState$_();
                }
                _$GetPropertyValueByIndex$_(e) {
                    switch (e) {
                      case p:
                        return this._$_GetValue$_();

                      case q:
                        return this._$_GetMinimum$_();

                      case r:
                        return this._$_GetMaximum$_();

                      case s:
                        return this._$_GetStep$_();

                      case t:
                        return this._$_GetTooltip$_();

                      case v:
                        return this._IsEnbled();
                    }
                }
                _$SetPropertyValueByIndex$_(e, i) {
                    switch (e) {
                      case p:
                        this._$_SetValue$_(i);
                        break;

                      case q:
                        this._$_SetMinimum$_(i);
                        break;

                      case r:
                        this._$_SetMaximum$_(i);
                        break;

                      case s:
                        this._$_SetStep$_(i);
                        break;

                      case t:
                        this._$_SetTooltip$_(i);
                        break;

                      case v:
                        this._$_SetEnabled$_(i);
                    }
                }
                _$GetDebuggerProperties$_() {
                    n._$Plugins$_._$sliderbar$_._$Acts$_;
                    const t = "plugins.sliderbar";
                    return [ {
                        title: t + ".name",
                        properties: [ {
                            name: t + ".properties.value.name",
                            value: this._$_GetValue$_(),
                            _$onedit$_: t => this._$_SetValue$_(t)
                        }, {
                            name: t + ".properties.minimum.name",
                            value: this._$_GetMinimum$_(),
                            _$onedit$_: t => this._$_SetMinimum$_(t)
                        }, {
                            name: t + ".properties.maximum.name",
                            value: this._$_GetMaximum$_(),
                            _$onedit$_: t => this._$_SetMaximum$_(t)
                        }, {
                            name: t + ".properties.step.name",
                            value: this._$_GetStep$_(),
                            _$onedit$_: t => this._$_SetStep$_(t)
                        }, {
                            name: t + ".properties.enabled.name",
                            value: this._$_IsEnabled$_(),
                            _$onedit$_: t => this._$_SetEnabled$_(t)
                        } ]
                    } ];
                }
                _$GetScriptInterfaceClass$_() {
                    return self._$ISliderBarInstance$_;
                }
            }, new WeakMap());
            self._$ISliderBarInstance$_ = class extends self._$IDOMInstance$_ {
                constructor() {
                    super(), z.set(this, self._$IInstance$_._$_GetInitInst$_()._$GetSdkInstance$_());
                }
                set value(t) {
                    o._$RequireFiniteNumber$_(t), z.get(this)._$_SetValue$_(t);
                }
                get value() {
                    return z.get(this)._$_GetValue$_();
                }
                set _$maximum$_(t) {
                    o._$RequireFiniteNumber$_(t), z.get(this)._$_SetMaximum$_(t);
                }
                get _$maximum$_() {
                    return z.get(this)._$_GetMaximum$_();
                }
                set _$minimum$_(t) {
                    o._$RequireFiniteNumber$_(t), z.get(this)._$_SetMinimum$_(t);
                }
                get _$minimum$_() {
                    return z.get(this)._$_GetMinimum$_();
                }
                set step(t) {
                    o._$RequireFiniteNumber$_(t), z.get(this)._$_SetStep$_(t);
                }
                get step() {
                    return z.get(this)._$_GetStep$_();
                }
                set _$tooltip$_(t) {
                    o._$RequireString$_(t), z.get(this)._$_SetTooltip$_(t);
                }
                get _$tooltip$_() {
                    return z.get(this)._$_GetTooltip$_();
                }
                set isEnabled(t) {
                    z.get(this)._$_SetEnabled$_(t);
                }
                get isEnabled() {
                    return z.get(this)._$_IsEnabled$_();
                }
            };
        }
        {
            const da = self._$C3$_;
            da._$Plugins$_._$sliderbar$_._$Cnds$_ = {
                _$OnClicked$_() {
                    return !0;
                },
                _$OnChanged$_() {
                    return !0;
                },
                _$OnChanging$_() {
                    return !0;
                },
                _$CompareValue$_(t, e) {
                    return da.compare(this._$_GetValue$_(), t, e);
                }
            };
        }
        {
            const ga = self._$C3$_;
            ga._$Plugins$_._$sliderbar$_._$Acts$_ = {
                _$SetTooltip$_(t) {
                    this._$_SetTooltip$_(t);
                },
                _$SetValue$_(t) {
                    this._$_SetValue$_(t);
                },
                _$SetMaximum$_(t) {
                    this._$_SetMaximum$_(t);
                },
                _$SetMinimum$_(t) {
                    this._$_SetMinimum$_(t);
                },
                _$SetStep$_(t) {
                    this._$_SetStep$_(t);
                }
            };
        }
        {
            const ma = self._$C3$_;
            ma._$Plugins$_._$sliderbar$_._$Exps$_ = {
                _$Value$_() {
                    return this._$_GetValue$_();
                },
                _$Maximum$_() {
                    return this._$_GetMaximum$_();
                },
                _$Minimum$_() {
                    return this._$_GetMinimum$_();
                },
                Step() {
                    return this._$_GetStep$_();
                }
            };
        }
        {
            const a = self._$C3$_, b = [];
            a._$Plugins$_.Audio = class extends a._$SDKPluginBase$_ {
                constructor(t) {
                    super(t);
                }
                _$_AddActionPromise$_(t) {
                    b.push(t);
                }
                static async _$WaitForAllActionPromises$_() {
                    await Promise.all(b), a._$clearArray$_(b);
                }
                _$Release$_() {
                    super._$Release$_();
                }
            };
        }
        {
            let GetAudioSdkInstance2 = function() {
                return e._$GetSingleGlobalInstance$_()._$GetSdkInstance$_();
            }, GetAudioDOMInterface2 = function() {
                if (self.C3Audio_DOMInterface) return self.C3Audio_DOMInterface;
                throw new Error("audio scripting API cannot be used here - make sure the project is using DOM mode, not worker mode");
            };
            GetAudioSdkInstance = GetAudioSdkInstance2, GetAudioDOMInterface = GetAudioDOMInterface2;
            const f = self._$C3$_, g = self._$C3X$_;
            f._$Plugins$_.Audio._$Type$_ = class extends f._$SDKTypeBase$_ {
                constructor(t) {
                    super(t);
                }
                _$Release$_() {
                    super._$Release$_();
                }
                _$OnCreate$_() {}
                _$GetScriptInterfaceClass$_() {
                    return self._$IAudioObjectType$_;
                }
            };
            let e = null;
            self._$IAudioObjectType$_ = class extends self._$IObjectClass$_ {
                constructor(t) {
                    super(t), e = t;
                }
                get _$audioContext$_() {
                    return GetAudioDOMInterface2().GetAudioContextExtern();
                }
                get _$destinationNode$_() {
                    return GetAudioDOMInterface2().GetDestinationNodeExtern();
                }
                get isSilent() {
                    return GetAudioSdkInstance2()._$_IsSilent$_();
                }
                set isSilent(t) {
                    GetAudioSdkInstance2()._$_SetSilent$_(t);
                }
                get masterVolume() {
                    return GetAudioSdkInstance2()._$_GetMasterVolume$_();
                }
                set masterVolume(t) {
                    g._$RequireFiniteNumber$_(t), GetAudioSdkInstance2()._$_SetMasterVolume$_(t);
                }
                _$stopAll$_() {
                    GetAudioSdkInstance2()._$_StopAll$_();
                }
            };
        }
        {
            const o = self._$C3$_, p = "audio", q = [ "interactive", "balanced", "playback" ];
            o._$Plugins$_.Audio.Instance = class extends o._$SDKInstanceBase$_ {
                constructor(t, e) {
                    super(t, p), this._$_nextPlayTime$_ = 0, this._$_triggerTags$_ = [], 
                    this._$_enableMultiTags$_ = !0, this._$_timeScaleMode$_ = 0, 
                    this._$_saveLoadMode$_ = 0, this._$_playInBackground$_ = !1, 
                    this._$_panningModel$_ = 1, this._$_distanceModel$_ = 1, this._$_listenerPos$_ = [ this._$_runtime$_._$GetViewportWidth$_() / 2, this._$_runtime$_._$GetViewportHeight$_() / 2, 600 ], 
                    this._$_listenerForwardVec$_ = [ 0, 0, -1 ], this._$_listenerUpVec$_ = [ 0, 1, 0 ], 
                    this._$_referenceDistance$_ = 600, this._$_maxDistance$_ = 1e4, 
                    this._$_rolloffFactor$_ = 1, this._$_listenerInst$_ = null, 
                    this._$_loadListenerUid$_ = -1, this._$_masterVolume$_ = 1, 
                    this._$_isSilent$_ = !1, this._$_sampleRate$_ = 0, this._$_audioContextState$_ = "suspended", 
                    this._$_outputLatency$_ = 0, this._$_effectCount$_ = new Map(), 
                    this._$_preloadTotal$_ = 0, this._$_preloadCount$_ = 0, this._$_bufferMetadata$_ = new Map(), 
                    this._$_remoteUrls$_ = new Map();
                    let s = "interactive";
                    e && (this._$_timeScaleMode$_ = e[0], this._$_saveLoadMode$_ = e[1], 
                    this._$_playInBackground$_ = e[2], s = q[e[3]], this._$_enableMultiTags$_ = e[4], 
                    this._$_panningModel$_ = e[5], this._$_distanceModel$_ = e[6], 
                    this._$_listenerPos$_[2] = e[7], this._$_referenceDistance$_ = e[8], 
                    this._$_maxDistance$_ = e[9], this._$_rolloffFactor$_ = e[10]), 
                    this._$_lastAIState$_ = [], this._$_lastFxState$_ = [], this._$_lastAnalysersData$_ = [], 
                    this._$AddDOMMessageHandlers$_([ [ "state", t => this._$_OnUpdateState$_(t) ], [ "audiocontext-state", t => this._$_OnAudioContextStateChanged$_(t) ], [ "fxstate", t => this._$_OnUpdateFxState$_(t) ], [ "trigger", t => this._$_OnTrigger$_(t) ], [ "buffer-metadata", t => this._$_OnBufferMetadata$_(t) ] ]);
                    const i = this._$GetRuntime$_()._$Dispatcher$_(), r = (this._$_disposables$_ = new o._$CompositeDisposable$_(o._$Disposable$_._$From$_(i, "instancedestroy", t => this._$_OnInstanceDestroyed$_(t.instance)), o._$Disposable$_._$From$_(i, "afterload", () => this._$_OnAfterLoad$_()), o._$Disposable$_._$From$_(i, "suspend", () => this._$_OnSuspend$_()), o._$Disposable$_._$From$_(i, "resume", () => this._$_OnResume$_())), 
                    this._$_runtime$_._$GetExportType$_()), n = "Safari" === o._$Platform$_._$Browser$_, h = this._$_runtime$_._$IsiOSWebView$_() || "macos-wkwebview" === r, a = this._$_runtime$_._$GetAssetManager$_()._$IsFileProtocol$_(), l = "playable-ad-single-file" === this._$_runtime$_._$GetExportType$_(), u = n || h || a || l;
                    this._$_runtime$_._$AddLoadPromise$_(this._$PostToDOMAsync$_("create-audio-context", {
                        preloadList: this._$_runtime$_._$GetAssetManager$_()._$GetAudioToPreload$_().map(t => ({
                            originalUrl: t.originalUrl,
                            url: t.url,
                            type: t.type,
                            fileSize: t.fileSize
                        })),
                        timeScaleMode: this._$_timeScaleMode$_,
                        latencyHint: s,
                        panningModel: this._$_panningModel$_,
                        distanceModel: this._$_distanceModel$_,
                        refDistance: this._$_referenceDistance$_,
                        maxDistance: this._$_maxDistance$_,
                        rolloffFactor: this._$_rolloffFactor$_,
                        listenerPos: this._$_listenerPos$_,
                        usePlayMusicAsSoundWorkaround: u
                    }).then(t => {
                        this._$_sampleRate$_ = t.sampleRate, this._$_audioContextState$_ = t.audioContextState, 
                        this._$_outputLatency$_ = t.outputLatency;
                    })), this._$_StartTicking$_();
                }
                _$Release$_() {
                    this._$_listenerInst$_ = null, super._$Release$_();
                }
                _$_SplitTags$_(t) {
                    return this._$_enableMultiTags$_ ? t.split(" ").filter(t => !!t) : t ? [ t ] : [];
                }
                _$_MatchTagLists$_(e, t) {
                    for (const s of t) {
                        let t = !1;
                        for (const i of e) if (o._$equalsNoCase$_(i, s)) {
                            t = !0;
                            break;
                        }
                        if (!t) return !1;
                    }
                    return !0;
                }
                _$_MatchTagListToStr$_(t, e) {
                    return this._$_MatchTagLists$_(t, this._$_SplitTags$_(e));
                }
                _$_AddActionPromise$_(t) {
                    this._$GetPlugin$_()._$_AddActionPromise$_(t);
                }
                _$_OnInstanceDestroyed$_(t) {
                    this._$_listenerInst$_ === t && (this._$_listenerInst$_ = null);
                }
                _$DbToLinearNoCap$_(t) {
                    return Math.pow(10, t / 20);
                }
                _$DbToLinear$_(t) {
                    const e = this._$DbToLinearNoCap$_(t);
                    return isFinite(e) ? Math.max(Math.min(e, 1), 0) : 0;
                }
                _$LinearToDbNoCap$_(t) {
                    return Math.log(t) / Math.log(10) * 20;
                }
                _$LinearToDb$_(t) {
                    return this._$LinearToDbNoCap$_(Math.max(Math.min(t, 1), 0));
                }
                _$_OnSuspend$_() {
                    this._$_playInBackground$_ || this._$PostToDOM$_("set-suspended", {
                        isSuspended: !0
                    });
                }
                _$_OnResume$_() {
                    this._$_playInBackground$_ || this._$PostToDOM$_("set-suspended", {
                        isSuspended: !1
                    });
                }
                _$_OnUpdateState$_(t) {
                    const e = t.tickCount, s = (this._$_outputLatency$_ = t.outputLatency, 
                    this._$_lastAIState$_.filter(t => t.hasOwnProperty("placeholder") && (t.placeholder > e || -1 === t.placeholder)));
                    this._$_lastAIState$_ = t.audioInstances, this._$_lastAnalysersData$_ = t.analysers, 
                    0 < s.length && o._$appendArray$_(this._$_lastAIState$_, s);
                }
                _$_OnBufferMetadata$_(t) {
                    this._$_bufferMetadata$_.set(t.originalUrl, {
                        duration: t.duration
                    });
                }
                _$_OnAudioContextStateChanged$_(t) {
                    this._$_audioContextState$_ = t.audioContextState;
                }
                _$GetAudioContextState$_() {
                    return this._$_runtime$_._$IsExportToVideo$_() ? "running" : this._$_audioContextState$_;
                }
                _$_OnUpdateFxState$_(t) {
                    this._$_lastFxState$_ = t.fxstate;
                }
                _$_GetFirstAudioStateByTags$_(t) {
                    const e = this._$_SplitTags$_(t);
                    for (const s of this._$_lastAIState$_) if (this._$_MatchTagLists$_(s.tags, e)) return s;
                    return null;
                }
                _$_IsTagPlaying$_(t) {
                    const e = this._$_SplitTags$_(t);
                    return this._$_lastAIState$_.some(t => this._$_MatchTagLists$_(t.tags, e) && t.isPlaying);
                }
                _$_MaybeMarkAsPlaying$_(t, e, s, i, r) {
                    if (this._$_IsTagPlaying$_(e)) return null;
                    const n = this._$_bufferMetadata$_.get(t), h = {
                        tags: this._$_SplitTags$_(e),
                        duration: n ? n.duration : 0,
                        volume: r,
                        isPlaying: !0,
                        playbackTime: 0,
                        playbackRate: 1,
                        uid: -1,
                        bufferOriginalUrl: t,
                        bufferUrl: "",
                        bufferType: "",
                        isMusic: s,
                        isLooping: i,
                        isMuted: !1,
                        resumePosition: 0,
                        pan: null,
                        placeholder: -1
                    };
                    return this._$_lastAIState$_.push(h), h;
                }
                _$_MaybeMarkAsStopped$_(t) {
                    const e = this._$_SplitTags$_(t);
                    for (const s of this._$_lastAIState$_) this._$_MatchTagLists$_(s.tags, e) && (s.isPlaying = !1);
                }
                async _$_OnTrigger$_(t) {
                    const e = t.type, s = (this._$_triggerTags$_ = t.tags, t.aiid);
                    if ("ended" === e) {
                        for (const i of this._$_lastAIState$_) if (i.aiid === s) {
                            i.isPlaying = !1;
                            break;
                        }
                        await this._$TriggerAsync$_(o._$Plugins$_.Audio._$Cnds$_._$OnEnded$_);
                    } else "fade-ended" === e && await this._$TriggerAsync$_(o._$Plugins$_.Audio._$Cnds$_._$OnFadeEnded$_);
                }
                _$_MatchTriggerTag$_(t) {
                    return this._$_MatchTagListToStr$_(this._$_triggerTags$_, t);
                }
                _$Tick$_() {
                    const t = {
                        timeScale: this._$_runtime$_._$GetTimeScale$_(),
                        gameTime: this._$_runtime$_._$GetGameTimeRaw$_(),
                        instPans: this._$GetInstancePans$_(),
                        tickCount: this._$_runtime$_._$GetTickCountNoSave$_()
                    };
                    if (this._$_listenerInst$_) {
                        const e = this._$_listenerInst$_._$GetWorldInfo$_();
                        this._$_listenerPos$_[0] = e._$GetX$_(), this._$_listenerPos$_[1] = e._$GetY$_(), 
                        t.listenerPos = this._$_listenerPos$_, t.listenerOrientation = [ ...this._$_listenerForwardVec$_, ...this._$_listenerUpVec$_ ];
                    }
                    this._$PostToDOM$_("tick", t);
                }
                _$rotatePtAround$_(t, e, s, i, r) {
                    if (0 !== s) {
                        const n = Math.sin(s), h = Math.cos(s), o = (t -= i) * n, a = (e -= r) * n, l = t * h, u = e * h;
                        t = l - a, e = u + o, t += i, e += r;
                    }
                    return [ t, e ];
                }
                _$GetInstancePans$_() {
                    return this._$_lastAIState$_.filter(t => -1 !== t.uid).map(t => this._$_runtime$_._$GetInstanceByUID$_(t.uid)).filter(t => t).map(t => {
                        const e = t._$GetWorldInfo$_(), s = e._$GetLayer$_().GetAngle(), [ i, r ] = this._$rotatePtAround$_(e._$GetX$_(), e._$GetY$_(), -s, this._$_listenerPos$_[0], this._$_listenerPos$_[1]);
                        return {
                            uid: t._$GetUID$_(),
                            x: i,
                            y: r,
                            z: e._$GetTotalZElevation$_(),
                            angle: e.GetAngle() - s
                        };
                    });
                }
                _$GetAnalyserData$_(t, e) {
                    for (const s of this._$_lastAnalysersData$_) if (s.index === e && o._$equalsNoCase$_(s.tag, t)) return s;
                    return null;
                }
                _$_IncrementEffectCount$_(t) {
                    for (const e of this._$_SplitTags$_(t)) {
                        const s = e.toLowerCase();
                        this._$_effectCount$_.set(s, (this._$_effectCount$_.get(s) || 0) + 1);
                    }
                }
                _$_IsSilent$_() {
                    return this._$_isSilent$_;
                }
                _$_SetSilent$_(t) {
                    this._$_isSilent$_ !== (t = !!t) && (this._$_isSilent$_ = t, 
                    this._$PostToDOM$_("set-silent", {
                        isSilent: t
                    }));
                }
                _$_GetMasterVolume$_() {
                    return this._$_masterVolume$_;
                }
                _$_SetMasterVolume$_(t) {
                    this._$_masterVolume$_ !== t && (this._$_masterVolume$_ = t, 
                    this._$PostToDOM$_("set-master-volume", {
                        vol: t
                    }));
                }
                _$_StopAll$_() {
                    this._$PostToDOM$_("stop-all");
                    for (const t of this._$_lastAIState$_) t.isPlaying = !1;
                }
                _$_ShouldSave$_(t) {
                    return !t.hasOwnProperty("placeholder") && 3 !== this._$_saveLoadMode$_ && !(t.isMusic && 1 === this._$_saveLoadMode$_ || !t.isMusic && 2 === this._$_saveLoadMode$_);
                }
                _$SaveToJson$_() {
                    return {
                        isSilent: this._$_isSilent$_,
                        masterVolume: this._$_masterVolume$_,
                        listenerZ: this._$_listenerPos$_[2],
                        listenerForwardVec: this._$_listenerForwardVec$_,
                        listenerUpVec: this._$_listenerUpVec$_,
                        listenerUid: this._$_listenerInst$_ ? this._$_listenerInst$_._$GetUID$_() : -1,
                        remoteUrls: [ ...this._$_remoteUrls$_.entries() ],
                        playing: this._$_lastAIState$_.filter(t => this._$_ShouldSave$_(t)),
                        effects: this._$_lastFxState$_,
                        analysers: this._$_lastAnalysersData$_
                    };
                }
                _$LoadFromJson$_(t) {
                    if (this._$_isSilent$_ = t.isSilent, this._$_masterVolume$_ = t.masterVolume, 
                    this._$_listenerPos$_[2] = t.listenerZ, this._$_listenerInst$_ = null, 
                    this._$_loadListenerUid$_ = t.listenerUid, t.hasOwnProperty("listenerForwardVec") ? this._$_listenerForwardVec$_ = t.listenerForwardVec : this._$_listenerForwardVec$_ = [ 0, 0, -1 ], 
                    t.hasOwnProperty("listenerUpVec") ? this._$_listenerUpVec$_ = t.listenerUpVec : this._$_listenerUpVec$_ = [ 0, 1, 0 ], 
                    this._$_remoteUrls$_.clear(), t.remoteUrls) for (const [ e, s ] of t.remoteUrls) this._$_remoteUrls$_.set(e, s);
                    this._$_lastAIState$_ = t.playing;
                    for (const i of this._$_lastAIState$_) i.hasOwnProperty("tag") && !i.hasOwnProperty("tags") && (i.tags = [ i.tag ].filter(t => !!t));
                    this._$_lastFxState$_ = t.effects, this._$_lastAnalysersData$_ = t.analysers;
                }
                _$_OnAfterLoad$_() {
                    if (-1 !== this._$_loadListenerUid$_ && (this._$_listenerInst$_ = this._$_runtime$_._$GetInstanceByUID$_(this._$_loadListenerUid$_), 
                    this._$_loadListenerUid$_ = -1, this._$_listenerInst$_)) {
                        const t = this._$_listenerInst$_._$GetWorldInfo$_();
                        this._$_listenerPos$_[0] = t._$GetX$_(), this._$_listenerPos$_[1] = t._$GetY$_();
                    }
                    for (const e of this._$_lastAIState$_) {
                        const s = this._$_runtime$_._$GetAssetManager$_()._$GetProjectAudioFileUrl$_(e.bufferOriginalUrl);
                        s ? (e.bufferUrl = s.url, e.bufferType = s.type) : e.bufferUrl = null;
                    }
                    for (const i of Object.values(this._$_lastFxState$_)) for (const r of i) if (r.hasOwnProperty("bufferOriginalUrl")) {
                        const n = this._$_runtime$_._$GetAssetManager$_()._$GetProjectAudioFileUrl$_(r.bufferOriginalUrl);
                        n && (r.bufferUrl = n.url, r.bufferType = n.type);
                    }
                    this._$PostToDOM$_("load-state", {
                        saveLoadMode: this._$_saveLoadMode$_,
                        timeScale: this._$_runtime$_._$GetTimeScale$_(),
                        gameTime: this._$_runtime$_._$GetGameTimeRaw$_(),
                        listenerPos: this._$_listenerPos$_,
                        listenerOrientation: [ ...this._$_listenerForwardVec$_, ...this._$_listenerUpVec$_ ],
                        isSilent: this._$_isSilent$_,
                        masterVolume: this._$_masterVolume$_,
                        playing: this._$_lastAIState$_.filter(t => null !== t.bufferUrl),
                        effects: this._$_lastFxState$_
                    });
                }
                _$GetDebuggerProperties$_() {
                    const t = [];
                    for (const [ s, i ] of Object.entries(this._$_lastFxState$_)) t.push({
                        name: "$" + s,
                        value: i.map(t => t.type).join(", ")
                    });
                    const e = "plugins.audio.debugger";
                    return [ {
                        title: e + ".tag-effects",
                        properties: t
                    }, {
                        title: e + ".currently-playing",
                        properties: [ {
                            name: e + ".currently-playing-count",
                            value: this._$_lastAIState$_.length
                        }, ...this._$_lastAIState$_.map((t, e) => ({
                            name: "$#" + e,
                            value: `${t.bufferOriginalUrl} ("${t.tags}") ${Math.round(10 * t.playbackTime) / 10} / ` + Math.round(10 * t.duration) / 10
                        })) ]
                    } ];
                }
            };
        }
        {
            const x0 = self._$C3$_;
            x0._$Plugins$_.Audio._$Cnds$_ = {
                _$OnEnded$_(t) {
                    return this._$_MatchTriggerTag$_(t);
                },
                _$OnFadeEnded$_(t) {
                    return this._$_MatchTriggerTag$_(t);
                },
                _$PreloadsComplete$_() {
                    return this._$_preloadCount$_ === this._$_preloadTotal$_;
                },
                _$AdvancedAudioSupported$_() {
                    return !0;
                },
                _$IsSilent$_() {
                    return this._$_IsSilent$_();
                },
                _$IsAnyPlaying$_() {
                    for (const t of this._$_lastAIState$_) if (t.isPlaying) return !0;
                    return !1;
                },
                _$IsTagPlaying$_(t) {
                    return this._$_IsTagPlaying$_(t);
                }
            };
        }
        {
            const C0 = self._$C3$_, D0 = [ "lowpass", "highpass", "bandpass", "lowshelf", "highshelf", "peaking", "notch", "allpass" ];
            C0._$Plugins$_.Audio._$Acts$_ = {
                Play(t, e, s, i, r) {
                    const n = C0._$Plugins$_.Audio._$Acts$_._$_DoPlay$_.call(this, t, e, s, i, r);
                    return this._$_AddActionPromise$_(n), n;
                },
                _$PlayFromTimeline$_(t, e, s, i) {
                    C0._$Plugins$_.Audio._$Acts$_._$_DoPlay$_.call(this, t, 0, e, 0, s, i);
                },
                async _$_DoPlay$_(t, e, s, i, r, n) {
                    if (!this._$_isSilent$_) {
                        const h = t[1], o = this._$_runtime$_._$GetAssetManager$_()._$GetProjectAudioFileUrl$_(t[0]);
                        if (o) {
                            const a = this._$_nextPlayTime$_, l = (this._$_nextPlayTime$_ = 0, 
                            this._$_MaybeMarkAsPlaying$_(t[0], r, h, 0 !== e, this._$DbToLinear$_(s)));
                            try {
                                await this._$PostToDOMAsync$_("play", {
                                    originalUrl: t[0],
                                    url: o.url,
                                    type: o.type,
                                    isMusic: h,
                                    tags: this._$_SplitTags$_(r),
                                    isLooping: 0 !== e,
                                    vol: this._$DbToLinear$_(s),
                                    stereoPan: C0._$clamp$_(i / 100, -1, 1),
                                    pos: n || 0,
                                    off: a,
                                    trueClock: !!self.C3_GetAudioContextCurrentTime
                                });
                            } finally {
                                l && (l.placeholder = this._$_runtime$_._$GetTickCountNoSave$_());
                            }
                        }
                    }
                },
                async _$PlayAtPosition$_(t, e, s, i, r, n, h, o, a, l, u) {
                    if (!this._$_isSilent$_) {
                        const c = t[1], f = this._$_runtime$_._$GetAssetManager$_()._$GetProjectAudioFileUrl$_(t[0]);
                        if (f) {
                            const d = this._$_nextPlayTime$_, p = (this._$_nextPlayTime$_ = 0, 
                            this._$_MaybeMarkAsPlaying$_(t[0], u, c, 0 !== e, this._$DbToLinear$_(s)));
                            try {
                                await this._$PostToDOMAsync$_("play", {
                                    originalUrl: t[0],
                                    url: f.url,
                                    type: f.type,
                                    isMusic: c,
                                    tags: this._$_SplitTags$_(u),
                                    isLooping: 0 !== e,
                                    vol: this._$DbToLinear$_(s),
                                    pos: 0,
                                    off: d,
                                    trueClock: !!self.C3_GetAudioContextCurrentTime,
                                    panning: {
                                        x: i,
                                        y: r,
                                        z: n,
                                        angle: C0._$toRadians$_(h),
                                        innerAngle: C0._$toRadians$_(o),
                                        outerAngle: C0._$toRadians$_(a),
                                        outerGain: this._$DbToLinear$_(l)
                                    }
                                });
                            } finally {
                                p && (p.placeholder = this._$_runtime$_._$GetTickCountNoSave$_());
                            }
                        }
                    }
                },
                async _$PlayAtObject$_(t, e, s, i, r, n, h, o) {
                    if (!this._$_isSilent$_ && i) {
                        const a = i._$GetFirstPicked$_();
                        if (a && a._$GetWorldInfo$_()) {
                            const l = a._$GetWorldInfo$_(), u = l._$GetLayer$_().GetAngle(), [ c, f ] = this._$rotatePtAround$_(l._$GetX$_(), l._$GetY$_(), -u, this._$_listenerPos$_[0], this._$_listenerPos$_[1]), d = t[1], p = this._$_runtime$_._$GetAssetManager$_()._$GetProjectAudioFileUrl$_(t[0]);
                            if (p) {
                                const m = this._$_nextPlayTime$_, C = (this._$_nextPlayTime$_ = 0, 
                                this._$_MaybeMarkAsPlaying$_(t[0], o, d, 0 !== e, this._$DbToLinear$_(s)));
                                try {
                                    await this._$PostToDOMAsync$_("play", {
                                        originalUrl: t[0],
                                        url: p.url,
                                        type: p.type,
                                        isMusic: d,
                                        tags: this._$_SplitTags$_(o),
                                        isLooping: 0 !== e,
                                        vol: this._$DbToLinear$_(s),
                                        pos: 0,
                                        off: m,
                                        trueClock: !!self.C3_GetAudioContextCurrentTime,
                                        panning: {
                                            x: c,
                                            y: f,
                                            z: l._$GetTotalZElevation$_(),
                                            angle: l.GetAngle() - u,
                                            innerAngle: C0._$toRadians$_(r),
                                            outerAngle: C0._$toRadians$_(n),
                                            outerGain: this._$DbToLinear$_(h),
                                            uid: a._$GetUID$_()
                                        }
                                    });
                                } finally {
                                    C && (C.placeholder = this._$_runtime$_._$GetTickCountNoSave$_());
                                }
                            }
                        }
                    }
                },
                async _$PlayByName$_(t, e, s, i, r, n) {
                    if (!this._$_isSilent$_) {
                        const h = 1 === t, o = this._$_runtime$_._$GetAssetManager$_()._$GetProjectAudioFileUrl$_(e) || this._$_remoteUrls$_.get(e.toLowerCase());
                        if (o) {
                            const a = this._$_nextPlayTime$_, l = (this._$_nextPlayTime$_ = 0, 
                            this._$_MaybeMarkAsPlaying$_(e, n, h, 0 !== s, this._$DbToLinear$_(i)));
                            try {
                                await this._$PostToDOMAsync$_("play", {
                                    originalUrl: e,
                                    url: o.url,
                                    type: o.type,
                                    isMusic: h,
                                    tags: this._$_SplitTags$_(n),
                                    isLooping: 0 !== s,
                                    vol: this._$DbToLinear$_(i),
                                    stereoPan: C0._$clamp$_(r / 100, -1, 1),
                                    pos: 0,
                                    off: a,
                                    trueClock: !!self.C3_GetAudioContextCurrentTime
                                });
                            } finally {
                                l && (l.placeholder = this._$_runtime$_._$GetTickCountNoSave$_());
                            }
                        }
                    }
                },
                async _$PlayAtPositionByName$_(t, e, s, i, r, n, h, o, a, l, u, c) {
                    if (!this._$_isSilent$_) {
                        const f = 1 === t, d = this._$_runtime$_._$GetAssetManager$_()._$GetProjectAudioFileUrl$_(e) || this._$_remoteUrls$_.get(e.toLowerCase());
                        if (d) {
                            const p = this._$_nextPlayTime$_, m = (this._$_nextPlayTime$_ = 0, 
                            this._$_MaybeMarkAsPlaying$_(e, c, f, 0 !== s, this._$DbToLinear$_(i)));
                            try {
                                await this._$PostToDOMAsync$_("play", {
                                    originalUrl: e,
                                    url: d.url,
                                    type: d.type,
                                    isMusic: f,
                                    tags: this._$_SplitTags$_(c),
                                    isLooping: 0 !== s,
                                    vol: this._$DbToLinear$_(i),
                                    pos: 0,
                                    off: p,
                                    trueClock: !!self.C3_GetAudioContextCurrentTime,
                                    panning: {
                                        x: r,
                                        y: n,
                                        z: h,
                                        angle: C0._$toRadians$_(o),
                                        innerAngle: C0._$toRadians$_(a),
                                        outerAngle: C0._$toRadians$_(l),
                                        outerGain: this._$DbToLinear$_(u)
                                    }
                                });
                            } finally {
                                m && (m.placeholder = this._$_runtime$_._$GetTickCountNoSave$_());
                            }
                        }
                    }
                },
                async _$PlayAtObjectByName$_(t, e, s, i, r, n, h, o, a) {
                    if (!this._$_isSilent$_ && !this._$_isSilent$_ && r) {
                        const l = r._$GetFirstPicked$_();
                        if (l && l._$GetWorldInfo$_()) {
                            const u = l._$GetWorldInfo$_(), c = u._$GetLayer$_().GetAngle(), [ f, d ] = this._$rotatePtAround$_(u._$GetX$_(), u._$GetY$_(), -c, this._$_listenerPos$_[0], this._$_listenerPos$_[1]), p = 1 === t, m = this._$_runtime$_._$GetAssetManager$_()._$GetProjectAudioFileUrl$_(e) || this._$_remoteUrls$_.get(e.toLowerCase());
                            if (m) {
                                const C = this._$_nextPlayTime$_, g = (this._$_nextPlayTime$_ = 0, 
                                this._$_MaybeMarkAsPlaying$_(e, a, p, 0 !== s, this._$DbToLinear$_(i)));
                                try {
                                    await this._$PostToDOMAsync$_("play", {
                                        originalUrl: e,
                                        url: m.url,
                                        type: m.type,
                                        isMusic: p,
                                        tags: this._$_SplitTags$_(a),
                                        isLooping: 0 !== s,
                                        vol: this._$DbToLinear$_(i),
                                        pos: 0,
                                        off: C,
                                        trueClock: !!self.C3_GetAudioContextCurrentTime,
                                        panning: {
                                            x: f,
                                            y: d,
                                            z: u._$GetTotalZElevation$_(),
                                            angle: u.GetAngle() - c,
                                            innerAngle: C0._$toRadians$_(n),
                                            outerAngle: C0._$toRadians$_(h),
                                            outerGain: this._$DbToLinear$_(o),
                                            uid: l._$GetUID$_()
                                        }
                                    });
                                } finally {
                                    g && (g.placeholder = this._$_runtime$_._$GetTickCountNoSave$_());
                                }
                            }
                        }
                    }
                },
                _$SetLooping$_(t, e) {
                    this._$PostToDOM$_("set-looping", {
                        tags: this._$_SplitTags$_(t),
                        isLooping: 0 === e
                    });
                },
                _$SetMuted$_(t, e) {
                    this._$PostToDOM$_("set-muted", {
                        tags: this._$_SplitTags$_(t),
                        isMuted: 0 === e
                    });
                },
                _$SetVolume$_(t, e) {
                    this._$PostToDOM$_("set-volume", {
                        tags: this._$_SplitTags$_(t),
                        vol: this._$DbToLinear$_(e)
                    });
                },
                _$FadeVolume$_(t, e, s, i) {
                    this._$PostToDOM$_("fade-volume", {
                        tags: this._$_SplitTags$_(t),
                        vol: this._$DbToLinear$_(e),
                        duration: s,
                        stopOnEnd: 0 === i
                    });
                },
                _$SetStereoPan$_(t, e) {
                    this._$PostToDOM$_("set-stereo-pan", {
                        tags: this._$_SplitTags$_(t),
                        p: C0._$clamp$_(e / 100, -1, 1)
                    });
                },
                async _$Preload$_(t) {
                    const e = t[1], s = this._$_runtime$_._$GetAssetManager$_()._$GetProjectAudioFileUrl$_(t[0]);
                    s && (this._$_preloadTotal$_++, await this._$PostToDOMAsync$_("preload", {
                        originalUrl: t[0],
                        url: s.url,
                        type: s.type,
                        isMusic: e
                    }), this._$_preloadCount$_++);
                },
                async _$PreloadByName$_(t, e) {
                    const s = 1 === t, i = this._$_runtime$_._$GetAssetManager$_()._$GetProjectAudioFileUrl$_(e) || this._$_remoteUrls$_.get(e.toLowerCase());
                    i && (this._$_preloadTotal$_++, await this._$PostToDOMAsync$_("preload", {
                        originalUrl: e,
                        url: i.url,
                        type: i.type,
                        isMusic: s
                    }), this._$_preloadCount$_++);
                },
                _$SetPlaybackRate$_(t, e) {
                    this._$PostToDOM$_("set-playback-rate", {
                        tags: this._$_SplitTags$_(t),
                        rate: Math.max(e, 0)
                    });
                },
                _$Stop$_(t) {
                    this._$_MaybeMarkAsStopped$_(t), this._$PostToDOM$_("stop", {
                        tags: this._$_SplitTags$_(t)
                    });
                },
                _$StopAll$_() {
                    this._$_StopAll$_();
                },
                _$SetPaused$_(t, e) {
                    this._$PostToDOM$_("set-paused", {
                        tags: this._$_SplitTags$_(t),
                        paused: 0 === e
                    });
                },
                _$Seek$_(t, e) {
                    this._$PostToDOM$_("seek", {
                        tags: this._$_SplitTags$_(t),
                        pos: e
                    });
                },
                _$SetSilent$_(t) {
                    2 === t && (t = this._$_IsSilent$_() ? 1 : 0), this._$_SetSilent$_(0 === t);
                },
                _$SetMasterVolume$_(t) {
                    const e = this._$DbToLinear$_(t);
                    this._$_SetMasterVolume$_(e);
                },
                _$AddFilterEffect$_(t, e, s, i, r, n, h) {
                    const o = D0[e];
                    this._$_IncrementEffectCount$_(t), this._$PostToDOM$_("add-effect", {
                        type: "filter",
                        tags: this._$_SplitTags$_(t),
                        params: [ o, s, i, r, n, C0._$clamp$_(h / 100, 0, 1) ]
                    });
                },
                _$AddDelayEffect$_(t, e, s, i) {
                    this._$_IncrementEffectCount$_(t), this._$PostToDOM$_("add-effect", {
                        type: "delay",
                        tags: this._$_SplitTags$_(t),
                        params: [ e, this._$DbToLinear$_(s), C0._$clamp$_(i / 100, 0, 1) ]
                    });
                },
                _$AddFlangerEffect$_(t, e, s, i, r, n) {
                    this._$_IncrementEffectCount$_(t), this._$PostToDOM$_("add-effect", {
                        type: "flanger",
                        tags: this._$_SplitTags$_(t),
                        params: [ e / 1e3, s / 1e3, i, r / 100, C0._$clamp$_(n / 100, 0, 1) ]
                    });
                },
                _$AddPhaserEffect$_(t, e, s, i, r, n, h) {
                    this._$_IncrementEffectCount$_(t), this._$PostToDOM$_("add-effect", {
                        type: "phaser",
                        tags: this._$_SplitTags$_(t),
                        params: [ e, s, i, r, n, C0._$clamp$_(h / 100, 0, 1) ]
                    });
                },
                _$AddConvolutionEffect$_(t, e, s, i) {
                    const r = this._$_runtime$_._$GetAssetManager$_()._$GetProjectAudioFileUrl$_(e[0]);
                    r && (this._$_IncrementEffectCount$_(t), this._$PostToDOM$_("add-effect", {
                        type: "convolution",
                        tags: this._$_SplitTags$_(t),
                        bufferOriginalUrl: e[0],
                        bufferUrl: r.url,
                        bufferType: r.type,
                        params: [ 0 === s, C0._$clamp$_(i / 100, 0, 1) ]
                    }));
                },
                _$AddGainEffect$_(t, e) {
                    this._$_IncrementEffectCount$_(t), this._$PostToDOM$_("add-effect", {
                        type: "gain",
                        tags: this._$_SplitTags$_(t),
                        params: [ this._$DbToLinear$_(e) ]
                    });
                },
                _$AddStereoPanEffect$_(t, e) {
                    this._$_IncrementEffectCount$_(t), this._$PostToDOM$_("add-effect", {
                        type: "stereopan",
                        tags: this._$_SplitTags$_(t),
                        params: [ C0._$clamp$_(e / 100, -1, 1) ]
                    });
                },
                _$AddMuteEffect$_(t) {
                    this._$_IncrementEffectCount$_(t), this._$PostToDOM$_("add-effect", {
                        type: "gain",
                        tags: this._$_SplitTags$_(t),
                        params: [ 0 ]
                    });
                },
                _$AddTremoloEffect$_(t, e, s) {
                    this._$_IncrementEffectCount$_(t), this._$PostToDOM$_("add-effect", {
                        type: "tremolo",
                        tags: this._$_SplitTags$_(t),
                        params: [ e, C0._$clamp$_(s / 100, 0, 1) ]
                    });
                },
                _$AddRingModEffect$_(t, e, s) {
                    this._$_IncrementEffectCount$_(t), this._$PostToDOM$_("add-effect", {
                        type: "ringmod",
                        tags: this._$_SplitTags$_(t),
                        params: [ e, C0._$clamp$_(s / 100, 0, 1) ]
                    });
                },
                _$AddDistortionEffect$_(t, e, s, i, r, n) {
                    this._$_IncrementEffectCount$_(t), this._$PostToDOM$_("add-effect", {
                        type: "distortion",
                        tags: this._$_SplitTags$_(t),
                        params: [ this._$DbToLinearNoCap$_(e), this._$DbToLinearNoCap$_(s), i, this._$DbToLinearNoCap$_(r), C0._$clamp$_(n / 100, 0, 1) ]
                    });
                },
                _$AddCompressorEffect$_(t, e, s, i, r, n) {
                    this._$_IncrementEffectCount$_(t), this._$PostToDOM$_("add-effect", {
                        type: "compressor",
                        tags: this._$_SplitTags$_(t),
                        params: [ e, s, i, r / 1e3, n / 1e3 ]
                    });
                },
                _$AddAnalyserEffect$_(t, e, s) {
                    this._$_IncrementEffectCount$_(t), this._$PostToDOM$_("add-effect", {
                        type: "analyser",
                        tags: this._$_SplitTags$_(t),
                        params: [ e, s ]
                    });
                },
                _$RemoveEffects$_(t) {
                    const e = this._$_SplitTags$_(t);
                    for (const s of e) this._$_effectCount$_.set(s.toLowerCase(), 0);
                    this._$PostToDOM$_("remove-effects", {
                        tags: e
                    }), this._$_lastFxState$_ = {};
                },
                _$SetEffectParameter$_(t, e, s, i, r, n) {
                    this._$PostToDOM$_("set-effect-param", {
                        tags: this._$_SplitTags$_(t),
                        index: Math.floor(e),
                        param: s,
                        value: i,
                        ramp: r,
                        time: n
                    });
                },
                _$SetListenerObject$_(t) {
                    if (t) {
                        const e = t._$GetFirstPicked$_();
                        e && e._$GetWorldInfo$_() && (this._$_listenerInst$_ = e);
                    }
                },
                _$SetListenerZ$_(t) {
                    this._$_listenerPos$_[2] = t;
                },
                _$SetListenerOrientation$_(t, e, s, i, r, n) {
                    this._$_listenerForwardVec$_[0] = t, this._$_listenerForwardVec$_[1] = e, 
                    this._$_listenerForwardVec$_[2] = -s, this._$_listenerUpVec$_[0] = i, 
                    this._$_listenerUpVec$_[1] = r, this._$_listenerUpVec$_[2] = -n;
                },
                _$ScheduleNextPlay$_(t) {
                    this._$_nextPlayTime$_ = Math.max(t, 0);
                },
                _$UnloadAudio$_(t) {
                    const e = t[1], s = this._$_runtime$_._$GetAssetManager$_()._$GetProjectAudioFileUrl$_(t[0]);
                    s && this._$PostToDOM$_("unload", {
                        url: s.url,
                        type: s.type,
                        isMusic: e
                    });
                },
                _$UnloadAudioByName$_(t, e) {
                    const s = 1 === t, i = this._$_runtime$_._$GetAssetManager$_()._$GetProjectAudioFileUrl$_(e) || this._$_remoteUrls$_.get(e.toLowerCase());
                    i && this._$PostToDOM$_("unload", {
                        url: i.url,
                        type: i.type,
                        isMusic: s
                    });
                },
                _$UnloadAll$_() {
                    this._$PostToDOM$_("unload-all");
                },
                _$AddRemoteURL$_(t, e, s) {
                    this._$_remoteUrls$_.set(s.toLowerCase(), {
                        url: t,
                        type: e
                    });
                }
            };
        }
        {
            const y2 = self._$C3$_;
            y2._$Plugins$_.Audio._$Exps$_ = {
                _$Duration$_(t) {
                    const e = this._$_GetFirstAudioStateByTags$_(t);
                    return e ? e.duration : 0;
                },
                _$PlaybackTime$_(t) {
                    const e = this._$_GetFirstAudioStateByTags$_(t);
                    return e ? e.playbackTime : 0;
                },
                _$PlaybackRate$_(t) {
                    const e = this._$_GetFirstAudioStateByTags$_(t);
                    return e ? e.playbackRate : 0;
                },
                _$Volume$_(t) {
                    const e = this._$_GetFirstAudioStateByTags$_(t);
                    return e ? this._$LinearToDb$_(e.volume) : 0;
                },
                _$MasterVolume$_() {
                    return this._$LinearToDb$_(this._$_GetMasterVolume$_());
                },
                _$EffectCount$_(t) {
                    return this._$_effectCount$_.get(t.toLowerCase()) || 0;
                },
                _$AnalyserFreqBinCount$_(t, e) {
                    const s = this._$GetAnalyserData$_(t, Math.floor(e));
                    return s ? s.binCount : 0;
                },
                _$AnalyserFreqBinAt$_(t, e, s) {
                    const i = this._$GetAnalyserData$_(t, Math.floor(e));
                    return !i || (s = Math.floor(s)) < 0 || s >= i.binCount ? 0 : i.freqBins[s];
                },
                _$AnalyserPeakLevel$_(t, e) {
                    const s = this._$GetAnalyserData$_(t, Math.floor(e));
                    return s ? s.peak : 0;
                },
                _$AnalyserRMSLevel$_(t, e) {
                    const s = this._$GetAnalyserData$_(t, Math.floor(e));
                    return s ? s.rms : 0;
                },
                _$SampleRate$_() {
                    return this._$_sampleRate$_;
                },
                _$CurrentTime$_() {
                    return self.C3_GetAudioContextCurrentTime ? self.C3_GetAudioContextCurrentTime() : performance.now() / 1e3;
                },
                _$OutputLatency$_() {
                    return this._$_outputLatency$_;
                },
                _$NormalizedVolume$_(t, e) {
                    return 0 == (t = y2._$clamp$_(+t, 0, 100) / 100) ? -1 / 0 : t < .1 ? this._$LinearToDb$_(y2._$lerp$_(0, this._$DbToLinear$_(e), 10 * t)) : y2._$lerp$_(e, 0, (t - .1) / .9);
                }
            };
        }
        {
            const a = self._$C3$_;
            a._$Plugins$_._$Dictionary$_ = class extends a._$SDKPluginBase$_ {
                constructor(t) {
                    super(t);
                }
                _$Release$_() {
                    super._$Release$_();
                }
            };
        }
        {
            const d = self._$C3$_;
            d._$Plugins$_._$Dictionary$_._$Type$_ = class extends d._$SDKTypeBase$_ {
                constructor(t) {
                    super(t);
                }
                _$Release$_() {
                    super._$Release$_();
                }
                _$OnCreate$_() {}
            };
        }
        {
            const g = self._$C3$_, h = self._$C3X$_, i = self._$IInstance$_, j = (g._$Plugins$_._$Dictionary$_.Instance = class extends g._$SDKInstanceBase$_ {
                constructor(t, e) {
                    super(t), this._$_data$_ = new Map(), this._$_curKey$_ = "";
                }
                _$Release$_() {
                    this._$_data$_.clear(), super._$Release$_();
                }
                _$GetAsJsonString$_() {
                    return JSON.stringify({
                        c2dictionary: !0,
                        data: g._$MapToObject$_(this._$_data$_)
                    });
                }
                _$GetDataMap$_() {
                    return this._$_data$_;
                }
                _$SaveToJson$_() {
                    return g._$MapToObject$_(this._$_data$_);
                }
                _$LoadFromJson$_(t) {
                    g._$ObjectToMap$_(t, this._$_data$_);
                }
                _$GetDebuggerProperties$_() {
                    const t = "plugins.dictionary";
                    return [ {
                        title: t + ".name",
                        properties: [ {
                            name: t + ".debugger.key-count",
                            value: this._$_data$_.size
                        }, ...[ ...this._$_data$_ ].map(e => ({
                            name: "$" + e[0],
                            value: e[1],
                            _$onedit$_: t => this._$_data$_.set(e[0], t)
                        })) ]
                    } ];
                }
                _$GetScriptInterfaceClass$_() {
                    return self._$IDictionaryInstance$_;
                }
            }, new WeakMap());
            self._$IDictionaryInstance$_ = class extends i {
                constructor() {
                    super(), j.set(this, i._$_GetInitInst$_()._$GetSdkInstance$_());
                }
                _$getDataMap$_() {
                    return j.get(this)._$GetDataMap$_();
                }
            };
        }
        {
            const s = self._$C3$_;
            s._$Plugins$_._$Dictionary$_._$Cnds$_ = {
                _$CompareValue$_(t, e, i) {
                    const r = this._$_data$_.get(t);
                    return void 0 !== r && s.compare(r, e, i);
                },
                _$ForEachKey$_() {
                    const t = this._$_runtime$_, e = t._$GetEventSheetManager$_(), s = t._$GetCurrentEvent$_(), i = s._$GetSolModifiers$_(), r = t._$GetEventStack$_(), n = r._$GetCurrentStackFrame$_(), h = r._$Push$_(s);
                    t._$SetDebuggingEnabled$_(!1);
                    for (const o of this._$_data$_.keys()) {
                        this._$_curKey$_ = o, e._$PushCopySol$_(i);
                        const a = this._$GetObjectClass$_()._$GetCurrentSol$_();
                        a._$PickOne$_(this._$GetInstance$_()), s._$Retrigger$_(n, h), 
                        e._$PopSol$_(i);
                    }
                    return t._$SetDebuggingEnabled$_(!0), this._$_curKey$_ = "", 
                    r._$Pop$_(), !1;
                },
                _$CompareCurrentValue$_(t, e) {
                    const i = this._$_data$_.get(this._$_curKey$_);
                    return void 0 !== i && s.compare(i, t, e);
                },
                _$HasKey$_(t) {
                    return this._$_data$_.has(t);
                },
                _$IsEmpty$_() {
                    return 0 === this._$_data$_.size;
                }
            };
        }
        {
            const K = self._$C3$_;
            K._$Plugins$_._$Dictionary$_._$Acts$_ = {
                _$AddKey$_(t, e) {
                    this._$_data$_.set(t, e);
                },
                _$SetKey$_(t, e) {
                    this._$_data$_.has(t) && this._$_data$_.set(t, e);
                },
                _$DeleteKey$_(t) {
                    this._$_data$_.delete(t);
                },
                _$Clear$_() {
                    this._$_data$_.clear();
                },
                _$JSONLoad$_(t) {
                    let e = null;
                    try {
                        e = JSON.parse(t);
                    } catch (t) {
                        return void console.error("[Construct] Error parsing JSON: ", t);
                    }
                    e.c2dictionary && K._$ObjectToMap$_(e.data, this._$_data$_);
                },
                _$JSONDownload$_(t) {
                    const e = URL.createObjectURL(new Blob([ this._$GetAsJsonString$_() ], {
                        type: "application/json"
                    }));
                    this._$_runtime$_._$InvokeDownload$_(e, t);
                }
            };
        }
        {
            const V = self._$C3$_;
            V._$Plugins$_._$Dictionary$_._$Exps$_ = {
                _$Get$_(t) {
                    const e = this._$_data$_.get(t);
                    return void 0 === e ? 0 : e;
                },
                _$GetDefault$_(t, e) {
                    const s = this._$_data$_.get(t);
                    return void 0 === s ? e : s;
                },
                _$KeyCount$_() {
                    return this._$_data$_.size;
                },
                _$CurrentKey$_() {
                    return this._$_curKey$_;
                },
                _$CurrentValue$_() {
                    return this._$_data$_.get(this._$_curKey$_) ?? 0;
                },
                _$AsJSON$_() {
                    return this._$GetAsJsonString$_();
                }
            };
        }
        {
            const a = self._$C3$_;
            a._$Plugins$_.Geolocation = class extends a._$SDKPluginBase$_ {
                constructor(t) {
                    super(t);
                }
                _$Release$_() {
                    super._$Release$_();
                }
            };
        }
        {
            const d = self._$C3$_;
            d._$Plugins$_.Geolocation._$Type$_ = class extends d._$SDKTypeBase$_ {
                constructor(t) {
                    super(t);
                }
                _$Release$_() {
                    super._$Release$_();
                }
                _$OnCreate$_() {}
            };
        }
        {
            const g = self._$C3$_, h = "geolocation";
            g._$Plugins$_.Geolocation.Instance = class extends g._$SDKInstanceBase$_ {
                constructor(t, e) {
                    super(t, h), this._$_isWatching$_ = !1, this._$_errorMsg$_ = "", 
                    this._$_timeStamp$_ = 0, this._$_latitude$_ = 0, this._$_longitude$_ = 0, 
                    this._$_altitude$_ = 0, this._$_accuracy$_ = 0, this._$_altitudeAccuracy$_ = 0, 
                    this._$_heading$_ = 0, this._$_speed$_ = 0, this._$AddDOMMessageHandler$_("update", t => this._$_Update$_(t)), 
                    this._$AddDOMMessageHandler$_("error", t => this._$_OnError$_(t));
                }
                _$Release$_() {
                    super._$Release$_();
                }
                async _$_Update$_(t) {
                    this._$_timeStamp$_ = t.timestamp;
                    const e = t.coords;
                    this._$_latitude$_ = e.latitude || 0, this._$_longitude$_ = e.longitude || 0, 
                    this._$_altitude$_ = e.altitude || 0, this._$_accuracy$_ = e.accuracy || 0, 
                    this._$_altitudeAccuracy$_ = e.altitudeAccuracy || 0, this._$_heading$_ = e.heading || 0, 
                    this._$_speed$_ = e.speed || 0, await this._$TriggerAsync$_(g._$Plugins$_.Geolocation._$Cnds$_._$OnUpdate$_);
                }
                async _$_OnError$_(t) {
                    this._$_errorMsg$_ = t.message || "Unknown error", await this._$TriggerAsync$_(g._$Plugins$_.Geolocation._$Cnds$_._$OnError$_);
                }
            };
        }
        {
            const q = self._$C3$_;
            q._$Plugins$_.Geolocation._$Cnds$_ = {
                _$IsSupported$_() {
                    const t = this._$_runtime$_._$GetExportType$_();
                    return "nwjs" !== t && "macos-wkwebview" !== t;
                },
                _$IsWatching$_() {
                    return this._$_isWatching$_;
                },
                _$OnUpdate$_() {
                    return !0;
                },
                _$OnError$_() {
                    return !0;
                }
            };
        }
        {
            const s = self._$C3$_;
            s._$Plugins$_.Geolocation._$Acts$_ = {
                _$RequestLocation$_(t, e, s) {
                    this._$PostToDOM$_("request-location", {
                        enableHighAccuracy: 0 !== t,
                        timeout: 1e3 * e,
                        maximumAge: 1e3 * s
                    });
                },
                _$WatchLocation$_(t, e, s) {
                    this._$_isWatching$_ = !0, this._$PostToDOM$_("watch-location", {
                        enableHighAccuracy: 0 !== t,
                        timeout: 1e3 * e,
                        maximumAge: 1e3 * s
                    });
                },
                _$StopWatching$_() {
                    this._$_isWatching$_ = !1, this._$PostToDOM$_("stop-watching");
                }
            };
        }
        {
            const z = self._$C3$_;
            z._$Plugins$_.Geolocation._$Exps$_ = {
                _$ErrorMessage$_() {
                    return this._$_errorMsg$_;
                },
                _$Timestamp$_() {
                    return this._$_timeStamp$_;
                },
                _$Latitude$_() {
                    return this._$_latitude$_;
                },
                _$Longitude$_() {
                    return this._$_longitude$_;
                },
                _$Altitude$_() {
                    return this._$_altitude$_;
                },
                _$Accuracy$_() {
                    return this._$_accuracy$_;
                },
                _$AltitudeAccuracy$_() {
                    return this._$_altitudeAccuracy$_;
                },
                _$Heading$_() {
                    return this._$_heading$_;
                },
                _$Speed$_() {
                    return this._$_speed$_;
                }
            };
        }
        {
            const a = self._$C3$_;
            a._$Plugins$_._$Timeline$_ = class extends a._$SDKPluginBase$_ {
                constructor(t) {
                    super(t);
                }
                _$Release$_() {
                    super._$Release$_();
                }
            };
        }
        {
            let GetTCInst2 = function() {
                return l._$GetSingleGlobalInstance$_()._$GetSdkInstance$_();
            }, GetTimelineParameter2 = function(t) {
                if ("string" == typeof t) {
                    const e = i._$GetTimelineByName$_(t);
                    if (e) return e;
                    throw new Error(`invalid timeline name '${t}'`);
                }
                if (t instanceof self._$ITimelineState$_) return l._$GetRuntime$_()._$_UnwrapScriptInterface$_(t);
                throw new Error("invalid timeline parameter");
            }, ValidateTags2 = function(t, e = !1) {
                if (!(e && null == t || "string" == typeof t || Array.isArray(t))) throw new Error("invalid tags");
            };
            GetTCInst = GetTCInst2, GetTimelineParameter = GetTimelineParameter2, 
            ValidateTags = ValidateTags2;
            const d = self._$C3$_, e = self._$C3X$_;
            d._$Plugins$_._$Timeline$_._$Type$_ = class extends d._$SDKTypeBase$_ {
                constructor(t) {
                    super(t);
                }
                _$Release$_() {
                    super._$Release$_();
                }
                _$OnCreate$_() {}
                _$GetScriptInterfaceClass$_() {
                    return self._$ITimelineControllerObjectType$_;
                }
            };
            let l = null, i = null;
            self._$ITimelineControllerObjectType$_ = class extends self._$IObjectClass$_ {
                constructor(t) {
                    super(t), l = t, i = t._$GetRuntime$_()._$GetTimelineManager$_(), 
                    t._$GetRuntime$_()._$_GetCommonScriptInterfaces$_()._$timelineController$_ = this;
                }
                _$setInstances$_(t, s) {
                    let i = l._$GetRuntime$_(), r;
                    if (t instanceof self._$IWorldInstance$_) r = [ i._$_UnwrapIWorldInstance$_(t) ]; else {
                        if (!Array.isArray(t)) throw new TypeError("invalid instances");
                        r = t.map(t => i._$_UnwrapIWorldInstance$_(t));
                    }
                    if (0 !== r.length) {
                        e._$RequireOptionalString$_(s);
                        const n = r[0]._$GetObjectClass$_();
                        GetTCInst2()._$_SetInstancesForNextPlay$_(n, r, s ?? "");
                    }
                }
                play(t, e) {
                    const s = GetTimelineParameter2(t);
                    return ValidateTags2(e, !0), GetTCInst2()._$_PlayTimeline$_(s, e ?? []), 
                    s._$GetITimelineState$_();
                }
                *_$allTimelines$_() {
                    for (const t of i._$GetTimelines$_()) yield t._$GetITimelineState$_();
                }
                *_$timelinesByTags$_(t) {
                    ValidateTags2(t);
                    for (const e of i._$GetTimelinesByTags$_(t)) yield e._$GetITimelineState$_();
                }
            };
        }
        {
            const B = self._$C3$_;
            B._$Plugins$_._$Timeline$_.Instance = class extends B._$SDKInstanceBase$_ {
                constructor(t, e) {
                    super(t), this._$_nextTimelineObjectClasses$_ = new Map(), this._$GetRuntime$_()._$GetTimelineManager$_()._$SetPluginInstance$_(t);
                }
                _$Release$_() {
                    super._$Release$_();
                }
                _$_SetTimelineInstanceObjects$_(t, e) {
                    for (const s of t) e._$SetTrackInstance$_(s.trackId, s.instance);
                }
                _$_GetTimelineInstanceObjects$_() {
                    const t = [], r = (t, e, s) => {
                        const i = e._$pickedInstances$_[e._$startIndex$_];
                        if (i) return e._$startIndex$_++, t._$usedObjectClassInstances$_.includes(i) || i._$IsDestroyed$_() ? r(t, e, s) : (t._$usedObjectClassInstances$_.push(i), 
                        {
                            trackId: s,
                            instance: i
                        });
                    };
                    for (const e of this._$_nextTimelineObjectClasses$_.values()) for (const [ s, i ] of e._$trackIdPickedInstances$_.entries()) {
                        const n = r(e, i, s);
                        n && t.push(n);
                    }
                    return t;
                }
                _$_SetInstancesForNextPlay$_(t, e, s) {
                    if (t._$IsFamily$_() && (t = t._$GetFirstPicked$_()._$GetObjectClass$_()), 
                    this._$_nextTimelineObjectClasses$_.has(t)) {
                        const i = this._$_nextTimelineObjectClasses$_.get(t)._$trackIdPickedInstances$_;
                        if (i.has(s)) {
                            const r = new Set([ ...i.get(s)._$pickedInstances$_, ...e ]);
                            i.set(s, {
                                _$startIndex$_: 0,
                                _$pickedInstances$_: Array.from(r)
                            });
                        } else i.set(s, {
                            _$startIndex$_: 0,
                            _$pickedInstances$_: e
                        });
                    } else this._$_nextTimelineObjectClasses$_.set(t, {
                        _$usedObjectClassInstances$_: [],
                        _$trackIdPickedInstances$_: new Map([ [ s, {
                            _$startIndex$_: 0,
                            _$pickedInstances$_: e
                        } ] ])
                    });
                }
                _$_UnsetInstancesForNextPlay$_() {
                    this._$_nextTimelineObjectClasses$_ && this._$_nextTimelineObjectClasses$_.clear();
                }
                async _$_PlayTimeline$_(r, n, t) {
                    if (r) {
                        let e = this._$_runtime$_._$GetTimelineManager$_(), s, i = [];
                        if (this._$_nextTimelineObjectClasses$_.size) {
                            let t = this._$_GetTimelineInstanceObjects$_();
                            for (;t.length && ((s = e._$GetTimelineOfTemplateForInstances$_(r, t)) || ((s = e._$CreateFromTemplate$_(r))._$ClearTrackInstances$_(), 
                            this._$_SetTimelineInstanceObjects$_(t, s)), s._$SetTags$_(n), 
                            s.Play() && i.push(s._$GetPlayPromise$_()), t = this._$_GetTimelineInstanceObjects$_()), 
                            t.length; );
                        } else r._$SetTags$_(n), r.Play() && i.push(r._$GetPlayPromise$_());
                        t || this._$_nextTimelineObjectClasses$_.clear(), await Promise.all(i);
                    } else t || this._$_nextTimelineObjectClasses$_.clear();
                }
            };
        }
        {
            let ca = self._$C3$_, t = [], i = [];
            ca._$Plugins$_._$Timeline$_._$Cnds$_ = {
                _$PushTriggerTimeline$_(e) {
                    t.push(e);
                },
                _$PopTriggerTimeline$_() {
                    t.pop();
                },
                _$GetTriggerTimeline$_() {
                    return t[t.length - 1];
                },
                _$PushTriggerKeyframe$_(t) {
                    i.push(t);
                },
                _$PopTriggerKeyframe$_(t) {
                    i.pop();
                },
                _$GetTriggerKeyframe$_() {
                    return i[i.length - 1];
                },
                _$OnTimelineStarted$_(t) {
                    return ca._$Plugins$_._$Timeline$_._$Cnds$_._$GetTriggerTimeline$_() === t;
                },
                _$OnTimelineStartedByName$_(t) {
                    const e = ca._$Plugins$_._$Timeline$_._$Cnds$_._$GetTriggerTimeline$_();
                    if (e) {
                        const s = this._$_runtime$_._$GetTimelineManager$_();
                        for (const i of s._$GetTimelinesByName$_(t)) if (ca._$equalsNoCase$_(e._$GetName$_(), i._$GetName$_())) return !0;
                    }
                    return !1;
                },
                _$OnTimelineStartedByTags$_(t) {
                    const e = ca._$Plugins$_._$Timeline$_._$Cnds$_._$GetTriggerTimeline$_();
                    if (e) {
                        const s = this._$_runtime$_._$GetTimelineManager$_();
                        for (const i of s._$GetTimelinesByTags$_(t)) if (i._$HasTags$_(e._$GetTags$_())) return !0;
                    }
                    return !1;
                },
                _$OnAnyTimelineStarted$_() {
                    return !0;
                },
                _$OnTimelineFinished$_(t) {
                    return ca._$Plugins$_._$Timeline$_._$Cnds$_._$GetTriggerTimeline$_() === t;
                },
                _$OnTimelineFinishedByName$_(t) {
                    const e = ca._$Plugins$_._$Timeline$_._$Cnds$_._$GetTriggerTimeline$_();
                    if (e) {
                        const s = this._$_runtime$_._$GetTimelineManager$_();
                        for (const i of s._$GetTimelinesByName$_(t)) if (ca._$equalsNoCase$_(e._$GetName$_(), i._$GetName$_())) return !0;
                    }
                    return !1;
                },
                _$OnTimelineFinishedByTags$_(t) {
                    const e = ca._$Plugins$_._$Timeline$_._$Cnds$_._$GetTriggerTimeline$_();
                    if (e) {
                        const s = this._$_runtime$_._$GetTimelineManager$_();
                        for (const i of s._$GetTimelinesByTags$_(t)) if (i._$HasTags$_(e._$GetTags$_())) return !0;
                    }
                    return !1;
                },
                _$OnAnyTimelineFinished$_() {
                    return !0;
                },
                IsPlaying(t) {
                    return t.IsPlaying();
                },
                _$IsPlayingByName$_(t) {
                    const e = this._$_runtime$_._$GetTimelineManager$_();
                    for (const s of e._$GetTimelinesByName$_(t)) if (s.IsPlaying()) return !0;
                    return !1;
                },
                _$IsPlayingByTags$_(t) {
                    const e = this._$_runtime$_._$GetTimelineManager$_();
                    for (const s of e._$GetTimelinesByTags$_(t)) if (s.IsPlaying()) return !0;
                    return !1;
                },
                _$IsAnyPlaying$_() {
                    const t = [ ...this._$_runtime$_._$GetTimelineManager$_()._$GetTimelines$_() ];
                    if (t) return t.some(t => t.IsPlaying());
                },
                _$IsPaused$_(t) {
                    return t._$IsPaused$_();
                },
                _$IsPausedByName$_(t) {
                    const e = this._$_runtime$_._$GetTimelineManager$_();
                    for (const s of e._$GetTimelinesByName$_(t)) if (s._$IsPaused$_()) return !0;
                    return !1;
                },
                _$IsPausedByTags$_(t) {
                    const e = this._$_runtime$_._$GetTimelineManager$_();
                    for (const s of e._$GetTimelinesByTags$_(t)) if (s._$IsPaused$_()) return !0;
                    return !1;
                },
                _$IsAnyPaused$_() {
                    const t = [ ...this._$_runtime$_._$GetTimelineManager$_()._$GetTimelines$_() ];
                    if (t) return t.some(t => t._$IsPaused$_());
                },
                _$OnTimeSet$_(t) {
                    return ca._$Plugins$_._$Timeline$_._$Cnds$_._$GetTriggerTimeline$_() === t;
                },
                _$OnTimeSetByName$_(t) {
                    const e = ca._$Plugins$_._$Timeline$_._$Cnds$_._$GetTriggerTimeline$_();
                    if (e) {
                        const s = this._$_runtime$_._$GetTimelineManager$_();
                        for (const i of s._$GetTimelinesByName$_(t)) if (e === i) return !0;
                    }
                    return !1;
                },
                _$OnTimeSetByTags$_(t) {
                    const e = ca._$Plugins$_._$Timeline$_._$Cnds$_._$GetTriggerTimeline$_();
                    if (e) {
                        const s = this._$_runtime$_._$GetTimelineManager$_();
                        for (const i of s._$GetTimelinesByTags$_(t)) if (e === i) return !0;
                    }
                    return !1;
                },
                _$OnAnyKeyframeReached$_() {
                    return !!ca._$Plugins$_._$Timeline$_._$Cnds$_._$GetTriggerKeyframe$_();
                },
                _$OnKeyframeReached$_(t, e) {
                    const s = ca._$Plugins$_._$Timeline$_._$Cnds$_._$GetTriggerKeyframe$_();
                    if (!s) return !1;
                    if (0 === s._$GetTags$_().length || !t) return !1;
                    const i = t ? t.split(" ") : [];
                    if (0 === e) {
                        for (const r of i) if (s._$HasTag$_(r)) return !0;
                        return !1;
                    }
                    for (const n of i) if (!s._$HasTag$_(n)) return !1;
                    return !0;
                }
            };
        }
        {
            const f0 = self._$C3$_;
            f0._$Plugins$_._$Timeline$_._$Acts$_ = {
                _$PlayTimeline$_(t, e) {
                    return this._$_PlayTimeline$_(t, e, !1);
                },
                async _$PlayTimelineByName$_(t, e) {
                    const s = this._$_runtime$_._$GetTimelineManager$_(), i = [];
                    for (const r of s._$GetTimelinesByName$_(t)) i.push(this._$_PlayTimeline$_(r, e, !0));
                    this._$_nextTimelineObjectClasses$_.clear(), await Promise.all(i);
                },
                async _$PlayAllTimelines$_() {
                    const t = this._$_runtime$_._$GetTimelineManager$_(), e = [];
                    for (const s of t._$GetTimelines$_()) s.Play() && e.push(s._$GetPlayPromise$_());
                    this._$_nextTimelineObjectClasses$_.clear(), await Promise.all(e);
                },
                _$PauseTimeline$_(t) {
                    t && t._$Stop$_();
                },
                _$PauseTimelineByName$_(t) {
                    const e = this._$_runtime$_._$GetTimelineManager$_();
                    for (const s of e._$GetTimelinesByName$_(t)) f0._$Plugins$_._$Timeline$_._$Acts$_._$PauseTimeline$_.call(this, s);
                },
                _$PauseTimelineByTags$_(t) {
                    const e = this._$_runtime$_._$GetTimelineManager$_();
                    for (const s of e._$GetTimelinesByTags$_(t)) f0._$Plugins$_._$Timeline$_._$Acts$_._$PauseTimeline$_.call(this, s);
                },
                _$PauseAllTimelines$_() {
                    const t = this._$_runtime$_._$GetTimelineManager$_();
                    for (const e of t._$GetTimelines$_()) e._$Stop$_();
                },
                _$ResumeTimeline$_(t) {
                    t && t._$Resume$_();
                },
                _$ResumeTimelineByName$_(t) {
                    const e = this._$_runtime$_._$GetTimelineManager$_();
                    for (const s of e._$GetTimelinesByName$_(t)) f0._$Plugins$_._$Timeline$_._$Acts$_._$ResumeTimeline$_.call(this, s);
                },
                _$ResumeTimelineByTags$_(t) {
                    const e = this._$_runtime$_._$GetTimelineManager$_();
                    for (const s of e._$GetTimelinesByTags$_(t)) f0._$Plugins$_._$Timeline$_._$Acts$_._$ResumeTimeline$_.call(this, s);
                },
                _$ResumeAllTimelines$_() {
                    const t = this._$_runtime$_._$GetTimelineManager$_();
                    for (const e of t._$GetTimelines$_()) e._$Resume$_();
                },
                _$StopTimeline$_(t) {
                    t && t._$Reset$_();
                },
                _$StopTimelineByName$_(t) {
                    const e = this._$_runtime$_._$GetTimelineManager$_();
                    for (const s of e._$GetTimelinesByName$_(t)) f0._$Plugins$_._$Timeline$_._$Acts$_._$StopTimeline$_.call(this, s);
                },
                _$StopTimelineByTags$_(t) {
                    const e = this._$_runtime$_._$GetTimelineManager$_();
                    for (const s of e._$GetTimelinesByTags$_(t)) f0._$Plugins$_._$Timeline$_._$Acts$_._$StopTimeline$_.call(this, s);
                },
                _$StopAllTimelines$_() {
                    const t = this._$_runtime$_._$GetTimelineManager$_();
                    for (const e of t._$GetTimelines$_()) e._$Reset$_();
                },
                _$SetTimelineTime$_(t, e) {
                    if (t) if (f0._$IsFiniteNumber$_(e)) t._$SetTime$_(e); else if (f0._$IsString$_(e)) {
                        const s = t._$GetKeyframeWithTags$_(e);
                        s ? t._$SetTime$_(s._$GetTime$_()) : f0._$Plugins$_._$Timeline$_._$Acts$_._$SetTimelineTime$_.call(this, t, Number(e));
                    }
                },
                _$SetTimelineTimeByName$_(t, e) {
                    const s = this._$_runtime$_._$GetTimelineManager$_();
                    for (const i of s._$GetTimelinesByName$_(t)) f0._$Plugins$_._$Timeline$_._$Acts$_._$SetTimelineTime$_.call(this, i, e);
                },
                _$SetTimelineTimeByTags$_(t, e) {
                    const s = this._$_runtime$_._$GetTimelineManager$_();
                    for (const i of s._$GetTimelinesByTags$_(t)) f0._$Plugins$_._$Timeline$_._$Acts$_._$SetTimelineTime$_.call(this, i, e);
                },
                _$SetTimelinePlaybackRate$_(t, e) {
                    t && t._$SetPlaybackRate$_(e);
                },
                _$SetTimelinePlaybackRateByName$_(t, e) {
                    const s = this._$_runtime$_._$GetTimelineManager$_();
                    for (const i of s._$GetTimelinesByName$_(t)) f0._$Plugins$_._$Timeline$_._$Acts$_._$SetTimelinePlaybackRate$_.call(this, i, e);
                },
                _$SetTimelinePlaybackRateByTags$_(t, e) {
                    const s = this._$_runtime$_._$GetTimelineManager$_();
                    for (const i of s._$GetTimelinesByTags$_(t)) f0._$Plugins$_._$Timeline$_._$Acts$_._$SetTimelinePlaybackRate$_.call(this, i, e);
                },
                _$SetInstance$_(t, e) {
                    const s = [ ...t._$GetCurrentSol$_()._$GetInstances$_() ];
                    this._$_SetInstancesForNextPlay$_(t, s, e);
                },
                _$UnsetInstances$_() {
                    this._$_UnsetInstancesForNextPlay$_();
                }
            };
        }
        {
            const nb = self._$C3$_;
            nb._$Plugins$_._$Timeline$_._$Exps$_ = {
                _$Time$_(t) {
                    const e = this._$_runtime$_._$GetTimelineManager$_();
                    for (const s of e._$GetTimelinesByName$_(t)) return s._$GetTime$_();
                    for (const i of e._$GetTimelinesByTags$_(t)) return i._$GetTime$_();
                    return 0;
                },
                _$TotalTime$_(t) {
                    const e = this._$_runtime$_._$GetTimelineManager$_();
                    for (const s of e._$GetTimelinesByName$_(t)) return s._$GetTotalTime$_();
                    for (const i of e._$GetTimelinesByTags$_(t)) return i._$GetTotalTime$_();
                    return 0;
                },
                _$Progress$_(t) {
                    const e = this._$_runtime$_._$GetTimelineManager$_();
                    for (const s of e._$GetTimelinesByName$_(t)) return s._$GetTime$_() / s._$GetTotalTime$_();
                    for (const i of e._$GetTimelinesByTags$_(t)) return i._$GetTime$_() / i._$GetTotalTime$_();
                    return 0;
                },
                _$KeyframeTags$_() {
                    const t = nb._$Plugins$_._$Timeline$_._$Cnds$_._$GetTriggerKeyframe$_();
                    return t ? t._$GetTags$_().join(" ") : "";
                },
                _$TimelineName$_() {
                    const t = nb._$Plugins$_._$Timeline$_._$Cnds$_._$GetTriggerTimeline$_();
                    return t ? t._$GetName$_() : "";
                },
                _$TimelineTags$_() {
                    const t = nb._$Plugins$_._$Timeline$_._$Cnds$_._$GetTriggerTimeline$_();
                    return t ? t._$GetStringTags$_() : "";
                },
                _$Value$_(t, e) {
                    const s = this._$_runtime$_._$GetTimelineManager$_();
                    for (const i of s._$GetTimelinesByName$_(t)) {
                        let t = i._$GetTrackByName$_(e);
                        if (t) {
                            const r = t._$GetPropertyTrack$_("value");
                            if (r) return r._$GetSourceAdapterValue$_();
                        } else {
                            let t = i._$GetTrackById$_(e);
                            if (t) {
                                const n = t._$GetPropertyTrack$_("value");
                                if (n) return n._$GetSourceAdapterValue$_();
                            }
                        }
                    }
                    for (const h of s._$GetTimelinesByTags$_(t)) {
                        let t = h._$GetTrackByName$_(e);
                        if (t) {
                            const o = t._$GetPropertyTrack$_("value");
                            if (o) return o._$GetSourceAdapterValue$_();
                        } else {
                            let t = h._$GetTrackById$_(e);
                            if (t) {
                                const a = t._$GetPropertyTrack$_("value");
                                if (a) return a._$GetSourceAdapterValue$_();
                            }
                        }
                    }
                    return 0;
                },
                _$Ease$_(t, e) {
                    1 <= (e = e < 0 ? 0 : e) && (e = 1);
                    const s = self._$Ease$_._$ToInternal$_(t);
                    if (s) return self._$Ease$_._$GetRuntimeEase$_(s)(e, 0, 1, 1);
                    {
                        const i = self._$Ease$_._$GetRuntimeEase$_(t);
                        if (i) return i(e, 0, 1, 1);
                    }
                    return console.warn("[TimelineController.Ease expression] no matching built-in or custom ease function found, returning 0"), 
                    0;
                }
            };
        }
        {
            const a = self._$C3$_;
            a._$Plugins$_._$Multiplayer$_ = class extends a._$SDKPluginBase$_ {
                constructor(t) {
                    super(t);
                }
                _$Release$_() {
                    super._$Release$_();
                }
            };
        }
        {
            let GetSdkInstance2 = function() {
                return s._$GetSingleGlobalInstance$_()._$GetSdkInstance$_();
            };
            GetSdkInstance = GetSdkInstance2;
            const d = self._$C3$_, e = self._$C3X$_;
            d._$Plugins$_._$Multiplayer$_._$Type$_ = class extends d._$SDKTypeBase$_ {
                constructor(t) {
                    super(t);
                }
                _$Release$_() {
                    super._$Release$_();
                }
                _$OnCreate$_() {}
                _$GetScriptInterfaceClass$_() {
                    return self._$IMultiplayerObjectType$_;
                }
            };
            let s = null, g = new Set([ "all", "unlocked", "available" ]);
            class h {
                constructor() {}
                addEventListener(t, s) {
                    e._$RequireString$_(t), e._$RequireFunction$_(s), GetSdkInstance2()._$_GetSignallingScriptDispatcher$_().addEventListener(t, s);
                }
                removeEventListener(t, s) {
                    e._$RequireString$_(t), e._$RequireFunction$_(s), GetSdkInstance2()._$_GetSignallingScriptDispatcher$_().removeEventListener(t, s);
                }
                async connect(t = "wss://multiplayer.construct.net") {
                    e._$RequireString$_(t);
                    const s = GetSdkInstance2();
                    return await s._$_SignallingConnect$_(t), {
                        _$myId$_: s._$_GetMyId$_(),
                        _$serverVersion$_: s._$_GetSignallingVersion$_(),
                        _$serverName$_: s._$_GetSignallingName$_(),
                        _$serverOperator$_: s._$_GetSignallingOperator$_(),
                        _$serverMOTD$_: s._$_GetSignallingMOTD$_()
                    };
                }
                get isConnected() {
                    return GetSdkInstance2()._$_SignallingIsConnected$_();
                }
                disconnect() {
                    GetSdkInstance2()._$_SignallingDisconnect$_();
                }
                _$addICEServer$_(t, s, i) {
                    e._$RequireString$_(t), e._$RequireOptionalString$_(s), e._$RequireOptionalString$_(i), 
                    GetSdkInstance2()._$_AddICEServer$_(t, s, i);
                }
                async login(t) {
                    e._$RequireString$_(t);
                    const s = GetSdkInstance2();
                    return await s._$_SignallingLogin$_(t), {
                        _$myAlias$_: s._$_GetMyAlias$_()
                    };
                }
                get _$isLoggedIn$_() {
                    return GetSdkInstance2()._$_SignallingIsLoggedIn$_();
                }
                async _$joinRoom$_(t, s, i, r = 0) {
                    e._$RequireString$_(t), e._$RequireString$_(s), e._$RequireString$_(i), 
                    e._$RequireFiniteNumber$_(r);
                    const n = GetSdkInstance2();
                    return await n._$_SignallingJoinRoom$_(t, s, i, r), {
                        isHost: n._$_SignallingIsHost$_(),
                        hostId: n._$_GetHostId$_(),
                        hostAlias: n._$_GetHostAlias$_()
                    };
                }
                async _$autoJoinRoom$_(t, s, i, r = 2, n = !0) {
                    e._$RequireString$_(t), e._$RequireString$_(s), e._$RequireString$_(i), 
                    e._$RequireFiniteNumber$_(r);
                    const h = GetSdkInstance2();
                    return await h._$_SignallingAutoJoinRoom$_(t, s, i, r, n), {
                        isHost: h._$_SignallingIsHost$_(),
                        hostId: h._$_GetHostId$_(),
                        hostAlias: h._$_GetHostAlias$_(),
                        room: h._$_GetCurrentRoom$_()
                    };
                }
                async _$leaveRoom$_() {
                    await GetSdkInstance2()._$_SignallingLeaveRoom$_();
                }
                async _$requestGameInstanceList$_(t) {
                    e._$RequireString$_(t);
                    const s = GetSdkInstance2();
                    return await s._$_SignallingRequestGameInstanceList$_(t), s._$_GetGameInstanceList$_().map(t => ({
                        name: t.name,
                        _$peerCount$_: t.peercount
                    }));
                }
                async _$requestRoomList$_(t, s, i = "all") {
                    if (e._$RequireString$_(t), e._$RequireString$_(s), !g.has(i)) throw new Error("invalid type");
                    const r = GetSdkInstance2();
                    return await r._$_SignallingRequestRoomList$_(t, s, i), r._$_GetRoomInstanceList$_().map(t => ({
                        name: t.name,
                        _$peerCount$_: t.peercount,
                        _$maxPeerCount$_: t.maxpeercount,
                        state: t.state
                    }));
                }
            }
            class i {
                constructor() {}
                get _$outboundCount$_() {
                    return GetSdkInstance2()._$_StatOutboundCount$_();
                }
                get _$outboundBandwidth$_() {
                    return GetSdkInstance2()._$_StatOutboundBandwidth$_();
                }
                get _$outboundDecompressedBandwidth$_() {
                    return GetSdkInstance2()._$_StatOutboundDecompressedBandwidth$_();
                }
                get _$inboundCount$_() {
                    return GetSdkInstance2()._$_StatInboundCount$_();
                }
                get _$inboundBandwidth$_() {
                    return GetSdkInstance2()._$_StatInboundBandwidth$_();
                }
                get _$inboundDecompressedBandwidth$_() {
                    return GetSdkInstance2()._$_StatInboundDecompressedBandwidth$_();
                }
            }
            const j = new Set([ "o", "r", "u" ]);
            self._$IMultiplayerObjectType$_ = class extends self._$IObjectClass$_ {
                constructor(t) {
                    super(t), s = t;
                    const e = {
                        _$signalling$_: {
                            value: new h(),
                            writable: !1
                        },
                        stats: {
                            value: new i(),
                            writable: !1
                        }
                    };
                    Object.defineProperties(this, e);
                }
                get isHost() {
                    return GetSdkInstance2()._$_SignallingIsHost$_();
                }
                get _$myAlias$_() {
                    return GetSdkInstance2()._$_GetMyAlias$_();
                }
                get _$myId$_() {
                    return GetSdkInstance2()._$_GetMyId$_();
                }
                get hostAlias() {
                    return GetSdkInstance2()._$_GetHostAlias$_();
                }
                get hostId() {
                    return GetSdkInstance2()._$_GetHostId$_();
                }
                get _$currentGame$_() {
                    return GetSdkInstance2()._$_GetCurrentGame$_();
                }
                get _$currentGameInstance$_() {
                    return GetSdkInstance2()._$_GetCurrentGameInstance$_();
                }
                get _$currentRoom$_() {
                    return GetSdkInstance2()._$_GetCurrentRoom$_();
                }
                get _$peerCount$_() {
                    return GetSdkInstance2()._$_GetAllPeers$_().length;
                }
                _$getAllPeers$_() {
                    return GetSdkInstance2()._$_GetAllPeers$_().map(t => t._$GetScriptInterface$_());
                }
                _$getPeerById$_(t) {
                    e._$RequireString$_(t);
                    const s = GetSdkInstance2()._$_GetPeerById$_(t);
                    return s ? s._$GetScriptInterface$_() : null;
                }
                _$sendPeerMessage$_(t, s, i = "o") {
                    if (e._$RequireString$_(t), "string" != typeof s && "object" != typeof s && !(s instanceof ArrayBuffer)) throw new TypeError("invalid message");
                    if (!j.has(i)) throw new Error("invalid transmission mode");
                    GetSdkInstance2()._$_SendPeerMessage$_(t, null, s, i, "s");
                }
                _$hostBroadcastMessage$_(t, s, i = "o") {
                    if (e._$RequireOptionalString$_(t), "string" != typeof s && "object" != typeof s && !(s instanceof ArrayBuffer)) throw new TypeError("invalid message");
                    if (!j.has(i)) throw new Error("invalid transmission mode");
                    GetSdkInstance2()._$_HostBroadcastMessage$_(t, null, s, i, "s");
                }
                _$disconnectRoom$_() {
                    GetSdkInstance2()._$_DisconnectRoom$_();
                }
                _$simulateLatency$_(t, e, s) {
                    GetSdkInstance2()._$_SimulateLatency$_(t, e, s);
                }
            };
        }
        {
            const da = self._$C3$_, ea = "multiplayer";
            da._$Plugins$_._$Multiplayer$_.Instance = class extends da._$SDKInstanceBase$_ {
                constructor(t, e) {
                    super(t, ea), this._$_isSupported$_ = !1, this._$_errorMessage$_ = "", 
                    this._$_signallingUrl$_ = "", this._$_sigservInfo$_ = {
                        protocolrev: 0,
                        version: 0,
                        name: "",
                        operator: "",
                        motd: ""
                    }, this._$_signallingIsConnected$_ = !1, this._$_signallingIsLoggedIn$_ = !1, 
                    this._$_signallingGameInstanceList$_ = [], this._$_signallingRoomList$_ = [], 
                    this._$_myId$_ = "", this._$_myAlias$_ = "", this._$_isHost$_ = !1, 
                    this._$_hostId$_ = "", this._$_hostAlias$_ = "", this._$_game$_ = "", 
                    this._$_gameInstance$_ = "", this._$_room$_ = "", this._$_nextRoId$_ = 1, 
                    this._$_sidToRoId$_ = new Map(), this._$_roInfoById$_ = new Map(), 
                    this._$_allPeers$_ = [], this._$_peersById$_ = new Map(), this._$_instToPeerId$_ = new Map(), 
                    this._$_peerIdToInst$_ = new Map(), this._$_trackObjects$_ = [], 
                    this._$_inputPredictObjects$_ = new Map(), this._$_objectHistories$_ = new Map(), 
                    this._$_peerId$_ = "", this._$_peerAlias$_ = "", this._$_leaveReason$_ = "", 
                    this._$_msgTag$_ = "", this._$_msgFromId$_ = "", this._$_msgFromAlias$_ = "", 
                    this._$_msgContent$_ = "", this._$_isInBeforeClientUpdate$_ = !1, 
                    this._$_queuedClientUpdates$_ = [], this._$_lastStats$_ = null, 
                    this._$_simTime$_ = 0, this._$_hostInputArrivalTime$_ = 0, this._$_isReadyForInput$_ = !1, 
                    this._$_clientDelay$_ = 0, this._$_clientXerror$_ = 0, this._$_clientYerror$_ = 0, 
                    this._$_hostX$_ = 0, this._$_hostY$_ = 0, this._$_signallingScriptDispatcher$_ = da._$New$_(da.Event._$Dispatcher$_), 
                    this._$_wakerWorker$_ = null, this._$AddDOMMessageHandler$_("signalling-error", t => this._$_OnSignallingError$_(t)), 
                    this._$AddDOMMessageHandler$_("signalling-close", () => this._$_OnSignallingClose$_()), 
                    this._$AddDOMMessageHandler$_("signalling-welcome", t => this._$_OnSignallingWelcome$_(t)), 
                    this._$AddDOMMessageHandler$_("signalling-login-ok", t => this._$_OnSignallingLoginOK$_(t)), 
                    this._$AddDOMMessageHandler$_("signalling-join-ok", t => this._$_OnSignallingJoinOK$_(t)), 
                    this._$AddDOMMessageHandler$_("signalling-leave-ok", () => this._$_OnSignallingLeaveOK$_()), 
                    this._$AddDOMMessageHandler$_("signalling-kicked", () => this._$_OnSignallingKicked$_()), 
                    this._$AddDOMMessageHandler$_("signalling-instance-list", t => this._$_OnSignallingInstanceList$_(t)), 
                    this._$AddDOMMessageHandler$_("signalling-room-list", t => this._$_OnSignallingRoomList$_(t)), 
                    this._$AddDOMMessageHandler$_("peer-open", t => this._$_OnPeerOpen$_(t)), 
                    this._$AddDOMMessageHandler$_("peer-message", t => this._$_OnPeerMessage$_(t)), 
                    this._$AddDOMMessageHandler$_("peer-close", t => this._$_OnPeerClose$_(t)), 
                    this._$AddDOMMessageHandler$_("peer-kicked", () => this._$_OnPeerKicked$_()), 
                    this._$AddDOMMessageHandler$_("add-peer", t => this._$_OnAddPeer$_(t)), 
                    this._$AddDOMMessageHandler$_("remove-peer", t => this._$_OnRemovePeer$_(t)), 
                    this._$AddDOMMessageHandler$_("stats", t => this._$_OnStats$_(t)), 
                    this._$AddDOMMessageHandler$_("before-client-update", () => this._$_OnBeforeClientUpdate$_()), 
                    this._$AddDOMMessageHandler$_("instance-destroyed", t => this._$_OnNotifyInstanceDestroyed$_(t)), 
                    this._$AddDOMMessageHandler$_("get-object-info", t => this._$_OnGetObjectInfo$_(t)), 
                    this._$_runtime$_._$AddLoadPromise$_(this._$_InitWakerWorker$_());
                    const s = this._$_runtime$_._$Dispatcher$_();
                    this._$_disposables$_ = new da._$CompositeDisposable$_(da._$Disposable$_._$From$_(s, "pretick", () => this._$PreTick$_()), da._$Disposable$_._$From$_(s, "instancedestroy", t => this._$_OnInstanceDestroyed$_(t.instance)), da._$Disposable$_._$From$_(s, "suspend", () => this._$_OnSuspend$_()), da._$Disposable$_._$From$_(s, "resume", () => this._$_OnResume$_())), 
                    this._$_runtime$_._$AddLoadPromise$_(this._$PostToDOMAsync$_("get-supported").then(t => {
                        this._$_isSupported$_ = t.isSupported;
                    }));
                }
                async _$_InitWakerWorker$_() {
                    const t = await this._$_runtime$_._$GetAssetManager$_()._$GetProjectFileUrl$_("waker.js");
                    this._$_wakerWorker$_ = new Worker(t, {
                        name: "MultiplayerHostWaker"
                    }), this._$_wakerWorker$_.addEventListener("message", t => {
                        "tick" === t.data && this._$_runtime$_._$IsSuspended$_() && this._$_runtime$_._$Tick$_(performance.now(), !1, "background-wake");
                    }), this._$_wakerWorker$_.postMessage("");
                }
                _$Release$_() {
                    super._$Release$_();
                }
                _$_OnSuspend$_() {
                    this._$_isSupported$_ && this._$IsHost$_() && this._$_wakerWorker$_.postMessage("start");
                }
                _$_OnResume$_() {
                    this._$_wakerWorker$_.postMessage("stop");
                }
                _$IsHost$_() {
                    return this._$IsInRoom$_() && this._$_myId$_ && this._$_myId$_ === this._$_hostId$_;
                }
                _$_DispatchScriptEvent$_(t, e, s) {
                    this._$GetSdkType$_()._$DispatchScriptEvent$_(t, e, s);
                }
                _$_DispatchSignallingScriptEvent$_(t, e, s) {
                    const i = da._$New$_(da.Event, t, e);
                    s && Object.assign(i, s), this._$_signallingScriptDispatcher$_.dispatchEvent(i);
                }
                _$_GetSignallingScriptDispatcher$_() {
                    return this._$_signallingScriptDispatcher$_;
                }
                async _$_SignallingConnect$_(t) {
                    if (this._$_signallingIsConnected$_) throw new Error("already connected");
                    this._$_signallingUrl$_ = t, await this._$PostToDOMAsync$_("signalling-connect", {
                        url: t
                    });
                }
                _$_SignallingDisconnect$_() {
                    this._$_signallingIsConnected$_ && this._$PostToDOM$_("signalling-disconnect");
                }
                _$_AddICEServer$_(t, e, s) {
                    const i = {
                        urls: t
                    };
                    e && (i.username = e), s && (i.credential = s), this._$PostToDOM$_("add-ice-servers", {
                        list: [ i ]
                    });
                }
                async _$_SignallingLogin$_(t) {
                    if (!this._$_signallingIsConnected$_) throw new Error("not connected");
                    if (this._$_signallingIsLoggedIn$_) throw new Error("already logged in");
                    await this._$PostToDOMAsync$_("signalling-login", {
                        alias: t
                    });
                }
                async _$_SignallingJoinRoom$_(t, e, s, i) {
                    if (!this._$_signallingIsLoggedIn$_) throw new Error("not logged in");
                    if (this._$IsInRoom$_()) throw new Error("already in room");
                    await this._$PostToDOMAsync$_("signalling-join-room", {
                        game: t,
                        instance: e,
                        room: s,
                        maxClients: i
                    });
                }
                async _$_SignallingAutoJoinRoom$_(t, e, s, i, r) {
                    if (!this._$_signallingIsLoggedIn$_) throw new Error("not logged in");
                    if (this._$IsInRoom$_()) throw new Error("already in room");
                    await this._$PostToDOMAsync$_("signalling-auto-join-room", {
                        game: t,
                        instance: e,
                        room: s,
                        maxClients: i,
                        lock: r
                    });
                }
                async _$_SignallingLeaveRoom$_() {
                    if (!this._$IsInRoom$_()) throw new Error("not in room");
                    await this._$PostToDOMAsync$_("signalling-leave-room");
                }
                async _$_SignallingRequestGameInstanceList$_(t) {
                    if (!this._$_signallingIsConnected$_) throw new Error("not connected");
                    await this._$PostToDOMAsync$_("signalling-list-game-instances", {
                        game: t
                    });
                }
                async _$_SignallingRequestRoomList$_(t, e, s) {
                    if (!this._$_signallingIsConnected$_) throw new Error("not connected");
                    await this._$PostToDOMAsync$_("signalling-list-rooms", {
                        game: t,
                        instance: e,
                        which: s
                    });
                }
                _$_DisconnectRoom$_() {
                    this._$PostToDOM$_("disconnect-room");
                }
                _$_SendPeerMessage$_(t, e, s, i, r) {
                    this._$PostToDOM$_("peer-send-message", {
                        id: t || this._$_hostId$_,
                        tag: e,
                        message: s,
                        transmissionMode: i,
                        contentMode: r
                    });
                }
                _$_HostBroadcastMessage$_(t, e, s, i, r) {
                    if (!this._$IsHost$_()) throw new Error("not host");
                    this._$PostToDOM$_("host-broadcast", {
                        fromId: t || this._$_hostId$_,
                        tag: e,
                        message: s,
                        transmissionMode: i,
                        contentMode: r
                    });
                }
                _$_SetBandwidthProfile$_(t, e) {
                    this._$PostToDOM$_("set-bandwidth-profile", {
                        updateRate: t,
                        delay: e
                    });
                }
                _$_SimulateLatency$_(t, e, s) {
                    this._$PostToDOM$_("simulate-latency", {
                        latency: 1e3 * t,
                        pdv: 1e3 * e,
                        loss: s
                    });
                }
                _$_KickPeer$_(t, e) {
                    if (!this._$IsHost$_()) throw new Error("not host");
                    if (t === this._$_myId$_) throw new Error("cannot kick self");
                    this._$PostToDOM$_("kick-peer", {
                        id: t,
                        reason: e
                    });
                }
                _$_SignallingIsConnected$_() {
                    return this._$_signallingIsConnected$_;
                }
                _$_SignallingIsLoggedIn$_() {
                    return this._$_signallingIsLoggedIn$_;
                }
                _$_SignallingIsHost$_() {
                    return this._$_isHost$_;
                }
                _$_GetSignallingURL$_() {
                    return this._$_signallingUrl$_;
                }
                _$_GetSignallingVersion$_() {
                    return this._$_sigservInfo$_.version;
                }
                _$_GetSignallingName$_() {
                    return this._$_sigservInfo$_.name;
                }
                _$_GetSignallingOperator$_() {
                    return this._$_sigservInfo$_.operator;
                }
                _$_GetSignallingMOTD$_() {
                    return this._$_sigservInfo$_.motd;
                }
                _$_GetMyId$_() {
                    return this._$_myId$_;
                }
                _$_GetMyAlias$_() {
                    return this._$_myAlias$_;
                }
                _$_GetHostId$_() {
                    return this._$_hostId$_;
                }
                _$_GetHostAlias$_() {
                    return this._$_hostAlias$_;
                }
                _$_GetCurrentGame$_() {
                    return this._$_game$_;
                }
                _$_GetCurrentGameInstance$_() {
                    return this._$_gameInstance$_;
                }
                _$_GetCurrentRoom$_() {
                    return this._$_room$_;
                }
                _$IsInRoom$_() {
                    return !!this._$_room$_;
                }
                _$_GetLastErrorMessage$_() {
                    return this._$_errorMessage$_;
                }
                _$_StatOutboundCount$_() {
                    return this._$_lastStats$_ ? this._$_lastStats$_.outboundPerSec : 0;
                }
                _$_StatOutboundBandwidth$_() {
                    return this._$_lastStats$_ ? this._$_lastStats$_.outboundBandwidthPerSec : 0;
                }
                _$_StatOutboundDecompressedBandwidth$_() {
                    return this._$_lastStats$_ ? this._$_lastStats$_.outboundDecompressedBandwidthPerSec : 0;
                }
                _$_StatInboundCount$_() {
                    return this._$_lastStats$_ ? this._$_lastStats$_.inboundPerSec : 0;
                }
                _$_StatInboundBandwidth$_() {
                    return this._$_lastStats$_ ? this._$_lastStats$_.inboundBandwidthPerSec : 0;
                }
                _$_StatInboundDecompressedBandwidth$_() {
                    return this._$_lastStats$_ ? this._$_lastStats$_.inboundDecompressedBandwidthPerSec : 0;
                }
                _$PreTick$_() {
                    if (this._$_TrackObjectHistories$_(), this._$_runtime$_._$IsInWorker$_()) return this._$_PreTick_Worker$_();
                    this._$_PreTick_DOM$_();
                }
                async _$_PreTick_Worker$_() {
                    const t = await this._$PostToDOMAsync$_("tick", {
                        dt: this._$_runtime$_._$GetDt1$_()
                    });
                    this._$_PreTick_ReadDomInfo$_(t);
                }
                _$_PreTick_DOM$_() {
                    const t = this._$_PostToDOMMaybeSync$_("tick", {
                        dt: this._$_runtime$_._$GetDt1$_()
                    });
                    this._$_PreTick_ReadDomInfo$_(t);
                }
                _$_PreTick_ReadDomInfo$_(t) {
                    if (t) {
                        this._$_simTime$_ = t.simulationTime, this._$_hostInputArrivalTime$_ = t.hostInputArrivalTime, 
                        this._$_clientDelay$_ = t.clientDelay, this._$_isReadyForInput$_ = t.isReadyForInput;
                        for (const [ s, i ] of Object.entries(t.peerData)) {
                            const r = this._$_peersById$_.get(s);
                            r && (r._$SetNid$_(i.nid), r._$SetLatency$_(i.latency), 
                            r._$SetPdv$_(i.pdv), da._$ObjectToMap$_(i.clientState, r._$GetClientState$_()));
                        }
                        const e = t.roData;
                        if (this._$IsInRoom$_() && !this._$IsHost$_()) {
                            const n = {};
                            for (const [ h, o ] of this._$_roInfoById$_) if (e.hasOwnProperty(h)) {
                                const a = this._$_UpdateRegisteredObject$_(h, o, e[h]);
                                a.length && (n[h] = a);
                            }
                            this._$PostToDOM$_("remove-net-insts", n);
                        }
                    }
                }
                async _$_OnSignallingError$_(t) {
                    this._$_errorMessage$_ = t.message, this._$_DispatchSignallingScriptEvent$_("error", !1, {
                        message: this._$_errorMessage$_
                    }), await this._$TriggerAsync$_(da._$Plugins$_._$Multiplayer$_._$Cnds$_._$OnSignallingError$_);
                }
                async _$_OnSignallingClose$_() {
                    this._$_DispatchSignallingScriptEvent$_("disconnected"), await this._$TriggerAsync$_(da._$Plugins$_._$Multiplayer$_._$Cnds$_._$OnSignallingDisconnected$_), 
                    this._$_signallingUrl$_ = "", this._$_signallingIsConnected$_ = !1, 
                    this._$_signallingIsLoggedIn$_ = !1;
                }
                async _$_OnSignallingWelcome$_(t) {
                    this._$_signallingIsConnected$_ = !0, this._$_room$_ = "", this._$_myId$_ = t.myid, 
                    this._$_sigservInfo$_ = t.sigservinfo, this._$_DispatchSignallingScriptEvent$_("connected", !1, {
                        _$myId$_: this._$_GetMyId$_(),
                        _$serverVersion$_: this._$_GetSignallingVersion$_(),
                        _$serverName$_: this._$_GetSignallingName$_(),
                        _$serverOperator$_: this._$_GetSignallingOperator$_(),
                        _$serverMOTD$_: this._$_GetSignallingMOTD$_()
                    }), await this._$TriggerAsync$_(da._$Plugins$_._$Multiplayer$_._$Cnds$_._$OnSignallingConnected$_);
                }
                async _$_OnSignallingLoginOK$_(t) {
                    this._$_myAlias$_ = t.myalias, this._$_signallingIsLoggedIn$_ = !0, 
                    this._$_DispatchSignallingScriptEvent$_("login", !1, {
                        _$myAlias$_: this._$_myAlias$_
                    }), await this._$TriggerAsync$_(da._$Plugins$_._$Multiplayer$_._$Cnds$_._$OnSignallingLoggedIn$_);
                }
                async _$_OnSignallingJoinOK$_(t) {
                    this._$_isHost$_ = t.isHost, this._$_hostId$_ = t.hostId, this._$_hostAlias$_ = t.hostAlias, 
                    this._$_game$_ = t.game, this._$_gameInstance$_ = t.gameInstance, 
                    this._$_room$_ = t.room, this._$_runtime$_._$IsSuspended$_() && this._$_isHost$_ && this._$_wakerWorker$_.postMessage("start"), 
                    this._$_instToPeerId$_.clear(), this._$_peerIdToInst$_.clear(), 
                    this._$_objectHistories$_.clear(), da._$clearArray$_(this._$_trackObjects$_), 
                    this._$_inputPredictObjects$_.clear(), this._$_DispatchSignallingScriptEvent$_("join", !1, {
                        isHost: this._$_isHost$_,
                        hostId: this._$_hostId$_,
                        hostAlias: this._$_hostAlias$_,
                        room: this._$_room$_
                    }), await this._$TriggerAsync$_(da._$Plugins$_._$Multiplayer$_._$Cnds$_._$OnSignallingJoinedRoom$_);
                }
                async _$_OnSignallingLeaveOK$_() {
                    this._$_room$_ = "", this._$_DispatchSignallingScriptEvent$_("leave"), 
                    await this._$TriggerAsync$_(da._$Plugins$_._$Multiplayer$_._$Cnds$_._$OnSignallingLeftRoom$_);
                }
                async _$_OnSignallingKicked$_() {
                    this._$_room$_ = "", this._$_DispatchSignallingScriptEvent$_("kicked"), 
                    await this._$TriggerAsync$_(da._$Plugins$_._$Multiplayer$_._$Cnds$_._$OnSignallingKicked$_);
                }
                async _$_OnPeerKicked$_() {
                    this._$_room$_ = "", this._$_DispatchScriptEvent$_("kicked"), 
                    await this._$TriggerAsync$_(da._$Plugins$_._$Multiplayer$_._$Cnds$_._$OnSignallingKicked$_);
                }
                async _$_OnSignallingInstanceList$_(t) {
                    this._$_signallingGameInstanceList$_ = t.list, await this._$TriggerAsync$_(da._$Plugins$_._$Multiplayer$_._$Cnds$_._$OnGameInstanceList$_);
                }
                async _$_OnSignallingRoomList$_(t) {
                    this._$_signallingRoomList$_ = t.list, await this._$TriggerAsync$_(da._$Plugins$_._$Multiplayer$_._$Cnds$_._$OnRoomList$_);
                }
                _$_GetGameInstanceList$_() {
                    return this._$_signallingGameInstanceList$_;
                }
                _$_GetGameInstanceAt$_(t) {
                    return (t = Math.floor(t)) < 0 || t >= this._$_signallingGameInstanceList$_.length ? null : this._$_signallingGameInstanceList$_[t];
                }
                _$_GetRoomInstanceList$_() {
                    return this._$_signallingRoomList$_;
                }
                _$_GetRoomInstanceAt$_(t) {
                    return (t = Math.floor(t)) < 0 || t >= this._$_signallingRoomList$_.length ? null : this._$_signallingRoomList$_[t];
                }
                async _$_OnPeerOpen$_(t) {
                    this._$_peerId$_ = t.id, this._$_peerAlias$_ = t.alias, this._$_DispatchScriptEvent$_("peerconnect", !1, {
                        peerId: this._$_peerId$_,
                        _$peerAlias$_: this._$_peerAlias$_
                    }), await this._$TriggerAsync$_(da._$Plugins$_._$Multiplayer$_._$Cnds$_._$OnPeerConnected$_);
                }
                async _$_OnPeerMessage$_(t) {
                    const e = t.fromId, s = t.fromAlias, i = t.transmissionMode, r = t.content, n = t.contentMode;
                    "e" === n ? (this._$_msgFromId$_ = e, this._$_msgFromAlias$_ = s, 
                    this._$_msgContent$_ = r, this._$_msgTag$_ = t.tag, await this._$TriggerAsync$_(da._$Plugins$_._$Multiplayer$_._$Cnds$_._$OnAnyPeerMessage$_), 
                    await this._$TriggerAsync$_(da._$Plugins$_._$Multiplayer$_._$Cnds$_._$OnPeerMessage$_)) : "s" === n && this._$_DispatchScriptEvent$_("message", !1, {
                        fromId: e,
                        fromAlias: s,
                        transmissionMode: i,
                        message: r
                    });
                }
                async _$_OnPeerClose$_(t) {
                    this._$_peerId$_ = t.id, this._$_peerAlias$_ = t.alias, this._$_leaveReason$_ = t.reason;
                    const e = this._$_peersById$_.get(this._$_peerId$_), s = this._$GetAssociatedInstanceForPeer$_(this._$_peerId$_);
                    if (s) {
                        const i = this._$_sidToRoId$_.get(s._$GetObjectClass$_()._$GetSID$_());
                        e && i && this._$PostToDOM$_("remove-object-nid", {
                            roId: i,
                            nid: e._$GetNid$_()
                        }), this._$_runtime$_._$DestroyInstance$_(s);
                    }
                    this._$_peerIdToInst$_.delete(this._$_peerId$_), e && e._$MarkClosed$_(), 
                    this._$_DispatchScriptEvent$_("peerdisconnect", !1, {
                        peerId: this._$_peerId$_,
                        _$peerAlias$_: this._$_peerAlias$_,
                        _$leaveReason$_: this._$_leaveReason$_
                    }), this._$_isHost$_ || this._$_peerId$_ !== this._$_hostId$_ || (this._$_room$_ = "", 
                    await this._$TriggerAsync$_(da._$Plugins$_._$Multiplayer$_._$Cnds$_._$OnHostDisconnected$_)), 
                    this._$_isHost$_ && 1 === this._$_allPeers$_.length && !this._$_signallingIsConnected$_ && (this._$_room$_ = ""), 
                    await this._$TriggerAsync$_(da._$Plugins$_._$Multiplayer$_._$Cnds$_._$OnPeerDisconnected$_);
                }
                _$_OnAddPeer$_(t) {
                    const e = da._$New$_(da._$Plugins$_._$Multiplayer$_._$PeerInfo$_, this, t.id, t.alias);
                    this._$_allPeers$_.push(e), this._$_peersById$_.set(e._$GetId$_(), e);
                }
                _$_OnRemovePeer$_(t) {
                    const s = t.id;
                    this._$_peersById$_.delete(s);
                    for (let t = 0, e = this._$_allPeers$_.length; t < e; ++t) {
                        const i = this._$_allPeers$_[t];
                        if (i._$GetId$_() === s) return void this._$_allPeers$_.splice(t, 1);
                    }
                }
                _$_GetAllPeers$_() {
                    return this._$_allPeers$_.filter(t => !t._$IsClosed$_());
                }
                _$_GetPeerById$_(t) {
                    return this._$_peersById$_.get(t) || null;
                }
                _$GetPeerCount$_() {
                    return this._$IsInRoom$_() ? this._$_allPeers$_.length : 0;
                }
                _$GetPeerInfoAt$_(t) {
                    return (t = Math.floor(t)) < 0 || t >= this._$_allPeers$_.length || !this._$IsInRoom$_() ? null : this._$_allPeers$_[t];
                }
                _$GetPeerInfoByNid$_(t) {
                    for (const e of this._$_allPeers$_) if (e._$GetNid$_() === t) return e;
                    return null;
                }
                _$PeerHasClientState$_(t, e) {
                    const s = this._$_peersById$_.get(t);
                    return !!s && s._$GetClientState$_().has(e);
                }
                _$GetPeerInterpClientState$_(t, e) {
                    const s = this._$_peersById$_.get(t);
                    if (!s) return 0;
                    const i = s._$GetClientState$_().get(e);
                    return "number" == typeof i ? i : 0;
                }
                _$_OnStats$_(t) {
                    this._$_lastStats$_ = t.stats;
                }
                _$_OnInstanceDestroyed$_(t) {
                    const e = t._$GetUID$_();
                    this._$_instToPeerId$_.delete(e);
                    for (const [ i, r ] of this._$_peerIdToInst$_) if (e === r) {
                        this._$_peerIdToInst$_.delete(i);
                        break;
                    }
                    this._$_inputPredictObjects$_.delete(t);
                    const s = this._$_trackObjects$_.indexOf(t);
                    -1 !== s && this._$_trackObjects$_.splice(s, 1), this._$_objectHistories$_.delete(t), 
                    this._$PostToDOM$_("remove-object-id", {
                        uid: e
                    });
                }
                _$GetAssociatedInstanceForPeer$_(t) {
                    const e = this._$_peerIdToInst$_.get(t);
                    return void 0 === e ? null : this._$_runtime$_._$GetInstanceByUID$_(e);
                }
                async _$_OnBeforeClientUpdate$_() {
                    this._$_isInBeforeClientUpdate$_ = !0, await this._$TriggerAsync$_(da._$Plugins$_._$Multiplayer$_._$Cnds$_._$OnClientUpdate$_), 
                    this._$_isInBeforeClientUpdate$_ = !1;
                    const t = this._$_queuedClientUpdates$_.slice(0);
                    return da._$clearArray$_(this._$_queuedClientUpdates$_), {
                        clientStateUpdates: t
                    };
                }
                _$GetInputPredicting$_(t) {
                    return this._$_inputPredictObjects$_.get(t);
                }
                _$_TrackObjectHistories$_() {
                    const t = this._$_hostInputArrivalTime$_;
                    for (const e of this._$_trackObjects$_) this._$_TrackObjectHistory$_(e, t);
                }
                _$_TrackObjectHistory$_(t, e) {
                    let s = t._$GetWorldInfo$_(), i = this._$_objectHistories$_.get(t);
                    i || (i = da._$New$_(da._$Plugins$_._$Multiplayer$_._$ObjectHistory$_, t), 
                    this._$_objectHistories$_.set(t, i));
                    const r = da._$New$_(da._$Plugins$_._$Multiplayer$_._$ObjectHistoryEntry$_, i);
                    r.timestamp = e, r.x = s._$GetX$_(), r.y = s._$GetY$_(), r.angle = s.GetAngle(), 
                    da._$shallowAssignArray$_(r.ivs, t._$GetAllInstanceVariableValues$_()), 
                    i._$AddEntry$_(r), i._$ExpireOldEntries$_(e);
                }
                _$_UpdateRegisteredObject$_(t, e, s) {
                    const i = this._$_roInfoById$_.get(t), r = this._$_runtime$_._$GetObjectClassBySID$_(i.sid), n = i._$instMap$_, h = i._$deadMap$_, o = this._$_simTime$_, a = s.netValues, l = s.netInstances;
                    for (const [ c, f ] of n) this._$_runtime$_._$GetInstanceByUID$_(f._$GetUID$_()) || n.delete(c);
                    for (const [ d, p ] of h) p < o - 3e3 && h.delete(d);
                    const u = [];
                    for (const m of l) {
                        const C = m.nid;
                        if (h.get(C) >= o - 3e3) u.push(C), n.has(C) && (this._$_runtime$_._$DestroyInstance$_(n.get(C)), 
                        n.delete(C)); else {
                            let t = null, e = !1;
                            if (n.has(C)) t = n.get(C); else {
                                const g = this._$GetPeerInfoByNid$_(C);
                                if (g) this._$_peerId$_ = g._$GetId$_(), this._$_peerAlias$_ = g._$GetAlias$_(); else {
                                    if (s.hasOverriddenNids) continue;
                                    this._$_peerId$_ = "", this._$_peerAlias$_ = "";
                                }
                                const S = this._$_runtime$_._$GetMainRunningLayout$_();
                                t = this._$_runtime$_._$CreateInstance$_(r, S._$GetLayerByIndex$_(r._$GetDefaultLayerIndex$_()), -1e3, -1e3), 
                                n.set(C, t), e = !0;
                            }
                            if (m.isTimedOut) u.push(C), n.delete(C), this._$_runtime$_._$DestroyInstance$_(t); else {
                                const _ = this._$GetInputPredicting$_(t);
                                if (_) this._$CorrectInputPrediction$_(t, m, a, this._$_simTime$_, _); else {
                                    let s = t._$GetWorldInfo$_(), i = t._$GetAllInstanceVariableValues$_(), r;
                                    for (let t = 0, e = a.length; t < e; ++t) {
                                        const T = m.interpValues[t], y = a[t];
                                        switch (y.tag) {
                                          case "x":
                                            s._$SetX$_(T), s._$SetBboxChanged$_();
                                            break;

                                          case "y":
                                            s._$SetY$_(T), s._$SetBboxChanged$_();
                                            break;

                                          case "a":
                                            s._$SetAngle$_(T), s._$SetBboxChanged$_();
                                            break;

                                          case "iv":
                                            (r = y.userData) > i.length || "number" != typeof i[r] || (i[r] = T);
                                        }
                                    }
                                }
                                e && t._$_TriggerOnCreated$_();
                            }
                        }
                    }
                    return u;
                }
                static _$LinearCorrect$_(t, e, s, i) {
                    const r = e - t;
                    if (0 == r) return 0;
                    const n = Math.abs(r);
                    if (n <= Math.abs(s / 10) || i && (n < 1 || 1e3 <= n)) return r;
                    let h = n / 50, o = Math.abs(s / 5), a = (i && 10 <= n && (h = n / 10, 
                    o = Math.abs(s / 2)), Math.max(h, o));
                    return a > n && (a = n), 0 < r ? a : -a;
                }
                _$CorrectInputPrediction$_(a, l, e, t, s) {
                    const u = a._$GetWorldInfo$_(), c = this._$_objectHistories$_.get(a);
                    if (c) {
                        let i = da._$distanceTo$_(0, 0, c._$GetLastDelta$_("x"), c._$GetLastDelta$_("y")), r = da._$Plugins$_._$Multiplayer$_.Instance._$LinearCorrect$_, n = s._$avoidSolids$_, h = s._$platformMode$_, o = null;
                        h && (o = a._$GetBehaviorSdkInstanceFromCtor$_(da._$Behaviors$_._$Platform$_));
                        for (let s = 0, t = e.length; s < t; ++s) {
                            const f = e[s], d = f.tag, p = f.userData, m = f.interp, C = l.latestUpdate;
                            if (C) {
                                const g = C.data[s], S = c._$GetInterp$_(d, p, C.timestamp, m);
                                if (void 0 !== S) {
                                    let t = 0, e = a._$GetAllInstanceVariableValues$_();
                                    switch (d) {
                                      case "x":
                                        if (0 !== (t = r(S, g, i, !0))) {
                                            const _ = u._$GetX$_();
                                            u._$OffsetX$_(t), u._$SetBboxChanged$_(), 
                                            n && this._$_runtime$_._$GetCollisionEngine$_()._$TestOverlapSolid$_(a) && (u._$SetX$_(_), 
                                            u._$SetBboxChanged$_(), t = 0);
                                        }
                                        this._$_clientXerror$_ = g - S + t, this._$_hostX$_ = g;
                                        break;

                                      case "y":
                                        if (0 !== (t = h && o?._$_IsOnFloor$_() ? 0 : r(S, g, i, !0))) {
                                            const T = u._$GetY$_();
                                            u._$OffsetY$_(t), u._$SetBboxChanged$_(), 
                                            n && this._$_runtime$_._$GetCollisionEngine$_()._$TestOverlapSolid$_(a) && (u._$SetY$_(T), 
                                            u._$SetBboxChanged$_(), t = 0);
                                        }
                                        this._$_clientYerror$_ = g - S + t, this._$_hostY$_ = g;
                                        break;

                                      case "a":
                                        0 != (t = da._$angleLerp$_(S, g, .5) - S) && (u._$SetAngle$_(u.GetAngle() + t), 
                                        u._$SetBboxChanged$_());
                                        break;

                                      case "iv":
                                        p > e.length || "number" != typeof e[p] || f.cvt || (e[p] = l.interpValues[s]);
                                    }
                                    0 !== t && c._$ApplyCorrection$_(d, p, t);
                                }
                            }
                        }
                    }
                }
                _$_OnNotifyInstanceDestroyed$_(t) {
                    const e = t.roId, s = t.nid, i = t.timestamp, r = this._$_roInfoById$_.get(e);
                    if (r) {
                        const n = r._$instMap$_, h = r._$deadMap$_, o = (h.set(s, i), 
                        n.get(s));
                        o && (this._$_runtime$_._$DestroyInstance$_(o), n.delete(s));
                    }
                }
                _$_OnGetObjectInfo$_(t) {
                    const e = {};
                    for (const s of t.ros) {
                        const i = s.roId, r = s.sid, n = s.netValues, h = this._$_runtime$_._$GetObjectClassBySID$_(r);
                        h && (e[i] = h._$GetInstances$_().map(t => this._$_GetInstNetValues$_(t, n)));
                    }
                    return e;
                }
                _$_GetInstNetValues$_(e, t) {
                    return {
                        uid: e._$GetUID$_(),
                        netValues: t.map(t => this._$_GetInstNetValue$_(e, t))
                    };
                }
                _$_GetInstNetValue$_(t, e) {
                    const s = t._$GetWorldInfo$_(), i = e.tag;
                    switch (i) {
                      case "x":
                        return s._$GetX$_();

                      case "y":
                        return s._$GetY$_();

                      case "a":
                        return s.GetAngle();

                      case "iv":
                        {
                            const r = e.userData, n = e.cvt;
                            if (n) {
                                const o = this._$_instToPeerId$_.get(t._$GetUID$_());
                                if (o && this._$_myId$_ !== o && this._$PeerHasClientState$_(o, n)) return this._$GetPeerInterpClientState$_(o, n);
                            }
                            const h = t._$GetAllInstanceVariableValues$_()[r];
                            return "number" == typeof h ? h : 0;
                        }

                      default:
                        return 0;
                    }
                }
                _$LagCompensate$_(t, e, s, i) {
                    if (!this._$_isSupported$_) return 0;
                    if (!this._$IsHost$_()) return 0;
                    const r = this._$_peersById$_.get(t);
                    if (!r) return 0;
                    const n = this._$GetAssociatedInstanceForPeer$_(t);
                    if (!n) return 0;
                    let h = 0, o = n._$GetWorldInfo$_();
                    switch (s) {
                      case "x":
                        h = o._$GetX$_();
                        break;

                      case "y":
                        h = o._$GetY$_();
                        break;

                      case "a":
                        h = o.GetAngle();
                    }
                    const a = this._$_peersById$_.get(e);
                    if (!a || e === t) return h;
                    if (this._$_myId$_ === e) return h;
                    const l = 2 * (a._$GetLatency$_() + this._$_clientDelay$_), u = this._$_objectHistories$_.get(n);
                    if (!u) return h;
                    const c = u._$GetInterp$_(s, 0, performance.now() - l, i);
                    return void 0 === c ? h : c;
                }
                _$GetDebuggerProperties$_() {
                    const t = "plugins.multiplayer.debugger", e = t + ".multiplayer", s = t + ".statistics", i = t + ".signalling", r = [];
                    for (let t = 0, e = this._$GetPeerCount$_(); t < e; ++t) {
                        const n = this._$GetPeerInfoAt$_(t);
                        r.push({
                            name: "$" + n._$GetId$_(),
                            value: n._$GetAlias$_()
                        });
                    }
                    return [ {
                        title: e + ".title",
                        properties: [ {
                            name: e + ".my-id",
                            value: this._$_GetMyId$_()
                        }, {
                            name: e + ".my-alias",
                            value: this._$_GetMyAlias$_()
                        }, {
                            name: e + ".host-id",
                            value: this._$_GetHostId$_()
                        }, {
                            name: e + ".host-alias",
                            value: this._$_GetHostAlias$_()
                        }, {
                            name: e + ".game",
                            value: this._$_GetCurrentGame$_()
                        }, {
                            name: e + ".instance",
                            value: this._$_GetCurrentGameInstance$_()
                        }, {
                            name: e + ".room",
                            value: this._$_GetCurrentRoom$_()
                        } ]
                    }, {
                        title: t + ".peers.title",
                        properties: r
                    }, {
                        title: s + ".title",
                        properties: [ {
                            name: s + ".outbound-count",
                            value: this._$_StatOutboundCount$_()
                        }, {
                            name: s + ".outbound-bandwidth",
                            value: this._$_StatOutboundBandwidth$_()
                        }, {
                            name: s + ".outbound-decompressed-bandwidth",
                            value: this._$_StatOutboundDecompressedBandwidth$_()
                        }, {
                            name: s + ".outbound-compression",
                            value: da._$clamp$_(100 - Math.round(100 * this._$_StatOutboundBandwidth$_() / this._$_StatOutboundDecompressedBandwidth$_()), 0, 100) + "%"
                        }, {
                            name: s + ".inbound-count",
                            value: this._$_StatInboundCount$_()
                        }, {
                            name: s + ".inbound-bandwidth",
                            value: this._$_StatInboundBandwidth$_()
                        }, {
                            name: s + ".inbound-decompressed-bandwidth",
                            value: this._$_StatInboundDecompressedBandwidth$_()
                        }, {
                            name: s + ".inbound-compression",
                            value: da._$clamp$_(100 - Math.round(100 * this._$_StatInboundBandwidth$_() / this._$_StatInboundDecompressedBandwidth$_()), 0, 100) + "%"
                        } ]
                    }, {
                        title: i + ".title",
                        properties: [ {
                            name: i + ".url",
                            value: this._$_GetSignallingURL$_()
                        }, {
                            name: i + ".version",
                            value: this._$_GetSignallingVersion$_()
                        }, {
                            name: i + ".name",
                            value: this._$_GetSignallingName$_()
                        }, {
                            name: i + ".operator",
                            value: this._$_GetSignallingOperator$_()
                        }, {
                            name: i + ".motd",
                            value: this._$_GetSignallingMOTD$_()
                        } ]
                    } ];
                }
            };
        }
        {
            const Fc = self._$C3$_;
            Fc._$Plugins$_._$Multiplayer$_._$Cnds$_ = {
                _$OnSignallingError$_() {
                    return !0;
                },
                _$OnSignallingConnected$_() {
                    return !0;
                },
                _$OnSignallingDisconnected$_() {
                    return !0;
                },
                _$OnSignallingLoggedIn$_() {
                    return !0;
                },
                _$OnSignallingJoinedRoom$_() {
                    return !0;
                },
                _$OnSignallingLeftRoom$_() {
                    return !0;
                },
                _$OnSignallingKicked$_() {
                    return !0;
                },
                _$OnPeerConnected$_() {
                    return !0;
                },
                _$OnPeerDisconnected$_() {
                    return !0;
                },
                _$OnHostDisconnected$_() {
                    return !0;
                },
                _$SignallingIsConnected$_() {
                    return this._$_SignallingIsConnected$_();
                },
                _$SignallingIsLoggedIn$_() {
                    return this._$_SignallingIsLoggedIn$_();
                },
                _$SignallingIsInRoom$_() {
                    return this._$IsInRoom$_();
                },
                _$IsHost$_() {
                    return this._$_SignallingIsHost$_();
                },
                _$IsSupported$_() {
                    return this._$_isSupported$_;
                },
                _$OnPeerMessage$_(t) {
                    return this._$_msgTag$_ === t;
                },
                _$OnAnyPeerMessage$_() {
                    return !0;
                },
                _$OnClientUpdate$_() {
                    return !0;
                },
                _$OnGameInstanceList$_() {
                    return !0;
                },
                _$OnRoomList$_() {
                    return !0;
                },
                _$IsReadyForInput$_() {
                    return this._$_isReadyForInput$_;
                },
                _$ComparePeerCount$_(t, e) {
                    return Fc.compare(this._$_allPeers$_.length, t, e);
                },
                _$OnServerList$_() {
                    return !1;
                }
            };
        }
        {
            let ModeToDCType2 = function(t) {
                switch (t) {
                  case 0:
                    return "o";

                  case 1:
                    return "r";

                  case 2:
                    return "u";

                  default:
                    return "o";
                }
            }, Jc = (ModeToDCType = ModeToDCType2, self._$C3$_), d = !1;
            Jc._$Plugins$_._$Multiplayer$_._$Acts$_ = {
                async _$SignallingConnect$_(t) {
                    this._$_isSupported$_ && !this._$_signallingIsConnected$_ && await this._$_SignallingConnect$_(t);
                },
                _$SignallingDisconnect$_() {
                    this._$_isSupported$_ && this._$_SignallingDisconnect$_();
                },
                _$AddICEServer$_(t, e, s) {
                    this._$_isSupported$_ && this._$_AddICEServer$_(t, e, s);
                },
                async _$SignallingLogin$_(t) {
                    this._$_isSupported$_ && this._$_signallingIsConnected$_ && !this._$_signallingIsLoggedIn$_ && await this._$_SignallingLogin$_(t);
                },
                async _$SignallingJoinRoom$_(t, e, s, i) {
                    this._$_isSupported$_ && this._$_signallingIsLoggedIn$_ && !this._$IsInRoom$_() && await this._$_SignallingJoinRoom$_(t, e, s, i);
                },
                async _$SignallingAutoJoinRoom$_(t, e, s, i, r) {
                    this._$_isSupported$_ && this._$_signallingIsLoggedIn$_ && !this._$IsInRoom$_() && await this._$_SignallingAutoJoinRoom$_(t, e, s, i, 0 === r);
                },
                async _$SignallingLeaveRoom$_() {
                    this._$_isSupported$_ && this._$IsInRoom$_() && await this._$_SignallingLeaveRoom$_();
                },
                _$DisconnectRoom$_() {
                    this._$_isSupported$_ && this._$_DisconnectRoom$_();
                },
                _$SendPeerMessage$_(t, e, s, i) {
                    this._$_isSupported$_ && this._$_SendPeerMessage$_(t, e, s, ModeToDCType2(i), "e");
                },
                _$HostBroadcastMessage$_(t, e, s, i) {
                    this._$_isSupported$_ && this._$IsHost$_() && this._$_HostBroadcastMessage$_(t, e, s, ModeToDCType2(i), "e");
                },
                _$SimulateLatency$_(t, e, s) {
                    this._$_isSupported$_ && this._$_SimulateLatency$_(t, e, s);
                },
                _$SyncObject$_(t, e, s, i) {
                    let r = !1, n = !1, h = !1;
                    1 === e ? (r = !0, n = !0) : 2 === e ? h = !0 : 3 === e && (r = !0, 
                    n = !0, h = !0), Jc._$Plugins$_._$Multiplayer$_._$Acts$_._$SyncObject2$_.call(this, t, r, n, h, s, i);
                },
                _$SyncObject2$_(e, s, i, r, n, h) {
                    if (this._$_isSupported$_) {
                        let t = [];
                        for (const o of e._$IsFamily$_() ? e._$GetFamilyMembers$_() : [ e ]) {
                            const a = o._$GetSID$_(), l = this._$_nextRoId$_++;
                            this._$_roInfoById$_.set(l, {
                                sid: a,
                                _$instMap$_: new Map(),
                                _$deadMap$_: new Map()
                            }), this._$_sidToRoId$_.set(a, l), t.push({
                                roId: l,
                                sid: a
                            });
                        }
                        this._$PostToDOM$_("sync-object", {
                            objectClasses: t,
                            x: s,
                            y: i,
                            angle: r,
                            precision: n,
                            bandwidth: h
                        });
                    }
                },
                _$SyncObjectInstanceVar$_(s, i, t, r, n) {
                    if (this._$_isSupported$_) {
                        let e = [];
                        for (const h of s._$IsFamily$_() ? s._$GetFamilyMembers$_() : [ s ]) {
                            const o = this._$_sidToRoId$_.get(h._$GetSID$_());
                            if (!o) return void (d || (d = !0, this._$PostToDOM$_("alert", {
                                message: `Multiplayer object: incorrect use of 'Sync instance variable' for object type '${h._$GetName$_()}'. You must use 'Sync object' before you can use 'Sync instance variable'. Please refer to the documentation for more information.`
                            })));
                            let t = i;
                            s._$IsFamily$_() && (t += h._$GetFamilyInstanceVariableOffset$_(s._$GetFamilyIndex$_())), 
                            e.push({
                                roId: o,
                                varIndex: t
                            });
                        }
                        this._$PostToDOM$_("sync-inst-var", {
                            syncData: e,
                            precision: t,
                            interp: r,
                            cvt: n
                        });
                    }
                },
                _$AssociateObjectWithPeer$_(t, e) {
                    if (this._$_isSupported$_ && this._$_peersById$_.has(e)) {
                        const s = t._$GetFirstPicked$_();
                        if (s) {
                            const i = this._$_sidToRoId$_.get(t._$GetSID$_());
                            i && (this._$IsHost$_() && !this._$_trackObjects$_.includes(s) && this._$_trackObjects$_.push(s), 
                            this._$_instToPeerId$_.set(s._$GetUID$_(), e), this._$_peerIdToInst$_.set(e, s._$GetUID$_()), 
                            this._$PostToDOM$_("associate-object", {
                                roId: i,
                                peerId: e,
                                instUid: s._$GetUID$_()
                            }));
                        }
                    }
                },
                _$SetClientState$_(t, e) {
                    if (this._$_isSupported$_) {
                        const s = {
                            tag: t,
                            value: e
                        };
                        this._$_isInBeforeClientUpdate$_ ? this._$_queuedClientUpdates$_.push(s) : this._$PostToDOM$_("set-client-state", s);
                    }
                },
                _$AddClientInputValue$_(t, e, s) {
                    this._$_isSupported$_ && this._$PostToDOM$_("add-client-input-value", {
                        tag: t,
                        precision: e,
                        interp: s
                    });
                },
                _$InputPredictObject$_(t, e, s) {
                    if (this._$_isSupported$_ && t && !this._$IsHost$_()) {
                        const i = t._$GetFirstPicked$_();
                        i && !this._$_inputPredictObjects$_.has(i) && (this._$_trackObjects$_.push(i), 
                        this._$_inputPredictObjects$_.set(i, {
                            _$avoidSolids$_: e,
                            _$platformMode$_: s
                        }));
                    }
                },
                async _$SignallingRequestGameInstanceList$_(t) {
                    this._$_isSupported$_ && this._$_signallingIsConnected$_ && await this._$_SignallingRequestGameInstanceList$_(t);
                },
                async _$SignallingRequestRoomList$_(e, s, i) {
                    if (this._$_isSupported$_ && this._$_signallingIsConnected$_) {
                        let t = "all";
                        1 === i ? t = "unlocked" : 2 === i && (t = "available"), 
                        await this._$_SignallingRequestRoomList$_(e, s, t);
                    }
                },
                _$SetBandwidthProfile$_(s) {
                    if (this._$_isSupported$_) {
                        let t, e;
                        e = 0 === s ? (t = 30, 80) : (t = 60, 40), this._$_SetBandwidthProfile$_(t, e);
                    }
                },
                _$KickPeer$_(t, e) {
                    this._$_isSupported$_ && this._$IsHost$_() && t !== this._$_myId$_ && this._$_KickPeer$_(t, e);
                },
                _$RequestServerList$_(t) {}
            };
        }
        {
            const id = self._$C3$_;
            id._$Plugins$_._$Multiplayer$_._$Exps$_ = {
                _$SignallingURL$_() {
                    return this._$_GetSignallingURL$_();
                },
                _$SignallingVersion$_() {
                    return this._$_GetSignallingVersion$_();
                },
                _$SignallingName$_() {
                    return this._$_GetSignallingName$_();
                },
                _$SignallingOperator$_() {
                    return this._$_GetSignallingOperator$_();
                },
                _$SignallingMOTD$_() {
                    return this._$_GetSignallingMOTD$_();
                },
                _$MyAlias$_() {
                    return this._$_GetMyAlias$_();
                },
                _$CurrentGame$_() {
                    return this._$_GetCurrentGame$_();
                },
                _$CurrentInstance$_() {
                    return this._$_GetCurrentGameInstance$_();
                },
                _$CurrentRoom$_() {
                    return this._$_GetCurrentRoom$_();
                },
                _$ErrorMessage$_() {
                    return this._$_GetLastErrorMessage$_();
                },
                _$MyID$_() {
                    return this._$_GetMyId$_();
                },
                _$PeerID$_() {
                    return this._$_peerId$_;
                },
                _$PeerAlias$_() {
                    return this._$_peerAlias$_;
                },
                _$HostID$_() {
                    return this._$_GetHostId$_();
                },
                _$HostAlias$_() {
                    return this._$_GetHostAlias$_();
                },
                _$Message$_() {
                    return this._$_msgContent$_;
                },
                Tag() {
                    return this._$_msgTag$_;
                },
                _$FromID$_() {
                    return this._$_msgFromId$_;
                },
                _$FromAlias$_() {
                    return this._$_msgFromAlias$_;
                },
                _$PeerAliasFromID$_(t) {
                    const e = this._$_peersById$_.get(t);
                    return e ? e._$GetAlias$_() : "";
                },
                _$PeerLatency$_(t) {
                    const e = this._$_peersById$_.get(t);
                    return e ? e._$GetLatency$_() : 0;
                },
                _$PeerPDV$_(t) {
                    const e = this._$_peersById$_.get(t);
                    return e ? e._$GetPdv$_() : 0;
                },
                _$StatOutboundCount$_() {
                    return this._$_StatOutboundCount$_();
                },
                _$StatOutboundBandwidth$_() {
                    return this._$_StatOutboundBandwidth$_();
                },
                _$StatOutboundDecompressedBandwidth$_() {
                    return this._$_StatOutboundDecompressedBandwidth$_();
                },
                _$StatInboundCount$_() {
                    return this._$_StatInboundCount$_();
                },
                _$StatInboundBandwidth$_() {
                    return this._$_StatInboundBandwidth$_();
                },
                _$StatInboundDecompressedBandwidth$_() {
                    return this._$_StatInboundDecompressedBandwidth$_();
                },
                _$PeerState$_(t, e) {
                    return this._$GetPeerInterpClientState$_(t, e);
                },
                _$ClientXError$_() {
                    return this._$_clientXerror$_;
                },
                _$ClientYError$_() {
                    return this._$_clientYerror$_;
                },
                _$HostX$_() {
                    return this._$_hostX$_;
                },
                _$HostY$_() {
                    return this._$_hostY$_;
                },
                _$PeerCount$_() {
                    return this._$GetPeerCount$_();
                },
                _$ListInstanceCount$_() {
                    return this._$_signallingGameInstanceList$_.length;
                },
                _$ListInstanceName$_(t) {
                    const e = this._$_GetGameInstanceAt$_(t);
                    return e ? e.name : "";
                },
                _$ListInstancePeerCount$_(t) {
                    const e = this._$_GetGameInstanceAt$_(t);
                    return e ? e.peercount : 0;
                },
                _$ListRoomCount$_() {
                    return this._$_signallingRoomList$_.length;
                },
                _$ListRoomName$_(t) {
                    const e = this._$_GetRoomInstanceAt$_(t);
                    return e ? e.name : "";
                },
                _$ListRoomPeerCount$_(t) {
                    const e = this._$_GetRoomInstanceAt$_(t);
                    return e ? e.peercount : 0;
                },
                _$ListRoomMaxPeerCount$_(t) {
                    const e = this._$_GetRoomInstanceAt$_(t);
                    return e ? e.maxpeercount : 0;
                },
                _$ListRoomState$_(t) {
                    const e = this._$_GetRoomInstanceAt$_(t);
                    return e ? e.state : "";
                },
                _$LeaveReason$_() {
                    return this._$_leaveReason$_;
                },
                _$LagCompensateX$_(t, e) {
                    return this._$LagCompensate$_(t, e, "x", 1);
                },
                _$LagCompensateY$_(t, e) {
                    return this._$LagCompensate$_(t, e, "y", 1);
                },
                _$LagCompensateAngle$_(t, e) {
                    return id._$toDegrees$_(this._$LagCompensate$_(t, e, "a", 2));
                },
                _$PeerIDAt$_(t) {
                    const e = this._$GetPeerInfoAt$_(t);
                    return e ? e._$GetId$_() : "";
                },
                _$PeerAliasAt$_(t) {
                    const e = this._$GetPeerInfoAt$_(t);
                    return e ? e._$GetAlias$_() : "";
                },
                _$ServerListCount$_() {
                    return 0;
                },
                _$ServerListURLAt$_(t) {
                    return "";
                },
                _$ServerListNameAt$_(t) {
                    return "";
                },
                _$ServerListOperatorAt$_(t) {
                    return "";
                },
                _$ServerListWebsiteAt$_(t) {
                    return "";
                }
            };
        }
        {
            let InterpNetValue2 = function(t, e, s, i, r) {
                switch (t) {
                  case 0:
                    return r ? s : e;

                  case 1:
                    return C33._$lerp$_(e, s, i);

                  case 2:
                    return C33._$angleLerp$_(e, s, i);

                  default:
                    return r ? s : e;
                }
            };
            InterpNetValue = InterpNetValue2;
            const C33 = self._$C3$_;
            C33._$Plugins$_._$Multiplayer$_._$ObjectHistoryEntry$_ = class extends C33._$DefendedBase$_ {
                constructor(t) {
                    super(), this._$oh$_ = t, this.timestamp = 0, this.x = 0, this.y = 0, 
                    this.angle = 0, this.ivs = [];
                }
            }, C33._$Plugins$_._$Multiplayer$_._$ObjectHistory$_ = class extends C33._$DefendedBase$_ {
                constructor(t) {
                    super(), this._$_inst$_ = t, this._$_history$_ = [];
                }
                _$AddEntry$_(t) {
                    this._$_history$_.push(t);
                }
                _$ExpireOldEntries$_(t) {
                    for (;0 < this._$_history$_.length && this._$_history$_[0].timestamp <= t - 2e3; ) this._$_history$_.shift();
                }
                _$GetLastDelta$_(t, e) {
                    if (!(this._$_history$_.length < 2)) {
                        const s = this._$_history$_.at(-2), i = this._$_history$_.at(-1);
                        switch (t) {
                          case "x":
                            return i.x - s.x;

                          case "y":
                            return i.y - s.y;

                          case "a":
                            return i.angle - s.angle;

                          case "iv":
                            return i.ivs[e] - s.ivs[e];
                        }
                    }
                    return 0;
                }
                _$GetInterp$_(s, i, r, n) {
                    let h = null, o = null;
                    for (let t = 0, e = this._$_history$_.length; t < e; ++t) {
                        const a = this._$_history$_[t];
                        if (!(a.timestamp < r)) {
                            t + 1 < this._$_history$_.length && (o = this._$_history$_[t + 1]);
                            break;
                        }
                        h = a;
                    }
                    if (h) {
                        let t = 0;
                        switch (s) {
                          case "x":
                            t = h.x;
                            break;

                          case "y":
                            t = h.y;
                            break;

                          case "a":
                            t = h.angle;
                            break;

                          case "iv":
                            t = h.ivs[i];
                        }
                        if (!o) return t;
                        let e = t;
                        switch (s) {
                          case "x":
                            e = o.x;
                            break;

                          case "y":
                            e = o.y;
                            break;

                          case "a":
                            e = o.angle;
                            break;

                          case "iv":
                            e = o.ivs[i];
                        }
                        const l = C33._$unlerp$_(h.timestamp, o.timestamp, r);
                        return InterpNetValue2(n, t, e, l, !1);
                    }
                }
                _$ApplyCorrection$_(t, e, s) {
                    for (const i of this._$_history$_) switch (t) {
                      case "x":
                        i.x += s;
                        break;

                      case "y":
                        i.y += s;
                        break;

                      case "a":
                        i.angle += s;
                        break;

                      case "iv":
                        i.ivs[e] += s;
                    }
                }
            };
        }
        {
            const C33 = self._$C3$_, C3X = self._$C3X$_, map = (C33._$Plugins$_._$Multiplayer$_._$PeerInfo$_ = class {
                constructor(t, e, s) {
                    this._$_mpInst$_ = t, this._$_id$_ = e, this._$_alias$_ = s, 
                    this._$_nid$_ = -1, this._$_latency$_ = 0, this._$_pdv$_ = 0, 
                    this._$_clientState$_ = new Map(), this._$_isClosed$_ = !1, 
                    this._$_iPeer$_ = null;
                }
                _$_GetInst$_() {
                    return this._$_mpInst$_;
                }
                _$GetId$_() {
                    return this._$_id$_;
                }
                _$GetAlias$_() {
                    return this._$_alias$_;
                }
                _$SetNid$_(t) {
                    C3X._$RequireFiniteNumber$_(t), this._$_nid$_ = t;
                }
                _$GetNid$_() {
                    return this._$_nid$_;
                }
                _$SetLatency$_(t) {
                    this._$_latency$_ = t;
                }
                _$GetLatency$_() {
                    return this._$_latency$_;
                }
                _$SetPdv$_(t) {
                    this._$_pdv$_ = t;
                }
                _$GetPdv$_() {
                    return this._$_pdv$_;
                }
                _$GetClientState$_() {
                    return this._$_clientState$_;
                }
                _$MarkClosed$_() {
                    this._$_isClosed$_ = !0;
                }
                _$IsClosed$_() {
                    return this._$_isClosed$_;
                }
                _$GetScriptInterface$_() {
                    return this._$_iPeer$_ || (this._$_iPeer$_ = C33._$New$_(self._$IMultiplayerPeer$_, this)), 
                    this._$_iPeer$_;
                }
            }, new WeakMap());
            self._$IMultiplayerPeer$_ = class {
                constructor(t) {
                    const e = {
                        id: {
                            value: t._$GetId$_(),
                            writable: !1
                        },
                        alias: {
                            value: t._$GetAlias$_(),
                            writable: !1
                        },
                        isHost: {
                            value: t._$GetId$_() === t._$_GetInst$_()._$_GetHostId$_(),
                            writable: !1
                        },
                        _$isMe$_: {
                            value: t._$GetId$_() === t._$_GetInst$_()._$_GetMyId$_(),
                            writable: !1
                        }
                    };
                    Object.defineProperties(this, e), map.set(this, t);
                }
                get latency() {
                    return map.get(this)._$GetLatency$_();
                }
                get pdv() {
                    return map.get(this)._$GetPdv$_();
                }
                send(t, e = "o") {
                    map.get(this)._$_GetInst$_()._$GetObjectClass$_()._$GetIObjectClass$_()._$sendPeerMessage$_(this.id, t, e);
                }
            };
        }
        {
            const a = self._$C3$_;
            a._$Plugins$_._$qrcode$_ = class extends a._$SDKPluginBase$_ {
                constructor(t) {
                    super(t);
                }
                _$Release$_() {
                    super._$Release$_();
                }
            };
        }
        {
            const d = self._$C3$_;
            d._$Plugins$_._$qrcode$_._$Type$_ = class extends d._$SDKTypeBase$_ {
                constructor(t) {
                    super(t);
                }
                _$Release$_() {
                    super._$Release$_();
                }
                _$OnCreate$_() {}
            };
        }
        {
            let g = self._$C3$_, h = self._$C3X$_, i = g._$New$_(g.Rect), r = !1;
            g._$Plugins$_._$qrcode$_.Instance = class extends g._$SDKWorldInstanceBase$_ {
                constructor(t, e) {
                    super(t), this._$_text$_ = "", this._$_correctionLevel$_ = "h", 
                    e && (this._$_text$_ = e[0], this._$_correctionLevel$_ = [ "l", "m", "q", "h" ][e[1]], 
                    this._$GetWorldInfo$_()._$SetVisible$_(e[2]));
                    const s = this._$_runtime$_._$Dispatcher$_();
                    this._$_disposables$_ = new g._$CompositeDisposable$_(g._$Disposable$_._$From$_(s, "renderercontextlost", () => this._$_OnRendererContextLost$_())), 
                    this._$_qrTexture$_ = null;
                }
                _$Release$_() {
                    this._$_ReleaseTexture$_(), super._$Release$_();
                }
                _$_GetQRCodeCorrectionLevel$_(t) {
                    const e = self._$C3_QRCode$_._$CorrectLevel$_;
                    switch (t) {
                      case "l":
                        return e._$L$_;

                      case "m":
                        return e._$M$_;

                      case "q":
                        return e.Q;

                      case "h":
                        return e._$H$_;

                      default:
                        throw new Error(`unknown correction level '${t}'`);
                    }
                }
                _$_GenerateQRCodeTexture$_(t) {
                    this._$_ReleaseTexture$_();
                    try {
                        const e = new self._$C3_QRCode$_(null, {
                            width: 512,
                            height: 512,
                            text: this._$_text$_,
                            _$correctLevel$_: this._$_GetQRCodeCorrectionLevel$_(this._$_correctionLevel$_)
                        });
                        this._$_qrTexture$_ = t._$CreateStaticTexture$_(e._$getCanvas$_(), {
                            _$sampling$_: "nearest"
                        });
                    } catch (t) {
                        r || (console.error(`Unable to create QR code with text length ${this._$_text$_.length}: `, t), 
                        r = !0);
                    }
                }
                _$_ReleaseTexture$_() {
                    this._$_qrTexture$_ && (this._$_runtime$_._$GetRenderer$_()._$DeleteTexture$_(this._$_qrTexture$_), 
                    this._$_qrTexture$_ = null);
                }
                _$_OnRendererContextLost$_() {
                    this._$_qrTexture$_ = null;
                }
                _$Draw$_(t) {
                    this._$_qrTexture$_ || this._$_GenerateQRCodeTexture$_(t);
                    const e = this._$GetWorldInfo$_(), s = e._$GetBoundingBox$_(), r = Math.min(s.width(), s.height());
                    i._$setWH$_(s._$getLeft$_(), s._$getTop$_(), r, r), t._$SetTexture$_(this._$_qrTexture$_), 
                    t.Rect(i);
                }
                _$_SetText$_(t) {
                    this._$_text$_ !== t && (this._$_text$_ = t, this._$_ReleaseTexture$_(), 
                    this._$_runtime$_._$UpdateRender$_());
                }
                _$_GetText$_() {
                    return this._$_text$_;
                }
                _$_SetCorrectionLevel$_(t) {
                    this._$_correctionLevel$_ !== t && (this._$_correctionLevel$_ = t, 
                    this._$_ReleaseTexture$_(), this._$_runtime$_._$UpdateRender$_());
                }
                _$_GetCorrectionLevel$_(t) {
                    return this._$_correctionLevel$_;
                }
                _$GetDebuggerProperties$_() {
                    const t = "plugins.qrcode", e = t + ".properties";
                    return [ {
                        title: t + ".name",
                        properties: [ {
                            name: e + ".text.name",
                            value: this._$_GetText$_(),
                            _$onedit$_: t => this._$_SetText$_(t)
                        }, {
                            name: e + ".correction-level.name",
                            value: this._$_GetCorrectionLevel$_().toUpperCase()
                        } ]
                    } ];
                }
                _$GetScriptInterfaceClass$_() {
                    return self._$IQRCodeInstance$_;
                }
            };
            const k = new WeakMap(), l = new Set([ "l", "m", "q", "h" ]);
            self._$IQRCodeInstance$_ = class extends self._$IWorldInstance$_ {
                constructor() {
                    super(), k.set(this, self._$IInstance$_._$_GetInitInst$_()._$GetSdkInstance$_());
                }
                set text(t) {
                    h._$RequireString$_(t), k.get(this)._$_SetText$_(t);
                }
                get text() {
                    return k.get(this)._$_GetText$_();
                }
                set _$correctionLevel$_(t) {
                    if (!l.has(t)) throw new Error(`invalid correction level '${t}'`);
                    k.get(this)._$_SetCorrectionLevel$_(t);
                }
                get _$correctionLevel$_() {
                    return k.get(this)._$_GetCorrectionLevel$_();
                }
            };
        }
        {
            const I = self._$C3$_;
            I._$Plugins$_._$qrcode$_._$Cnds$_ = {};
        }
        {
            const J = self._$C3$_;
            J._$Plugins$_._$qrcode$_._$Acts$_ = {
                _$SetText$_(t) {
                    this._$_SetText$_(t);
                },
                _$SetCorrectionLevel$_(t) {
                    this._$_SetCorrectionLevel$_([ "l", "m", "q", "h" ][t]);
                }
            };
        }
        {
            const M = self._$C3$_;
            M._$Plugins$_._$qrcode$_._$Exps$_ = {};
        }
        (() => {
            function e(t) {
                this.mode = n._$MODE_8BIT_BYTE$_, this.data = t, this._$parsedData$_ = [];
                for (var e = 0, s = this.data.length; e < s; e++) {
                    var i = [], r = this.data.charCodeAt(e);
                    65536 < r ? (i[0] = 240 | (1835008 & r) >>> 18, i[1] = 128 | (258048 & r) >>> 12, 
                    i[2] = 128 | (4032 & r) >>> 6, i[3] = 128 | 63 & r) : 2048 < r ? (i[0] = 224 | (61440 & r) >>> 12, 
                    i[1] = 128 | (4032 & r) >>> 6, i[2] = 128 | 63 & r) : 128 < r ? (i[0] = 192 | (1984 & r) >>> 6, 
                    i[1] = 128 | 63 & r) : i[0] = r, this._$parsedData$_.push(i);
                }
                this._$parsedData$_ = Array.prototype.concat.apply([], this._$parsedData$_), 
                this._$parsedData$_.length != this.data.length && (this._$parsedData$_.unshift(191), 
                this._$parsedData$_.unshift(187), this._$parsedData$_.unshift(239));
            }
            function a(t, e) {
                this._$typeNumber$_ = t, this._$errorCorrectLevel$_ = e, this._$modules$_ = null, 
                this._$moduleCount$_ = 0, this._$dataCache$_ = null, this._$dataList$_ = [];
            }
            e.prototype = {
                _$getLength$_: function(t) {
                    return this._$parsedData$_.length;
                },
                write: function(t) {
                    for (var e = 0, s = this._$parsedData$_.length; e < s; e++) t.put(this._$parsedData$_[e], 8);
                }
            }, a.prototype = {
                _$addData$_: function(t) {
                    t = new e(t), this._$dataList$_.push(t), this._$dataCache$_ = null;
                },
                _$isDark$_: function(t, e) {
                    if (t < 0 || this._$moduleCount$_ <= t || e < 0 || this._$moduleCount$_ <= e) throw new Error(t + "," + e);
                    return this._$modules$_[t][e];
                },
                _$getModuleCount$_: function() {
                    return this._$moduleCount$_;
                },
                _$make$_: function() {
                    this._$makeImpl$_(!1, this._$getBestMaskPattern$_());
                },
                _$makeImpl$_: function(t, e) {
                    this._$moduleCount$_ = 4 * this._$typeNumber$_ + 17, this._$modules$_ = new Array(this._$moduleCount$_);
                    for (var s = 0; s < this._$moduleCount$_; s++) {
                        this._$modules$_[s] = new Array(this._$moduleCount$_);
                        for (var i = 0; i < this._$moduleCount$_; i++) this._$modules$_[s][i] = null;
                    }
                    this._$setupPositionProbePattern$_(0, 0), this._$setupPositionProbePattern$_(this._$moduleCount$_ - 7, 0), 
                    this._$setupPositionProbePattern$_(0, this._$moduleCount$_ - 7), 
                    this._$setupPositionAdjustPattern$_(), this._$setupTimingPattern$_(), 
                    this._$setupTypeInfo$_(t, e), 7 <= this._$typeNumber$_ && this._$setupTypeNumber$_(t), 
                    null == this._$dataCache$_ && (this._$dataCache$_ = a._$createData$_(this._$typeNumber$_, this._$errorCorrectLevel$_, this._$dataList$_)), 
                    this._$mapData$_(this._$dataCache$_, e);
                },
                _$setupPositionProbePattern$_: function(t, e) {
                    for (var s = -1; s <= 7; s++) if (!(t + s <= -1 || this._$moduleCount$_ <= t + s)) for (var i = -1; i <= 7; i++) e + i <= -1 || this._$moduleCount$_ <= e + i || (this._$modules$_[t + s][e + i] = 0 <= s && s <= 6 && (0 == i || 6 == i) || 0 <= i && i <= 6 && (0 == s || 6 == s) || 2 <= s && s <= 4 && 2 <= i && i <= 4);
                },
                _$getBestMaskPattern$_: function() {
                    for (var t = 0, e = 0, s = 0; s < 8; s++) {
                        this._$makeImpl$_(!0, s);
                        var i = C._$getLostPoint$_(this);
                        (0 == s || i < t) && (t = i, e = s);
                    }
                    return e;
                },
                _$createMovieClip$_: function(t, e, s) {
                    var i = t.createEmptyMovieClip(e, s);
                    this._$make$_();
                    for (var r = 0; r < this._$modules$_.length; r++) for (var n = +r, h = 0; h < this._$modules$_[r].length; h++) {
                        var o = +h;
                        this._$modules$_[r][h] && (i.beginFill(0, 100), i.moveTo(o, n), 
                        i.lineTo(1 + o, n), i.lineTo(1 + o, 1 + n), i.lineTo(o, 1 + n), 
                        i.endFill());
                    }
                    return i;
                },
                _$setupTimingPattern$_: function() {
                    for (var t = 8; t < this._$moduleCount$_ - 8; t++) null == this._$modules$_[t][6] && (this._$modules$_[t][6] = t % 2 == 0);
                    for (var e = 8; e < this._$moduleCount$_ - 8; e++) null == this._$modules$_[6][e] && (this._$modules$_[6][e] = e % 2 == 0);
                },
                _$setupPositionAdjustPattern$_: function() {
                    for (var t = C._$getPatternPosition$_(this._$typeNumber$_), e = 0; e < t.length; e++) for (var s = 0; s < t.length; s++) {
                        var i = t[e], r = t[s];
                        if (null == this._$modules$_[i][r]) for (var n = -2; n <= 2; n++) for (var h = -2; h <= 2; h++) this._$modules$_[i + n][r + h] = -2 == n || 2 == n || -2 == h || 2 == h || 0 == n && 0 == h;
                    }
                },
                _$setupTypeNumber$_: function(t) {
                    for (var e = C._$getBCHTypeNumber$_(this._$typeNumber$_), s = 0; s < 18; s++) {
                        var i = !t && 1 == (e >> s & 1);
                        this._$modules$_[Math.floor(s / 3)][s % 3 + this._$moduleCount$_ - 8 - 3] = i;
                    }
                    for (s = 0; s < 18; s++) i = !t && 1 == (e >> s & 1), this._$modules$_[s % 3 + this._$moduleCount$_ - 8 - 3][Math.floor(s / 3)] = i;
                },
                _$setupTypeInfo$_: function(t, e) {
                    for (var e = this._$errorCorrectLevel$_ << 3 | e, s = C._$getBCHTypeInfo$_(e), i = 0; i < 15; i++) {
                        var r = !t && 1 == (s >> i & 1);
                        i < 6 ? this._$modules$_[i][8] = r : i < 8 ? this._$modules$_[i + 1][8] = r : this._$modules$_[this._$moduleCount$_ - 15 + i][8] = r;
                    }
                    for (i = 0; i < 15; i++) r = !t && 1 == (s >> i & 1), i < 8 ? this._$modules$_[8][this._$moduleCount$_ - i - 1] = r : i < 9 ? this._$modules$_[8][15 - i - 1 + 1] = r : this._$modules$_[8][15 - i - 1] = r;
                    this._$modules$_[this._$moduleCount$_ - 8][8] = !t;
                },
                _$mapData$_: function(t, e) {
                    for (var s = -1, i = this._$moduleCount$_ - 1, r = 7, n = 0, h = this._$moduleCount$_ - 1; 0 < h; h -= 2) for (6 == h && h--; ;) {
                        for (var o, a, l = 0; l < 2; l++) null == this._$modules$_[i][h - l] && (o = !1, 
                        n < t.length && (o = 1 == (t[n] >>> r & 1)), a = C._$getMask$_(e, i, h - l), 
                        this._$modules$_[i][h - l] = o = a ? !o : o, -1 == --r) && (n++, 
                        r = 7);
                        if ((i += s) < 0 || this._$moduleCount$_ <= i) {
                            i -= s, s = -s;
                            break;
                        }
                    }
                }
            }, a._$PAD0$_ = 236, a._$PAD1$_ = 17, a._$createData$_ = function(t, e, s) {
                for (var i = u._$getRSBlocks$_(t, e), r = new c(), n = 0; n < s.length; n++) {
                    var h = s[n];
                    r.put(h.mode, 4), r.put(h._$getLength$_(), C._$getLengthInBits$_(h.mode, t)), 
                    h.write(r);
                }
                for (var o = 0, n = 0; n < i.length; n++) o += i[n]._$dataCount$_;
                if (r._$getLengthInBits$_() > 8 * o) throw new Error("code length overflow. (" + r._$getLengthInBits$_() + ">" + 8 * o + ")");
                for (r._$getLengthInBits$_() + 4 <= 8 * o && r.put(0, 4); r._$getLengthInBits$_() % 8 != 0; ) r._$putBit$_(!1);
                for (;!(r._$getLengthInBits$_() >= 8 * o) && (r.put(a._$PAD0$_, 8), 
                !(r._$getLengthInBits$_() >= 8 * o)); ) r.put(a._$PAD1$_, 8);
                return a._$createBytes$_(r, i);
            }, a._$createBytes$_ = function(t, e) {
                for (var s = 0, i = 0, r = 0, n = new Array(e.length), h = new Array(e.length), o = 0; o < e.length; o++) {
                    var a = e[o]._$dataCount$_, l = e[o]._$totalCount$_ - a, i = Math.max(i, a), r = Math.max(r, l);
                    n[o] = new Array(a);
                    for (var u = 0; u < n[o].length; u++) n[o][u] = 255 & t.buffer[u + s];
                    s += a;
                    var a = C._$getErrorCorrectPolynomial$_(l), c = new g(n[o], a._$getLength$_() - 1)._$mod$_(a);
                    for (h[o] = new Array(a._$getLength$_() - 1), u = 0; u < h[o].length; u++) {
                        var f = u + c._$getLength$_() - h[o].length;
                        h[o][u] = 0 <= f ? c.get(f) : 0;
                    }
                }
                for (var d = 0, u = 0; u < e.length; u++) d += e[u]._$totalCount$_;
                for (var p = new Array(d), m = 0, u = 0; u < i; u++) for (o = 0; o < e.length; o++) u < n[o].length && (p[m++] = n[o][u]);
                for (u = 0; u < r; u++) for (o = 0; o < e.length; o++) u < h[o].length && (p[m++] = h[o][u]);
                return p;
            };
            for (var n = {
                _$MODE_NUMBER$_: 1,
                _$MODE_ALPHA_NUM$_: 2,
                _$MODE_8BIT_BYTE$_: 4,
                _$MODE_KANJI$_: 8
            }, l = {
                _$L$_: 1,
                _$M$_: 0,
                Q: 3,
                _$H$_: 2
            }, C = {
                _$PATTERN_POSITION_TABLE$_: [ [], [ 6, 18 ], [ 6, 22 ], [ 6, 26 ], [ 6, 30 ], [ 6, 34 ], [ 6, 22, 38 ], [ 6, 24, 42 ], [ 6, 26, 46 ], [ 6, 28, 50 ], [ 6, 30, 54 ], [ 6, 32, 58 ], [ 6, 34, 62 ], [ 6, 26, 46, 66 ], [ 6, 26, 48, 70 ], [ 6, 26, 50, 74 ], [ 6, 30, 54, 78 ], [ 6, 30, 56, 82 ], [ 6, 30, 58, 86 ], [ 6, 34, 62, 90 ], [ 6, 28, 50, 72, 94 ], [ 6, 26, 50, 74, 98 ], [ 6, 30, 54, 78, 102 ], [ 6, 28, 54, 80, 106 ], [ 6, 32, 58, 84, 110 ], [ 6, 30, 58, 86, 114 ], [ 6, 34, 62, 90, 118 ], [ 6, 26, 50, 74, 98, 122 ], [ 6, 30, 54, 78, 102, 126 ], [ 6, 26, 52, 78, 104, 130 ], [ 6, 30, 56, 82, 108, 134 ], [ 6, 34, 60, 86, 112, 138 ], [ 6, 30, 58, 86, 114, 142 ], [ 6, 34, 62, 90, 118, 146 ], [ 6, 30, 54, 78, 102, 126, 150 ], [ 6, 24, 50, 76, 102, 128, 154 ], [ 6, 28, 54, 80, 106, 132, 158 ], [ 6, 32, 58, 84, 110, 136, 162 ], [ 6, 26, 54, 82, 110, 138, 166 ], [ 6, 30, 58, 86, 114, 142, 170 ] ],
                _$G15$_: 1335,
                _$G18$_: 7973,
                _$G15_MASK$_: 21522,
                _$getBCHTypeInfo$_: function(t) {
                    for (var e = t << 10; 0 <= C._$getBCHDigit$_(e) - C._$getBCHDigit$_(C._$G15$_); ) e ^= C._$G15$_ << C._$getBCHDigit$_(e) - C._$getBCHDigit$_(C._$G15$_);
                    return (t << 10 | e) ^ C._$G15_MASK$_;
                },
                _$getBCHTypeNumber$_: function(t) {
                    for (var e = t << 12; 0 <= C._$getBCHDigit$_(e) - C._$getBCHDigit$_(C._$G18$_); ) e ^= C._$G18$_ << C._$getBCHDigit$_(e) - C._$getBCHDigit$_(C._$G18$_);
                    return t << 12 | e;
                },
                _$getBCHDigit$_: function(t) {
                    for (var e = 0; 0 != t; ) e++, t >>>= 1;
                    return e;
                },
                _$getPatternPosition$_: function(t) {
                    return C._$PATTERN_POSITION_TABLE$_[t - 1];
                },
                _$getMask$_: function(t, e, s) {
                    switch (t) {
                      case 0:
                        return (e + s) % 2 == 0;

                      case 1:
                        return e % 2 == 0;

                      case 2:
                        return s % 3 == 0;

                      case 3:
                        return (e + s) % 3 == 0;

                      case 4:
                        return (Math.floor(e / 2) + Math.floor(s / 3)) % 2 == 0;

                      case 5:
                        return e * s % 2 + e * s % 3 == 0;

                      case 6:
                        return (e * s % 2 + e * s % 3) % 2 == 0;

                      case 7:
                        return (e * s % 3 + (e + s) % 2) % 2 == 0;

                      default:
                        throw new Error("bad maskPattern:" + t);
                    }
                },
                _$getErrorCorrectPolynomial$_: function(t) {
                    for (var e = new g([ 1 ], 0), s = 0; s < t; s++) e = e.multiply(new g([ 1, r._$gexp$_(s) ], 0));
                    return e;
                },
                _$getLengthInBits$_: function(t, e) {
                    if (1 <= e && e < 10) switch (t) {
                      case n._$MODE_NUMBER$_:
                        return 10;

                      case n._$MODE_ALPHA_NUM$_:
                        return 9;

                      case n._$MODE_8BIT_BYTE$_:
                      case n._$MODE_KANJI$_:
                        return 8;

                      default:
                        throw new Error("mode:" + t);
                    } else if (e < 27) switch (t) {
                      case n._$MODE_NUMBER$_:
                        return 12;

                      case n._$MODE_ALPHA_NUM$_:
                        return 11;

                      case n._$MODE_8BIT_BYTE$_:
                        return 16;

                      case n._$MODE_KANJI$_:
                        return 10;

                      default:
                        throw new Error("mode:" + t);
                    } else {
                        if (!(e < 41)) throw new Error("type:" + e);
                        switch (t) {
                          case n._$MODE_NUMBER$_:
                            return 14;

                          case n._$MODE_ALPHA_NUM$_:
                            return 13;

                          case n._$MODE_8BIT_BYTE$_:
                            return 16;

                          case n._$MODE_KANJI$_:
                            return 12;

                          default:
                            throw new Error("mode:" + t);
                        }
                    }
                },
                _$getLostPoint$_: function(t) {
                    for (var e = t._$getModuleCount$_(), s = 0, i = 0; i < e; i++) for (var r = 0; r < e; r++) {
                        for (var n = 0, h = t._$isDark$_(i, r), o = -1; o <= 1; o++) if (!(i + o < 0 || e <= i + o)) for (var a = -1; a <= 1; a++) r + a < 0 || e <= r + a || 0 == o && 0 == a || h == t._$isDark$_(i + o, r + a) && n++;
                        5 < n && (s += 3 + n - 5);
                    }
                    for (i = 0; i < e - 1; i++) for (r = 0; r < e - 1; r++) {
                        var l = 0;
                        t._$isDark$_(i, r) && l++, t._$isDark$_(i + 1, r) && l++, 
                        t._$isDark$_(i, r + 1) && l++, t._$isDark$_(i + 1, r + 1) && l++, 
                        0 != l && 4 != l || (s += 3);
                    }
                    for (i = 0; i < e; i++) for (r = 0; r < e - 6; r++) t._$isDark$_(i, r) && !t._$isDark$_(i, r + 1) && t._$isDark$_(i, r + 2) && t._$isDark$_(i, r + 3) && t._$isDark$_(i, r + 4) && !t._$isDark$_(i, r + 5) && t._$isDark$_(i, r + 6) && (s += 40);
                    for (r = 0; r < e; r++) for (i = 0; i < e - 6; i++) t._$isDark$_(i, r) && !t._$isDark$_(i + 1, r) && t._$isDark$_(i + 2, r) && t._$isDark$_(i + 3, r) && t._$isDark$_(i + 4, r) && !t._$isDark$_(i + 5, r) && t._$isDark$_(i + 6, r) && (s += 40);
                    for (var u = 0, r = 0; r < e; r++) for (i = 0; i < e; i++) t._$isDark$_(i, r) && u++;
                    return s + Math.abs(100 * u / e / e - 50) / 5 * 10;
                }
            }, r = {
                _$glog$_: function(t) {
                    if (t < 1) throw new Error("glog(" + t + ")");
                    return r._$LOG_TABLE$_[t];
                },
                _$gexp$_: function(t) {
                    for (;t < 0; ) t += 255;
                    for (;256 <= t; ) t -= 255;
                    return r._$EXP_TABLE$_[t];
                },
                _$EXP_TABLE$_: new Array(256),
                _$LOG_TABLE$_: new Array(256)
            }, t = 0; t < 8; t++) r._$EXP_TABLE$_[t] = 1 << t;
            for (t = 8; t < 256; t++) r._$EXP_TABLE$_[t] = r._$EXP_TABLE$_[t - 4] ^ r._$EXP_TABLE$_[t - 5] ^ r._$EXP_TABLE$_[t - 6] ^ r._$EXP_TABLE$_[t - 8];
            for (t = 0; t < 255; t++) r._$LOG_TABLE$_[r._$EXP_TABLE$_[t]] = t;
            function g(t, e) {
                if (null == t.length) throw new Error(t.length + "/" + e);
                for (var s = 0; s < t.length && 0 == t[s]; ) s++;
                this._$num$_ = new Array(t.length - s + e);
                for (var i = 0; i < t.length - s; i++) this._$num$_[i] = t[i + s];
            }
            function u(t, e) {
                this._$totalCount$_ = t, this._$dataCount$_ = e;
            }
            function c() {
                this.buffer = [], this.length = 0;
            }
            g.prototype = {
                get: function(t) {
                    return this._$num$_[t];
                },
                _$getLength$_: function() {
                    return this._$num$_.length;
                },
                multiply: function(t) {
                    for (var e = new Array(this._$getLength$_() + t._$getLength$_() - 1), s = 0; s < this._$getLength$_(); s++) for (var i = 0; i < t._$getLength$_(); i++) e[s + i] ^= r._$gexp$_(r._$glog$_(this.get(s)) + r._$glog$_(t.get(i)));
                    return new g(e, 0);
                },
                _$mod$_: function(t) {
                    if (this._$getLength$_() - t._$getLength$_() < 0) return this;
                    for (var e = r._$glog$_(this.get(0)) - r._$glog$_(t.get(0)), s = new Array(this._$getLength$_()), i = 0; i < this._$getLength$_(); i++) s[i] = this.get(i);
                    for (i = 0; i < t._$getLength$_(); i++) s[i] ^= r._$gexp$_(r._$glog$_(t.get(i)) + e);
                    return new g(s, 0)._$mod$_(t);
                }
            }, u._$RS_BLOCK_TABLE$_ = [ [ 1, 26, 19 ], [ 1, 26, 16 ], [ 1, 26, 13 ], [ 1, 26, 9 ], [ 1, 44, 34 ], [ 1, 44, 28 ], [ 1, 44, 22 ], [ 1, 44, 16 ], [ 1, 70, 55 ], [ 1, 70, 44 ], [ 2, 35, 17 ], [ 2, 35, 13 ], [ 1, 100, 80 ], [ 2, 50, 32 ], [ 2, 50, 24 ], [ 4, 25, 9 ], [ 1, 134, 108 ], [ 2, 67, 43 ], [ 2, 33, 15, 2, 34, 16 ], [ 2, 33, 11, 2, 34, 12 ], [ 2, 86, 68 ], [ 4, 43, 27 ], [ 4, 43, 19 ], [ 4, 43, 15 ], [ 2, 98, 78 ], [ 4, 49, 31 ], [ 2, 32, 14, 4, 33, 15 ], [ 4, 39, 13, 1, 40, 14 ], [ 2, 121, 97 ], [ 2, 60, 38, 2, 61, 39 ], [ 4, 40, 18, 2, 41, 19 ], [ 4, 40, 14, 2, 41, 15 ], [ 2, 146, 116 ], [ 3, 58, 36, 2, 59, 37 ], [ 4, 36, 16, 4, 37, 17 ], [ 4, 36, 12, 4, 37, 13 ], [ 2, 86, 68, 2, 87, 69 ], [ 4, 69, 43, 1, 70, 44 ], [ 6, 43, 19, 2, 44, 20 ], [ 6, 43, 15, 2, 44, 16 ], [ 4, 101, 81 ], [ 1, 80, 50, 4, 81, 51 ], [ 4, 50, 22, 4, 51, 23 ], [ 3, 36, 12, 8, 37, 13 ], [ 2, 116, 92, 2, 117, 93 ], [ 6, 58, 36, 2, 59, 37 ], [ 4, 46, 20, 6, 47, 21 ], [ 7, 42, 14, 4, 43, 15 ], [ 4, 133, 107 ], [ 8, 59, 37, 1, 60, 38 ], [ 8, 44, 20, 4, 45, 21 ], [ 12, 33, 11, 4, 34, 12 ], [ 3, 145, 115, 1, 146, 116 ], [ 4, 64, 40, 5, 65, 41 ], [ 11, 36, 16, 5, 37, 17 ], [ 11, 36, 12, 5, 37, 13 ], [ 5, 109, 87, 1, 110, 88 ], [ 5, 65, 41, 5, 66, 42 ], [ 5, 54, 24, 7, 55, 25 ], [ 11, 36, 12 ], [ 5, 122, 98, 1, 123, 99 ], [ 7, 73, 45, 3, 74, 46 ], [ 15, 43, 19, 2, 44, 20 ], [ 3, 45, 15, 13, 46, 16 ], [ 1, 135, 107, 5, 136, 108 ], [ 10, 74, 46, 1, 75, 47 ], [ 1, 50, 22, 15, 51, 23 ], [ 2, 42, 14, 17, 43, 15 ], [ 5, 150, 120, 1, 151, 121 ], [ 9, 69, 43, 4, 70, 44 ], [ 17, 50, 22, 1, 51, 23 ], [ 2, 42, 14, 19, 43, 15 ], [ 3, 141, 113, 4, 142, 114 ], [ 3, 70, 44, 11, 71, 45 ], [ 17, 47, 21, 4, 48, 22 ], [ 9, 39, 13, 16, 40, 14 ], [ 3, 135, 107, 5, 136, 108 ], [ 3, 67, 41, 13, 68, 42 ], [ 15, 54, 24, 5, 55, 25 ], [ 15, 43, 15, 10, 44, 16 ], [ 4, 144, 116, 4, 145, 117 ], [ 17, 68, 42 ], [ 17, 50, 22, 6, 51, 23 ], [ 19, 46, 16, 6, 47, 17 ], [ 2, 139, 111, 7, 140, 112 ], [ 17, 74, 46 ], [ 7, 54, 24, 16, 55, 25 ], [ 34, 37, 13 ], [ 4, 151, 121, 5, 152, 122 ], [ 4, 75, 47, 14, 76, 48 ], [ 11, 54, 24, 14, 55, 25 ], [ 16, 45, 15, 14, 46, 16 ], [ 6, 147, 117, 4, 148, 118 ], [ 6, 73, 45, 14, 74, 46 ], [ 11, 54, 24, 16, 55, 25 ], [ 30, 46, 16, 2, 47, 17 ], [ 8, 132, 106, 4, 133, 107 ], [ 8, 75, 47, 13, 76, 48 ], [ 7, 54, 24, 22, 55, 25 ], [ 22, 45, 15, 13, 46, 16 ], [ 10, 142, 114, 2, 143, 115 ], [ 19, 74, 46, 4, 75, 47 ], [ 28, 50, 22, 6, 51, 23 ], [ 33, 46, 16, 4, 47, 17 ], [ 8, 152, 122, 4, 153, 123 ], [ 22, 73, 45, 3, 74, 46 ], [ 8, 53, 23, 26, 54, 24 ], [ 12, 45, 15, 28, 46, 16 ], [ 3, 147, 117, 10, 148, 118 ], [ 3, 73, 45, 23, 74, 46 ], [ 4, 54, 24, 31, 55, 25 ], [ 11, 45, 15, 31, 46, 16 ], [ 7, 146, 116, 7, 147, 117 ], [ 21, 73, 45, 7, 74, 46 ], [ 1, 53, 23, 37, 54, 24 ], [ 19, 45, 15, 26, 46, 16 ], [ 5, 145, 115, 10, 146, 116 ], [ 19, 75, 47, 10, 76, 48 ], [ 15, 54, 24, 25, 55, 25 ], [ 23, 45, 15, 25, 46, 16 ], [ 13, 145, 115, 3, 146, 116 ], [ 2, 74, 46, 29, 75, 47 ], [ 42, 54, 24, 1, 55, 25 ], [ 23, 45, 15, 28, 46, 16 ], [ 17, 145, 115 ], [ 10, 74, 46, 23, 75, 47 ], [ 10, 54, 24, 35, 55, 25 ], [ 19, 45, 15, 35, 46, 16 ], [ 17, 145, 115, 1, 146, 116 ], [ 14, 74, 46, 21, 75, 47 ], [ 29, 54, 24, 19, 55, 25 ], [ 11, 45, 15, 46, 46, 16 ], [ 13, 145, 115, 6, 146, 116 ], [ 14, 74, 46, 23, 75, 47 ], [ 44, 54, 24, 7, 55, 25 ], [ 59, 46, 16, 1, 47, 17 ], [ 12, 151, 121, 7, 152, 122 ], [ 12, 75, 47, 26, 76, 48 ], [ 39, 54, 24, 14, 55, 25 ], [ 22, 45, 15, 41, 46, 16 ], [ 6, 151, 121, 14, 152, 122 ], [ 6, 75, 47, 34, 76, 48 ], [ 46, 54, 24, 10, 55, 25 ], [ 2, 45, 15, 64, 46, 16 ], [ 17, 152, 122, 4, 153, 123 ], [ 29, 74, 46, 14, 75, 47 ], [ 49, 54, 24, 10, 55, 25 ], [ 24, 45, 15, 46, 46, 16 ], [ 4, 152, 122, 18, 153, 123 ], [ 13, 74, 46, 32, 75, 47 ], [ 48, 54, 24, 14, 55, 25 ], [ 42, 45, 15, 32, 46, 16 ], [ 20, 147, 117, 4, 148, 118 ], [ 40, 75, 47, 7, 76, 48 ], [ 43, 54, 24, 22, 55, 25 ], [ 10, 45, 15, 67, 46, 16 ], [ 19, 148, 118, 6, 149, 119 ], [ 18, 75, 47, 31, 76, 48 ], [ 34, 54, 24, 34, 55, 25 ], [ 20, 45, 15, 61, 46, 16 ] ], 
            u._$getRSBlocks$_ = function(t, e) {
                var s = u._$getRsBlockTable$_(t, e);
                if (null == s) throw new Error("bad rs block @ typeNumber:" + t + "/errorCorrectLevel:" + e);
                for (var i = s.length / 3, r = [], n = 0; n < i; n++) for (var h = s[3 * n + 0], o = s[3 * n + 1], a = s[3 * n + 2], l = 0; l < h; l++) r.push(new u(o, a));
                return r;
            }, u._$getRsBlockTable$_ = function(t, e) {
                switch (e) {
                  case l._$L$_:
                    return u._$RS_BLOCK_TABLE$_[4 * (t - 1) + 0];

                  case l._$M$_:
                    return u._$RS_BLOCK_TABLE$_[4 * (t - 1) + 1];

                  case l.Q:
                    return u._$RS_BLOCK_TABLE$_[4 * (t - 1) + 2];

                  case l._$H$_:
                    return u._$RS_BLOCK_TABLE$_[4 * (t - 1) + 3];

                  default:
                    return;
                }
            }, c.prototype = {
                get: function(t) {
                    var e = Math.floor(t / 8);
                    return 1 == (this.buffer[e] >>> 7 - t % 8 & 1);
                },
                put: function(t, e) {
                    for (var s = 0; s < e; s++) this._$putBit$_(1 == (t >>> e - s - 1 & 1));
                },
                _$getLengthInBits$_: function() {
                    return this.length;
                },
                _$putBit$_: function(t) {
                    var e = Math.floor(this.length / 8);
                    this.buffer.length <= e && this.buffer.push(0), t && (this.buffer[e] |= 128 >>> this.length % 8), 
                    this.length++;
                }
            };
            var f = [ [ 17, 14, 11, 7 ], [ 32, 26, 20, 14 ], [ 53, 42, 32, 24 ], [ 78, 62, 46, 34 ], [ 106, 84, 60, 44 ], [ 134, 106, 74, 58 ], [ 154, 122, 86, 64 ], [ 192, 152, 108, 84 ], [ 230, 180, 130, 98 ], [ 271, 213, 151, 119 ], [ 321, 251, 177, 137 ], [ 367, 287, 203, 155 ], [ 425, 331, 241, 177 ], [ 458, 362, 258, 194 ], [ 520, 412, 292, 220 ], [ 586, 450, 322, 250 ], [ 644, 504, 364, 280 ], [ 718, 560, 394, 310 ], [ 792, 624, 442, 338 ], [ 858, 666, 482, 382 ], [ 929, 711, 509, 403 ], [ 1003, 779, 565, 439 ], [ 1091, 857, 611, 461 ], [ 1171, 911, 661, 511 ], [ 1273, 997, 715, 535 ], [ 1367, 1059, 751, 593 ], [ 1465, 1125, 805, 625 ], [ 1528, 1190, 868, 658 ], [ 1628, 1264, 908, 698 ], [ 1732, 1370, 982, 742 ], [ 1840, 1452, 1030, 790 ], [ 1952, 1538, 1112, 842 ], [ 2068, 1628, 1168, 898 ], [ 2188, 1722, 1228, 958 ], [ 2303, 1809, 1283, 983 ], [ 2431, 1911, 1351, 1051 ], [ 2563, 1989, 1423, 1093 ], [ 2699, 2099, 1499, 1139 ], [ 2809, 2213, 1579, 1219 ], [ 2953, 2331, 1663, 1273 ] ], i = (s.prototype.draw = function(t) {
                var e = this._$_oContext$_, s = this._$_htOption$_, i = t._$getModuleCount$_(), r = s.width / i, n = s.height / i, h = Math.round(r), o = Math.round(n);
                this.clear();
                for (var a = 0; a < i; a++) for (var l = 0; l < i; l++) {
                    var u = t._$isDark$_(a, l), c = l * r, f = a * n;
                    e.strokeStyle = u ? s._$colorDark$_ : s._$colorLight$_, e.lineWidth = 1, 
                    e.fillStyle = u ? s._$colorDark$_ : s._$colorLight$_, e.fillRect(c, f, r, n), 
                    e.strokeRect(Math.floor(c) + .5, Math.floor(f) + .5, h, o), 
                    e.strokeRect(Math.ceil(c) - .5, Math.ceil(f) - .5, h, o);
                }
                this._$_bIsPainted$_ = !0;
            }, s.prototype._$isPainted$_ = function() {
                return this._$_bIsPainted$_;
            }, s.prototype.clear = function() {
                this._$_oContext$_.clearRect(0, 0, this._$_elCanvas$_.width, this._$_elCanvas$_.height), 
                this._$_bIsPainted$_ = !1;
            }, s.prototype._$getCanvas$_ = function() {
                return this._$_elCanvas$_;
            }, s.prototype.round = function(t) {
                return t && Math.floor(1e3 * t) / 1e3;
            }, s);
            function s(t, e) {
                this._$_bIsPainted$_ = !1, this._$_htOption$_ = e, this._$_elCanvas$_ = null, 
                "undefined" != typeof document ? (this._$_elCanvas$_ = document.createElement("canvas"), 
                this._$_elCanvas$_.width = e.width, this._$_elCanvas$_.height = e.height) : this._$_elCanvas$_ = new OffscreenCanvas(e.width, e.height), 
                t && t.appendChild(this._$_elCanvas$_), this._$_el$_ = t, this._$_oContext$_ = this._$_elCanvas$_.getContext("2d"), 
                this._$_bIsPainted$_ = !1, this._$_bSupportDataURI$_ = null;
            }
            self._$C3_QRCode$_ = function(t, e) {
                if (this._$_htOption$_ = {
                    width: 256,
                    height: 256,
                    _$typeNumber$_: 4,
                    _$colorDark$_: "#000000",
                    _$colorLight$_: "#ffffff",
                    _$correctLevel$_: l._$H$_
                }, e = "string" == typeof e ? {
                    text: e
                } : e) for (var s in e) this._$_htOption$_[s] = e[s];
                "string" == typeof t && (t = document.getElementById(t)), this._$_el$_ = t, 
                this._$_oQRCode$_ = null, this._$_oDrawing$_ = new i(this._$_el$_, this._$_htOption$_), 
                this._$makeCode$_(this._$_htOption$_.text);
            }, self._$C3_QRCode$_.prototype._$makeCode$_ = function(t) {
                this._$_oQRCode$_ = new a(((t, e) => {
                    for (var s, i = 1, r = (s = encodeURI(t).toString().replace(/\%[0-9a-fA-F]{2}/g, "a")).length + (s.length != t ? 3 : 0), n = 0, h = f.length; n <= h; n++) {
                        var o = 0;
                        switch (e) {
                          case l._$L$_:
                            o = f[n][0];
                            break;

                          case l._$M$_:
                            o = f[n][1];
                            break;

                          case l.Q:
                            o = f[n][2];
                            break;

                          case l._$H$_:
                            o = f[n][3];
                        }
                        if (r <= o) break;
                        i++;
                    }
                    if (f.length < i) throw new Error("Too long data");
                    return i;
                })(t, this._$_htOption$_._$correctLevel$_), this._$_htOption$_._$correctLevel$_), 
                this._$_oQRCode$_._$addData$_(t), this._$_oQRCode$_._$make$_(), 
                this._$_oDrawing$_.draw(this._$_oQRCode$_);
            }, self._$C3_QRCode$_.prototype.clear = function() {
                this._$_oDrawing$_.clear();
            }, self._$C3_QRCode$_.prototype._$getCanvas$_ = function() {
                return this._$_oDrawing$_._$getCanvas$_();
            }, self._$C3_QRCode$_._$CorrectLevel$_ = l;
        })();
        {
            const a = self._$C3$_, b = "iframe";
            a._$Plugins$_._$iframe$_ = class extends a._$SDKDOMPluginBase$_ {
                constructor(t) {
                    super(t, b);
                }
                _$Release$_() {
                    super._$Release$_();
                }
            };
        }
        {
            const e = self._$C3$_;
            e._$Plugins$_._$iframe$_._$Type$_ = class extends e._$SDKTypeBase$_ {
                constructor(t) {
                    super(t);
                }
                _$Release$_() {
                    super._$Release$_();
                }
                _$OnCreate$_() {}
            };
        }
        {
            const h = self._$C3$_, i = self._$C3X$_, j = "iframe", k = (h._$Plugins$_._$iframe$_.Instance = class extends h._$SDKDOMInstanceBase$_ {
                constructor(t, e) {
                    super(t, j);
                    let s = this._$_url$_ = "";
                    this._$_id$_ = "", this._$_allowAttrib$_ = "", this._$_enableSandbox$_ = !1, 
                    this._$_sandboxAttrib$_ = "", e && (this._$_url$_ = e[0], s = e[1], 
                    this._$GetWorldInfo$_()._$SetVisible$_(e[2]), this._$_id$_ = e[3], 
                    this._$_allowAttrib$_ = e[4], this._$_enableSandbox$_ = e[5], 
                    this._$_sandboxAttrib$_ = e[6]), this._$CreateElement$_({
                        url: "",
                        html: s,
                        id: this._$_id$_,
                        allow: this._$_allowAttrib$_,
                        enableSandbox: this._$_enableSandbox$_,
                        sandbox: this._$_sandboxAttrib$_
                    }), this._$_url$_ && this._$_runtime$_._$AddCreatePromise$_((async () => {
                        const t = this._$GetUrl$_();
                        await this._$PostToDOMElementAsync$_("navigate-url", {
                            url: t
                        });
                    })());
                }
                _$Release$_() {
                    super._$Release$_();
                }
                _$GetElementState$_() {
                    return {};
                }
                _$GetUrl$_(t) {
                    return this._$_runtime$_._$GetAssetManager$_()._$GetProjectFileIframeUrl$_(t || this._$_url$_);
                }
                _$Draw$_(t) {}
                _$SaveToJson$_() {
                    return {
                        url: this._$_url$_,
                        id: this._$_id$_
                    };
                }
                _$LoadFromJson$_(t) {
                    this._$_url$_ = t.url, this._$_id$_ = t.id, this._$UpdateElementState$_();
                }
                _$GetDebuggerProperties$_() {
                    const e = h._$Plugins$_._$iframe$_._$Acts$_, t = "plugins.iframe";
                    return [ {
                        title: t + ".name",
                        properties: [ {
                            name: t + ".properties.url.name",
                            value: this._$_url$_,
                            _$onedit$_: t => this._$CallAction$_(e._$NavigateURL$_, t)
                        } ]
                    } ];
                }
                _$GetScriptInterfaceClass$_() {
                    return self._$IIframeInstance$_;
                }
            }, new WeakMap());
            self._$IIframeInstance$_ = class extends self._$IDOMInstance$_ {
                constructor() {
                    super(), k.set(this, self._$IInstance$_._$_GetInitInst$_()._$GetSdkInstance$_());
                }
            };
        }
        {
            const x = self._$C3$_;
            x._$Plugins$_._$iframe$_._$Cnds$_ = {};
        }
        {
            const y = self._$C3$_;
            y._$Plugins$_._$iframe$_._$Acts$_ = {
                _$NavigateURL$_(t) {
                    const e = this._$GetUrl$_(t);
                    this._$PostToDOMElement$_("navigate-url", {
                        url: e
                    });
                },
                _$DisplayHTMLString$_(t) {
                    this._$PostToDOMElement$_("display-html", {
                        html: t
                    });
                }
            };
        }
        {
            const C = self._$C3$_;
            C._$Plugins$_._$iframe$_._$Exps$_ = {};
        }
        {
            let MaybeCloseImageBitmap2 = function(t) {
                t && t.close && t.close();
            };
            MaybeCloseImageBitmap = MaybeCloseImageBitmap2;
            const a = self._$C3$_, b = "video";
            a._$Plugins$_.video = class extends a._$SDKDOMPluginBase$_ {
                constructor(t) {
                    super(t, b), this._$_postImageBitmaps$_ = !1, this._$_supportedFormats$_ = {}, 
                    this._$_lastStateSequenceNumber$_ = -1, this._$_videoState$_ = new Map(), 
                    this._$_runtime$_._$AddLoadPromise$_(this._$_runtime$_._$PostComponentMessageToDOMAsync$_("video", "init", {
                        isInWorker: this._$_runtime$_._$IsInWorker$_()
                    }).then(t => {
                        this._$_postImageBitmaps$_ = t.postImageBitmaps, this._$_supportedFormats$_ = t.supportedFormats;
                    })), this._$AddElementMessageHandler$_("playback-event", (t, e) => t._$_OnPlaybackEvent$_(e)), 
                    this._$_runtime$_._$AddDOMComponentMessageHandler$_(b, "state", t => this._$_OnUpdateState$_(t));
                }
                _$Release$_() {
                    super._$Release$_();
                }
                _$IsPostImageBitmapsMode$_() {
                    return this._$_postImageBitmaps$_;
                }
                _$IsFormatSupported$_(t) {
                    return !!this._$_supportedFormats$_[t];
                }
                _$_OnUpdateState$_(t) {
                    const e = t.sequenceNumber;
                    if (e <= this._$_lastStateSequenceNumber$_) for (const s of Object.values(t.videoData)) MaybeCloseImageBitmap2(s.imageBitmap); else {
                        this._$_lastStateSequenceNumber$_ = e;
                        for (const i of this._$_videoState$_.values()) MaybeCloseImageBitmap2(i.imageBitmap);
                        this._$_videoState$_.clear();
                        for (const [ r, n ] of Object.entries(t.videoData)) this._$_videoState$_.set(parseInt(r, 10), n);
                    }
                }
                _$_DeleteVideoState$_(t) {
                    this._$_videoState$_.delete(t);
                }
                _$GetVideoState$_(t) {
                    return this._$_videoState$_.get(t) || null;
                }
            };
        }
        {
            const s = self._$C3$_;
            s._$Plugins$_.video._$Type$_ = class extends s._$SDKTypeBase$_ {
                constructor(t) {
                    super(t);
                }
                _$Release$_() {
                    super._$Release$_();
                }
                _$OnCreate$_() {}
            };
        }
        {
            const v = self._$C3$_, w = v._$New$_(v.Rect), x = v._$New$_(v._$Quad$_), y = "video", z = [ "webm-vp8", "webm-vp9", "webm-av1", "mp4-h264", "mp4-h265", "mp4-av1" ];
            v._$Plugins$_.video.Instance = class extends v._$SDKDOMInstanceBase$_ {
                constructor(t, e) {
                    super(t, y), this._$_primarySrc$_ = "", this._$_primaryFormat$_ = "mp4-h264", 
                    this._$_secondarySrc$_ = "", this._$_secondaryFormat$_ = "webm-vp9", 
                    this._$_autoplay$_ = 2, this._$_playInBackground$_ = !1, this._$_videoWasPlayingOnSuspend$_ = !1, 
                    this._$_webGLTexture$_ = null, this._$_currentTrigger$_ = -1, 
                    this._$_isSettingSource$_ = 0, this._$_isPlaying$_ = !1, this._$_isPaused$_ = !1, 
                    this._$_hasEnded$_ = !1, this._$_isLooping$_ = !1, this._$_isMuted$_ = !1, 
                    this._$_volume$_ = 0, e && (this._$_primarySrc$_ = e[0], this._$_primaryFormat$_ = z[e[1]], 
                    this._$_secondarySrc$_ = e[2], this._$_secondaryFormat$_ = z[e[3]], 
                    this._$_autoplay$_ = e[4], this._$_playInBackground$_ = e[5], 
                    this._$GetWorldInfo$_()._$SetVisible$_(e[6]));
                    const s = this._$_runtime$_._$Dispatcher$_();
                    this._$_disposables$_ = new v._$CompositeDisposable$_(v._$Disposable$_._$From$_(s, "renderercontextlost", () => this._$_OnRendererContextLost$_()), v._$Disposable$_._$From$_(s, "suspend", () => this._$_OnSuspend$_()), v._$Disposable$_._$From$_(s, "resume", () => this._$_OnResume$_())), 
                    this._$CreateElement$_({
                        src: this._$GetVideoSource$_(),
                        autoplay: this._$_autoplay$_
                    });
                }
                _$Release$_() {
                    this._$GetPlugin$_()._$_DeleteVideoState$_(this._$GetElementId$_()), 
                    this._$_ReleaseTexture$_(), super._$Release$_();
                }
                _$_MaybeCreateTexture$_(t, e, s) {
                    if (this._$_webGLTexture$_) {
                        if (this._$_webGLTexture$_._$GetWidth$_() === e || this._$_webGLTexture$_._$GetHeight$_() === s) return;
                        this._$_ReleaseTexture$_();
                    }
                    this._$_webGLTexture$_ = t._$CreateDynamicTexture$_(e, s, {
                        _$sampling$_: this._$_runtime$_._$GetSampling$_(),
                        _$mipMap$_: !1
                    });
                }
                _$_ReleaseTexture$_() {
                    this._$_webGLTexture$_ && (this._$_runtime$_._$GetRenderer$_()._$DeleteTexture$_(this._$_webGLTexture$_), 
                    this._$_webGLTexture$_ = null);
                }
                _$GetElementState$_() {
                    return {};
                }
                _$DbToLinearNoCap$_(t) {
                    return Math.pow(10, t / 20);
                }
                _$DbToLinear$_(t) {
                    const e = this._$DbToLinearNoCap$_(t);
                    return isFinite(e) ? Math.max(Math.min(e, 1), 0) : 0;
                }
                _$LinearToDbNoCap$_(t) {
                    return Math.log(t) / Math.log(10) * 20;
                }
                _$LinearToDb$_(t) {
                    return this._$LinearToDbNoCap$_(Math.max(Math.min(t, 1), 0));
                }
                _$GetVideoSource$_() {
                    let t = "", e = this._$GetPlugin$_();
                    return e._$IsFormatSupported$_(this._$_primaryFormat$_) && this._$_primarySrc$_ ? t = this._$_primarySrc$_ : e._$IsFormatSupported$_(this._$_secondaryFormat$_) && this._$_secondarySrc$_ && (t = this._$_secondarySrc$_), 
                    t && (v._$IsRelativeURL$_(t) ? this._$_runtime$_._$GetAssetManager$_()._$GetMediaFileUrl$_(t) : t);
                }
                _$_OnRendererContextLost$_() {
                    this._$_webGLTexture$_ = null;
                }
                async _$_OnPlaybackEvent$_(t) {
                    const e = t.type;
                    5 === e ? this._$_SetIsPlaying$_(!0) : 2 === e ? (this._$_SetIsPlaying$_(!1), 
                    this._$_hasEnded$_ = !0, this._$_isPaused$_ = !1) : 6 === e && (this._$_SetIsPlaying$_(!1), 
                    this._$_isPaused$_ = !0, this._$_hasEnded$_ = !1), this._$_currentTrigger$_ = e, 
                    await this._$TriggerAsync$_(v._$Plugins$_.video._$Cnds$_._$OnPlaybackEvent$_);
                }
                _$_SetIsPlaying$_(t) {
                    this._$_isPlaying$_ = !!t, this._$_isPlaying$_ ? (this._$_StartTicking$_(), 
                    this._$_isPaused$_ = !1, this._$_hasEnded$_ = !1) : this._$_StopTicking$_();
                }
                _$_OnSuspend$_() {
                    this._$_playInBackground$_ || this._$_isPlaying$_ && (this._$_videoWasPlayingOnSuspend$_ = !0, 
                    this._$PostToDOMElement$_("pause"));
                }
                _$_OnResume$_() {
                    this._$_playInBackground$_ || this._$_videoWasPlayingOnSuspend$_ && (this._$PostToDOMElement$_("play"), 
                    this._$_videoWasPlayingOnSuspend$_ = !1);
                }
                _$Draw$_(a) {
                    let l = this._$GetWorldInfo$_(), u = 0, c = 0, f = null, d = this._$GetPlugin$_()._$IsPostImageBitmapsMode$_();
                    if (d) {
                        const t = this._$GetMyState$_();
                        if (!t) return;
                        f = t.imageBitmap, t.imageBitmap = null, u = t.videoWidth, 
                        c = t.videoHeight;
                    } else {
                        const e = self.C3Video_GetElement(this._$GetElementId$_());
                        if (!e) return;
                        u = e.videoWidth, c = e.videoHeight, f = e;
                    }
                    if (!(u <= 0 || c <= 0)) {
                        this._$_MaybeCreateTexture$_(a, u, c), f && (a._$UpdateTexture$_(f, this._$_webGLTexture$_), 
                        d) && f.close && f.close();
                        let t = u / c, e = l._$GetWidth$_(), s = l._$GetHeight$_(), i = e / s, r = 0, n = 0, h = 0, o = 0;
                        t < i ? (h = s * t, o = s, r = Math.max(Math.floor((e - h) / 2), 0)) : (h = e, 
                        o = e / t, n = Math.max(Math.floor((s - o) / 2), 0)), a._$SetTexture$_(this._$_webGLTexture$_), 
                        w._$setWH$_(l._$GetX$_() + r, l._$GetY$_() + n, h, o), x._$setFromRect$_(w), 
                        a._$Quad$_(x);
                    }
                }
                _$Tick$_() {
                    this._$_runtime$_._$UpdateRender$_();
                }
                _$GetMyState$_() {
                    return this._$GetPlugin$_()._$GetVideoState$_(this._$GetElementId$_());
                }
            };
        }
        {
            const fa = self._$C3$_;
            fa._$Plugins$_.video._$Cnds$_ = {
                IsPlaying() {
                    return this._$_isPlaying$_;
                },
                _$IsPaused$_() {
                    return this._$_isPaused$_;
                },
                _$HasEnded$_() {
                    return this._$_hasEnded$_;
                },
                _$IsMuted$_() {
                    return this._$_isMuted$_;
                },
                _$OnPlaybackEvent$_(t) {
                    return this._$_currentTrigger$_ === t;
                }
            };
        }
        {
            const ha = self._$C3$_, ia = [ "webm-vp8", "webm-vp9", "webm-av1", "mp4-h264", "mp4-h265", "mp4-av1" ];
            ha._$Plugins$_.video._$Acts$_ = {
                _$SetSource$_(t, e) {
                    this._$_primarySrc$_ = t, this._$_primaryFormat$_ = "webm-vp8", 
                    this._$_secondarySrc$_ = e, this._$_secondaryFormat$_ = "mp4-h264", 
                    this._$PostToDOMElement$_("set-source", {
                        src: this._$GetVideoSource$_()
                    }), this._$_ReleaseTexture$_();
                },
                _$SetSource2$_(t, e, s, i) {
                    this._$_primarySrc$_ = t, this._$_primaryFormat$_ = ia[e], this._$_secondarySrc$_ = s, 
                    this._$_secondaryFormat$_ = ia[i], this._$PostToDOMElement$_("set-source", {
                        src: this._$GetVideoSource$_()
                    }), this._$_ReleaseTexture$_();
                },
                _$SetPlaybackTime$_(t) {
                    this._$PostToDOMElement$_("set-playback-time", {
                        time: t
                    });
                },
                _$SetPlaybackRate$_(t) {
                    this._$PostToDOMElement$_("set-playback-rate", {
                        rate: t
                    });
                },
                _$SetLooping$_(t) {
                    this._$_isLooping$_ !== (t = 0 !== t) && (this._$_isLooping$_ = t, 
                    this._$PostToDOMElement$_("set-looping", {
                        isLooping: t
                    }));
                },
                _$SetMuted$_(t) {
                    this._$_isMuted$_ !== (t = 0 !== t) && (this._$_isMuted$_ = t, 
                    this._$PostToDOMElement$_("set-muted", {
                        isMuted: t
                    }));
                },
                _$SetVolume$_(t) {
                    this._$_volume$_ !== t && (this._$_volume$_ = t, this._$PostToDOMElement$_("set-volume", {
                        volume: this._$DbToLinear$_(t)
                    }));
                },
                _$Pause$_() {
                    this._$PostToDOMElement$_("pause");
                },
                Play() {
                    this._$_PostToDOMElementMaybeSync$_("play");
                }
            };
        }
        {
            const ua = self._$C3$_;
            ua._$Plugins$_.video._$Exps$_ = {
                _$PlaybackTime$_() {
                    const t = this._$GetMyState$_();
                    return t ? t.currentTime : 0;
                },
                _$PlaybackRate$_() {
                    const t = this._$GetMyState$_();
                    return t ? t.playbackRate : 1;
                },
                _$Duration$_() {
                    const t = this._$GetMyState$_();
                    return t ? t.duration : 0;
                },
                _$Volume$_() {
                    return this._$_volume$_;
                },
                _$VideoWidth$_() {
                    const t = this._$GetMyState$_();
                    return t ? t.videoWidth : 0;
                },
                _$VideoHeight$_() {
                    const t = this._$GetMyState$_();
                    return t ? t.videoHeight : 0;
                }
            };
        }
        {
            const a = self._$C3$_;
            a._$Behaviors$_._$Platform$_ = class extends a._$SDKBehaviorBase$_ {
                constructor(t) {
                    super(t);
                }
                _$Release$_() {
                    super._$Release$_();
                }
            };
        }
        {
            const d = self._$C3$_;
            d._$Behaviors$_._$Platform$_._$Type$_ = class extends d._$SDKBehaviorTypeBase$_ {
                constructor(t) {
                    super(t);
                }
                _$Release$_() {
                    super._$Release$_();
                }
                _$OnCreate$_() {}
            };
        }
        {
            let accelerate2 = function(t, e, s, i, r) {
                const n = e * r, h = s * r;
                return g._$clamp$_(t * r + .5 * i * r * r, n, h);
            };
            accelerate = accelerate2;
            const g = self._$C3$_, h = self._$C3X$_, i = self._$IBehaviorInstance$_, j = 0, k = 1, l = 2, m = 3, n = 4, o = 5, p = 6, q = 7, r = 8, s = 9, t = .05, u = (g._$Behaviors$_._$Platform$_.Instance = class extends g._$SDKBehaviorInstanceBase$_ {
                constructor(t, e) {
                    super(t), this._$_keyboardDisposables$_ = null, this._$_leftKey$_ = !1, 
                    this._$_rightKey$_ = !1, this._$_jumpKey$_ = !1, this._$_jumped$_ = !1, 
                    this._$_doubleJumped$_ = !1, this._$_canDoubleJump$_ = !1, this._$_ignoreInput$_ = !1, 
                    this._$_simLeft$_ = !1, this._$_simRight$_ = !1, this._$_simJump$_ = !1, 
                    this._$_lastFloorObject$_ = null, this._$_loadFloorUid$_ = -1, 
                    this._$_lastFloorX$_ = 0, this._$_lastFloorY$_ = 0, this._$_floorIsJumpthru$_ = !1, 
                    this._$_wasOnFloor$_ = !1, this._$_wasOverJumpthru$_ = this._$_runtime$_._$GetCollisionEngine$_()._$TestOverlapJumpthru$_(this._$_inst$_), 
                    this._$_loadJumpthruUid$_ = -1, this._$_animMode$_ = "stopped", 
                    this._$_fallThroughTime$_ = -1, this._$_isFirstTick$_ = !0, 
                    this._$_dx$_ = 0, this._$_dy$_ = 0, this._$_downX$_ = 0, this._$_downY$_ = 0, 
                    this._$_rightX$_ = 0, this._$_rightY$_ = 0, this._$_g$_ = 1500, 
                    this._$_g1$_ = 1500, this._$_ga$_ = g._$toRadians$_(90), this._$_maxSpeed$_ = 330, 
                    this._$_acc$_ = 1500, this._$_dec$_ = 1500, this._$_jumpStrength$_ = 650, 
                    this._$_maxFall$_ = 1e3, this._$_enableDoubleJump$_ = !1, this._$_jumpSustain$_ = 0, 
                    this._$_sustainTime$_ = 0, this._$_defaultControls$_ = !0, this._$_ceilingCollisionMode$_ = 0, 
                    this._$_isEnabled$_ = !0, e && (this._$_maxSpeed$_ = e[j], this._$_acc$_ = e[k], 
                    this._$_dec$_ = e[l], this._$_jumpStrength$_ = e[m], this._$_g$_ = e[n], 
                    this._$_maxFall$_ = e[o], this._$_enableDoubleJump$_ = !!e[p], 
                    this._$_jumpSustain$_ = e[q] / 1e3, this._$_defaultControls$_ = !!e[r], 
                    this._$_isEnabled$_ = !!e[s]);
                    const i = this._$_runtime$_._$Dispatcher$_();
                    this._$_disposables$_ = new g._$CompositeDisposable$_(g._$Disposable$_._$From$_(i, "instancedestroy", t => this._$_OnInstanceDestroyed$_(t.instance)), g._$Disposable$_._$From$_(i, "afterload", t => this._$_OnAfterLoad$_())), 
                    this._$_defaultControls$_ && this._$_BindEvents$_(), this._$_isEnabled$_ && this._$_StartPostTicking$_(), 
                    this._$_UpdateGravity$_();
                }
                _$Release$_() {
                    this._$_keyboardDisposables$_ && (this._$_keyboardDisposables$_._$Release$_(), 
                    this._$_keyboardDisposables$_ = null), this._$_lastFloorObject$_ = null, 
                    this._$_wasOverJumpthru$_ = null, super._$Release$_();
                }
                _$_BindEvents$_() {
                    if (!this._$_keyboardDisposables$_) {
                        const t = this._$_runtime$_._$Dispatcher$_();
                        this._$_keyboardDisposables$_ = new g._$CompositeDisposable$_(g._$Disposable$_._$From$_(t, "keydown", t => this._$_OnKeyDown$_(t.data)), g._$Disposable$_._$From$_(t, "keyup", t => this._$_OnKeyUp$_(t.data)), g._$Disposable$_._$From$_(t, "window-blur", () => this._$_OnWindowOrKeyboardBlur$_()), g._$Disposable$_._$From$_(t, "keyboard-blur", () => this._$_OnWindowOrKeyboardBlur$_()));
                    }
                }
                _$_UnBindEvents$_() {
                    this._$_keyboardDisposables$_ && (this._$_keyboardDisposables$_._$Release$_(), 
                    this._$_keyboardDisposables$_ = null);
                }
                _$_OnInstanceDestroyed$_(t) {
                    this._$_lastFloorObject$_ === t && (this._$_lastFloorObject$_ = null), 
                    this._$_wasOverJumpthru$_ === t && (this._$_wasOverJumpthru$_ = null);
                }
                _$_OnKeyDown$_(t) {
                    switch (t.key) {
                      case "ArrowLeft":
                        this._$_leftKey$_ = !0;
                        break;

                      case "ArrowRight":
                        this._$_rightKey$_ = !0;
                        break;

                      case "ArrowUp":
                        this._$_jumpKey$_ = !0;
                    }
                }
                _$_OnKeyUp$_(t) {
                    switch (t.key) {
                      case "ArrowLeft":
                        this._$_leftKey$_ = !1;
                        break;

                      case "ArrowRight":
                        this._$_rightKey$_ = !1;
                        break;

                      case "ArrowUp":
                        this._$_jumpKey$_ = !1, this._$_jumped$_ = !1;
                    }
                }
                _$_OnWindowOrKeyboardBlur$_() {
                    this._$_leftKey$_ = !1, this._$_rightKey$_ = !1, this._$_jumpKey$_ = !1, 
                    this._$_jumped$_ = !1;
                }
                _$SaveToJson$_() {
                    return {
                        ii: this._$_ignoreInput$_,
                        lfx: this._$_lastFloorX$_,
                        lfy: this._$_lastFloorY$_,
                        lfo: this._$_lastFloorObject$_ ? this._$_lastFloorObject$_._$GetUID$_() : -1,
                        am: this._$_animMode$_,
                        en: this._$_isEnabled$_,
                        fallt: this._$_fallThroughTime$_,
                        ft: this._$_isFirstTick$_,
                        dx: this._$_dx$_,
                        dy: this._$_dy$_,
                        ms: this._$_maxSpeed$_,
                        acc: this._$_acc$_,
                        dec: this._$_dec$_,
                        js: this._$_jumpStrength$_,
                        g: this._$_g$_,
                        g1: this._$_g1$_,
                        mf: this._$_maxFall$_,
                        wof: this._$_wasOnFloor$_,
                        woj: this._$_wasOverJumpthru$_ ? this._$_wasOverJumpthru$_._$GetUID$_() : -1,
                        ga: this._$_ga$_,
                        edj: this._$_enableDoubleJump$_,
                        cdj: this._$_canDoubleJump$_,
                        dj: this._$_doubleJumped$_,
                        sus: this._$_jumpSustain$_,
                        dc: this._$_defaultControls$_,
                        cc: this._$_ceilingCollisionMode$_
                    };
                }
                _$LoadFromJson$_(t) {
                    this._$_ignoreInput$_ = t.ii, this._$_lastFloorX$_ = t.lfx, 
                    this._$_lastFloorY$_ = t.lfy, this._$_loadFloorUid$_ = t.lfo, 
                    this._$_animMode$_ = t.am;
                    const e = t.en;
                    this._$_fallThroughTime$_ = t.fallt || -1, this._$_isFirstTick$_ = t.ft, 
                    this._$_dx$_ = t.dx, this._$_dy$_ = t.dy, this._$_maxSpeed$_ = t.ms, 
                    this._$_acc$_ = t.acc, this._$_dec$_ = t.dec, this._$_jumpStrength$_ = t.js, 
                    this._$_g$_ = t.g, this._$_g1$_ = t.g1, this._$_maxFall$_ = t.mf, 
                    this._$_wasOnFloor$_ = t.wof, this._$_loadJumpthruUid$_ = t.woj, 
                    this._$_ga$_ = t.ga, this._$_enableDoubleJump$_ = t.edj, this._$_canDoubleJump$_ = t.cdj, 
                    this._$_doubleJumped$_ = t.dj, this._$_jumpSustain$_ = t.sus, 
                    this._$_defaultControls$_ = t.dc, this._$_ceilingCollisionMode$_ = t.cc || 0, 
                    this._$_leftKey$_ = !1, this._$_rightKey$_ = !1, this._$_jumpKey$_ = !1, 
                    this._$_jumped$_ = !1, this._$_simLeft$_ = !1, this._$_simRight$_ = !1, 
                    this._$_simJump$_ = !1, this._$_sustainTime$_ = 0, this._$_defaultControls$_ ? this._$_BindEvents$_() : this._$_UnBindEvents$_(), 
                    this._$_SetEnabled$_(e), this._$_UpdateGravity$_();
                }
                _$_OnAfterLoad$_() {
                    -1 === this._$_loadFloorUid$_ ? this._$_lastFloorObject$_ = null : this._$_lastFloorObject$_ = this._$_runtime$_._$GetInstanceByUID$_(this._$_loadFloorUid$_), 
                    -1 === this._$_loadJumpthruUid$_ ? this._$_wasOverJumpthru$_ = null : this._$_wasOverJumpthru$_ = this._$_runtime$_._$GetInstanceByUID$_(this._$_loadJumpthruUid$_);
                }
                _$_SetLastFloorObject$_(t) {
                    if (this._$_lastFloorObject$_ = t) {
                        const e = t._$GetWorldInfo$_();
                        this._$_lastFloorX$_ = e._$GetX$_(), this._$_lastFloorY$_ = e._$GetY$_();
                    }
                }
                _$_IsFallThroughEnabled$_() {
                    return this._$_runtime$_._$GetGameTime$_() > this._$_fallThroughTime$_ + t;
                }
                _$_UpdateGravity$_() {
                    this._$_downX$_ = Math.cos(this._$_ga$_), this._$_downY$_ = Math.sin(this._$_ga$_), 
                    this._$_rightX$_ = Math.cos(this._$_ga$_ - Math.PI / 2), this._$_rightY$_ = Math.sin(this._$_ga$_ - Math.PI / 2), 
                    this._$_downX$_ = g._$roundToDp$_(this._$_downX$_, 6), this._$_downY$_ = g._$roundToDp$_(this._$_downY$_, 6), 
                    this._$_rightX$_ = g._$roundToDp$_(this._$_rightX$_, 6), this._$_rightY$_ = g._$roundToDp$_(this._$_rightY$_, 6), 
                    this._$_g1$_ = this._$_g$_, this._$_g$_ < 0 && (this._$_downX$_ *= -1, 
                    this._$_downY$_ *= -1, this._$_g$_ = Math.abs(this._$_g$_));
                }
                _$_GetGDir$_() {
                    return this._$_g$_ < 0 ? -1 : 1;
                }
                _$_IsOnFloor$_() {
                    const e = this._$_inst$_._$GetWorldInfo$_(), r = this._$_runtime$_._$GetCollisionEngine$_(), n = this._$_inst$_, t = this._$_lastFloorObject$_, s = e._$GetX$_(), h = e._$GetY$_();
                    if (e._$OffsetXY$_(this._$_downX$_, this._$_downY$_), e._$SetBboxChanged$_(), 
                    !t || !r._$TestOverlap$_(n, t) || t._$GetObjectClass$_()._$HasSolidBehavior$_() && !r._$IsSolidCollisionAllowed$_(t, n) || t._$GetObjectClass$_()._$HasJumpthruBehavior$_() && !t._$_IsJumpthruEnabled$_()) {
                        let t = r._$TestOverlapSolid$_(n), i = null;
                        if (!t && this._$_IsFallThroughEnabled$_() && (i = r._$TestOverlapJumpthru$_(n, !0)), 
                        e._$SetXY$_(s, h), e._$SetBboxChanged$_(), t) return r._$TestOverlap$_(n, t) ? null : (this._$_floorIsJumpthru$_ = !1, 
                        t);
                        if (i && i.length) {
                            let s = 0;
                            for (let t = 0, e = i.length; t < e; ++t) i[s] = i[t], 
                            r._$TestOverlap$_(n, i[t]) || ++s;
                            if (1 <= s) return this._$_floorIsJumpthru$_ = !0, i[0];
                        }
                        return null;
                    }
                    return e._$SetXY$_(s, h), e._$SetBboxChanged$_(), t;
                }
                _$PostTick$_() {
                    if (this._$_isEnabled$_) {
                        const c = this._$_runtime$_._$GetDt$_(this._$_inst$_);
                        this._$_jumpKey$_ || this._$_simJump$_ || (this._$_jumped$_ = !1);
                        let i = this._$_leftKey$_ || this._$_simLeft$_, r = this._$_rightKey$_ || this._$_simRight$_, n = this._$_jumpKey$_ || this._$_simJump$_, h = n && !this._$_jumped$_, [ o, , a ] = (this._$_simLeft$_ = !1, 
                        this._$_simRight$_ = !1, this._$_simJump$_ = !1, this._$_ignoreInput$_ && (i = !1, 
                        r = !1, n = !1, h = !1), n || (this._$_sustainTime$_ = 0), 
                        this._$_HandleFirstTick$_(), this._$_TrackMovingPlatform$_()), l = this._$_IsOnFloor$_(), u = l && !this._$_wasOnFloor$_, t = !1;
                        if ([ t, l ] = this._$_MaybePushOutSolid$_(l), !t) {
                            this._$_TrackFloor$_(l, a, o, n), h = this._$_HandleJump$_(l, h, n), 
                            l || this._$_HandleAirTime$_(h, n, c), this._$_wasOnFloor$_ = !!l;
                            let t = this._$_CalculateHorizontalAcceleration$_(i, r), e = !1, s = 0;
                            if (0 !== this._$_dx$_ && ([ e, l ] = this._$_HandleHorizontalMovement$_(c, t, l, h)), 
                            0 !== this._$_dy$_) {
                                const [ f, d ] = this._$_HandleVerticalMovement$_(c, l);
                                e = e || f, s = d;
                            }
                            !e && u && this._$_dy$_ < 0 && 0 < s && (this._$_dy$_ = 0, 
                            e = !0), this._$_ApplyHorizontalAcceleration$_(i, r, t, c), 
                            l && !h || e || (this._$_dy$_ = Math.min(this._$_dy$_ + this._$_g$_ * c, this._$_maxFall$_)), 
                            this._$_HandleAnimationTriggers$_(l, e, h), this._$_wasOverJumpthru$_ = this._$_runtime$_._$GetCollisionEngine$_()._$TestOverlapJumpthru$_(this._$_inst$_);
                        }
                    }
                }
                _$_HandleFirstTick$_() {
                    if (this._$_isFirstTick$_) {
                        const t = this._$_inst$_, e = this._$_runtime$_._$GetCollisionEngine$_();
                        (e._$TestOverlapSolid$_(t) || e._$TestOverlapJumpthru$_(t)) && e._$PushOutSolid$_(t, -this._$_downX$_, -this._$_downY$_, 4, !0), 
                        this._$_isFirstTick$_ = !1;
                    }
                }
                _$_TrackMovingPlatform$_() {
                    let t = this._$_lastFloorObject$_, e = t ? t._$GetWorldInfo$_() : null, s = 0, i = 0, r = !1;
                    if (t && 0 === this._$_dy$_ && (e._$GetY$_() !== this._$_lastFloorY$_ || e._$GetX$_() !== this._$_lastFloorX$_)) {
                        const n = this._$_inst$_, h = n._$GetWorldInfo$_(), o = this._$_runtime$_._$GetCollisionEngine$_(), a = e._$GetX$_(), l = e._$GetY$_(), u = (s = a - this._$_lastFloorX$_, 
                        i = l - this._$_lastFloorY$_, h._$OffsetXY$_(s, i), h._$SetBboxChanged$_(), 
                        this._$_lastFloorX$_ = a, this._$_lastFloorY$_ = l, r = !0, 
                        o._$TestOverlapSolid$_(n));
                        u && (o._$RegisterCollision$_(n, u), o._$PushOutSolid$_(n, -s, -i, 2.5 * g._$hypot2DFast$_(s, i)));
                    }
                    return [ s, i, r ];
                }
                _$_MaybePushOutSolid$_(t) {
                    let e = !1, s = this._$_inst$_, i = s._$GetWorldInfo$_(), r = this._$_runtime$_._$GetCollisionEngine$_(), n = r._$TestOverlapSolid$_(s);
                    if (!n) return [ !1, t ];
                    const h = Math.abs(i._$GetWidth$_()), o = Math.abs(i._$GetHeight$_());
                    return r._$PushOutSolid$_(s, -this._$_downX$_, -this._$_downY$_, o / 8) ? (r._$RegisterCollision$_(s, n), 
                    this._$_SetLastFloorObject$_(t = n), this._$_floorIsJumpthru$_ = !1, 
                    this._$_dy$_ = 0) : r._$PushOutSolidAxis$_(s, this._$_rightX$_, this._$_rightY$_, h / 2) || r._$PushOutSolidAxis$_(s, this._$_downX$_, this._$_downY$_, o / 2) || r._$PushOutSolidNearest$_(s, Math.max(h, o) / 2) ? r._$RegisterCollision$_(s, n) : e = !0, 
                    [ e, t ];
                }
                _$_TrackFloor$_(t, e, s, i) {
                    const r = this._$_inst$_, n = this._$_runtime$_._$GetCollisionEngine$_();
                    if (t) {
                        const h = this._$_downX$_, o = this._$_downY$_, a = this._$_rightX$_, l = this._$_rightY$_;
                        if (this._$_doubleJumped$_ = !1, this._$_canDoubleJump$_ = !1, 
                        0 < this._$_dy$_ && (this._$_wasOnFloor$_ || (n._$PushInFractional$_(r, -h, -o, t, 16), 
                        this._$_wasOnFloor$_ = !0), this._$_dy$_ = 0), this._$_lastFloorObject$_ !== t) this._$_SetLastFloorObject$_(t), 
                        n._$RegisterCollision$_(r, t); else if (e) {
                            const u = n._$TestOverlapSolid$_(r);
                            u && (n._$RegisterCollision$_(r, u), 0 !== s && (0 < s ? n._$PushOutSolid$_(r, -a, -l) : n._$PushOutSolid$_(r, a, l)), 
                            n._$PushOutSolid$_(r, -h, -o));
                        }
                    } else i || (this._$_canDoubleJump$_ = !0);
                }
                _$_HandleJump$_(t, e, s) {
                    if (t && e || !t && this._$_enableDoubleJump$_ && s && this._$_canDoubleJump$_ && !this._$_doubleJumped$_) {
                        const i = this._$_inst$_, r = i._$GetWorldInfo$_(), n = this._$_runtime$_._$GetCollisionEngine$_(), h = r._$GetX$_(), o = r._$GetY$_();
                        r._$OffsetXY$_(-this._$_downX$_, -this._$_downY$_), r._$SetBboxChanged$_(), 
                        n._$TestOverlapSolid$_(i) ? e = !1 : (this._$_sustainTime$_ = this._$_jumpSustain$_, 
                        this._$Trigger$_(g._$Behaviors$_._$Platform$_._$Cnds$_._$OnJump$_), 
                        this._$_animMode$_ = "jumping", this._$_dy$_ = -this._$_jumpStrength$_, 
                        e = !0, t ? this._$_jumped$_ = !0 : this._$_doubleJumped$_ = !0), 
                        r._$SetXY$_(h, o), r._$SetBboxChanged$_();
                    }
                    return e;
                }
                _$_HandleAirTime$_(t, e, s) {
                    e && 0 < this._$_sustainTime$_ ? (this._$_dy$_ = -this._$_jumpStrength$_, 
                    this._$_sustainTime$_ -= s) : this._$_lastFloorObject$_ = null, 
                    t && (this._$_jumped$_ = !0);
                }
                _$_CalculateHorizontalAcceleration$_(t, e) {
                    let s = 0, i = this._$_acc$_, r = this._$_dec$_;
                    return t && !e && (s = 0 < this._$_dx$_ ? -(i + r) : -i), s = e && !t ? this._$_dx$_ < 0 ? i + r : i : s;
                }
                _$_ApplyHorizontalAcceleration$_(t, e, s, i) {
                    const r = this._$_dec$_, n = (t === e && (this._$_dx$_ < 0 ? this._$_dx$_ = Math.min(this._$_dx$_ + r * i, 0) : 0 < this._$_dx$_ && (this._$_dx$_ = Math.max(this._$_dx$_ - r * i, 0))), 
                    this._$_dx$_ = g._$clamp$_(this._$_dx$_ + s * i, -this._$_maxSpeed$_, this._$_maxSpeed$_), 
                    this._$_runtime$_._$GetCollisionEngine$_()), h = this._$_dx$_ < 0 ? this._$_GetWallObstacle$_(0, 1, 1) : null;
                    if (h) this._$_dx$_ = 0, n._$RegisterCollision$_(this._$_inst$_, h); else {
                        const o = 0 < this._$_dx$_ ? this._$_GetWallObstacle$_(1, 1, 1) : null;
                        o && (this._$_dx$_ = 0, n._$RegisterCollision$_(this._$_inst$_, o));
                    }
                }
                _$_HandleHorizontalMovement$_(i, t, r, e) {
                    let n = this._$_inst$_, h = n._$GetWorldInfo$_(), o = this._$_runtime$_._$GetCollisionEngine$_(), a = this._$_downX$_, l = this._$_downY$_, s = this._$_rightX$_, u = this._$_rightY$_, c = this._$_maxSpeed$_, f = !1, d = new Set(o._$TestOverlapJumpthru$_(n, !0)), p = h._$GetX$_(), m = h._$GetY$_(), C = accelerate2(this._$_dx$_, -c, c, t, i) * s, g = accelerate2(this._$_dx$_, -c, c, t, i) * u, S = (h._$OffsetXY$_(s * (1 < this._$_dx$_ ? 1 : -1) - a, u * (1 < this._$_dx$_ ? 1 : -1) - l), 
                    h._$SetBboxChanged$_(), !1), _ = o._$TestOverlapSolid$_(n), T = (h._$SetXY$_(p + C, m + g), 
                    h._$SetBboxChanged$_(), o._$TestOverlapSolid$_(n));
                    if (!T && r && this._$_floorIsJumpthru$_ && (T = o._$TestOverlapJumpthru$_(n), 
                    d.has(T) ? T = null : S = !0), T) {
                        let t = Math.abs(this._$_dx$_ * i) + 2;
                        _ || !o._$PushOutSolid$_(n, -a, -l, t, S, T) ? (o._$RegisterCollision$_(n, T), 
                        t = Math.max(Math.abs(this._$_dx$_ * i * 2.5), Math.floor(h._$GetWidth$_())), 
                        o._$PushOutSolid$_(n, s * (this._$_dx$_ < 0 ? 1 : -1), u * (this._$_dx$_ < 0 ? 1 : -1), t, !1) && (!r || S || this._$_floorIsJumpthru$_ || (p = h._$GetX$_(), 
                        m = h._$GetY$_(), h._$OffsetXY$_(a, l), o._$TestOverlapSolid$_(n) && o._$PushOutSolid$_(n, -a, -l, 3, !1))) || (h._$SetXY$_(p, m), 
                        h._$SetBboxChanged$_()), S || (this._$_dx$_ = 0)) : !_ && !e && Math.abs(this._$_dy$_) < Math.abs(this._$_jumpStrength$_ / 4) && (this._$_dy$_ = 0, 
                        r || (f = !0));
                    } else {
                        const y = this._$_IsOnFloor$_();
                        if (r && !y) {
                            let t = Math.ceil(Math.abs(this._$_dx$_ * i)) + 2, e = (p = h._$GetX$_(), 
                            m = h._$GetY$_(), h._$OffsetXY$_(a * t, l * t), h._$SetBboxChanged$_(), 
                            o._$TestOverlapJumpthru$_(n)), s = !1;
                            e && !d.has(e) && o._$PushOutSolid$_(n, -a, -l, t + 2, !0, e) && (this._$_SetLastFloorObject$_(r = e), 
                            this._$_floorIsJumpthru$_ = !0, s = !0), s || (o._$TestOverlapSolid$_(n) ? o._$PushOutSolid$_(n, -a, -l, t + 2, !1) : (h._$SetXY$_(p, m), 
                            h._$SetBboxChanged$_()));
                        } else y && (!r && this._$_floorIsJumpthru$_ && (this._$_SetLastFloorObject$_(y), 
                        this._$_dy$_ = 0, f = !0), 0 === this._$_dy$_) && o._$PushInFractional$_(n, -a, -l, y, 16);
                    }
                    return [ f, r ];
                }
                _$_HandleVerticalMovement$_(e, t) {
                    let i = this._$_inst$_, r = i._$GetWorldInfo$_(), n = this._$_runtime$_._$GetCollisionEngine$_(), s = this._$_downX$_, h = this._$_downY$_, o = !1, a = r._$GetX$_(), l = r._$GetY$_(), u = accelerate2(this._$_dy$_, -1 / 0, this._$_maxFall$_, this._$_g$_, e), c = (r._$OffsetXY$_(u * s, u * h), 
                    r._$GetX$_()), f = r._$GetY$_(), d = (r._$SetBboxChanged$_(), 
                    n._$TestOverlapSolid$_(i)), p = !1;
                    if (!d && 0 < this._$_dy$_ && !t) {
                        const m = this._$_IsFallThroughEnabled$_() ? n._$TestOverlapJumpthru$_(i, !0) : null;
                        if (m && m.length) {
                            if (this._$_wasOverJumpthru$_) {
                                r._$SetXY$_(a, l), r._$SetBboxChanged$_();
                                let s = 0;
                                for (let t = 0, e = m.length; t < e; ++t) m[s] = m[t], 
                                n._$TestOverlap$_(i, m[t]) || ++s;
                                g._$truncateArray$_(m, s), r._$SetXY$_(c, f), r._$SetBboxChanged$_();
                            }
                            1 <= m.length && (d = m[0]);
                        }
                        p = !!d;
                    }
                    if (d) {
                        n._$RegisterCollision$_(i, d), this._$_sustainTime$_ = 0;
                        let t = 1.1;
                        p && !this._$_wasOverJumpthru$_ && (t = 2);
                        const C = Math.max(Math.abs(this._$_dy$_ * e * t), 2);
                        n._$PushOutSolid$_(i, s * (this._$_dy$_ < 0 ? 1 : -1), h * (this._$_dy$_ < 0 ? 1 : -1), C, p, d) ? (this._$_SetLastFloorObject$_(d), 
                        this._$_floorIsJumpthru$_ = p, 0 < this._$_dy$_ && (o = !0), 
                        (0 < this._$_dy$_ || 0 === this._$_ceilingCollisionMode$_) && (this._$_dy$_ = 0), 
                        this._$_dy$_ < 0 && 1 === this._$_ceilingCollisionMode$_ && n._$PushInFractional$_(i, s, h, d, 32)) : (r._$SetXY$_(a, l), 
                        r._$SetBboxChanged$_(), this._$_wasOnFloor$_ = !0, p || (this._$_dy$_ = 0));
                    }
                    return [ o, u ];
                }
                _$_HandleAnimationTriggers$_(t, e, s) {
                    "falling" !== this._$_animMode$_ && 0 < this._$_dy$_ && !t && (this._$Trigger$_(g._$Behaviors$_._$Platform$_._$Cnds$_._$OnFall$_), 
                    this._$_animMode$_ = "falling"), (t || e) && 0 <= this._$_dy$_ && ("falling" === this._$_animMode$_ || e || s && 0 === this._$_dy$_ ? (this._$Trigger$_(g._$Behaviors$_._$Platform$_._$Cnds$_._$OnLand$_), 
                    0 === this._$_dx$_ && 0 === this._$_dy$_ ? this._$_animMode$_ = "stopped" : this._$_animMode$_ = "moving") : ("stopped" !== this._$_animMode$_ && 0 === this._$_dx$_ && 0 === this._$_dy$_ && (this._$Trigger$_(g._$Behaviors$_._$Platform$_._$Cnds$_._$OnStop$_), 
                    this._$_animMode$_ = "stopped"), "moving" === this._$_animMode$_ || 0 === this._$_dx$_ && 0 === this._$_dy$_ || s || (this._$Trigger$_(g._$Behaviors$_._$Platform$_._$Cnds$_._$OnMove$_), 
                    this._$_animMode$_ = "moving")));
                }
                _$_IsMoving$_() {
                    return 0 !== this._$_GetVectorX$_() || 0 !== this._$_GetVectorY$_();
                }
                _$_CheckIfStandingOnFloor$_() {
                    if (0 === this._$_dy$_) {
                        let i = this._$_inst$_, t = this._$GetWorldInfo$_(), r = this._$_runtime$_._$GetCollisionEngine$_(), e = t._$GetX$_(), s = t._$GetY$_(), n = (t._$OffsetXY$_(this._$_downX$_, this._$_downY$_), 
                        t._$SetBboxChanged$_(), r._$TestOverlapSolid$_(i)), h = null;
                        if (!n && this._$_IsFallThroughEnabled$_() && (h = r._$TestOverlapJumpthru$_(i, !0)), 
                        t._$SetXY$_(e, s), t._$SetBboxChanged$_(), n) return !r._$TestOverlap$_(i, n);
                        if (h && h.length) {
                            let s = 0;
                            for (let t = 0, e = h.length; t < e; ++t) h[s] = h[t], 
                            r._$TestOverlap$_(i, h[t]) || s++;
                            if (1 <= s) return !0;
                        }
                    }
                    return !1;
                }
                _$_IsByWall$_(t, e = 2, s = 3) {
                    return !!this._$_GetWallObstacle$_(t, e, s);
                }
                _$_GetWallObstacle$_(t, e = 2, s = 3) {
                    const i = this._$_inst$_, r = this._$GetWorldInfo$_(), n = this._$_runtime$_._$GetCollisionEngine$_(), h = r._$GetX$_(), o = r._$GetY$_();
                    if (0 === t ? r._$OffsetXY$_(-this._$_rightX$_ * e, -this._$_rightY$_ * e) : r._$OffsetXY$_(this._$_rightX$_ * e, this._$_rightY$_ * e), 
                    r._$SetBboxChanged$_(), !n._$TestOverlapSolid$_(i)) return r._$SetXY$_(h, o), 
                    r._$SetBboxChanged$_(), null;
                    r._$OffsetXY$_(-this._$_downX$_ * s, -this._$_downY$_ * s), 
                    r._$SetBboxChanged$_();
                    const a = n._$TestOverlapSolid$_(i);
                    return r._$SetXY$_(h, o), r._$SetBboxChanged$_(), a;
                }
                _$_FallThroughJumpThru$_() {
                    const t = this._$GetWorldInfo$_(), e = t._$GetX$_(), s = t._$GetY$_(), i = (t._$OffsetXY$_(this._$_downX$_, this._$_downY$_), 
                    t._$SetBboxChanged$_(), this._$_runtime$_._$GetCollisionEngine$_()._$TestOverlapJumpthru$_(this._$_inst$_, !1));
                    t._$SetXY$_(e, s), t._$SetBboxChanged$_(), i && (this._$_fallThroughTime$_ = this._$_runtime$_._$GetGameTime$_(), 
                    this._$_lastFloorObject$_ = null);
                }
                _$_ResetDoubleJump$_(t) {
                    this._$_doubleJumped$_ = !t;
                }
                _$_GetSpeed$_() {
                    return Math.hypot(this._$_dx$_, this._$_dy$_);
                }
                _$_GetMovingAngle$_() {
                    return Math.atan2(this._$_dy$_, this._$_dx$_);
                }
                _$_IsJumping$_() {
                    return this._$_dy$_ < 0;
                }
                _$_IsFalling$_() {
                    return 0 < this._$_dy$_;
                }
                _$_SetMaxSpeed$_(t) {
                    this._$_maxSpeed$_ = Math.max(t, 0);
                }
                _$_GetMaxSpeed$_() {
                    return this._$_maxSpeed$_;
                }
                _$_SetAcceleration$_(t) {
                    this._$_acc$_ = Math.max(t, 0);
                }
                _$_GetAcceleration$_() {
                    return this._$_acc$_;
                }
                _$_SetDeceleration$_(t) {
                    this._$_dec$_ = Math.max(t, 0);
                }
                _$_GetDeceleration$_() {
                    return this._$_dec$_;
                }
                _$_SetJumpStrength$_(t) {
                    this._$_jumpStrength$_ = Math.max(t, 0);
                }
                _$_GetJumpStrength$_() {
                    return this._$_jumpStrength$_;
                }
                _$_SetMaxFallSpeed$_(t) {
                    this._$_maxFall$_ = Math.max(t, 0);
                }
                _$_GetMaxFallSpeed$_() {
                    return this._$_maxFall$_;
                }
                _$_SetGravity$_(t) {
                    if (this._$_g1$_ !== t) {
                        this._$_g$_ = t, this._$_UpdateGravity$_();
                        const e = this._$_runtime$_._$GetCollisionEngine$_(), s = this._$GetWorldInfo$_();
                        e._$TestOverlapSolid$_(this._$_inst$_) && (e._$PushOutSolid$_(this._$_inst$_, this._$_downX$_, this._$_downY$_, 10), 
                        s._$OffsetXY$_(2 * this._$_downX$_, 2 * this._$_downY$_), 
                        s._$SetBboxChanged$_()), this._$_lastFloorObject$_ = null;
                    }
                }
                _$_GetGravity$_() {
                    return this._$_g$_;
                }
                _$_SetGravityAngle$_(t) {
                    t = g._$clampAngle$_(t), this._$_ga$_ !== t && (this._$_ga$_ = t, 
                    this._$_UpdateGravity$_(), this._$_lastFloorObject$_ = null);
                }
                _$_GetGravityAngle$_() {
                    return this._$_ga$_;
                }
                _$_SetDoubleJumpEnabled$_(t) {
                    this._$_enableDoubleJump$_ = !!t;
                }
                _$_IsDoubleJumpEnabled$_() {
                    return this._$_enableDoubleJump$_;
                }
                _$_SetJumpSustain$_(t) {
                    this._$_jumpSustain$_ = t;
                }
                _$_GetJumpSustain$_() {
                    return this._$_jumpSustain$_;
                }
                _$_SetCeilingCollisionMode$_(t) {
                    this._$_ceilingCollisionMode$_ = t;
                }
                _$_GetCeilingCollisionMode$_() {
                    return this._$_ceilingCollisionMode$_;
                }
                _$_SetVectorX$_(t) {
                    this._$_dx$_ = t;
                }
                _$_GetVectorX$_() {
                    return this._$_dx$_;
                }
                _$_SetVectorY$_(t) {
                    this._$_dy$_ = t;
                }
                _$_GetVectorY$_() {
                    return this._$_dy$_;
                }
                _$_SimulateControl$_(t) {
                    if (this._$_isEnabled$_) switch (t) {
                      case 0:
                        this._$_simLeft$_ = !0;
                        break;

                      case 1:
                        this._$_simRight$_ = !0;
                        break;

                      case 2:
                        this._$_simJump$_ = !0;
                    }
                }
                _$_SetDefaultControls$_(t) {
                    this._$_defaultControls$_ !== (t = !!t) && (this._$_defaultControls$_ = t, 
                    this._$_defaultControls$_ ? this._$_BindEvents$_() : (this._$_UnBindEvents$_(), 
                    this._$_OnWindowOrKeyboardBlur$_()));
                }
                _$_IsDefaultControls$_() {
                    return this._$_defaultControls$_;
                }
                _$_SetIgnoreInput$_(t) {
                    this._$_ignoreInput$_ = !!t;
                }
                _$_IsIgnoreInput$_() {
                    return this._$_ignoreInput$_;
                }
                _$_SetEnabled$_(t) {
                    this._$_isEnabled$_ !== (t = !!t) && (this._$_isEnabled$_ = t, 
                    this._$_isEnabled$_ ? this._$_StartPostTicking$_() : (this._$_StopPostTicking$_(), 
                    this._$_lastFloorObject$_ = null, this._$_simLeft$_ = !1, this._$_simRight$_ = !1, 
                    this._$_simJump$_ = !1));
                }
                _$_IsEnabled$_() {
                    return this._$_isEnabled$_;
                }
                _$GetPropertyValueByIndex$_(t) {
                    switch (t) {
                      case j:
                        return this._$_GetMaxSpeed$_();

                      case k:
                        return this._$_GetAcceleration$_();

                      case l:
                        return this._$_GetDeceleration$_();

                      case m:
                        return this._$_GetJumpStrength$_();

                      case n:
                        return this._$_GetGravity$_();

                      case o:
                        return this._$_GetMaxFallSpeed$_();

                      case p:
                        return this._$_IsDoubleJumpEnabled$_();

                      case q:
                        return 1e3 * this._$_GetJumpSustain$_();

                      case r:
                        return this._$_IsDefaultControls$_();

                      case s:
                        return this._$_IsEnabled$_();
                    }
                }
                _$SetPropertyValueByIndex$_(t, e) {
                    switch (t) {
                      case j:
                        this._$_SetMaxSpeed$_(e);
                        break;

                      case k:
                        this._$_SetAcceleration$_(e);
                        break;

                      case l:
                        this._$_SetDeceleration$_(e);
                        break;

                      case m:
                        this._$_SetJumpStrength$_(e);
                        break;

                      case n:
                        this._$_SetGravity$_(e);
                        break;

                      case o:
                        this._$_SetMaxFallSpeed$_(e);
                        break;

                      case p:
                        this._$_SetDoubleJumpEnabled$_(!!e);
                        break;

                      case q:
                        this._$_SetJumpSustain$_(e / 1e3);
                        break;

                      case r:
                        this._$_SetDefaultControls$_(!!e);
                        break;

                      case s:
                        this._$_SetEnabled$_(!!e);
                    }
                }
                _$GetDebuggerProperties$_() {
                    const t = "behaviors.platform";
                    return [ {
                        title: "$" + this._$GetBehaviorType$_()._$GetName$_(),
                        properties: [ {
                            name: t + ".debugger.vector-x",
                            value: this._$_GetVectorX$_(),
                            _$onedit$_: t => this._$_SetVectorX$_(t)
                        }, {
                            name: t + ".debugger.vector-y",
                            value: this._$_GetVectorY$_(),
                            _$onedit$_: t => this._$_SetVectorY$_(t)
                        }, {
                            name: t + ".properties.max-speed.name",
                            value: this._$_GetMaxSpeed$_(),
                            _$onedit$_: t => this._$_SetMaxSpeed$_(t)
                        }, {
                            name: t + ".properties.acceleration.name",
                            value: this._$_GetAcceleration$_(),
                            _$onedit$_: t => this._$_SetAcceleration$_(t)
                        }, {
                            name: t + ".properties.deceleration.name",
                            value: this._$_GetDeceleration$_(),
                            _$onedit$_: t => this._$_SetDeceleration$_(t)
                        }, {
                            name: t + ".properties.jump-strength.name",
                            value: this._$_GetJumpStrength$_(),
                            _$onedit$_: t => this._$_SetJumpStrength$_(t)
                        }, {
                            name: t + ".properties.gravity.name",
                            value: this._$_GetGravity$_(),
                            _$onedit$_: t => this._$_SetGravity$_(t)
                        }, {
                            name: t + ".debugger.gravity-angle",
                            value: g._$toDegrees$_(this._$_GetGravityAngle$_()),
                            _$onedit$_: t => this._$_SetGravityAngle$_(g._$toRadians$_(t))
                        }, {
                            name: t + ".properties.max-fall-speed.name",
                            value: this._$_GetMaxFallSpeed$_(),
                            _$onedit$_: t => this._$_SetMaxFallSpeed$_(t)
                        }, {
                            name: t + ".properties.double-jump.name",
                            value: this._$_IsDoubleJumpEnabled$_(),
                            _$onedit$_: t => this._$_SetDoubleJumpEnabled$_(t)
                        }, {
                            name: t + ".properties.jump-sustain.name",
                            value: 1e3 * this._$_GetJumpSustain$_(),
                            _$onedit$_: t => this._$_SetJumpSustain$_(t / 1e3)
                        }, {
                            name: t + ".debugger.animation-mode",
                            value: [ t + ".debugger.anim-" + this._$_animMode$_ ]
                        }, {
                            name: t + ".properties.enabled.name",
                            value: this._$_IsEnabled$_(),
                            _$onedit$_: t => this._$_SetEnabled$_(t)
                        } ]
                    } ];
                }
                _$GetScriptInterfaceClass$_() {
                    return self._$IPlatformBehaviorInstance$_;
                }
            }, new WeakMap()), v = new Map([ [ "left", 0 ], [ "right", 1 ], [ "jump", 2 ] ]);
            self._$IPlatformBehaviorInstance$_ = class extends i {
                constructor() {
                    super(), u.set(this, i._$_GetInitInst$_()._$GetSdkInstance$_());
                }
                _$fallThrough$_() {
                    u.get(this)._$_FallThroughJumpThru$_();
                }
                _$resetDoubleJump$_(t) {
                    u.get(this)._$_ResetDoubleJump$_(!!t);
                }
                _$simulateControl$_(t) {
                    h._$RequireString$_(t);
                    const e = v.get(t);
                    if ("number" != typeof e) throw new Error("invalid control");
                    u.get(this)._$_SimulateControl$_(e);
                }
                get speed() {
                    return u.get(this)._$_GetSpeed$_();
                }
                get _$maxSpeed$_() {
                    return u.get(this)._$_GetMaxSpeed$_();
                }
                set _$maxSpeed$_(t) {
                    h._$RequireFiniteNumber$_(t), u.get(this)._$_SetMaxSpeed$_(t);
                }
                get acceleration() {
                    return u.get(this)._$_GetAcceleration$_();
                }
                set acceleration(t) {
                    h._$RequireFiniteNumber$_(t), u.get(this)._$_SetAcceleration$_(t);
                }
                get _$deceleration$_() {
                    return u.get(this)._$_GetDeceleration$_();
                }
                set _$deceleration$_(t) {
                    h._$RequireFiniteNumber$_(t), u.get(this)._$_SetDeceleration$_(t);
                }
                get _$jumpStrength$_() {
                    return u.get(this)._$_GetJumpStrength$_();
                }
                set _$jumpStrength$_(t) {
                    h._$RequireFiniteNumber$_(t), u.get(this)._$_SetJumpStrength$_(t);
                }
                get _$maxFallSpeed$_() {
                    return u.get(this)._$_GetMaxFallSpeed$_();
                }
                set _$maxFallSpeed$_(t) {
                    h._$RequireFiniteNumber$_(t), u.get(this)._$_SetMaxFallSpeed$_(t);
                }
                get _$gravity$_() {
                    return u.get(this)._$_GetGravity$_();
                }
                set _$gravity$_(t) {
                    h._$RequireFiniteNumber$_(t), u.get(this)._$_SetGravity$_(t);
                }
                get _$gravityAngle$_() {
                    return u.get(this)._$_GetGravityAngle$_();
                }
                set _$gravityAngle$_(t) {
                    h._$RequireFiniteNumber$_(t), u.get(this)._$_SetGravityAngle$_(t);
                }
                get _$isDoubleJumpEnabled$_() {
                    return u.get(this)._$_IsDoubleJumpEnabled$_();
                }
                set _$isDoubleJumpEnabled$_(t) {
                    u.get(this)._$_SetDoubleJumpEnabled$_(!!t);
                }
                get _$jumpSustain$_() {
                    return u.get(this)._$_GetJumpSustain$_();
                }
                set _$jumpSustain$_(t) {
                    h._$RequireFiniteNumber$_(t), u.get(this)._$_SetJumpSustain$_(t);
                }
                get _$ceilingCollisionMode$_() {
                    const t = u.get(this)._$_GetCeilingCollisionMode$_();
                    return 0 === t ? "stop" : "preserve-momentum";
                }
                set _$ceilingCollisionMode$_(t) {
                    h._$RequireString$_(t);
                    const e = u.get(this);
                    if ("stop" === t) e._$_SetCeilingCollisionMode$_(0); else {
                        if ("preserve-momentum" !== t) throw new Error("invalid mode");
                        e._$_SetCeilingCollisionMode$_(1);
                    }
                }
                get _$isOnFloor$_() {
                    return u.get(this)._$_CheckIfStandingOnFloor$_();
                }
                _$isByWall$_(t) {
                    h._$RequireString$_(t);
                    const e = u.get(this);
                    if ("left" === t) return e._$_IsByWall$_(0);
                    if ("right" === t) return e._$_IsByWall$_(1);
                    throw new Error("invalid side");
                }
                get _$isMoving$_() {
                    return u.get(this)._$_IsMoving$_();
                }
                get _$isJumping$_() {
                    return u.get(this)._$_IsJumping$_();
                }
                get _$isFalling$_() {
                    return u.get(this)._$_IsFalling$_();
                }
                get _$vectorX$_() {
                    return u.get(this)._$_GetVectorX$_();
                }
                set _$vectorX$_(t) {
                    h._$RequireFiniteNumber$_(t), u.get(this)._$_SetVectorX$_(t);
                }
                get _$vectorY$_() {
                    return u.get(this)._$_GetVectorY$_();
                }
                set _$vectorY$_(t) {
                    h._$RequireFiniteNumber$_(t), u.get(this)._$_SetVectorY$_(t);
                }
                _$setVector$_(t, e) {
                    h._$RequireFiniteNumber$_(t), h._$RequireFiniteNumber$_(e);
                    const s = u.get(this);
                    s._$_SetVectorX$_(t), s._$_SetVectorY$_(e);
                }
                _$getVector$_() {
                    const t = u.get(this);
                    return [ t._$_GetVectorX$_(), t._$_GetVectorY$_() ];
                }
                get _$isDefaultControls$_() {
                    return u.get(this)._$_IsDefaultControls$_();
                }
                set _$isDefaultControls$_(t) {
                    u.get(this)._$_SetDefaultControls$_(!!t);
                }
                get _$isIgnoringInput$_() {
                    return u.get(this)._$_IsIgnoreInput$_();
                }
                set _$isIgnoringInput$_(t) {
                    u.get(this)._$_SetIgnoreInput$_(!!t);
                }
                get isEnabled() {
                    return u.get(this)._$_IsEnabled$_();
                }
                set isEnabled(t) {
                    u.get(this)._$_SetEnabled$_(!!t);
                }
            };
        }
        {
            const Y1 = self._$C3$_;
            Y1._$Behaviors$_._$Platform$_._$Cnds$_ = {
                _$IsMoving$_() {
                    return this._$_IsMoving$_();
                },
                _$CompareSpeed$_(t, e) {
                    return Y1.compare(this._$_GetSpeed$_(), t, e);
                },
                _$IsOnFloor$_() {
                    return this._$_CheckIfStandingOnFloor$_();
                },
                _$IsByWall$_(t) {
                    return this._$_IsByWall$_(t);
                },
                _$IsJumping$_() {
                    return this._$_IsJumping$_();
                },
                _$IsFalling$_() {
                    return this._$_IsFalling$_();
                },
                _$IsDoubleJumpEnabled$_() {
                    return this._$_IsDoubleJumpEnabled$_();
                },
                _$OnJump$_() {
                    return !0;
                },
                _$OnFall$_() {
                    return !0;
                },
                _$OnStop$_() {
                    return !0;
                },
                _$OnMove$_() {
                    return !0;
                },
                _$OnLand$_() {
                    return !0;
                },
                _$IsEnabled$_() {
                    return this._$_IsEnabled$_();
                }
            };
        }
        {
            const ac = self._$C3$_;
            ac._$Behaviors$_._$Platform$_._$Acts$_ = {
                _$SetMaxSpeed$_(t) {
                    this._$_SetMaxSpeed$_(t);
                },
                _$SetAcceleration$_(t) {
                    this._$_SetAcceleration$_(t);
                },
                _$SetDeceleration$_(t) {
                    this._$_SetDeceleration$_(t);
                },
                _$SetJumpStrength$_(t) {
                    this._$_SetJumpStrength$_(t);
                },
                _$SetMaxFallSpeed$_(t) {
                    this._$_SetMaxFallSpeed$_(t);
                },
                SetGravity(t) {
                    this._$_SetGravity$_(t);
                },
                _$SimulateControl$_(t) {
                    this._$_SimulateControl$_(t);
                },
                _$SetIgnoreInput$_(t) {
                    this._$_SetIgnoreInput$_(!!t);
                },
                _$SetVectorX$_(t) {
                    this._$_SetVectorX$_(t);
                },
                _$SetVectorY$_(t) {
                    this._$_SetVectorY$_(t);
                },
                _$SetGravityAngle$_(t) {
                    this._$_SetGravityAngle$_(ac._$toRadians$_(t));
                },
                _$SetEnabled$_(t) {
                    this._$_SetEnabled$_(0 !== t);
                },
                _$FallThrough$_() {
                    this._$_FallThroughJumpThru$_();
                },
                _$SetDoubleJumpEnabled$_(t) {
                    this._$_SetDoubleJumpEnabled$_(0 !== t);
                },
                _$SetJumpSustain$_(t) {
                    this._$_SetJumpSustain$_(t / 1e3);
                },
                _$SetCeilingCollision$_(t) {
                    this._$_SetCeilingCollisionMode$_(t);
                },
                _$SetDefaultControls$_(t) {
                    this._$_SetDefaultControls$_(t);
                },
                _$ResetDoubleJump$_(t) {
                    this._$_ResetDoubleJump$_(t);
                }
            };
        }
        {
            const sc = self._$C3$_;
            sc._$Behaviors$_._$Platform$_._$Exps$_ = {
                _$Speed$_() {
                    return this._$_GetSpeed$_();
                },
                _$MaxSpeed$_() {
                    return this._$_GetMaxSpeed$_();
                },
                _$Acceleration$_() {
                    return this._$_GetAcceleration$_();
                },
                _$Deceleration$_() {
                    return this._$_GetDeceleration$_();
                },
                _$JumpStrength$_() {
                    return this._$_GetJumpStrength$_();
                },
                _$Gravity$_() {
                    return this._$_GetGravity$_();
                },
                _$GravityAngle$_() {
                    return sc._$toDegrees$_(this._$_GetGravityAngle$_());
                },
                _$MaxFallSpeed$_() {
                    return this._$_GetMaxFallSpeed$_();
                },
                _$MovingAngle$_() {
                    return sc._$toDegrees$_(this._$_GetMovingAngle$_());
                },
                _$VectorX$_() {
                    return this._$_GetVectorX$_();
                },
                _$VectorY$_() {
                    return this._$_GetVectorY$_();
                },
                _$JumpSustain$_() {
                    return 1e3 * this._$_GetJumpSustain$_();
                }
            };
        }
        {
            const a = self._$C3$_;
            a._$Behaviors$_._$scrollto$_ = class extends a._$SDKBehaviorBase$_ {
                constructor(t) {
                    super(t), this._$_shakeMag$_ = 0, this._$_shakeStart$_ = 0, 
                    this._$_shakeEnd$_ = 0, this._$_shakeMode$_ = 0;
                }
                _$Release$_() {
                    super._$Release$_();
                }
                _$SetShakeMagnitude$_(t) {
                    this._$_shakeMag$_ = t;
                }
                _$GetShakeMagnitude$_() {
                    return this._$_shakeMag$_;
                }
                _$SetShakeStart$_(t) {
                    this._$_shakeStart$_ = t;
                }
                _$GetShakeStart$_() {
                    return this._$_shakeStart$_;
                }
                _$SetShakeEnd$_(t) {
                    this._$_shakeEnd$_ = t;
                }
                _$GetShakeEnd$_() {
                    return this._$_shakeEnd$_;
                }
                _$SetShakeMode$_(t) {
                    this._$_shakeMode$_ = t;
                }
                _$GetShakeMode$_() {
                    return this._$_shakeMode$_;
                }
            };
        }
        {
            const h = self._$C3$_;
            h._$Behaviors$_._$scrollto$_._$Type$_ = class extends h._$SDKBehaviorTypeBase$_ {
                constructor(t) {
                    super(t);
                }
                _$Release$_() {
                    super._$Release$_();
                }
                _$OnCreate$_() {}
            };
        }
        {
            const k = self._$C3$_, l = 0;
            k._$Behaviors$_._$scrollto$_.Instance = class extends k._$SDKBehaviorInstanceBase$_ {
                constructor(t, e) {
                    super(t), this._$_isEnabled$_ = !0, e && (this._$_isEnabled$_ = e[l]), 
                    this._$_isEnabled$_ && this._$_StartTicking2$_();
                }
                _$Release$_() {
                    super._$Release$_();
                }
                _$SaveToJson$_() {
                    const t = this._$GetBehavior$_();
                    return {
                        e: this._$_isEnabled$_,
                        smg: t._$GetShakeMagnitude$_(),
                        ss: t._$GetShakeStart$_(),
                        se: t._$GetShakeEnd$_(),
                        smd: t._$GetShakeMode$_()
                    };
                }
                _$LoadFromJson$_(t) {
                    const e = this._$GetBehavior$_();
                    e._$SetShakeMagnitude$_(t.smg), e._$SetShakeStart$_(t.ss), e._$SetShakeEnd$_(t.se), 
                    e._$SetShakeMode$_(t.smd), this._$_isEnabled$_ = t.e, this._$_isEnabled$_ ? this._$_StartTicking2$_() : this._$_StopTicking2$_();
                }
                _$_SetEnabled$_(t) {
                    this._$_isEnabled$_ = !!t, this._$_isEnabled$_ ? this._$_StartTicking2$_() : this._$_StopTicking2$_();
                }
                _$IsEnabled$_() {
                    return this._$_isEnabled$_;
                }
                _$Tick2$_() {
                    if (this._$IsEnabled$_()) {
                        this._$_runtime$_._$GetDt$_(this._$_inst$_);
                        let e = this._$GetBehavior$_(), t = e._$GetInstances$_(), s = 0, i = 0, r = 0;
                        for (const l of t) {
                            const u = l._$GetBehaviorInstanceFromCtor$_(k._$Behaviors$_._$scrollto$_);
                            if (u && u._$GetSdkInstance$_()._$IsEnabled$_()) {
                                const c = l._$GetWorldInfo$_();
                                s += c._$GetX$_(), i += c._$GetY$_(), ++r;
                            }
                        }
                        let n = this._$_inst$_._$GetWorldInfo$_()._$GetLayout$_(), h = this._$_runtime$_._$GetGameTime$_(), o = 0, a = 0;
                        if (h >= e._$GetShakeStart$_() && h < e._$GetShakeEnd$_()) {
                            let t = e._$GetShakeMagnitude$_() * Math.min(this._$_runtime$_._$GetTimeScale$_(), 1);
                            0 === e._$GetShakeMode$_() && (t *= 1 - (h - e._$GetShakeStart$_()) / (e._$GetShakeEnd$_() - e._$GetShakeStart$_()));
                            const f = this._$_runtime$_._$Random$_() * Math.PI * 2, d = this._$_runtime$_._$Random$_() * t;
                            o = Math.cos(f) * d, a = Math.sin(f) * d;
                        }
                        n._$SetScrollX$_(s / r + o), n._$SetScrollY$_(i / r + a);
                    }
                }
                _$GetPropertyValueByIndex$_(t) {
                    if (t === l) return this._$_isEnabled$_;
                }
                _$SetPropertyValueByIndex$_(t, e) {
                    t === l && (this._$_isEnabled$_ = !!e, this._$_isEnabled$_ ? this._$_StartTicking2$_() : this._$_StopTicking2$_());
                }
                _$GetDebuggerProperties$_() {
                    return [ {
                        title: "$" + this._$GetBehaviorType$_()._$GetName$_(),
                        properties: [ {
                            name: "behaviors.scrollto.properties.enabled.name",
                            value: this._$IsEnabled$_(),
                            _$onedit$_: t => this._$_SetEnabled$_(t)
                        } ]
                    } ];
                }
            };
        }
        {
            const O = self._$C3$_;
            O._$Behaviors$_._$scrollto$_._$Cnds$_ = {
                _$IsEnabled$_() {
                    return this._$IsEnabled$_();
                }
            };
        }
        {
            const P = self._$C3$_;
            P._$Behaviors$_._$scrollto$_._$Acts$_ = {
                _$Shake$_(t, e, s) {
                    const i = this._$GetBehavior$_();
                    i._$SetShakeMagnitude$_(t), i._$SetShakeStart$_(this._$_runtime$_._$GetGameTime$_()), 
                    i._$SetShakeEnd$_(this._$_runtime$_._$GetGameTime$_() + e), 
                    i._$SetShakeMode$_(s);
                },
                _$SetEnabled$_(t) {
                    this._$_SetEnabled$_(0 !== t);
                }
            };
        }
        {
            const V = self._$C3$_;
            V._$Behaviors$_._$scrollto$_._$Exps$_ = {};
        }
        {
            const a = self._$C3$_;
            a._$Behaviors$_.wrap = class extends a._$SDKBehaviorBase$_ {
                constructor(t) {
                    super(t);
                }
                _$Release$_() {
                    super._$Release$_();
                }
            };
        }
        {
            const d = self._$C3$_;
            d._$Behaviors$_.wrap._$Type$_ = class extends d._$SDKBehaviorTypeBase$_ {
                constructor(t) {
                    super(t);
                }
                _$Release$_() {
                    super._$Release$_();
                }
                _$OnCreate$_() {}
            };
        }
        {
            const g = self._$C3$_, h = 0, i = new g.Rect();
            g._$Behaviors$_.wrap.Instance = class extends g._$SDKBehaviorInstanceBase$_ {
                constructor(t, e) {
                    super(t), this._$_mode$_ = 0, e && (this._$_mode$_ = e[h]), 
                    this._$_StartTicking$_();
                }
                _$Release$_() {
                    super._$Release$_();
                }
                _$SaveToJson$_() {
                    return {
                        m: this._$_mode$_
                    };
                }
                _$LoadFromJson$_(t) {
                    this._$_mode$_ = t.m;
                }
                _$Tick$_() {
                    const t = this._$_inst$_._$GetWorldInfo$_(), e = t._$GetLayer$_(), s = e._$GetLayout$_(), r = t._$GetBoundingBox$_();
                    0 === this._$_mode$_ ? i.set(0, 0, s._$GetWidth$_(), s._$GetHeight$_()) : i._$copy$_(e._$GetViewport$_());
                    let n = !1;
                    r._$getRight$_() < i._$getLeft$_() ? (t._$SetX$_(i._$getRight$_() - 1 + (t._$GetX$_() - r._$getLeft$_())), 
                    t._$SetBboxChanged$_(), n = !0) : r._$getLeft$_() > i._$getRight$_() ? (t._$SetX$_(i._$getLeft$_() + 1 - (r._$getRight$_() - t._$GetX$_())), 
                    t._$SetBboxChanged$_(), n = !0) : r._$getBottom$_() < i._$getTop$_() ? (t._$SetY$_(i._$getBottom$_() - 1 + (t._$GetY$_() - r._$getTop$_())), 
                    t._$SetBboxChanged$_(), n = !0) : r._$getTop$_() > i._$getBottom$_() && (t._$SetY$_(i._$getTop$_() + 1 - (r._$getBottom$_() - t._$GetY$_())), 
                    t._$SetBboxChanged$_(), n = !0), n && this._$Trigger$_(g._$Behaviors$_.wrap._$Cnds$_._$OnWrap$_);
                }
                _$GetPropertyValueByIndex$_(t) {
                    if (t === h) return this._$_mode$_;
                }
                _$SetPropertyValueByIndex$_(t, e) {
                    t === h && (this._$_mode$_ = e);
                }
            };
        }
        {
            const v = self._$C3$_;
            v._$Behaviors$_.wrap._$Cnds$_ = {
                _$OnWrap$_() {
                    return !0;
                }
            };
        }
        {
            const w = self._$C3$_;
            w._$Behaviors$_.wrap._$Acts$_ = {};
        }
        {
            const x = self._$C3$_;
            x._$Behaviors$_.wrap._$Exps$_ = {};
        }
        {
            const a = self._$C3$_;
            a._$Behaviors$_._$Bullet$_ = class extends a._$SDKBehaviorBase$_ {
                constructor(t) {
                    super(t);
                }
                _$Release$_() {
                    super._$Release$_();
                }
            };
        }
        {
            const d = self._$C3$_;
            d._$Behaviors$_._$Bullet$_._$Type$_ = class extends d._$SDKBehaviorTypeBase$_ {
                constructor(t) {
                    super(t);
                }
                _$Release$_() {
                    super._$Release$_();
                }
                _$OnCreate$_() {}
            };
        }
        {
            const g = self._$C3$_, h = self._$C3X$_, i = self._$IBehaviorInstance$_, j = 0, k = 1, l = 2, m = 3, n = 4, o = 5, p = 6, q = (g._$Behaviors$_._$Bullet$_.Instance = class extends g._$SDKBehaviorInstanceBase$_ {
                constructor(t, e) {
                    super(t);
                    const s = this._$GetWorldInfo$_(), i = (this._$_speed$_ = 0, 
                    this._$_acc$_ = 0, this._$_g$_ = 0, this._$_bounceOffSolid$_ = !1, 
                    this._$_setAngle$_ = !1, this._$_isStepping$_ = !1, this._$_isEnabled$_ = !0, 
                    this._$_dx$_ = 0, this._$_dy$_ = 0, this._$_lastX$_ = s._$GetX$_(), 
                    this._$_lastY$_ = s._$GetY$_(), this._$_lastKnownAngle$_ = s.GetAngle(), 
                    this._$_travelled$_ = 0, this._$_stepSize$_ = Math.min(Math.abs(s._$GetWidth$_()), Math.abs(s._$GetHeight$_()) / 2), 
                    this._$_stopStepping$_ = !1, e && (this._$_speed$_ = e[j], this._$_acc$_ = e[k], 
                    this._$_g$_ = e[l], this._$_bounceOffSolid$_ = !!e[m], this._$_setAngle$_ = !!e[n], 
                    this._$_isStepping$_ = !!e[o], this._$_isEnabled$_ = !!e[p]), 
                    s.GetAngle());
                    this._$_dx$_ = Math.cos(i) * this._$_speed$_, this._$_dy$_ = Math.sin(i) * this._$_speed$_, 
                    this._$_isEnabled$_ && (this._$_StartTicking$_(), this._$_bounceOffSolid$_) && this._$_StartPostTicking$_();
                }
                _$Release$_() {
                    super._$Release$_();
                }
                _$SaveToJson$_() {
                    const t = {
                        dx: this._$_dx$_,
                        dy: this._$_dy$_,
                        lx: this._$_lastX$_,
                        ly: this._$_lastY$_,
                        lka: this._$_lastKnownAngle$_,
                        t: this._$_travelled$_
                    };
                    return 0 !== this._$_acc$_ && (t.acc = this._$_acc$_), 0 !== this._$_g$_ && (t.g = this._$_g$_), 
                    this._$_isStepping$_ && (t.st = this._$_isStepping$_), this._$_isEnabled$_ || (t.e = this._$_isEnabled$_), 
                    this._$_bounceOffSolid$_ && (t.bos = this._$_bounceOffSolid$_), 
                    this._$_setAngle$_ && (t.sa = this._$_setAngle$_), t;
                }
                _$LoadFromJson$_(t) {
                    this._$_dx$_ = t.dx, this._$_dy$_ = t.dy, this._$_lastX$_ = t.lx, 
                    this._$_lastY$_ = t.ly, this._$_lastKnownAngle$_ = t.lka, this._$_travelled$_ = t.t, 
                    this._$_acc$_ = t.hasOwnProperty("acc") ? t.acc : 0, this._$_g$_ = t.hasOwnProperty("g") ? t.g : 0, 
                    this._$_isStepping$_ = !!t.hasOwnProperty("st") && t.st, this._$_bounceOffSolid$_ = !!t.hasOwnProperty("bos") && t.bos, 
                    this._$_setAngle$_ = !!t.hasOwnProperty("sa") && t.sa, this._$_SetEnabled$_(!t.hasOwnProperty("e") || t.e);
                }
                _$Tick$_() {
                    if (this._$_isEnabled$_) {
                        const r = this._$_runtime$_._$GetDt$_(this._$_inst$_), n = this._$_inst$_._$GetWorldInfo$_();
                        if (n.GetAngle() !== this._$_lastKnownAngle$_) {
                            const t = n.GetAngle();
                            if (this._$_setAngle$_) {
                                const e = g._$distanceTo$_(0, 0, this._$_dx$_, this._$_dy$_);
                                this._$_dx$_ = Math.cos(t) * e, this._$_dy$_ = Math.sin(t) * e;
                            }
                            this._$_lastKnownAngle$_ = t;
                        }
                        let s = 0, i = 0;
                        if (0 !== this._$_acc$_) {
                            let t = g._$distanceTo$_(0, 0, this._$_dx$_, this._$_dy$_), e;
                            e = 0 === this._$_dx$_ && 0 === this._$_dy$_ ? n.GetAngle() : g._$angleTo$_(0, 0, this._$_dx$_, this._$_dy$_), 
                            t += this._$_acc$_ * r, s = Math.cos(e) * this._$_acc$_, 
                            i = Math.sin(e) * this._$_acc$_, t < 0 && (t = 0, s = 0, 
                            i = 0), this._$_dx$_ = Math.cos(e) * t, this._$_dy$_ = Math.sin(e) * t;
                        }
                        if (0 !== this._$_g$_ && (this._$_dy$_ += this._$_g$_ * r, 
                        i += this._$_g$_), this._$_lastX$_ = n._$GetX$_(), this._$_lastY$_ = n._$GetY$_(), 
                        0 !== this._$_dx$_ || 0 !== this._$_dy$_) {
                            const h = this._$_dx$_ * r + .5 * s * r * r, o = this._$_dy$_ * r + .5 * i * r * r, a = g._$distanceTo$_(0, 0, h, o);
                            if (this._$_MoveBy$_(h, o, a), this._$_travelled$_ += a, 
                            this._$_setAngle$_ && (0 != h || 0 != o)) {
                                const l = g._$angleTo$_(0, 0, h, o);
                                n._$SetAngle$_(l), this._$_lastKnownAngle$_ = n.GetAngle();
                            }
                            n._$SetBboxChanged$_();
                        }
                    }
                }
                _$_MoveBy$_(t, e, s) {
                    const i = this._$GetWorldInfo$_();
                    if (!this._$_isStepping$_ || s <= this._$_stepSize$_) i._$OffsetXY$_(t, e), 
                    i._$SetBboxChanged$_(), this._$_isStepping$_ && this._$Trigger$_(g._$Behaviors$_._$Bullet$_._$Cnds$_._$OnStep$_); else {
                        this._$_stopStepping$_ = !1;
                        const r = i._$GetX$_(), n = i._$GetY$_(), h = r + t, o = n + e, a = g._$angleTo$_(0, 0, t, e), l = Math.cos(a) * this._$_stepSize$_, u = Math.sin(a) * this._$_stepSize$_, c = Math.floor(s / this._$_stepSize$_);
                        for (let t = 1; t <= c; ++t) if (i._$SetXY$_(r + l * t, n + u * t), 
                        i._$SetBboxChanged$_(), this._$Trigger$_(g._$Behaviors$_._$Bullet$_._$Cnds$_._$OnStep$_), 
                        this._$_inst$_._$IsDestroyed$_() || this._$_stopStepping$_) return;
                        i._$SetXY$_(h, o), i._$SetBboxChanged$_(), this._$Trigger$_(g._$Behaviors$_._$Bullet$_._$Cnds$_._$OnStep$_);
                    }
                }
                _$PostTick$_() {
                    if (this._$_isEnabled$_ && this._$_bounceOffSolid$_ && (0 !== this._$_dx$_ || 0 !== this._$_dy$_)) {
                        const t = this._$_runtime$_._$GetDt$_(this._$_inst$_), e = this._$_inst$_._$GetWorldInfo$_(), s = this._$_runtime$_._$GetCollisionEngine$_(), i = s._$TestOverlapSolid$_(this._$_inst$_);
                        if (i) {
                            s._$RegisterCollision$_(this._$_inst$_, i);
                            const r = g._$distanceTo$_(0, 0, this._$_dx$_, this._$_dy$_), n = s._$CalculateBounceAngle$_(this._$_inst$_, this._$_lastX$_, this._$_lastY$_);
                            this._$_dx$_ = Math.cos(n) * r, this._$_dy$_ = Math.sin(n) * r, 
                            e._$OffsetXY$_(this._$_dx$_ * t, this._$_dy$_ * t), 
                            e._$SetBboxChanged$_(), this._$_setAngle$_ && (e._$SetAngle$_(n), 
                            this._$_lastKnownAngle$_ = e.GetAngle(), e._$SetBboxChanged$_()), 
                            s._$PushOutSolid$_(this._$_inst$_, this._$_dx$_ / r, this._$_dy$_ / r, Math.max(2.5 * r * t, 30)) || s._$PushOutSolidNearest$_(this._$_inst$_, 100);
                        }
                    }
                }
                _$GetPropertyValueByIndex$_(t) {
                    switch (t) {
                      case j:
                        return this._$_GetSpeed$_();

                      case k:
                        return this._$_GetAcceleration$_();

                      case l:
                        return this._$_GetGravity$_();

                      case n:
                        return this._$_setAngle$_;

                      case o:
                        return this._$_isStepping$_;

                      case p:
                        return this._$_IsEnabled$_();
                    }
                }
                _$SetPropertyValueByIndex$_(t, e) {
                    switch (t) {
                      case j:
                        this._$_SetSpeed$_(e);
                        break;

                      case k:
                        this._$_acc$_ = e;
                        break;

                      case l:
                        this._$_g$_ = e;
                        break;

                      case n:
                        this._$_setAngle$_ = !!e;
                        break;

                      case o:
                        this._$_isStepping$_ = !!e;
                        break;

                      case p:
                        this._$_SetEnabled$_(!!e);
                    }
                }
                _$_SetSpeed$_(t) {
                    const e = g._$angleTo$_(0, 0, this._$_dx$_, this._$_dy$_);
                    this._$_dx$_ = Math.cos(e) * t, this._$_dy$_ = Math.sin(e) * t;
                }
                _$_GetSpeed$_() {
                    return g._$roundToDp$_(g._$distanceTo$_(0, 0, this._$_dx$_, this._$_dy$_), 6);
                }
                _$_SetAcceleration$_(t) {
                    this._$_acc$_ = t;
                }
                _$_GetAcceleration$_() {
                    return this._$_acc$_;
                }
                _$_SetGravity$_(t) {
                    this._$_g$_ = t;
                }
                _$_GetGravity$_() {
                    return this._$_g$_;
                }
                _$_SetAngleOfMotion$_(t) {
                    const e = g._$distanceTo$_(0, 0, this._$_dx$_, this._$_dy$_);
                    this._$_dx$_ = Math.cos(t) * e, this._$_dy$_ = Math.sin(t) * e;
                }
                _$_GetAngleOfMotion$_() {
                    return g._$angleTo$_(0, 0, this._$_dx$_, this._$_dy$_);
                }
                _$_SetBounceOffSolids$_(t) {
                    this._$_bounceOffSolid$_ !== (t = !!t) && (this._$_bounceOffSolid$_ = t, 
                    this._$_isEnabled$_) && (this._$_bounceOffSolid$_ ? this._$_StartPostTicking$_() : this._$_StopPostTicking$_());
                }
                _$_IsBounceOffSolids$_() {
                    return this._$_bounceOffSolid$_;
                }
                _$_SetDistanceTravelled$_(t) {
                    this._$_travelled$_ = t;
                }
                _$_GetDistanceTravelled$_() {
                    return this._$_travelled$_;
                }
                _$_SetEnabled$_(t) {
                    this._$_isEnabled$_ = !!t, this._$_isEnabled$_ ? (this._$_StartTicking$_(), 
                    this._$_bounceOffSolid$_ && this._$_StartPostTicking$_()) : (this._$_StopTicking$_(), 
                    this._$_StopPostTicking$_());
                }
                _$_IsEnabled$_() {
                    return this._$_isEnabled$_;
                }
                _$GetDebuggerProperties$_() {
                    const t = "behaviors.bullet";
                    return [ {
                        title: "$" + this._$GetBehaviorType$_()._$GetName$_(),
                        properties: [ {
                            name: t + ".debugger.vector-x",
                            value: this._$_dx$_,
                            _$onedit$_: t => this._$_dx$_ = t
                        }, {
                            name: t + ".debugger.vector-y",
                            value: this._$_dy$_,
                            _$onedit$_: t => this._$_dy$_ = t
                        }, {
                            name: t + ".properties.speed.name",
                            value: this._$_GetSpeed$_(),
                            _$onedit$_: t => this._$_SetSpeed$_(t)
                        }, {
                            name: t + ".debugger.angle-of-motion",
                            value: g._$toDegrees$_(this._$_GetAngleOfMotion$_())
                        }, {
                            name: t + ".properties.gravity.name",
                            value: this._$_GetGravity$_(),
                            _$onedit$_: t => this._$_SetGravity$_(t)
                        }, {
                            name: t + ".properties.acceleration.name",
                            value: this._$_GetAcceleration$_(),
                            _$onedit$_: t => this._$_SetAcceleration$_(t)
                        }, {
                            name: t + ".debugger.distance-travelled",
                            value: this._$_GetDistanceTravelled$_()
                        }, {
                            name: t + ".properties.enabled.name",
                            value: this._$_IsEnabled$_(),
                            _$onedit$_: t => this._$_SetEnabled$_(t)
                        } ]
                    } ];
                }
                _$GetScriptInterfaceClass$_() {
                    return self._$IBulletBehaviorInstance$_;
                }
            }, new WeakMap());
            self._$IBulletBehaviorInstance$_ = class extends i {
                constructor() {
                    super(), q.set(this, i._$_GetInitInst$_()._$GetSdkInstance$_());
                }
                get speed() {
                    return q.get(this)._$_GetSpeed$_();
                }
                set speed(t) {
                    h._$RequireFiniteNumber$_(t), q.get(this)._$_SetSpeed$_(t);
                }
                get acceleration() {
                    return q.get(this)._$_GetAcceleration$_();
                }
                set acceleration(t) {
                    h._$RequireFiniteNumber$_(t), q.get(this)._$_SetAcceleration$_(t);
                }
                get _$gravity$_() {
                    return q.get(this)._$_GetGravity$_();
                }
                set _$gravity$_(t) {
                    h._$RequireFiniteNumber$_(t), q.get(this)._$_SetGravity$_(t);
                }
                get _$angleOfMotion$_() {
                    return q.get(this)._$_GetAngleOfMotion$_();
                }
                set _$angleOfMotion$_(t) {
                    h._$RequireFiniteNumber$_(t), q.get(this)._$_SetAngleOfMotion$_(t);
                }
                get _$bounceOffSolids$_() {
                    return q.get(this)._$_IsBounceOffSolids$_();
                }
                set _$bounceOffSolids$_(t) {
                    q.get(this)._$_SetBounceOffSolids$_(!!t);
                }
                get _$distanceTravelled$_() {
                    return q.get(this)._$_GetDistanceTravelled$_();
                }
                set _$distanceTravelled$_(t) {
                    h._$RequireFiniteNumber$_(t), q.get(this)._$_SetDistanceTravelled$_(t);
                }
                get isEnabled() {
                    return q.get(this)._$_IsEnabled$_();
                }
                set isEnabled(t) {
                    q.get(this)._$_SetEnabled$_(t);
                }
            };
        }
        {
            const Ca = self._$C3$_;
            Ca._$Behaviors$_._$Bullet$_._$Cnds$_ = {
                _$CompareSpeed$_(t, e) {
                    const s = Math.hypot(this._$_dx$_, this._$_dy$_);
                    return Ca.compare(s, t, e);
                },
                _$CompareTravelled$_(t, e) {
                    return Ca.compare(this._$_GetDistanceTravelled$_(), t, e);
                },
                _$OnStep$_() {
                    return !0;
                },
                _$IsEnabled$_() {
                    return this._$_IsEnabled$_();
                }
            };
        }
        {
            const Ia = self._$C3$_;
            Ia._$Behaviors$_._$Bullet$_._$Acts$_ = {
                _$SetSpeed$_(t) {
                    this._$_SetSpeed$_(t);
                },
                _$SetAcceleration$_(t) {
                    this._$_SetAcceleration$_(t);
                },
                SetGravity(t) {
                    this._$_SetGravity$_(t);
                },
                _$SetAngleOfMotion$_(t) {
                    this._$_SetAngleOfMotion$_(Ia._$toRadians$_(t));
                },
                _$Bounce$_(t) {
                    if (t) {
                        const e = t._$GetFirstPicked$_(this._$_inst$_);
                        if (e) {
                            const s = this._$_inst$_._$GetWorldInfo$_(), i = this._$_runtime$_._$GetCollisionEngine$_(), r = this._$_runtime$_._$GetDt$_(this._$_inst$_), n = Ia._$distanceTo$_(0, 0, this._$_dx$_, this._$_dy$_), h = i._$CalculateBounceAngle$_(this._$_inst$_, this._$_lastX$_, this._$_lastY$_, e);
                            this._$_dx$_ = Math.cos(h) * n, this._$_dy$_ = Math.sin(h) * n, 
                            s._$OffsetXY$_(this._$_dx$_ * r, this._$_dy$_ * r), 
                            s._$SetBboxChanged$_(), this._$_setAngle$_ && (s._$SetAngle$_(h), 
                            this._$_lastKnownAngle$_ = s.GetAngle(), s._$SetBboxChanged$_()), 
                            0 !== n && (this._$_bounceOffSolid$_ ? i._$PushOutSolid$_(this._$_inst$_, this._$_dx$_ / n, this._$_dy$_ / n, Math.max(2.5 * n * r, 30)) || i._$PushOutSolidNearest$_(this._$_inst$_, 100) : i._$PushOut$_(this._$_inst$_, this._$_dx$_ / n, this._$_dy$_ / n, Math.max(2.5 * n * r, 30), e));
                        }
                    }
                },
                _$SetBounceOffSolids$_(t) {
                    this._$_SetBounceOffSolids$_(t);
                },
                _$SetDistanceTravelled$_(t) {
                    this._$_SetDistanceTravelled$_(t);
                },
                _$SetEnabled$_(t) {
                    this._$_SetEnabled$_(t);
                },
                _$StopStepping$_() {
                    this._$_stopStepping$_ = !0;
                }
            };
        }
        {
            const Xa = self._$C3$_;
            Xa._$Behaviors$_._$Bullet$_._$Exps$_ = {
                _$Speed$_() {
                    return this._$_GetSpeed$_();
                },
                _$Acceleration$_() {
                    return this._$_GetAcceleration$_();
                },
                _$AngleOfMotion$_() {
                    return Xa._$toDegrees$_(this._$_GetAngleOfMotion$_());
                },
                _$DistanceTravelled$_() {
                    return this._$_GetDistanceTravelled$_();
                },
                _$Gravity$_() {
                    return this._$_GetGravity$_();
                }
            };
        }
        {
            const a = self._$C3$_;
            a._$Behaviors$_._$Fade$_ = class extends a._$SDKBehaviorBase$_ {
                constructor(t) {
                    super(t);
                }
                _$Release$_() {
                    super._$Release$_();
                }
            };
        }
        {
            const d = self._$C3$_;
            d._$Behaviors$_._$Fade$_._$Type$_ = class extends d._$SDKBehaviorTypeBase$_ {
                constructor(t) {
                    super(t);
                }
                _$Release$_() {
                    super._$Release$_();
                }
                _$OnCreate$_() {}
            };
        }
        {
            const g = self._$C3$_, h = self._$C3X$_, i = self._$IBehaviorInstance$_, j = 0, k = 1, l = 2, m = 3, n = 4, o = (g._$Behaviors$_._$Fade$_.Instance = class extends g._$SDKBehaviorInstanceBase$_ {
                constructor(t, e) {
                    super(t), this._$_fadeInTime$_ = 0, this._$_waitTime$_ = 0, 
                    this._$_fadeOutTime$_ = 0, this._$_destroy$_ = !0, this._$_activeAtStart$_ = !0, 
                    this._$_setMaxOpacity$_ = !1, this._$_stage$_ = 0, this._$_stageTime$_ = g._$New$_(g._$KahanSum$_), 
                    this._$_maxOpacity$_ = this._$_inst$_._$GetWorldInfo$_()._$GetOpacity$_() || 1, 
                    e && (this._$_fadeInTime$_ = e[j], this._$_waitTime$_ = e[k], 
                    this._$_fadeOutTime$_ = e[l], this._$_destroy$_ = !!e[m], this._$_activeAtStart$_ = !!e[n], 
                    this._$_stage$_ = this._$_activeAtStart$_ ? 0 : 3), this._$_activeAtStart$_ && (0 === this._$_fadeInTime$_ ? (this._$_stage$_ = 1, 
                    0 === this._$_waitTime$_ && (this._$_stage$_ = 2)) : (this._$_inst$_._$GetWorldInfo$_()._$SetOpacity$_(0), 
                    this._$_runtime$_._$UpdateRender$_())), this._$_StartTicking$_();
                }
                _$Release$_() {
                    super._$Release$_();
                }
                _$SaveToJson$_() {
                    return {
                        fit: this._$_fadeInTime$_,
                        wt: this._$_waitTime$_,
                        fot: this._$_fadeOutTime$_,
                        d: this._$_destroy$_,
                        s: this._$_stage$_,
                        st: this._$_stageTime$_._$Get$_(),
                        mo: this._$_maxOpacity$_
                    };
                }
                _$LoadFromJson$_(t) {
                    this._$_fadeInTime$_ = t.fit, this._$_waitTime$_ = t.wt, this._$_fadeOutTime$_ = t.fot, 
                    this._$_destroy$_ = t.d, this._$_stage$_ = t.s, this._$_stageTime$_.Set(t.st), 
                    this._$_maxOpacity$_ = t.mo, 3 === this._$_stage$_ ? this._$_StopTicking$_() : this._$_StartTicking$_();
                }
                _$Tick$_() {
                    const t = this._$_runtime$_._$GetDt$_(this._$_inst$_), e = (this._$_stageTime$_._$Add$_(t), 
                    this._$_inst$_._$GetWorldInfo$_());
                    0 === this._$_stage$_ && (e._$SetOpacity$_(this._$_stageTime$_._$Get$_() / this._$_fadeInTime$_ * this._$_maxOpacity$_), 
                    this._$_runtime$_._$UpdateRender$_(), e._$GetOpacity$_() >= this._$_maxOpacity$_) && (e._$SetOpacity$_(this._$_maxOpacity$_), 
                    this._$_stage$_ = 1, this._$_stageTime$_._$Reset$_(), this._$DispatchScriptEvent$_("fadeinend"), 
                    this._$Trigger$_(g._$Behaviors$_._$Fade$_._$Cnds$_._$OnFadeInEnd$_)), 
                    1 === this._$_stage$_ && this._$_stageTime$_._$Get$_() >= this._$_waitTime$_ && (this._$_stage$_ = 2, 
                    this._$_stageTime$_._$Reset$_(), this._$DispatchScriptEvent$_("waitend"), 
                    this._$Trigger$_(g._$Behaviors$_._$Fade$_._$Cnds$_._$OnWaitEnd$_)), 
                    2 === this._$_stage$_ && (0 !== this._$_fadeOutTime$_ ? (e._$SetOpacity$_(this._$_maxOpacity$_ - this._$_stageTime$_._$Get$_() / this._$_fadeOutTime$_ * this._$_maxOpacity$_), 
                    this._$_runtime$_._$UpdateRender$_(), e._$GetOpacity$_() <= 0 && (this._$_stage$_ = 3, 
                    this._$_stageTime$_._$Reset$_(), this._$DispatchScriptEvent$_("fadeoutend"), 
                    this._$Trigger$_(g._$Behaviors$_._$Fade$_._$Cnds$_._$OnFadeOutEnd$_), 
                    this._$_destroy$_) && this._$_runtime$_._$DestroyInstance$_(this._$_inst$_)) : (this._$_stage$_ = 3, 
                    this._$_stageTime$_._$Reset$_())), 3 === this._$_stage$_ && this._$_StopTicking$_();
                }
                _$_StartFade$_() {
                    this._$_activeAtStart$_ || this._$_setMaxOpacity$_ || (this._$_maxOpacity$_ = this._$_inst$_._$GetWorldInfo$_()._$GetOpacity$_() || 1, 
                    this._$_setMaxOpacity$_ = !0), 3 === this._$_stage$_ && this._$Start$_();
                }
                _$_RestartFade$_() {
                    this._$Start$_();
                }
                _$Start$_() {
                    this._$_stage$_ = 0, this._$_stageTime$_._$Reset$_(), 0 === this._$_fadeInTime$_ ? (this._$_stage$_ = 1, 
                    0 === this._$_waitTime$_ && (this._$_stage$_ = 2)) : (this._$_inst$_._$GetWorldInfo$_()._$SetOpacity$_(0), 
                    this._$_runtime$_._$UpdateRender$_()), this._$_StartTicking$_();
                }
                _$_SetFadeInTime$_(t) {
                    this._$_fadeInTime$_ = Math.max(t, 0);
                }
                _$_GetFadeInTime$_() {
                    return this._$_fadeInTime$_;
                }
                _$_SetWaitTime$_(t) {
                    this._$_waitTime$_ = Math.max(t, 0);
                }
                _$_GetWaitTime$_() {
                    return this._$_waitTime$_;
                }
                _$_SetFadeOutTime$_(t) {
                    this._$_fadeOutTime$_ = Math.max(t, 0);
                }
                _$_GetFadeOutTime$_() {
                    return this._$_fadeOutTime$_;
                }
                _$GetPropertyValueByIndex$_(t) {
                    switch (t) {
                      case j:
                        return this._$_GetFadeInTime$_();

                      case k:
                        return this._$_GetWaitTime$_();

                      case l:
                        return this._$_GetFadeOutTime$_();

                      case m:
                        return this._$_destroy$_;
                    }
                }
                _$SetPropertyValueByIndex$_(t, e) {
                    switch (t) {
                      case j:
                        this._$_SetFadeInTime$_(e);
                        break;

                      case k:
                        this._$_SetWaitTime$_(e);
                        break;

                      case l:
                        this._$_SetFadeOutTime$_(e);
                        break;

                      case m:
                        this._$_destroy$_ = !!e;
                    }
                }
                _$GetDebuggerProperties$_() {
                    const t = "behaviors.fade";
                    return [ {
                        title: "$" + this._$GetBehaviorType$_()._$GetName$_(),
                        properties: [ {
                            name: t + ".properties.fade-in-time.name",
                            value: this._$_GetFadeInTime$_(),
                            _$onedit$_: t => this._$_SetFadeInTime$_(t)
                        }, {
                            name: t + ".properties.wait-time.name",
                            value: this._$_GetWaitTime$_(),
                            _$onedit$_: t => this._$_SetWaitTime$_(t)
                        }, {
                            name: t + ".properties.fade-out-time.name",
                            value: this._$_GetFadeOutTime$_(),
                            _$onedit$_: t => this._$_SetFadeOutTime$_(t)
                        }, {
                            name: t + ".debugger.stage",
                            value: [ t + ".debugger." + [ "fade-in", "wait", "fade-out", "done" ][this._$_stage$_] ]
                        } ]
                    } ];
                }
                _$GetScriptInterfaceClass$_() {
                    return self._$IFadeBehaviorInstance$_;
                }
            }, new WeakMap());
            self._$IFadeBehaviorInstance$_ = class extends i {
                constructor() {
                    super(), o.set(this, i._$_GetInitInst$_()._$GetSdkInstance$_());
                }
                _$startFade$_() {
                    o.get(this)._$_StartFade$_();
                }
                _$restartFade$_() {
                    o.get(this)._$_RestartFade$_();
                }
                set _$fadeInTime$_(t) {
                    h._$RequireFiniteNumber$_(t), o.get(this)._$_SetFadeInTime$_(t);
                }
                get _$fadeInTime$_() {
                    return o.get(this)._$_GetFadeInTime$_();
                }
                set _$waitTime$_(t) {
                    h._$RequireFiniteNumber$_(t), o.get(this)._$_SetWaitTime$_(t);
                }
                get _$waitTime$_() {
                    return o.get(this)._$_GetWaitTime$_();
                }
                set _$fadeOutTime$_(t) {
                    h._$RequireFiniteNumber$_(t), o.get(this)._$_SetFadeOutTime$_(t);
                }
                get _$fadeOutTime$_() {
                    return o.get(this)._$_GetFadeOutTime$_();
                }
            };
        }
        {
            const J = self._$C3$_;
            J._$Behaviors$_._$Fade$_._$Cnds$_ = {
                _$OnFadeOutEnd$_() {
                    return !0;
                },
                _$OnFadeInEnd$_() {
                    return !0;
                },
                _$OnWaitEnd$_() {
                    return !0;
                }
            };
        }
        {
            const K = self._$C3$_;
            K._$Behaviors$_._$Fade$_._$Acts$_ = {
                _$StartFade$_() {
                    this._$_StartFade$_();
                },
                _$RestartFade$_() {
                    this._$_RestartFade$_();
                },
                _$SetFadeInTime$_(t) {
                    this._$_SetFadeInTime$_(t);
                },
                _$SetWaitTime$_(t) {
                    this._$_SetWaitTime$_(t);
                },
                _$SetFadeOutTime$_(t) {
                    this._$_SetFadeOutTime$_(t);
                }
            };
        }
        {
            const O = self._$C3$_;
            O._$Behaviors$_._$Fade$_._$Exps$_ = {
                _$FadeInTime$_() {
                    return this._$_GetFadeInTime$_();
                },
                _$WaitTime$_() {
                    return this._$_GetWaitTime$_();
                },
                _$FadeOutTime$_() {
                    return this._$_GetFadeOutTime$_();
                }
            };
        }
        {
            const a = self._$C3$_;
            a._$Behaviors$_._$Tween$_ = class extends a._$SDKBehaviorBase$_ {
                constructor(t) {
                    super(t);
                }
                _$Release$_() {
                    super._$Release$_();
                }
            };
        }
        {
            const d = self._$C3$_;
            d._$Behaviors$_._$Tween$_._$Type$_ = class extends d._$SDKBehaviorTypeBase$_ {
                constructor(t) {
                    super(t);
                }
                _$Release$_() {
                    super._$Release$_();
                }
                _$OnCreate$_() {}
            };
        }
        {
            const g = self._$C3$_, h = g._$Behaviors$_._$Tween$_, i = 0;
            h.Instance = class extends g._$SDKBehaviorInstanceBase$_ {
                constructor(t, e) {
                    super(t), this._$_allowMultiple$_ = !1, this._$_enabled$_ = !0, 
                    e && (this._$_allowMultiple$_ = !1, this._$_enabled$_ = !!e[i]), 
                    this._$_activeTweens$_ = new Map(), this._$_disabledTweens$_ = [], 
                    this._$_waitingForReleaseTweens$_ = new Map(), this._$_finishingTween$_ = null, 
                    this._$_activeTweensJson$_ = null, this._$_disabledTweensJson$_ = null, 
                    this._$_waitingForReleaseTweensJson$_ = null, this._$_finishingTweenName$_ = "", 
                    this._$_triggerTweens$_ = [], this._$_afterLoad$_ = t => this._$_OnAfterLoad$_(), 
                    this._$GetRuntime$_()._$Dispatcher$_().addEventListener("afterload", this._$_afterLoad$_);
                }
                _$Release$_() {
                    this._$GetRuntime$_()._$Dispatcher$_().removeEventListener("afterload", this._$_afterLoad$_), 
                    this._$_afterLoad$_ = null, this._$_finishingTween$_ && (this._$ReleaseAndCompleteTween$_(this._$_finishingTween$_), 
                    this._$_finishingTween$_ = null), this._$ReleaseAndCompleteTweens$_(), 
                    this._$_tweens$_ = null, this._$ClearDisabledList$_(), this._$_disabledTweens$_ = null, 
                    this._$_ReleaseWaitingTweens$_(), this._$_waitingForReleaseTweens$_ = null, 
                    this._$_triggerTweens$_ = null, super._$Release$_();
                }
                _$PushTriggerTween$_(t) {
                    this._$_triggerTweens$_.push(t);
                }
                _$PopTriggerTween$_() {
                    this._$_triggerTweens$_.pop();
                }
                _$GetTriggerTween$_() {
                    return this._$_triggerTweens$_[this._$_triggerTweens$_.length - 1];
                }
                _$SetEnabled$_(t) {
                    this._$_enabled$_ = !!t, t ? this._$_waitingForReleaseTweens$_ && this._$_waitingForReleaseTweens$_.size && this._$_StartTicking2$_() : this._$_StopTicking2$_();
                    for (const e of this._$AllTweens$_()) t ? this._$IsInDisabledList$_(e) && e._$Resume$_() : ((e.IsPlaying() || e._$IsScheduled$_()) && this._$AddToDisabledList$_(e), 
                    e._$Stop$_());
                    t && this._$ClearDisabledList$_();
                }
                _$IsEnabled$_() {
                    return this._$_enabled$_;
                }
                _$AddToDisabledList$_(t) {
                    this._$_disabledTweens$_.push(t);
                }
                _$IsInDisabledList$_(t) {
                    return this._$_disabledTweens$_.includes(t);
                }
                _$ClearDisabledList$_() {
                    g._$clearArray$_(this._$_disabledTweens$_);
                }
                _$GetFinishingTween$_() {
                    return this._$_finishingTween$_;
                }
                _$IsInstanceValid$_() {
                    const t = this._$GetObjectInstance$_();
                    return !!t && !t._$IsDestroyed$_();
                }
                _$GetTween$_(t, e, s = !1) {
                    const i = e ? this._$PropertyTweens$_(e, s) : this._$AllTweens$_(s);
                    if (i && i.length) for (const r of i) if (r._$HasTags$_(t)) return r;
                }
                _$CheckTweensWithTags$_(t, e) {
                    for (const s of this._$_activeTweens$_.values()) for (const i of s) if (!i._$IsReleased$_() && i._$HasTags$_(t) && e(i)) return !0;
                    for (const r of this._$_waitingForReleaseTweens$_.values()) for (const n of r) if (!n._$IsReleased$_() && n._$HasTags$_(t) && e(n)) return !0;
                    return !1;
                }
                _$CheckTweens$_(t) {
                    for (const e of this._$_activeTweens$_.values()) for (const s of e) if (!s._$IsReleased$_() && t(s)) return !0;
                    for (const i of this._$_waitingForReleaseTweens$_.values()) for (const r of i) if (!r._$IsReleased$_() && t(r)) return !0;
                    return !1;
                }
                _$GetTweenIncludingWaitingForRelease$_(t, e) {
                    return this._$GetTween$_(t, e, !0);
                }
                *_$GetTweens$_(t, e, s = !1) {
                    const i = e ? this._$PropertyTweens$_(e, s) : this._$AllTweens$_(s);
                    if (i && i.length) for (const r of i) r._$HasTags$_(t) && (yield r);
                }
                *_$GetTweensIncludingWaitingForRelease$_(t, e) {
                    yield* this._$GetTweens$_(t, e, !0);
                }
                _$PropertyTweens$_(s, t) {
                    if (t) {
                        let t = this._$_activeTweens$_.get(s), e = this._$_waitingForReleaseTweens$_.get(s);
                        return (t = t || []).concat(e || []).filter(t => t).filter(t => !t._$IsReleased$_());
                    }
                    {
                        let t = this._$_activeTweens$_.get(s);
                        return (t = t || []).filter(t => t).filter(t => !t._$IsReleased$_());
                    }
                }
                _$AllTweens$_(t) {
                    if (t) {
                        const e = [ ...this._$_activeTweens$_.values() ].flat(), s = [ ...this._$_waitingForReleaseTweens$_.values() ].flat();
                        return e.concat(s).filter(t => t).filter(t => !t._$IsReleased$_());
                    }
                    {
                        const i = [ ...this._$_activeTweens$_.values() ].flat();
                        return i.filter(t => t).filter(t => !t._$IsReleased$_());
                    }
                }
                _$AllTweensIncludingWaitingForRelease$_() {
                    return this._$AllTweens$_(!0);
                }
                _$SaveToJson$_(t = 0) {
                    return {
                        s: !1,
                        e: !!this._$_enabled$_,
                        at: this._$_SaveActiveTweensToJson$_(),
                        dt: this._$_SaveDisabledTweensToJson$_(),
                        wt: this._$_SaveWaitingForReleaseTweensToJson$_(),
                        ft: this._$_SaveFinishingTweenToJson$_()
                    };
                }
                _$LoadFromJson$_(t, e = "full") {
                    t && (this._$_activeTweensJson$_ = t.at, this._$_disabledTweensJson$_ = t.dt, 
                    this._$_waitingForReleaseTweensJson$_ = t.wt, this._$_finishingTweenName$_ = t.ft, 
                    this._$_allowMultiple$_ = !1, this._$_enabled$_ = !!t.e, "state" === e) && this._$_OnAfterLoad$_();
                }
                _$_OnAfterLoad$_() {
                    const t = this._$GetRuntime$_()._$GetTimelineManager$_();
                    if (this._$_PopulateTweenMap$_(this._$_activeTweensJson$_, this._$_activeTweens$_, t), 
                    this._$_disabledTweensJson$_) {
                        g._$clearArray$_(this._$_disabledTweens$_);
                        for (const e of this._$_disabledTweensJson$_) this._$_PopulateTweenArray$_(this._$_disabledTweens$_, e, t);
                    }
                    this._$_PopulateTweenMap$_(this._$_waitingForReleaseTweensJson$_, this._$_waitingForReleaseTweens$_, t), 
                    this._$_finishingTween$_ = this._$_GetTween$_(this._$_finishingTweenName$_, t), 
                    this._$_enabled$_ ? this._$_waitingForReleaseTweens$_ && this._$_waitingForReleaseTweens$_.size && this._$_StartTicking2$_() : this._$_StopTicking2$_();
                }
                _$_PopulateTweenMap$_(e, s, i) {
                    if (e) for (const r in e) {
                        let t = s.get(r);
                        t ? g._$clearArray$_(t) : t = [];
                        const n = e[r];
                        for (const h of n) {
                            const o = this._$_PopulateTweenArray$_(t, h.name, i);
                            if (o) this._$_LoadTweenFromJson$_(h.name, h, i); else {
                                const a = g._$TweenState$_._$Build$_({
                                    runtime: this._$GetRuntime$_(),
                                    json: h
                                });
                                g._$TweenState$_._$SetInstanceUID$_(a, this._$GetObjectInstance$_()._$GetUID$_()), 
                                a._$AddCompletedCallback$_(t => this._$_FinishTriggers$_(t)), 
                                i._$AddScheduledTimeline$_(a), this._$_PopulateTweenArray$_(t, a, i);
                            }
                        }
                        s.set(r, t);
                    }
                }
                _$_GetTween$_(t, e) {
                    return e._$GetScheduledOrPlayingTimelineByName$_(t);
                }
                _$_PopulateTweenArray$_(t, e, s) {
                    if ("string" != typeof e) return !!t.push(e);
                    {
                        const i = this._$_GetTween$_(e, s);
                        if (i) return !!t.push(i);
                    }
                    return !1;
                }
                _$_LoadTweenFromJson$_(t, e, s) {
                    if ("string" == typeof t) {
                        const i = this._$_GetTween$_(t, s);
                        i && (i._$_LoadFromJson$_(e), g._$TweenState$_._$SetInstanceUID$_(i, this._$GetObjectInstance$_()._$GetUID$_()));
                    } else t._$_LoadFromJson$_(e), g._$TweenState$_._$SetInstanceUID$_(t, this._$GetObjectInstance$_()._$GetUID$_());
                }
                _$_SaveActiveTweensToJson$_() {
                    const t = {};
                    for (const [ e, s ] of this._$_activeTweens$_) t[e] = s.filter(t => !t._$IsReleased$_()).map(t => t._$_SaveToJson$_());
                    return t;
                }
                _$_SaveDisabledTweensToJson$_() {
                    return this._$_disabledTweens$_.filter(t => !t._$IsReleased$_()).map(t => t._$GetName$_());
                }
                _$_SaveWaitingForReleaseTweensToJson$_() {
                    const t = {};
                    for (const [ e, s ] of this._$_waitingForReleaseTweens$_) t[e] = s.map(t => t._$_SaveToJson$_());
                    return t;
                }
                _$_SaveFinishingTweenToJson$_() {
                    return this._$_finishingTween$_ ? this._$_finishingTween$_._$GetName$_() : "";
                }
                _$Tick2$_() {
                    this._$_ReleaseWaitingTweens$_();
                }
                _$CreateTween$_(t) {
                    const e = h._$Config$_._$GetPropertyTracksConfig$_(t.property, t._$startValue$_, t._$endValue$_, t.ease, t.resultMode, this._$GetObjectInstance$_()), s = h._$Maps$_._$GetPropertyFromIndex$_(t.property), i = (h._$Maps$_._$IsValueId$_(s) || this._$ReleaseTweens$_(t.property), 
                    g._$TweenState$_._$Build$_({
                        runtime: this._$GetRuntime$_(),
                        id: s,
                        tags: t.tags,
                        time: t.time,
                        instance: this._$GetObjectInstance$_(),
                        _$releaseOnComplete$_: !!t._$releaseOnComplete$_,
                        loop: !!t.loop,
                        pingPong: !!t.pingPong,
                        repeatCount: t.repeatCount,
                        initialValueMode: t.initialValueMode,
                        _$propertyTracksConfig$_: e
                    }));
                    return i._$AddCompletedCallback$_(t => this._$_FinishTriggers$_(t)), 
                    this._$_AddTween$_(i, t.property), i;
                }
                _$_MaybeRemoveFromActiveTweenMap$_(t) {
                    const e = t._$GetId$_();
                    if (this._$_activeTweens$_.has(e)) {
                        const s = this._$_activeTweens$_.get(e);
                        if (s) {
                            const i = s.indexOf(t);
                            -1 !== i && s.splice(i, 1);
                        }
                    }
                }
                _$ReleaseTween$_(t, e = !1) {
                    this._$_MaybeRemoveFromActiveTweenMap$_(t), t._$IsReleased$_() || this._$_IsInWaitingList$_(t) || (t._$Stop$_(e), 
                    this._$_AddToWaitingList$_(t));
                }
                _$ReleaseTweens$_(t, e = !1) {
                    if (g._$IsFiniteNumber$_(t)) {
                        const s = h._$Maps$_._$GetPropertyFromIndex$_(t);
                        if (this._$_activeTweens$_.has(s)) {
                            const i = this._$_activeTweens$_.get(s), r = this._$GetFinishingTween$_();
                            for (const n of i) n === r || n._$IsReleased$_() || this._$_IsInWaitingList$_(n) || (n._$Stop$_(e), 
                            n._$Release$_());
                            g._$clearArray$_(i);
                        }
                    } else {
                        const o = this._$GetFinishingTween$_();
                        for (const a of this._$AllTweens$_()) a === o || a._$IsReleased$_() || this._$_IsInWaitingList$_(a) || (a._$Stop$_(e), 
                        a._$Release$_());
                        for (const l of this._$_activeTweens$_.keys()) g._$clearArray$_(this._$_activeTweens$_.get(l)), 
                        this._$_activeTweens$_.delete(l);
                        this._$_activeTweens$_.clear();
                    }
                }
                _$ReleaseAndCompleteTween$_(t) {
                    this._$ReleaseTween$_(t, !0);
                }
                _$ReleaseAndCompleteTweens$_() {
                    this._$ReleaseTweens$_(NaN, !0);
                }
                _$GetPropertyValueByIndex$_(t) {
                    if (t === i) return this._$_enabled$_;
                }
                _$SetPropertyValueByIndex$_(t, e) {
                    t === i && (this._$_enabled$_ = !!e);
                }
                _$_GetBehaviorType$_(t) {
                    const e = t._$GetInstance$_(), s = e._$GetBehaviorInstances$_();
                    for (const i of s) {
                        const r = i._$GetBehaviorType$_();
                        if (r._$GetInstanceSdkCtor$_() === this.constructor) return r;
                    }
                }
                _$Trigger$_(t, e, s, i) {
                    return this._$_runtime$_ ? super._$Trigger$_(t) : e._$Trigger$_(t, s, i);
                }
                _$_FinishTriggers$_(t) {
                    this._$_finishingTween$_ = t, h._$Cnds$_._$SetFinishingTween$_(t);
                    let e, s;
                    if (this._$GetRuntime$_()) e = this._$_inst$_, s = this._$_runtime$_, 
                    this._$Trigger$_(h._$Cnds$_._$OnTweensFinished$_), this._$Trigger$_(h._$Cnds$_._$OnAnyTweensFinished$_), 
                    this._$ReleaseTween$_(t); else {
                        if (!(e = t._$GetInstance$_())) return;
                        if (e && e._$IsDestroyed$_()) return;
                        s = e._$GetRuntime$_();
                        const i = this._$_GetBehaviorType$_(t);
                        this._$Trigger$_(h._$Cnds$_._$OnTweensFinished$_, s, e, i), 
                        this._$Trigger$_(h._$Cnds$_._$OnAnyTweensFinished$_, s, e, i), 
                        t._$Stop$_();
                    }
                    this._$_finishingTween$_ = null, h._$Cnds$_._$SetFinishingTween$_(null), 
                    t._$GetDestroyInstanceOnComplete$_() && s._$DestroyInstance$_(e);
                }
                _$_AddTween$_(t, e) {
                    const s = h._$Maps$_._$GetPropertyFromIndex$_(e), i = (this._$_activeTweens$_.has(s) || this._$_activeTweens$_.set(s, []), 
                    this._$_activeTweens$_.get(s));
                    i.push(t);
                }
                _$_AddToWaitingList$_(t) {
                    const e = t._$GetId$_();
                    this._$_waitingForReleaseTweens$_.has(e) || this._$_waitingForReleaseTweens$_.set(e, []), 
                    this._$_waitingForReleaseTweens$_.get(e).push(t), this._$IsTicking2$_() || this._$_StartTicking2$_();
                }
                _$_IsInWaitingList$_(t) {
                    const e = t._$GetId$_();
                    return !!this._$_waitingForReleaseTweens$_.has(e) && this._$_waitingForReleaseTweens$_.get(e).includes(t);
                }
                _$_ReleaseWaitingTweens$_() {
                    if (this._$_waitingForReleaseTweens$_.size) {
                        for (const t of this._$_waitingForReleaseTweens$_.values()) {
                            for (const e of t) e._$IsReleased$_() || e._$Release$_();
                            g._$clearArray$_(t);
                        }
                        this._$_waitingForReleaseTweens$_.clear(), this._$IsTicking2$_() && this._$_StopTicking2$_();
                    }
                }
                _$GetDebuggerProperties$_() {
                    return [ {
                        title: "$" + this._$GetBehaviorType$_()._$GetName$_(),
                        properties: [ {
                            name: "behaviors.tween.properties.enabled.name",
                            value: this._$IsEnabled$_(),
                            _$onedit$_: t => this._$SetEnabled$_(t)
                        } ]
                    } ];
                }
                _$GetScriptInterfaceClass$_() {
                    return self._$ITweenBehaviorInstance$_;
                }
            };
        }
        {
            let M0 = self._$C3$_, s = null;
            M0._$Behaviors$_._$Tween$_._$Cnds$_ = {
                _$OnAnyTweenLoop$_() {
                    return !0;
                },
                _$OnTweensLoop$_(t) {
                    const e = this._$GetTriggerTween$_();
                    return !!e && e._$HasTags$_(t);
                },
                _$OnAnyTweenPingPong$_(t) {
                    const e = this._$GetTriggerTween$_();
                    return !!e && (e._$GetPingPongState$_() === t || 2 === t);
                },
                _$OnTweensPingPong$_(t, e) {
                    const s = this._$GetTriggerTween$_();
                    return !!s && (s._$GetPingPongState$_() === e || 2 === e) && s._$HasTags$_(t);
                },
                _$SetFinishingTween$_(t) {
                    s = t;
                },
                _$OnTweensFinished$_(t) {
                    return s._$HasTags$_(t);
                },
                _$OnAnyTweensFinished$_() {
                    return !0;
                },
                IsPlaying(t) {
                    return this._$CheckTweensWithTags$_(t, M0._$TweenState$_.IsPlaying);
                },
                _$IsAnyPlaying$_() {
                    return this._$CheckTweens$_(M0._$TweenState$_.IsPlaying);
                },
                _$IsPaused$_(t) {
                    return this._$CheckTweensWithTags$_(t, M0._$TweenState$_._$IsPaused$_);
                },
                _$IsAnyPaused$_() {
                    return this._$CheckTweens$_(M0._$TweenState$_._$IsPaused$_);
                },
                _$IsPingPong$_(t, e) {
                    return 0 === e ? this._$CheckTweensWithTags$_(t, M0._$TweenState$_._$IsPing$_) : 1 === e && this._$CheckTweensWithTags$_(t, M0._$TweenState$_._$IsPong$_);
                },
                _$IsAnyPingPong$_(t) {
                    return 0 === t ? this._$CheckTweens$_(M0._$TweenState$_._$IsPing$_) : 1 === t && this._$CheckTweens$_(M0._$TweenState$_._$IsPong$_);
                }
            };
        }
        {
            const ab = self._$C3$_, bb = self._$Ease$_, cb = ab._$Behaviors$_._$Tween$_;
            cb._$Acts$_ = {
                _$SetEnabled$_(t) {
                    this._$SetEnabled$_(!!t);
                },
                async _$TweenOneProperty$_(...t) {
                    if (this._$IsEnabled$_() && this._$IsInstanceValid$_()) {
                        const e = this._$CreateTween$_(cb._$TweenArguments$_._$OneProperty$_(this, ...t));
                        e.Play() && await e._$GetPlayPromise$_();
                    }
                },
                async _$TweenTwoProperties$_(...t) {
                    if (this._$IsEnabled$_() && this._$IsInstanceValid$_()) {
                        const e = this._$CreateTween$_(cb._$TweenArguments$_._$TwoProperties$_(this, ...t));
                        e.Play() && await e._$GetPlayPromise$_();
                    }
                },
                async _$TweenValue$_(...t) {
                    if (this._$IsEnabled$_() && this._$IsInstanceValid$_()) {
                        const e = this._$CreateTween$_(cb._$TweenArguments$_._$ValueProperty$_(this, ...t));
                        e.Play() && await e._$GetPlayPromise$_();
                    }
                },
                _$PauseTweens$_(t) {
                    if (this._$IsEnabled$_() && this._$IsInstanceValid$_()) for (const e of this._$GetTweens$_(t)) e._$Stop$_();
                },
                _$PauseAllTweens$_() {
                    if (this._$IsEnabled$_() && this._$IsInstanceValid$_()) for (const t of this._$AllTweens$_()) t._$Stop$_();
                },
                _$ResumeTweens$_(t) {
                    if (this._$IsEnabled$_() && this._$IsInstanceValid$_()) for (const e of this._$GetTweens$_(t)) e._$Resume$_();
                },
                _$ResumeAllTweens$_() {
                    if (this._$IsEnabled$_() && this._$IsInstanceValid$_()) for (const t of this._$AllTweens$_()) t._$Resume$_();
                },
                _$StopTweens$_(t) {
                    if (this._$IsEnabled$_() && this._$IsInstanceValid$_()) for (const e of this._$GetTweens$_(t)) this._$ReleaseTween$_(e);
                },
                _$StopAllTweens$_() {
                    if (this._$IsEnabled$_() && this._$IsInstanceValid$_()) for (const t of this._$AllTweens$_()) this._$ReleaseTween$_(t);
                },
                _$SetOnePropertyTweensEndValue$_(t, e, s) {
                    if (this._$IsEnabled$_() && this._$IsInstanceValid$_()) {
                        const i = ab._$Behaviors$_._$Tween$_._$Maps$_._$GetSinglePropertyFromIndex$_(e);
                        for (const r of this._$GetTweens$_(t)) r._$BeforeSetEndValues$_([ i ]), 
                        r._$SetEndValue$_(s, i);
                    }
                },
                _$SetTwoPropertiesTweensEndValue$_(t, e, s, i) {
                    if (this._$IsEnabled$_() && this._$IsInstanceValid$_()) {
                        const r = ab._$Behaviors$_._$Tween$_._$Maps$_._$GetRealProperties$_(e);
                        for (const n of this._$GetTweens$_(t)) n._$BeforeSetEndValues$_(r), 
                        n._$SetEndValue$_(s, r[0]), n._$SetEndValue$_(i, r[1]);
                    }
                },
                _$SetValuePropertyTweensStartValue$_(t, e) {
                    if (this._$IsEnabled$_() && this._$IsInstanceValid$_()) for (const s of this._$GetTweens$_(t, "value")) s._$SetStartValue$_(e, "value");
                },
                _$SetValuePropertyTweensEndValue$_(t, e) {
                    if (this._$IsEnabled$_() && this._$IsInstanceValid$_()) for (const s of this._$GetTweens$_(t, "value")) s._$BeforeSetEndValues$_([ "value" ]), 
                    s._$SetEndValue$_(e, "value");
                },
                _$SetTweensEase$_(t, e) {
                    if (this._$IsEnabled$_() && this._$IsInstanceValid$_()) {
                        const s = bb._$GetEaseFromIndex$_(e);
                        for (const i of this._$GetTweens$_(t)) i._$SetEase$_(s);
                    }
                },
                _$SetAllTweensEase$_(t) {
                    if (this._$IsEnabled$_() && this._$IsInstanceValid$_()) {
                        const e = bb._$GetEaseFromIndex$_(t);
                        for (const s of this._$AllTweens$_()) s._$SetEase$_(e);
                    }
                },
                _$SetTweensTime$_(t, e) {
                    if (this._$IsEnabled$_() && this._$IsInstanceValid$_()) for (const s of this._$GetTweens$_(t)) s._$SetTime$_(e);
                },
                _$SetAllTweensTime$_(t) {
                    if (this._$IsEnabled$_() && this._$IsInstanceValid$_()) for (const e of this._$AllTweens$_()) e._$SetTime$_(t);
                },
                _$SetTweensPlaybackRate$_(t, e) {
                    if (this._$IsEnabled$_() && this._$IsInstanceValid$_()) for (const s of this._$GetTweens$_(t)) s._$SetPlaybackRate$_(e);
                },
                _$SetAllTweensPlaybackRate$_(t) {
                    if (this._$IsEnabled$_() && this._$IsInstanceValid$_()) for (const e of this._$AllTweens$_()) e._$SetPlaybackRate$_(t);
                },
                _$SetTweensDestroyOnComplete$_(t, e) {
                    if (this._$IsEnabled$_() && this._$IsInstanceValid$_()) for (const s of this._$GetTweens$_(t)) s._$SetDestroyInstanceOnComplete$_(!!e);
                },
                _$SetAllTweensDestroyOnComplete$_(t) {
                    if (this._$IsEnabled$_() && this._$IsInstanceValid$_()) for (const e of this._$AllTweens$_()) e._$SetDestroyInstanceOnComplete$_(!!t);
                }
            };
        }
        {
            const e1 = self._$C3$_;
            e1._$Behaviors$_._$Tween$_._$Exps$_ = {
                _$Time$_(t) {
                    const e = this._$GetTweenIncludingWaitingForRelease$_(t);
                    return e ? e._$GetTime$_() : 0;
                },
                _$Progress$_(t) {
                    const e = this._$GetTweenIncludingWaitingForRelease$_(t);
                    return e ? e._$GetTime$_() / e._$GetTotalTime$_() : 0;
                },
                _$PlaybackRate$_(t) {
                    const e = this._$GetTweenIncludingWaitingForRelease$_(t);
                    return e ? e._$GetPlaybackRate$_() : 0;
                },
                _$Value$_(t) {
                    const e = this._$GetTweenIncludingWaitingForRelease$_(t, "value");
                    return e ? e._$GetPropertyTrack$_("value")._$GetSourceAdapterValue$_() : 0;
                },
                _$Tags$_() {
                    let t = this._$GetFinishingTween$_();
                    return (t = t || this._$GetTriggerTween$_()) ? t._$GetStringTags$_() : "";
                }
            };
        }
        {
            const C33 = self._$C3$_, Ease = self._$Ease$_, PAIR_PROPERTIES = [ "position", "size", "scale" ], SINGLE_PROPERTIES = [ "offsetX", "offsetY", "offsetWidth", "offsetHeight", "offsetAngle", "offsetOpacity", "offsetColor", "offsetZElevation", "offsetScaleX", "offsetScaleY" ], VALUE_PROPERTIES = [ "value" ], PROPERTY_INDEX_TO_NAME = [].concat(PAIR_PROPERTIES).concat(SINGLE_PROPERTIES).concat(VALUE_PROPERTIES), PROPERTY_PAIR_TO_REAL_PROPERTIES = {
                position: [ "offsetX", "offsetY" ],
                size: [ "offsetWidth", "offsetHeight" ],
                scale: [ "offsetScaleX", "offsetScaleY" ]
            }, ALL_REAL_PROPERTIES = Object.assign({}, PROPERTY_INDEX_TO_NAME.reduce((t, e) => Object.assign({}, t, {
                [e]: [ e ]
            }), {}), PROPERTY_PAIR_TO_REAL_PROPERTIES);
            C33._$Behaviors$_._$Tween$_._$Maps$_ = class {
                constructor() {}
                static _$GetEases$_() {
                    return [ ...Ease._$GetRuntimeEaseNames$_() ];
                }
                static _$GetEaseFromIndex$_(t) {
                    return [ ...Ease._$GetRuntimeEaseNames$_() ][t];
                }
                static _$GetPropertyFromIndex$_(t) {
                    return PROPERTY_INDEX_TO_NAME[t];
                }
                static _$GetPropertyIndexFromName$_(t) {
                    return PROPERTY_INDEX_TO_NAME.indexOf(t);
                }
                static _$GetPairPropertyFromIndex$_(t) {
                    return PAIR_PROPERTIES[t];
                }
                static _$GetSinglePropertyFromIndex$_(t) {
                    return SINGLE_PROPERTIES[t];
                }
                static _$GetValuePropertyFromIndex$_(t) {
                    return VALUE_PROPERTIES[t];
                }
                static _$GetPairProperties$_(t) {
                    return PROPERTY_PAIR_TO_REAL_PROPERTIES[t];
                }
                static _$GetRealProperties$_(t) {
                    return C33._$IsString$_(t) ? ALL_REAL_PROPERTIES[t] : ALL_REAL_PROPERTIES[PROPERTY_INDEX_TO_NAME[t]];
                }
                static _$IsPairId$_(t) {
                    return !!PROPERTY_PAIR_TO_REAL_PROPERTIES[t];
                }
                static _$IsColorId$_(t) {
                    return "offsetColor" === t;
                }
                static _$IsAngleId$_(t) {
                    return "offsetAngle" === t;
                }
                static _$IsOpacityId$_(t) {
                    return "offsetOpacity" === t;
                }
                static _$IsValueId$_(t) {
                    return "value" === t;
                }
            };
        }
        {
            const C33 = self._$C3$_, NAMESPACE = C33._$Behaviors$_._$Tween$_, TWEEN_CONFIGURATIONS = new Map();
            NAMESPACE._$Config$_ = class {
                constructor() {}
                static _$GetPropertyTracksConfig$_(t, e, s, i, r, n) {
                    0 === TWEEN_CONFIGURATIONS.size && this._$_CreateConfigObjects$_();
                    let h = NAMESPACE._$PropertyTypes$_._$Pick$_(t), o = TWEEN_CONFIGURATIONS.get(h);
                    return C33._$IsFiniteNumber$_(t) && (t = NAMESPACE._$Maps$_._$GetPropertyFromIndex$_(t)), 
                    this._$_GetConfig$_(o, t, e, s, i, r, n);
                }
                static _$TransformValue$_(t, e) {
                    const s = C33._$Behaviors$_._$Tween$_._$GetPropertyTracksConfig$_(t);
                    return s._$valueGetter$_(e);
                }
                static _$_CreateConfigObjects$_() {
                    const t = NAMESPACE._$PropertyTypes$_, e = NAMESPACE._$ValueGetters$_;
                    this._$_AddConfigObject$_(t._$PAIR$_, this._$_GetPairConfig$_, e._$_GetPropertyValue$_), 
                    this._$_AddConfigObject$_(t.COLOR, this._$_GetColorConfig$_, e._$_GetColorPropertyValue$_), 
                    this._$_AddConfigObject$_(t._$ANGLE$_, this._$_GetAngleConfig$_, e._$_GetPropertyAngleValue$_), 
                    this._$_AddConfigObject$_(t._$VALUE$_, this._$_GetValueConfig$_, e._$_GetPropertyValue$_), 
                    this._$_AddConfigObject$_(t._$OTHER$_, this._$_GetCommonConfig$_, e._$_GetPropertyValue$_);
                }
                static _$_AddConfigObject$_(t, e, s) {
                    TWEEN_CONFIGURATIONS.set(t, this._$_CreateConfigObject$_(t, e, s));
                }
                static _$_CreateConfigObject$_(t, e, s) {
                    return {
                        name: t,
                        _$configFunc$_: e,
                        _$valueGetter$_: s
                    };
                }
                static _$_GetConfig$_(t, e, s, i, r, n, h) {
                    return t._$configFunc$_(e, t._$valueGetter$_(s), t._$valueGetter$_(i), r, n, h);
                }
                static _$_GetPairConfig$_(t, s, i, r, n, e) {
                    const h = NAMESPACE._$Maps$_._$GetPairProperties$_(t);
                    return h.map((t, e) => ({
                        _$sourceId$_: "world-instance",
                        property: t,
                        type: "float",
                        valueType: "numeric",
                        _$startValue$_: s[e],
                        _$endValue$_: i[e],
                        ease: NAMESPACE._$Maps$_._$GetEaseFromIndex$_(r),
                        resultMode: n
                    }));
                }
                static _$_GetColorConfig$_(t, e, s, i, r, n) {
                    return C33._$Plugins$_.Text && n._$GetPlugin$_() instanceof C33._$Plugins$_.Text ? {
                        _$sourceId$_: "plugin",
                        _$sourceArgs$_: [ 7 ],
                        property: "color",
                        type: "color",
                        valueType: "color",
                        _$startValue$_: e,
                        _$endValue$_: s,
                        ease: NAMESPACE._$Maps$_._$GetEaseFromIndex$_(i),
                        resultMode: r
                    } : {
                        _$sourceId$_: "world-instance",
                        property: t,
                        type: "color",
                        valueType: "color",
                        _$startValue$_: e,
                        _$endValue$_: s,
                        ease: NAMESPACE._$Maps$_._$GetEaseFromIndex$_(i),
                        resultMode: r
                    };
                }
                static _$_GetAngleConfig$_(t, e, s, i, r, n) {
                    return {
                        _$sourceId$_: "world-instance",
                        property: t,
                        type: "angle",
                        valueType: "angle",
                        _$startValue$_: e,
                        _$endValue$_: s,
                        ease: NAMESPACE._$Maps$_._$GetEaseFromIndex$_(i),
                        resultMode: r
                    };
                }
                static _$_GetCommonConfig$_(t, e, s, i, r, n) {
                    return {
                        _$sourceId$_: "world-instance",
                        property: t,
                        type: "float",
                        valueType: "numeric",
                        _$startValue$_: e,
                        _$endValue$_: s,
                        ease: NAMESPACE._$Maps$_._$GetEaseFromIndex$_(i),
                        resultMode: r
                    };
                }
                static _$_GetValueConfig$_(t, e, s, i, r, n) {
                    return {
                        _$sourceId$_: "value",
                        property: t,
                        type: "float",
                        valueType: "numeric",
                        _$startValue$_: e,
                        _$endValue$_: s,
                        ease: NAMESPACE._$Maps$_._$GetEaseFromIndex$_(i),
                        resultMode: r
                    };
                }
            };
        }
        {
            const C33 = self._$C3$_, NAMESPACE = C33._$Behaviors$_._$Tween$_, COMMON_FIXED_ARGS = {
                resultMode: "absolute"
            }, COMMON_VARIABLE_ARGS = Object.assign({}, COMMON_FIXED_ARGS, {
                tags: "",
                property: "",
                time: 0,
                ease: 0,
                _$releaseOnComplete$_: 0,
                loop: !1,
                pingPong: !1,
                repeatCount: 1
            }), ONE_PROPERTY_ARGS = Object.assign({}, COMMON_VARIABLE_ARGS, {
                initialValueMode: "current-state",
                _$startValue$_: 0,
                _$endValue$_: 0
            }), TWO_PROPERTIES_ARGS = Object.assign({}, COMMON_VARIABLE_ARGS, {
                initialValueMode: "current-state",
                _$startValue$_: [ 0, 0 ],
                _$endValue$_: [ 0, 0 ]
            }), COLOR_PROPERTY_ARGS = Object.assign({}, COMMON_VARIABLE_ARGS, {
                initialValueMode: "current-state",
                _$startValue$_: [ 0, 0, 0 ],
                _$endValue$_: [ 0, 0, 0 ]
            }), VALUE_PROPERTY_ARGS = Object.assign({}, ONE_PROPERTY_ARGS, {
                initialValueMode: "start-value"
            }), X = 0, Y = 1, R = 0, G = 1, B = 2;
            NAMESPACE._$TweenArguments$_ = class {
                constructor() {}
                static _$_SetCommonProperties$_(t, e, s, i, r, n, h, o) {
                    t.tags = e, t.time = s, t.ease = i, t._$releaseOnComplete$_ = r, 
                    t.loop = n, t.pingPong = h, t.repeatCount = o;
                }
                static _$OneProperty$_(t, e, s, i, r, n, h, o, a, l) {
                    const u = "string" == typeof s ? s : NAMESPACE._$Maps$_._$GetSinglePropertyFromIndex$_(s), c = NAMESPACE._$Maps$_._$IsColorId$_(u) ? COLOR_PROPERTY_ARGS : ONE_PROPERTY_ARGS;
                    return this._$_SetCommonProperties$_(c, e, r, n, h, o, a, l), 
                    NAMESPACE._$Maps$_._$IsColorId$_(u) ? (COLOR_PROPERTY_ARGS._$endValue$_[R] = C33._$GetRValue$_(i), 
                    COLOR_PROPERTY_ARGS._$endValue$_[G] = C33._$GetGValue$_(i), 
                    COLOR_PROPERTY_ARGS._$endValue$_[B] = C33._$GetBValue$_(i), 
                    COLOR_PROPERTY_ARGS.property = NAMESPACE._$Maps$_._$GetPropertyIndexFromName$_(u)) : NAMESPACE._$Maps$_._$IsOpacityId$_(u) ? ONE_PROPERTY_ARGS._$endValue$_ = i / 100 : ONE_PROPERTY_ARGS._$endValue$_ = i, 
                    c.property = NAMESPACE._$Maps$_._$GetPropertyIndexFromName$_(u), 
                    c;
                }
                static _$TwoProperties$_(t, e, s, i, r, n, h, o, a, l, u) {
                    this._$_SetCommonProperties$_(TWO_PROPERTIES_ARGS, e, n, h, o, a, l, u);
                    const c = "string" == typeof s ? s : NAMESPACE._$Maps$_._$GetPairPropertyFromIndex$_(s);
                    return TWO_PROPERTIES_ARGS._$endValue$_[X] = i, TWO_PROPERTIES_ARGS._$endValue$_[Y] = r, 
                    TWO_PROPERTIES_ARGS.property = NAMESPACE._$Maps$_._$GetPropertyIndexFromName$_(c), 
                    TWO_PROPERTIES_ARGS;
                }
                static _$ValueProperty$_(t, e, s, i, r, n, h, o, a, l) {
                    return this._$_SetCommonProperties$_(VALUE_PROPERTY_ARGS, e, r, n, h, o, a, l), 
                    VALUE_PROPERTY_ARGS._$startValue$_ = s, VALUE_PROPERTY_ARGS._$endValue$_ = i, 
                    VALUE_PROPERTY_ARGS.property = NAMESPACE._$Maps$_._$GetPropertyIndexFromName$_("value"), 
                    VALUE_PROPERTY_ARGS;
                }
            };
        }
        {
            const C33 = self._$C3$_, NAMESPACE = C33._$Behaviors$_._$Tween$_, TYPE_CHECK_OBJECTS = [];
            NAMESPACE._$PropertyTypes$_ = class {
                constructor() {}
                static _$Pick$_(t) {
                    if (0 === TYPE_CHECK_OBJECTS.length) {
                        const e = TYPE_CHECK_OBJECTS;
                        e.push({
                            _$checkFunc$_: NAMESPACE._$Maps$_._$IsPairId$_,
                            result: this._$PAIR$_
                        }), e.push({
                            _$checkFunc$_: NAMESPACE._$Maps$_._$IsColorId$_,
                            result: this.COLOR
                        }), e.push({
                            _$checkFunc$_: NAMESPACE._$Maps$_._$IsAngleId$_,
                            result: this._$ANGLE$_
                        }), e.push({
                            _$checkFunc$_: NAMESPACE._$Maps$_._$IsValueId$_,
                            result: this._$VALUE$_
                        }), e.push({
                            _$checkFunc$_: () => !0,
                            result: this._$OTHER$_
                        });
                    }
                    C33._$IsFiniteNumber$_(t) && (t = C33._$Behaviors$_._$Tween$_._$Maps$_._$GetPropertyFromIndex$_(t));
                    for (const s of TYPE_CHECK_OBJECTS) if (s._$checkFunc$_(t)) return s.result;
                }
                static get _$PAIR$_() {
                    return "pair";
                }
                static get COLOR() {
                    return "color";
                }
                static get _$ANGLE$_() {
                    return "angle";
                }
                static get _$VALUE$_() {
                    return "value";
                }
                static get _$OTHER$_() {
                    return "other";
                }
            };
        }
        {
            const C33 = self._$C3$_, NAMESPACE = C33._$Behaviors$_._$Tween$_;
            NAMESPACE._$ValueGetters$_ = class {
                constructor() {}
                static _$_GetPropertyAngleValue$_(t) {
                    const e = C33._$toRadians$_(parseFloat(t));
                    return C33._$clampAngle$_(e);
                }
                static _$_GetColorPropertyValue$_(t) {
                    return t.slice(0);
                }
                static _$_GetPropertyValue$_(t) {
                    return t;
                }
            };
        }
        {
            let getIndexForEase2 = function(t) {
                C3X._$RequireString$_(t);
                let e = Ease._$ToInternal$_(t), s;
                if (-1 === (s = e ? Ease._$GetIndexForEase$_(e, null) : Ease._$GetIndexForEase$_(t, null))) throw new Error(`invalid ease name '${t}'`);
                return s;
            }, ValidateTags2 = function(t, e = !1) {
                if (!(e && null == t || "string" == typeof t || Array.isArray(t))) throw new Error("invalid tags");
            };
            getIndexForEase = getIndexForEase2, ValidateTags = ValidateTags2;
            const C33 = self._$C3$_, C3X = self._$C3X$_, IBehaviorInstance = self._$IBehaviorInstance$_, Ease = self._$Ease$_, NAMESPACE = C33._$Behaviors$_._$Tween$_, map = new WeakMap(), TWEEN_PROPERTIES = new Map([ [ "x", {
                name: "offsetX",
                type: "one"
            } ], [ "y", {
                name: "offsetY",
                type: "one"
            } ], [ "width", {
                name: "offsetWidth",
                type: "one"
            } ], [ "height", {
                name: "offsetHeight",
                type: "one"
            } ], [ "angle", {
                name: "offsetAngle",
                type: "one"
            } ], [ "opacity", {
                name: "offsetOpacity",
                type: "one"
            } ], [ "color", {
                name: "offsetColor",
                type: "color"
            } ], [ "z-elevation", {
                name: "offsetZElevation",
                type: "one"
            } ], [ "x-scale", {
                name: "offsetScaleX",
                type: "one"
            } ], [ "y-scale", {
                name: "offsetScaleY",
                type: "one"
            } ], [ "position", {
                name: "position",
                type: "two"
            } ], [ "size", {
                name: "size",
                type: "two"
            } ], [ "scale", {
                name: "scale",
                type: "two"
            } ], [ "value", {
                name: "value",
                type: "value"
            } ] ]), TWEEN_OPTS = {
                tags: "",
                _$destroyOnComplete$_: !1,
                loop: !1,
                pingPong: !1,
                repeatCount: 1,
                _$startValue$_: 0
            }, I_TWEEN_OPTS = {
                _$easeToIndexFunc$_: getIndexForEase2
            };
            self._$ITweenBehaviorInstance$_ = class extends IBehaviorInstance {
                constructor() {
                    super(), map.set(this, IBehaviorInstance._$_GetInitInst$_()._$GetSdkInstance$_());
                }
                _$startTween$_(t, e, s, i, r) {
                    const n = map.get(this);
                    if (!n._$IsEnabled$_() || !n._$IsInstanceValid$_()) return null;
                    const h = TWEEN_PROPERTIES.get(t);
                    if (!h) throw new Error("invalid tween property");
                    "one" === h.type || "value" === h.type ? C3X._$RequireNumber$_(e) : (C3X._$RequireArray$_(e), 
                    "two" === h.type ? (C3X._$RequireNumber$_(e[0]), C3X._$RequireNumber$_(e[1])) : "color" === h.type && (C3X._$RequireNumber$_(e[0]), 
                    C3X._$RequireNumber$_(e[1]), C3X._$RequireNumber$_(e[2]))), 
                    "angle" === t ? e = C33._$toDegrees$_(e) : "opacity" === t ? e *= 100 : "color" === t && (e = C33._$PackRGBEx$_(e[0], e[1], e[2]));
                    const o = getIndexForEase2(i);
                    C3X._$RequireFiniteNumber$_(s), r = Object.assign({}, TWEEN_OPTS, r), 
                    "value" === h.type && C3X._$RequireNumber$_(r._$startValue$_), 
                    ValidateTags2(r.tags, !0);
                    let a;
                    if ("one" === h.type || "color" === h.type ? a = n._$CreateTween$_(NAMESPACE._$TweenArguments$_._$OneProperty$_(n, r.tags, h.name, e, s, o, !!r._$destroyOnComplete$_, !!r.loop, !!r.pingPong, r.repeatCount)) : "two" === h.type ? a = n._$CreateTween$_(NAMESPACE._$TweenArguments$_._$TwoProperties$_(n, r.tags, h.name, e[0], e[1], s, o, !!r._$destroyOnComplete$_, !!r.loop, !!r.pingPong, r.repeatCount)) : "value" === h.type && (a = n._$CreateTween$_(NAMESPACE._$TweenArguments$_._$ValueProperty$_(n, r.tags, r._$startValue$_, e, s, o, !!r._$destroyOnComplete$_, !!r.loop, !!r.pingPong, r.repeatCount))), 
                    a.Play()) return a._$GetITweenState$_(n, I_TWEEN_OPTS);
                    throw new Error("failed to start tween");
                }
                *_$allTweens$_() {
                    const t = map.get(this);
                    for (const e of t._$AllTweens$_()) yield e._$GetITweenState$_(t, I_TWEEN_OPTS);
                }
                *_$tweensByTags$_(t) {
                    ValidateTags2(t);
                    const e = map.get(this);
                    for (const s of e._$GetTweens$_(t)) yield s._$GetITweenState$_(e, I_TWEEN_OPTS);
                }
                get isEnabled() {
                    return map.get(this)._$IsEnabled$_();
                }
                set isEnabled(t) {
                    map.get(this)._$SetEnabled$_(t);
                }
            };
        }
        {
            const a = self._$C3$_;
            a._$Behaviors$_._$Sin$_ = class extends a._$SDKBehaviorBase$_ {
                constructor(t) {
                    super(t);
                }
                _$Release$_() {
                    super._$Release$_();
                }
            };
        }
        {
            const d = self._$C3$_;
            d._$Behaviors$_._$Sin$_._$Type$_ = class extends d._$SDKBehaviorTypeBase$_ {
                constructor(t) {
                    super(t);
                }
                _$Release$_() {
                    super._$Release$_();
                }
                _$OnCreate$_() {}
            };
        }
        {
            const g = self._$C3$_, h = self._$C3X$_, i = self._$IBehaviorInstance$_, j = 0, k = 1, l = 2, m = 3, n = 4, o = 5, p = 6, q = 7, r = 8, s = 0, t = 1, u = 2, v = 3, w = 4, x = 5, y = 6, z = 7, A = 8, B = 9, C = 0, D = 1, E = 2, F = 3, G = 4, H = 2 * Math.PI, I = Math.PI / 2, J = 3 * Math.PI / 2, K = [ 0, 1, 8, 3, 4, 2, 5, 6, 9, 7 ], L = (g._$Behaviors$_._$Sin$_.Instance = class extends g._$SDKBehaviorInstanceBase$_ {
                constructor(t, e) {
                    super(t), this._$_i$_ = 0, this._$_movement$_ = 0, this._$_wave$_ = 0, 
                    this._$_period$_ = 0, this._$_mag$_ = 0, this._$_isEnabled$_ = !0, 
                    this._$_basePeriod$_ = 0, this._$_basePeriodOffset$_ = 0, this._$_baseMag$_ = 0, 
                    this._$_periodRandom$_ = 0, this._$_periodOffsetRandom$_ = 0, 
                    this._$_magnitudeRandom$_ = 0, this._$_initialValue$_ = 0, this._$_initialValue2$_ = 0, 
                    this._$_lastKnownValue$_ = 0, this._$_lastKnownValue2$_ = 0, 
                    this._$_ratio$_ = 0, e && (this._$_movement$_ = K[e[j]], this._$_wave$_ = e[k], 
                    this._$_periodRandom$_ = this._$_runtime$_._$Random$_() * e[m], 
                    this._$_basePeriod$_ = e[l], this._$_period$_ = e[l], this._$_period$_ += this._$_periodRandom$_, 
                    this._$_basePeriodOffset$_ = e[n], 0 !== this._$_period$_ && (this._$_periodOffsetRandom$_ = this._$_runtime$_._$Random$_() * e[o], 
                    this._$_i$_ = e[n] / this._$_period$_ * H, this._$_i$_ += this._$_periodOffsetRandom$_ / this._$_period$_ * H), 
                    this._$_magnitudeRandom$_ = this._$_runtime$_._$Random$_() * e[q], 
                    this._$_baseMag$_ = e[p], this._$_mag$_ = e[p], this._$_mag$_ += this._$_magnitudeRandom$_, 
                    this._$_isEnabled$_ = !!e[r]), this._$_movement$_ === x && (this._$_mag$_ = g._$toRadians$_(this._$_mag$_)), 
                    this._$Init$_(), this._$_isEnabled$_ && this._$_StartTicking$_();
                }
                _$Release$_() {
                    super._$Release$_();
                }
                _$SaveToJson$_() {
                    return {
                        i: this._$_i$_,
                        e: this._$_isEnabled$_,
                        mv: this._$_movement$_,
                        w: this._$_wave$_,
                        p: this._$_period$_,
                        mag: this._$_mag$_,
                        iv: this._$_initialValue$_,
                        iv2: this._$_initialValue2$_,
                        r: this._$_ratio$_,
                        lkv: this._$_lastKnownValue$_,
                        lkv2: this._$_lastKnownValue2$_
                    };
                }
                _$LoadFromJson$_(t) {
                    this._$_i$_ = t.i, this._$_SetEnabled$_(t.e), this._$_movement$_ = t.mv, 
                    this._$_wave$_ = t.w, this._$_period$_ = t.p, this._$_mag$_ = t.mag, 
                    this._$_initialValue$_ = t.iv, this._$_initialValue2$_ = t.iv2, 
                    this._$_ratio$_ = t.r, this._$_lastKnownValue$_ = t.lkv, this._$_lastKnownValue2$_ = t.lkv2;
                }
                _$Init$_() {
                    const e = this._$_inst$_._$GetWorldInfo$_();
                    switch (this._$_movement$_) {
                      case s:
                        this._$_initialValue$_ = e._$GetX$_();
                        break;

                      case t:
                        this._$_initialValue$_ = e._$GetY$_();
                        break;

                      case u:
                        this._$_initialValue$_ = e._$GetWidth$_(), this._$_ratio$_ = e._$GetHeight$_() / e._$GetWidth$_();
                        break;

                      case v:
                        this._$_initialValue$_ = e._$GetWidth$_();
                        break;

                      case w:
                        this._$_initialValue$_ = e._$GetHeight$_();
                        break;

                      case x:
                        this._$_initialValue$_ = e.GetAngle();
                        break;

                      case y:
                        this._$_initialValue$_ = e._$GetOpacity$_();
                        break;

                      case z:
                        this._$_initialValue$_ = 0;
                        break;

                      case A:
                        this._$_initialValue$_ = e._$GetX$_(), this._$_initialValue2$_ = e._$GetY$_();
                        break;

                      case B:
                        this._$_initialValue$_ = e._$GetZElevation$_();
                    }
                    this._$_lastKnownValue$_ = this._$_initialValue$_, this._$_lastKnownValue2$_ = this._$_initialValue2$_;
                }
                _$WaveFunc$_(t) {
                    switch (t %= H, this._$_wave$_) {
                      case C:
                        return Math.sin(t);

                      case D:
                        return t <= I ? t / I : t <= J ? 1 - 2 * (t - I) / Math.PI : (t - J) / I - 1;

                      case E:
                        return 2 * t / H - 1;

                      case F:
                        return -2 * t / H + 1;

                      case G:
                        return t < Math.PI ? -1 : 1;
                    }
                    return 0;
                }
                _$Tick$_() {
                    const t = this._$_runtime$_._$GetDt$_(this._$_inst$_);
                    this._$_isEnabled$_ && 0 !== t && (0 === this._$_period$_ ? this._$_i$_ = 0 : this._$_i$_ = (this._$_i$_ + t / this._$_period$_ * H) % H, 
                    this._$_UpdateFromPhase$_());
                }
                _$_UpdateFromPhase$_() {
                    const e = this._$_inst$_._$GetWorldInfo$_();
                    switch (this._$_movement$_) {
                      case s:
                        e._$GetX$_() !== this._$_lastKnownValue$_ && (this._$_initialValue$_ += e._$GetX$_() - this._$_lastKnownValue$_), 
                        e._$SetX$_(this._$_initialValue$_ + this._$WaveFunc$_(this._$_i$_) * this._$_mag$_), 
                        this._$_lastKnownValue$_ = e._$GetX$_();
                        break;

                      case t:
                        e._$GetY$_() !== this._$_lastKnownValue$_ && (this._$_initialValue$_ += e._$GetY$_() - this._$_lastKnownValue$_), 
                        e._$SetY$_(this._$_initialValue$_ + this._$WaveFunc$_(this._$_i$_) * this._$_mag$_), 
                        this._$_lastKnownValue$_ = e._$GetY$_();
                        break;

                      case u:
                        e._$SetWidth$_(this._$_initialValue$_ + this._$WaveFunc$_(this._$_i$_) * this._$_mag$_), 
                        e._$SetHeight$_(e._$GetWidth$_() * this._$_ratio$_);
                        break;

                      case v:
                        e._$SetWidth$_(this._$_initialValue$_ + this._$WaveFunc$_(this._$_i$_) * this._$_mag$_);
                        break;

                      case w:
                        e._$SetHeight$_(this._$_initialValue$_ + this._$WaveFunc$_(this._$_i$_) * this._$_mag$_);
                        break;

                      case x:
                        e.GetAngle() !== this._$_lastKnownValue$_ && (this._$_initialValue$_ = g._$clampAngle$_(this._$_initialValue$_ + (e.GetAngle() - this._$_lastKnownValue$_))), 
                        e._$SetAngle$_(this._$_initialValue$_ + this._$WaveFunc$_(this._$_i$_) * this._$_mag$_), 
                        this._$_lastKnownValue$_ = e.GetAngle();
                        break;

                      case y:
                        e._$SetOpacity$_(this._$_initialValue$_ + this._$WaveFunc$_(this._$_i$_) * this._$_mag$_ / 100);
                        break;

                      case A:
                        e._$GetX$_() !== this._$_lastKnownValue$_ && (this._$_initialValue$_ += e._$GetX$_() - this._$_lastKnownValue$_), 
                        e._$GetY$_() !== this._$_lastKnownValue2$_ && (this._$_initialValue2$_ += e._$GetY$_() - this._$_lastKnownValue2$_), 
                        e._$SetX$_(this._$_initialValue$_ + Math.cos(e.GetAngle()) * this._$WaveFunc$_(this._$_i$_) * this._$_mag$_), 
                        e._$SetY$_(this._$_initialValue2$_ + Math.sin(e.GetAngle()) * this._$WaveFunc$_(this._$_i$_) * this._$_mag$_), 
                        this._$_lastKnownValue$_ = e._$GetX$_(), this._$_lastKnownValue2$_ = e._$GetY$_();
                        break;

                      case B:
                        e._$SetZElevation$_(this._$_initialValue$_ + this._$WaveFunc$_(this._$_i$_) * this._$_mag$_);
                    }
                    e._$SetBboxChanged$_();
                }
                _$_OnSpriteFrameChanged$_(t, e) {}
                _$_SetPeriod$_(t) {
                    this._$_period$_ = t;
                }
                _$_GetPeriod$_() {
                    return this._$_period$_;
                }
                _$_SetMagnitude$_(t) {
                    this._$_mag$_ = t;
                }
                _$_SetMagnitude_ConvertAngle$_(t) {
                    5 === this._$_movement$_ && (t = g._$toRadians$_(t)), this._$_SetMagnitude$_(t);
                }
                _$_GetMagnitude$_() {
                    return this._$_mag$_;
                }
                _$_GetMagnitude_ConvertAngle$_() {
                    let t = this._$_GetMagnitude$_();
                    return 5 === this._$_movement$_ ? g._$toDegrees$_(t) : t;
                }
                _$_SetMovement$_(t) {
                    5 === this._$_movement$_ && 5 !== t && (this._$_mag$_ = g._$toDegrees$_(this._$_mag$_)), 
                    this._$_movement$_ = t, this._$Init$_();
                }
                _$_GetMovement$_() {
                    return this._$_movement$_;
                }
                _$_SetWave$_(t) {
                    this._$_wave$_ = t;
                }
                _$_GetWave$_() {
                    return this._$_wave$_;
                }
                _$_SetPhase$_(t) {
                    this._$_i$_ = g._$clamp$_(t, 0, 2 * Math.PI), this._$_UpdateFromPhase$_();
                }
                _$_GetPhase$_() {
                    return this._$_i$_;
                }
                _$_SetEnabled$_(t) {
                    this._$_isEnabled$_ = !!t, this._$_isEnabled$_ ? this._$_StartTicking$_() : this._$_StopTicking$_();
                }
                _$_IsEnabled$_() {
                    return this._$_isEnabled$_;
                }
                _$GetPropertyValueByIndex$_(t) {
                    switch (t) {
                      case j:
                        return this._$_movement$_;

                      case k:
                        return this._$_wave$_;

                      case l:
                        return this._$_basePeriod$_;

                      case p:
                        return this._$_baseMag$_;

                      case r:
                        return this._$_isEnabled$_;
                    }
                }
                _$SetPropertyValueByIndex$_(t, e) {
                    switch (t) {
                      case j:
                        this._$_movement$_ = K[e], this._$Init$_();
                        break;

                      case k:
                        this._$_wave$_ = e;
                        break;

                      case l:
                        this._$_basePeriod$_ = e, this._$_period$_ = this._$_basePeriod$_ + this._$_periodRandom$_, 
                        this._$_isEnabled$_ || (0 !== this._$_period$_ ? (this._$_i$_ = this._$_basePeriodOffset$_ / this._$_period$_ * H, 
                        this._$_i$_ += this._$_periodOffsetRandom$_ / this._$_period$_ * H) : this._$_i$_ = 0);
                        break;

                      case p:
                        this._$_baseMag$_ = e, this._$_mag$_ = this._$_baseMag$_ + this._$_magnitudeRandom$_, 
                        this._$_movement$_ === x && (this._$_mag$_ = g._$toRadians$_(this._$_mag$_));
                        break;

                      case r:
                        this._$_isEnabled$_ = !!e;
                    }
                }
                _$GetDebuggerProperties$_() {
                    const t = "behaviors.sin";
                    return [ {
                        title: "$" + this._$GetBehaviorType$_()._$GetName$_(),
                        properties: [ {
                            name: t + ".properties.enabled.name",
                            value: this._$_IsEnabled$_(),
                            _$onedit$_: t => this._$_SetEnabled$_(t)
                        }, {
                            name: t + ".properties.period.name",
                            value: this._$_GetPeriod$_(),
                            _$onedit$_: t => this._$_SetPeriod$_(t)
                        }, {
                            name: t + ".properties.magnitude.name",
                            value: this._$_GetMagnitude_ConvertAngle$_(),
                            _$onedit$_: t => this._$_SetMagnitude_ConvertAngle$_(t)
                        }, {
                            name: t + ".debugger.value",
                            value: this._$WaveFunc$_(this._$_GetPhase$_()) * this._$_GetMagnitude_ConvertAngle$_()
                        } ]
                    } ];
                }
                _$GetScriptInterfaceClass$_() {
                    return self._$ISineBehaviorInstance$_;
                }
            }, new WeakMap()), M = [ "horizontal", "vertical", "size", "width", "height", "angle", "opacity", "value-only", "forwards-backwards", "z-elevation" ], N = [ "sine", "triangle", "sawtooth", "reverse-sawtooth", "square" ];
            self._$ISineBehaviorInstance$_ = class extends i {
                constructor() {
                    super(), L.set(this, i._$_GetInitInst$_()._$GetSdkInstance$_());
                }
                set _$period$_(t) {
                    h._$RequireFiniteNumber$_(t), L.get(this)._$_SetPeriod$_(t);
                }
                get _$period$_() {
                    return L.get(this)._$_GetPeriod$_();
                }
                set _$magnitude$_(t) {
                    h._$RequireFiniteNumber$_(t), L.get(this)._$_SetMagnitude$_(t);
                }
                get _$magnitude$_() {
                    return L.get(this)._$_GetMagnitude$_();
                }
                set _$phase$_(t) {
                    L.get(this)._$_SetPhase$_(t);
                }
                get _$phase$_() {
                    return L.get(this)._$_GetPhase$_();
                }
                set _$movement$_(t) {
                    h._$RequireString$_(t);
                    const e = M.indexOf(t);
                    if (-1 === e) throw new Error("invalid movement");
                    L.get(this)._$_SetMovement$_(e);
                }
                get _$movement$_() {
                    return M[L.get(this)._$_GetMovement$_()];
                }
                set _$wave$_(t) {
                    h._$RequireString$_(t);
                    const e = N.indexOf(t);
                    if (-1 === e) throw new Error("invalid wave");
                    L.get(this)._$_SetWave$_(e);
                }
                get _$wave$_() {
                    return N[L.get(this)._$_GetWave$_()];
                }
                get value() {
                    const t = L.get(this);
                    return t._$WaveFunc$_(t._$_GetPhase$_()) * t._$_GetMagnitude$_();
                }
                _$updateInitialState$_() {
                    L.get(this)._$Init$_();
                }
                set isEnabled(t) {
                    L.get(this)._$_SetEnabled$_(!!t);
                }
                get isEnabled() {
                    return L.get(this)._$_IsEnabled$_();
                }
            };
        }
        {
            const va = self._$C3$_;
            va._$Behaviors$_._$Sin$_._$Cnds$_ = {
                _$IsEnabled$_() {
                    return this._$_IsEnabled$_();
                },
                _$CompareMovement$_(t) {
                    return this._$_GetMovement$_() === t;
                },
                _$ComparePeriod$_(t, e) {
                    return va.compare(this._$_GetPeriod$_(), t, e);
                },
                _$CompareMagnitude$_(t, e) {
                    return va.compare(this._$_GetMagnitude_ConvertAngle$_(), t, e);
                },
                _$CompareWave$_(t) {
                    return this._$_GetWave$_() === t;
                }
            };
        }
        {
            const Ca = self._$C3$_;
            Ca._$Behaviors$_._$Sin$_._$Acts$_ = {
                _$SetEnabled$_(t) {
                    this._$_SetEnabled$_(0 !== t);
                },
                _$SetPeriod$_(t) {
                    this._$_SetPeriod$_(t);
                },
                _$SetMagnitude$_(t) {
                    this._$_SetMagnitude_ConvertAngle$_(t);
                },
                _$SetMovement$_(t) {
                    this._$_SetMovement$_(t);
                },
                _$SetWave$_(t) {
                    this._$_wave$_ = t;
                },
                _$SetPhase$_(t) {
                    const e = 2 * Math.PI;
                    this._$_SetPhase$_(t * e % e);
                },
                _$UpdateInitialState$_() {
                    this._$Init$_();
                }
            };
        }
        {
            const Ka = self._$C3$_;
            Ka._$Behaviors$_._$Sin$_._$Exps$_ = {
                _$CyclePosition$_() {
                    return this._$_GetPhase$_() / (2 * Math.PI);
                },
                _$Period$_() {
                    return this._$_GetPeriod$_();
                },
                _$Magnitude$_() {
                    return this._$_GetMagnitude_ConvertAngle$_();
                },
                _$Value$_() {
                    return this._$WaveFunc$_(this._$_GetPhase$_()) * this._$_GetMagnitude_ConvertAngle$_();
                }
            };
        }
        {
            const a = self._$C3$_;
            a._$Behaviors$_._$solid$_ = class extends a._$SDKBehaviorBase$_ {
                constructor(t) {
                    super(t);
                }
                _$Release$_() {
                    super._$Release$_();
                }
            };
        }
        {
            const d = self._$C3$_;
            d._$Behaviors$_._$solid$_._$Type$_ = class extends d._$SDKBehaviorTypeBase$_ {
                constructor(t) {
                    super(t);
                }
                _$Release$_() {
                    super._$Release$_();
                }
                _$OnCreate$_() {}
            };
        }
        {
            const g = self._$C3$_, h = self._$C3X$_, i = self._$IBehaviorInstance$_, j = 0, k = 1, l = new Set(), m = (g._$Behaviors$_._$solid$_.Instance = class extends g._$SDKBehaviorInstanceBase$_ {
                constructor(t, e) {
                    super(t), this._$SetEnabled$_(!0), e && (this._$SetEnabled$_(e[j]), 
                    this._$SetTags$_(e[k]));
                }
                _$Release$_() {
                    super._$Release$_();
                }
                _$SetEnabled$_(t) {
                    this._$_inst$_._$_SetSolidEnabled$_(!!t);
                }
                _$IsEnabled$_() {
                    return this._$_inst$_._$_IsSolidEnabled$_();
                }
                _$SetTags$_(e) {
                    const s = this._$_inst$_._$GetSavedDataMap$_();
                    if (e.trim()) {
                        let t = s.get("solidTags");
                        t || (t = new Set(), s.set("solidTags", t)), t.clear();
                        for (const i of e.split(" ")) i && t.add(i.toLowerCase());
                    } else s.delete("solidTags");
                }
                _$GetTags$_() {
                    return this._$_inst$_._$GetSavedDataMap$_().get("solidTags") || l;
                }
                _$_GetTagsString$_() {
                    return [ ...this._$GetTags$_() ].join(" ");
                }
                _$SaveToJson$_() {
                    return {
                        e: this._$IsEnabled$_()
                    };
                }
                _$LoadFromJson$_(t) {
                    this._$SetEnabled$_(t.e);
                }
                _$GetPropertyValueByIndex$_(t) {
                    if (t === j) return this._$IsEnabled$_();
                }
                _$SetPropertyValueByIndex$_(t, e) {
                    t === j && this._$SetEnabled$_(e);
                }
                _$GetDebuggerProperties$_() {
                    return [ {
                        title: "$" + this._$GetBehaviorType$_()._$GetName$_(),
                        properties: [ {
                            name: "behaviors.solid.properties.enabled.name",
                            value: this._$IsEnabled$_(),
                            _$onedit$_: t => this._$SetEnabled$_(t)
                        }, {
                            name: "behaviors.solid.properties.tags.name",
                            value: this._$_GetTagsString$_(),
                            _$onedit$_: t => this._$SetTags$_(t)
                        } ]
                    } ];
                }
                _$GetScriptInterfaceClass$_() {
                    return self._$ISolidBehaviorInstance$_;
                }
            }, new WeakMap());
            self._$ISolidBehaviorInstance$_ = class extends i {
                constructor() {
                    super(), m.set(this, i._$_GetInitInst$_()._$GetSdkInstance$_());
                }
                set isEnabled(t) {
                    m.get(this)._$SetEnabled$_(!!t);
                }
                get isEnabled() {
                    return m.get(this)._$IsEnabled$_();
                }
                set tags(t) {
                    h._$RequireString$_(t), m.get(this)._$SetTags$_(t);
                }
                get tags() {
                    return m.get(this)._$_GetTagsString$_();
                }
            };
        }
        {
            const E = self._$C3$_;
            E._$Behaviors$_._$solid$_._$Cnds$_ = {
                _$IsEnabled$_() {
                    return this._$IsEnabled$_();
                }
            };
        }
        {
            const F = self._$C3$_;
            F._$Behaviors$_._$solid$_._$Acts$_ = {
                _$SetEnabled$_(t) {
                    this._$SetEnabled$_(t);
                },
                _$SetTags$_(t) {
                    this._$SetTags$_(t);
                }
            };
        }
        {
            const I = self._$C3$_;
            I._$Behaviors$_._$solid$_._$Exps$_ = {};
        }
        {
            const a = self._$C3$_;
            a._$Behaviors$_._$custom$_ = class extends a._$SDKBehaviorBase$_ {
                constructor(t) {
                    super(t);
                }
                _$Release$_() {
                    super._$Release$_();
                }
            };
        }
        {
            const d = self._$C3$_;
            d._$Behaviors$_._$custom$_._$Type$_ = class extends d._$SDKBehaviorTypeBase$_ {
                constructor(t) {
                    super(t);
                }
                _$Release$_() {
                    super._$Release$_();
                }
                _$OnCreate$_() {}
            };
        }
        {
            const g = self._$C3$_, h = 0, i = 1, j = 2;
            g._$Behaviors$_._$custom$_.Instance = class extends g._$SDKBehaviorInstanceBase$_ {
                constructor(t, e) {
                    super(t), this._$_dx$_ = 0, this._$_dy$_ = 0, this._$_cancelStep$_ = 0, 
                    this._$_stepMode$_ = 0, this._$_pxPerStep$_ = 5, this._$_isEnabled$_ = !0, 
                    e && (this._$_stepMode$_ = e[h], this._$_pxPerStep$_ = e[i], 
                    this._$_isEnabled$_ = e[j]), this._$_isEnabled$_ && this._$_StartTicking$_();
                }
                _$Release$_() {
                    super._$Release$_();
                }
                _$SaveToJson$_() {
                    return {
                        dx: this._$_dx$_,
                        dy: this._$_dy$_,
                        cs: this._$_cancelStep$_,
                        sm: this._$_stepMode$_,
                        px: this._$_pxPerStep$_,
                        e: this._$_isEnabled$_
                    };
                }
                _$LoadFromJson$_(t) {
                    this._$_dx$_ = t.dx, this._$_dy$_ = t.dy, this._$_cancelStep$_ = t.cs, 
                    this._$_stepMode$_ = t.sm, this._$_pxPerStep$_ = t.px, this._$_SetEnabled$_(t.e);
                }
                _$GetSpeed$_() {
                    return Math.hypot(this._$_dx$_, this._$_dy$_);
                }
                GetAngle() {
                    return Math.atan2(this._$_dy$_, this._$_dx$_);
                }
                _$_Step$_(h, o, a) {
                    if (0 !== h || 0 !== o) {
                        let s = this._$GetWorldInfo$_(), i = s._$GetX$_(), r = s._$GetY$_(), n = Math.round(g._$hypot2DFast$_(h, o) / this._$_pxPerStep$_);
                        0 === n && (n = 1);
                        for (let e = 1; e <= n; ++e) {
                            let t = e / n;
                            if (s._$SetXY$_(i + h * t, r + o * t), s._$SetBboxChanged$_(), 
                            this._$Trigger$_(a), 1 === this._$_cancelStep$_) return t = --e / n, 
                            s._$SetXY$_(i + h * t, r + o * t), void s._$SetBboxChanged$_();
                            if (2 === this._$_cancelStep$_) return;
                        }
                    }
                }
                _$Tick$_() {
                    if (this._$_isEnabled$_ && (0 !== this._$_dx$_ || 0 !== this._$_dy$_)) {
                        const t = this._$_inst$_._$GetWorldInfo$_(), e = this._$_runtime$_._$GetDt$_(this._$_inst$_), s = this._$_dx$_ * e, i = this._$_dy$_ * e;
                        (this._$_cancelStep$_ = 0) === this._$_stepMode$_ ? (t._$OffsetXY$_(s, i), 
                        t._$SetBboxChanged$_()) : 1 === this._$_stepMode$_ ? this._$_Step$_(s, i, g._$Behaviors$_._$custom$_._$Cnds$_._$OnCMStep$_) : 2 === this._$_stepMode$_ ? (this._$_Step$_(s, 0, g._$Behaviors$_._$custom$_._$Cnds$_._$OnCMHorizStep$_), 
                        this._$_cancelStep$_ = 0, this._$_Step$_(0, i, g._$Behaviors$_._$custom$_._$Cnds$_._$OnCMVertStep$_)) : 3 === this._$_stepMode$_ && (this._$_Step$_(0, i, g._$Behaviors$_._$custom$_._$Cnds$_._$OnCMVertStep$_), 
                        this._$_cancelStep$_ = 0, this._$_Step$_(s, 0, g._$Behaviors$_._$custom$_._$Cnds$_._$OnCMHorizStep$_));
                    }
                }
                _$GetPropertyValueByIndex$_(t) {
                    switch (t) {
                      case h:
                        return this._$_stepMode$_;

                      case i:
                        return this._$_pxPerStep$_;

                      case j:
                        return this._$_isEnabled$_;
                    }
                }
                _$SetPropertyValueByIndex$_(t, e) {
                    switch (t) {
                      case h:
                        this._$_stepMode$_ = e;
                        break;

                      case i:
                        this._$_pxPerStep$_ = e;
                        break;

                      case j:
                        this._$_SetEnabled$_(e);
                    }
                }
                _$_SetEnabled$_(t) {
                    this._$_isEnabled$_ = !!t, this._$_isEnabled$_ ? this._$_StartTicking$_() : this._$_StopTicking$_();
                }
                _$GetDebuggerProperties$_() {
                    const t = "behaviors.custom";
                    return [ {
                        title: "$" + this._$GetBehaviorType$_()._$GetName$_(),
                        properties: [ {
                            name: t + ".debugger.vector-x",
                            value: this._$_dx$_,
                            _$onedit$_: t => this._$_dx$_ = t
                        }, {
                            name: t + ".debugger.vector-y",
                            value: this._$_dy$_,
                            _$onedit$_: t => this._$_dy$_ = t
                        }, {
                            name: t + ".properties.pixels-per-step.name",
                            value: this._$_pxPerStep$_,
                            _$onedit$_: t => this._$_pxPerStep$_ = t
                        }, {
                            name: t + ".properties.enabled.name",
                            value: this._$_isEnabled$_,
                            _$onedit$_: t => this._$_SetEnabled$_(t)
                        } ]
                    } ];
                }
            };
        }
        {
            const K = self._$C3$_;
            K._$Behaviors$_._$custom$_._$Cnds$_ = {
                _$IsMoving$_() {
                    return 0 !== this._$_dx$_ || 0 !== this._$_dy$_;
                },
                _$CompareSpeed$_(t, e, s) {
                    let i = 0;
                    switch (t) {
                      case 0:
                        i = this._$GetSpeed$_();
                        break;

                      case 1:
                        i = this._$_dx$_;
                        break;

                      case 2:
                        i = this._$_dy$_;
                    }
                    return K.compare(i, e, s);
                },
                _$OnCMStep$_() {
                    return !0;
                },
                _$OnCMHorizStep$_() {
                    return !0;
                },
                _$OnCMVertStep$_() {
                    return !0;
                },
                _$IsEnabled$_() {
                    return this._$_isEnabled$_;
                }
            };
        }
        {
            const P = self._$C3$_;
            P._$Behaviors$_._$custom$_._$Acts$_ = {
                _$Stop$_() {
                    this._$_dx$_ = 0, this._$_dy$_ = 0;
                },
                _$Reverse$_(t) {
                    switch (t) {
                      case 0:
                        this._$_dx$_ *= -1, this._$_dy$_ *= -1;
                        break;

                      case 1:
                        this._$_dx$_ *= -1;
                        break;

                      case 2:
                        this._$_dy$_ *= -1;
                    }
                },
                _$SetSpeed$_(t, e) {
                    let s;
                    switch (t) {
                      case 0:
                        s = this.GetAngle(), this._$_dx$_ = Math.cos(s) * e, this._$_dy$_ = Math.sin(s) * e;
                        break;

                      case 1:
                        this._$_dx$_ = e;
                        break;

                      case 2:
                        this._$_dy$_ = e;
                    }
                },
                _$Accelerate$_(t, e) {
                    let s = this._$_runtime$_._$GetDt$_(this._$_inst$_), i = e * s, r;
                    switch (t) {
                      case 0:
                        r = this.GetAngle(), this._$_dx$_ += Math.cos(r) * i, this._$_dy$_ += Math.sin(r) * i;
                        break;

                      case 1:
                        this._$_dx$_ += i;
                        break;

                      case 2:
                        this._$_dy$_ += i;
                    }
                },
                _$AccelerateAngle$_(t, e) {
                    e = P._$toRadians$_(e);
                    const s = this._$_runtime$_._$GetDt$_(this._$_inst$_), i = t * s;
                    this._$_dx$_ += Math.cos(e) * i, this._$_dy$_ += Math.sin(e) * i;
                },
                _$AcceleratePos$_(t, e, s) {
                    const i = this._$GetWorldInfo$_(), r = this._$_runtime$_._$GetDt$_(this._$_inst$_), n = t * r, h = Math.atan2(s - i._$GetY$_(), e - i._$GetX$_());
                    this._$_dx$_ += Math.cos(h) * n, this._$_dy$_ += Math.sin(h) * n;
                },
                _$SetAngleOfMotion$_(t) {
                    t = P._$toRadians$_(t);
                    const e = this._$GetSpeed$_();
                    this._$_dx$_ = Math.cos(t) * e, this._$_dy$_ = Math.sin(t) * e;
                },
                _$RotateAngleOfMotionClockwise$_(t) {
                    t = this.GetAngle() + P._$toRadians$_(t);
                    const e = this._$GetSpeed$_();
                    this._$_dx$_ = Math.cos(t) * e, this._$_dy$_ = Math.sin(t) * e;
                },
                _$RotateAngleOfMotionCounterClockwise$_(t) {
                    t = this.GetAngle() - P._$toRadians$_(t);
                    const e = this._$GetSpeed$_();
                    this._$_dx$_ = Math.cos(t) * e, this._$_dy$_ = Math.sin(t) * e;
                },
                _$StopStepping$_(t) {
                    this._$_cancelStep$_ = t + 1;
                },
                _$PushOutSolid$_(t) {
                    let e, s, i, r = this._$_inst$_, n = this._$GetRuntime$_()._$GetCollisionEngine$_();
                    switch (t) {
                      case 0:
                        e = this.GetAngle(), s = Math.cos(e), i = Math.sin(e), n._$PushOutSolid$_(r, -s, -i, Math.max(3 * this._$GetSpeed$_(), 100));
                        break;

                      case 1:
                        n._$PushOutSolidNearest$_(r);
                        break;

                      case 2:
                        n._$PushOutSolid$_(r, 0, -1, Math.max(3 * Math.abs(this._$_dy$_), 100));
                        break;

                      case 3:
                        n._$PushOutSolid$_(r, 0, 1, Math.max(3 * Math.abs(this._$_dy$_), 100));
                        break;

                      case 4:
                        n._$PushOutSolid$_(r, -1, 0, Math.max(3 * Math.abs(this._$_dx$_), 100));
                        break;

                      case 5:
                        n._$PushOutSolid$_(r, 1, 0, Math.max(3 * Math.abs(this._$_dx$_), 100));
                    }
                },
                _$PushOutSolidAngle$_(t) {
                    t = P._$toRadians$_(t);
                    const e = Math.cos(t), s = Math.sin(t);
                    this._$GetRuntime$_()._$GetCollisionEngine$_()._$PushOutSolid$_(this._$_inst$_, e, s, Math.max(3 * this._$GetSpeed$_(), 100));
                },
                _$SetEnabled$_(t) {
                    this._$_SetEnabled$_(t);
                }
            };
        }
        {
            const za = self._$C3$_;
            za._$Behaviors$_._$custom$_._$Exps$_ = {
                _$Speed$_() {
                    return this._$GetSpeed$_();
                },
                _$MovingAngle$_() {
                    return za._$toDegrees$_(this.GetAngle());
                },
                dx() {
                    return this._$_dx$_;
                },
                dy() {
                    return this._$_dy$_;
                }
            };
        }
        {
            let SetObjectTypeCollisionsEnabled2 = function(s, i, t) {
                const r = s._$GetSavedDataMap$_(), n = i._$GetSavedDataMap$_();
                if (t) {
                    const e = r.get(h), o = (e && e.delete(i._$GetSID$_()), n.get(h));
                    o && o.delete(s._$GetSID$_());
                } else {
                    let t = r.get(h), e = (t || (t = new Set(), r.set(h, t)), n.get(h));
                    e || (e = new Set(), n.set(h, e)), t.add(i._$GetSID$_()), e.add(s._$GetSID$_());
                }
            }, a = (SetObjectTypeCollisionsEnabled = SetObjectTypeCollisionsEnabled2, 
            self._$C3$_), b = self._$C3X$_, s = null, o = null, n = [], y = null, r = null, h = "Physics_DisabledCollisions";
            a._$Behaviors$_._$Physics$_ = class extends a._$SDKBehaviorBase$_ {
                constructor(t) {
                    super(t), (r = this)._$_world$_ = null, this._$_worldG$_ = 10, 
                    this._$_worldScale$_ = .02, this._$_worldManifold$_ = null, 
                    this._$_lastUpdateTick$_ = -1, this._$_steppingMode$_ = 1, this._$_velocityIterations$_ = 8, 
                    this._$_positionIterations$_ = 3, this._$_allCollisionsEnabled$_ = !0, 
                    this._$_runtime$_._$AddLoadPromise$_(this._$_LoadBox2DWasm$_());
                }
                _$GetScriptInterfaceClass$_() {
                    return self._$IPhysicsBehavior$_;
                }
                async _$_LoadBox2DWasm$_() {
                    const t = await this._$_runtime$_._$GetAssetManager$_()._$GetProjectFileUrl$_("box2d.wasm");
                    await new Promise(e => {
                        self.Box2DWasmModule({
                            wasmBinaryFile: t
                        }).then(t => {
                            y = t, this._$_InitBox2DWorld$_(), e();
                        });
                    });
                }
                _$_InitBox2DWorld$_() {
                    const r = this._$_runtime$_._$GetCollisionEngine$_(), t = (s = a._$Behaviors$_._$Physics$_._$GetVec2$_(0, 0), 
                    o = a._$Behaviors$_._$Physics$_._$GetVec2$_(0, 0), this._$_world$_ = new y.b2World(a._$Behaviors$_._$Physics$_._$GetTempVec2A$_(0, this._$_worldG$_), !0), 
                    new y.JSContactListener()), e = (t.BeginContact = t => {
                        const e = y.wrapPointer(t, y.b2Contact), s = a._$Behaviors$_._$Physics$_.Instance._$LookupBehInstFromBody$_(e.GetFixtureA().GetBody()), i = a._$Behaviors$_._$Physics$_.Instance._$LookupBehInstFromBody$_(e.GetFixtureB().GetBody());
                        r._$RegisterCollision$_(s._$GetObjectInstance$_(), i._$GetObjectInstance$_());
                    }, t.EndContact = () => {}, t.PreSolve = () => {}, t.PostSolve = () => {}, 
                    this._$_world$_.SetContactListener(t), new y.JSContactFilter());
                    e.ShouldCollide = (t, e) => {
                        if (this._$_allCollisionsEnabled$_) return !0;
                        const s = y.wrapPointer(t, y.b2Fixture), i = y.wrapPointer(e, y.b2Fixture), r = a._$Behaviors$_._$Physics$_.Instance._$LookupBehInstFromBody$_(s.GetBody()), n = a._$Behaviors$_._$Physics$_.Instance._$LookupBehInstFromBody$_(i.GetBody()), o = r._$GetObjectInstance$_()._$GetObjectClass$_(), l = n._$GetObjectInstance$_()._$GetObjectClass$_(), u = o._$GetSID$_(), c = l._$GetSID$_(), f = o._$GetSavedDataMap$_().get(h);
                        if (f && f.has(c)) return !1;
                        const d = l._$GetSavedDataMap$_().get(h);
                        return !d || !d.has(u);
                    }, this._$_world$_.SetContactFilter(e), this._$_worldManifold$_ = new y.b2WorldManifold();
                }
                _$Release$_() {
                    super._$Release$_();
                }
                _$GetBox2D$_() {
                    return y;
                }
                _$GetWorld$_() {
                    return this._$_world$_;
                }
                _$GetWorldScale$_() {
                    return this._$_worldScale$_;
                }
                _$GetSteppingMode$_() {
                    return this._$_steppingMode$_;
                }
                _$SetSteppingMode$_(t) {
                    this._$_steppingMode$_ = t;
                }
                _$SetLastUpdateTick$_(t) {
                    this._$_lastUpdateTick$_ = t;
                }
                _$GetLastUpdateTick$_() {
                    return this._$_lastUpdateTick$_;
                }
                _$SetVelocityIterations$_(t) {
                    this._$_velocityIterations$_ = Math.max(t, 1);
                }
                _$GetVelocityIterations$_() {
                    return this._$_velocityIterations$_;
                }
                _$SetPositionIterations$_(t) {
                    this._$_positionIterations$_ = Math.max(t, 1);
                }
                _$GetPositionIterations$_() {
                    return this._$_positionIterations$_;
                }
                _$SetIterations$_(t, e) {
                    this._$SetVelocityIterations$_(t), this._$SetPositionIterations$_(e);
                }
                _$GetGravity$_() {
                    return this._$_worldG$_;
                }
                SetGravity(t) {
                    t !== this._$_worldG$_ && (this._$_world$_.SetGravity(a._$Behaviors$_._$Physics$_._$GetTempVec2A$_(0, t)), 
                    this._$_worldG$_ = t, this._$_WakeUpAllPhysicsBodies$_());
                }
                _$_WakeUpAllPhysicsBodies$_() {
                    for (const t of this._$GetInstances$_()) {
                        const e = a._$Behaviors$_._$Physics$_.Instance._$LookupBehInstFromInst$_(t);
                        if (e) {
                            const s = e.GetBody();
                            s && s.SetAwake(!0);
                        }
                    }
                }
                _$DisableShouldCollideFastPath$_() {
                    this._$_allCollisionsEnabled$_ = !1;
                }
                _$SetCollisionsEnabled$_(t, e, s) {
                    if (s = !!s, t && e) {
                        if (e._$IsFamily$_()) for (const i of e._$GetFamilyMembers$_()) SetObjectTypeCollisionsEnabled2(t, i, s); else SetObjectTypeCollisionsEnabled2(t, e, s);
                        this._$DisableShouldCollideFastPath$_();
                    }
                }
                GetWorldManifold() {
                    return this._$_worldManifold$_;
                }
                static _$GetPhysicsCollisionKey$_() {
                    return h;
                }
                static _$GetVec2$_(t, e) {
                    if (n.length) {
                        const s = n.pop();
                        return s.set_x(t), s.set_y(e), s;
                    }
                    {
                        const i = y.b2Vec2;
                        return new i(t, e);
                    }
                }
                static _$FreeVec2$_(t) {
                    n.push(t);
                }
                static _$GetTempVec2A$_(t, e) {
                    return s.set_x(t), s.set_y(e), s;
                }
                static _$GetTempVec2B$_(t, e) {
                    return o.set_x(t), o.set_y(e), o;
                }
                static _$CreatePolygonShape$_(e) {
                    let t = y.b2PolygonShape, s = new t(), i = y._malloc(8 * e.length), r = 0;
                    for (let t = 0; t < e.length; ++t) y.HEAPF32[i + r >> 2] = e[t].get_x(), 
                    y.HEAPF32[i + (r + 4) >> 2] = e[t].get_y(), r += 8;
                    const n = y.wrapPointer(i, y.b2Vec2);
                    return s.Set(n, e.length), y._free(i), s;
                }
            };
            const i = [ "fixed", "variable" ];
            self._$IPhysicsBehavior$_ = class extends self._$IBehavior$_ {
                constructor() {
                    super();
                }
                set _$worldGravity$_(t) {
                    b._$RequireFiniteNumber$_(t), r.SetGravity(t);
                }
                get _$worldGravity$_() {
                    return r._$GetGravity$_();
                }
                set _$steppingMode$_(t) {
                    const e = i.indexOf(t);
                    if (e < 0) throw new Error("invalid stepping mode");
                    r._$SetSteppingMode$_(i[e]);
                }
                get _$steppingMode$_() {
                    return i[r._$GetSteppingMode$_()];
                }
                set _$velocityIterations$_(t) {
                    b._$RequireFiniteNumber$_(t), r._$SetVelocityIterations$_(t);
                }
                get _$velocityIterations$_() {
                    return r._$GetVelocityIterations$_();
                }
                set _$positionIterations$_(t) {
                    b._$RequireFiniteNumber$_(t), r._$SetPositionIterations$_(t);
                }
                get _$positionIterations$_() {
                    return r._$GetPositionIterations$_();
                }
                _$setCollisionsEnabled$_(t, e, s) {
                    const i = r._$GetRuntime$_(), n = i._$_UnwrapIObjectClass$_(t), h = i._$_UnwrapIObjectClass$_(e);
                    s = !!s, r._$SetCollisionsEnabled$_(n, h, s);
                }
            };
        }
        {
            const Ea = self._$C3$_;
            Ea._$Behaviors$_._$Physics$_._$Type$_ = class extends Ea._$SDKBehaviorTypeBase$_ {
                constructor(t) {
                    super(t);
                }
                _$Release$_() {
                    super._$Release$_();
                }
                _$OnCreate$_() {}
            };
        }
        {
            let UnwrapIWorldInstance2 = function(t, e) {
                const s = f0.get(t)._$GetRuntime$_();
                return s._$_UnwrapIWorldInstance$_(e);
            };
            UnwrapIWorldInstance = UnwrapIWorldInstance2;
            const Ha = self._$C3$_, Ia = self._$C3X$_, Ja = self._$IBehaviorInstance$_, Ka = self.assert, La = 0, Ma = 1, Na = 2, Oa = 3, Pa = 4, Qa = 5, Ra = 6, Sa = 7, Ta = 8, Ua = 9, Va = new WeakMap(), Wa = new WeakMap(), Xa = new WeakMap(), Ya = -2147483648, Za = 1073741824, $a = 536870912, _a = 3758096384, a0 = 536870911, b0 = Ha._$Behaviors$_._$Physics$_._$GetTempVec2A$_, c0 = Ha._$Behaviors$_._$Physics$_._$GetTempVec2B$_, d0 = Ha._$New$_(Ha.Rect), e0 = Ha._$New$_(Ha._$Quad$_), f0 = (Ha._$Behaviors$_._$Physics$_.Instance = class extends Ha._$SDKBehaviorInstanceBase$_ {
                constructor(t, e) {
                    super(t);
                    const s = this._$GetBehavior$_(), i = this._$GetWorldInfo$_(), r = (this._$_box2d$_ = s._$GetBox2D$_(), 
                    this._$_world$_ = s._$GetWorld$_(), this._$_worldScale$_ = s._$GetWorldScale$_(), 
                    this._$_isImmovable$_ = !1, this._$_collisionMask$_ = 0, this._$_actualCollisionMask$_ = 0, 
                    this._$_preventRotation$_ = !1, this._$_density$_ = 1, this._$_friction$_ = .5, 
                    this._$_restitution$_ = .2, this._$_linearDamping$_ = 0, this._$_angularDamping$_ = .01, 
                    this._$_isBullet$_ = !1, this._$_isEnabled$_ = !0, this._$_body$_ = null, 
                    this._$_fixtures$_ = [], this._$_myJoints$_ = [], this._$_myCreatedJoints$_ = [], 
                    this._$_joiningMe$_ = new Set(), this._$_lastKnownX$_ = i._$GetX$_(), 
                    this._$_lastKnownY$_ = i._$GetY$_(), this._$_lastKnownAngle$_ = i.GetAngle(), 
                    this._$_lastWidth$_ = 0, this._$_lastHeight$_ = 0, this._$_lastTickOverride$_ = !1, 
                    e && (this._$_isImmovable$_ = !!e[La], this._$_collisionMask$_ = e[Ma], 
                    this._$_preventRotation$_ = !!e[Na], this._$_density$_ = e[Oa], 
                    this._$_friction$_ = e[Pa], this._$_restitution$_ = e[Qa], this._$_linearDamping$_ = e[Ra], 
                    this._$_angularDamping$_ = e[Sa], this._$_isBullet$_ = !!e[Ta], 
                    this._$_isEnabled$_ = !!e[Ua]), this._$_runtime$_._$Dispatcher$_());
                    this._$_disposables$_ = new Ha._$CompositeDisposable$_(Ha._$Disposable$_._$From$_(r, "instancedestroy", t => this._$_OnInstanceDestroyed$_(t.instance)), Ha._$Disposable$_._$From$_(r, "beforeload", () => this._$_OnBeforeLoad$_()), Ha._$Disposable$_._$From$_(r, "afterload", () => this._$_OnAfterLoad$_())), 
                    Wa.set(this._$_inst$_, this), this._$_isEnabled$_ && this._$_StartTicking$_();
                }
                _$PostCreate$_() {
                    this._$_CreateBody$_();
                }
                _$Release$_() {
                    this._$_DestroyMyJoints$_(), Ha._$clearArray$_(this._$_myCreatedJoints$_), 
                    this._$_joiningMe$_.clear(), this._$_body$_ && (this._$_DestroyFixtures$_(), 
                    this._$_world$_.DestroyBody(this._$_body$_), this._$_body$_ = null), 
                    super._$Release$_();
                }
                _$_CreateFixture$_(t) {
                    if (this._$_body$_) {
                        const e = this._$_body$_.CreateFixture(t);
                        return this._$_fixtures$_.push(e), e;
                    }
                }
                _$_DestroyFixtures$_() {
                    if (this._$_body$_) {
                        for (const t of this._$_fixtures$_) this._$_body$_.DestroyFixture(t);
                        Ha._$clearArray$_(this._$_fixtures$_);
                    }
                }
                _$_GetBoundingQuadExcludingMesh$_() {
                    const t = this._$GetWorldInfo$_();
                    return t._$HasMesh$_() ? (t._$CalculateBbox$_(d0, e0, !1), e0) : t._$GetBoundingQuad$_();
                }
                _$_Destroy$_(t) {
                    this._$_box2d$_.destroy(t);
                }
                _$_CreateBody$_() {
                    if (this._$_isEnabled$_) {
                        const t = this._$_box2d$_.b2FixtureDef, s = this._$_box2d$_.b2BodyDef, i = this._$GetWorldInfo$_(), e = i._$HasOwnCollisionPoly$_();
                        if (this._$_actualCollisionMask$_ = this._$_collisionMask$_, 
                        e || this._$_inst$_._$HasTilemap$_() || 0 !== this._$_actualCollisionMask$_ || (this._$_actualCollisionMask$_ = 1), 
                        !this._$_body$_) {
                            const o = new s();
                            o.set_type(this._$_isImmovable$_ ? 0 : 2);
                            let t = i._$GetX$_() * this._$_worldScale$_, e = i._$GetY$_() * this._$_worldScale$_;
                            if (2 === this._$_actualCollisionMask$_) {
                                const a = this._$_GetBoundingQuadExcludingMesh$_();
                                t = a._$midX$_() * this._$_worldScale$_, e = a._$midY$_() * this._$_worldScale$_;
                            }
                            o.set_position(c0(t, e)), o.set_angle(i.GetAngle()), 
                            o.set_fixedRotation(this._$_preventRotation$_), o.set_linearDamping(this._$_linearDamping$_), 
                            o.set_angularDamping(this._$_angularDamping$_), o.set_bullet(this._$_isBullet$_), 
                            this._$_body$_ = this._$_world$_.CreateBody(o), this._$_Destroy$_(o), 
                            Va.set(this._$_body$_, this);
                        }
                        this._$_DestroyFixtures$_();
                        const r = new t(), n = (r.set_density(this._$_density$_), 
                        r.set_friction(this._$_friction$_), r.set_restitution(this._$_restitution$_), 
                        Math.max(Math.abs(i._$GetWidth$_()), 1)), h = Math.max(Math.abs(i._$GetHeight$_()), 1);
                        0 === this._$_actualCollisionMask$_ ? this._$_inst$_._$HasTilemap$_() ? this._$_CreateTilemapFixtures$_(r) : this._$_CreatePolygonFixture$_(r, n, h) : 1 === this._$_actualCollisionMask$_ ? this._$_CreateBoundingBoxFixture$_(r, i, n, h) : this._$_CreateCircleFixture$_(r, n, h), 
                        this._$_lastWidth$_ = i._$GetWidth$_(), this._$_lastHeight$_ = i._$GetHeight$_(), 
                        i._$SetPhysicsBodyChanged$_(!1), this._$_Destroy$_(r);
                    }
                }
                _$_CreateBoundingBoxFixture$_(t, e, s, i) {
                    let r = this._$_box2d$_.b2PolygonShape, n = new r(), h = s * this._$_worldScale$_, o = i * this._$_worldScale$_, a = e._$GetOriginX$_(), l = e._$GetOriginY$_();
                    e._$GetWidth$_() < 0 && (a = 1 - a), e._$GetHeight$_() < 0 && (l = 1 - l);
                    const u = (.5 - a) * h, c = (.5 - l) * o, f = Ha._$Behaviors$_._$Physics$_._$GetVec2$_(u, c);
                    n.SetAsBox(h / 2, o / 2, f, 0), t.set_shape(n), this._$_CreateFixture$_(t), 
                    this._$_Destroy$_(n), Ha._$Behaviors$_._$Physics$_._$FreeVec2$_(f);
                }
                _$_CreateCircleFixture$_(t, e, s) {
                    const i = this._$_box2d$_.b2CircleShape, r = new i();
                    r.set_m_radius(Math.min(e, s) * this._$_worldScale$_ * .5), 
                    t.set_shape(r), this._$_CreateFixture$_(t), this._$_Destroy$_(r);
                }
                _$_CreatePolygonFixture$_(t, e, s) {
                    const i = this._$GetWorldInfo$_(), r = i._$GetWidth$_() < 0, n = i._$GetHeight$_() < 0, h = this._$_worldScale$_, o = i._$GetCustomTransformedCollisionPoly$_(r ? -e : e, n ? -s : s, 0), a = o._$pointsArr$_(), l = a.length / 2, u = [];
                    for (let t = 0; t < l; ++t) u.push(Ha._$Behaviors$_._$Physics$_._$GetVec2$_(a[2 * t], a[2 * t + 1]));
                    r != n && u.reverse();
                    const c = Ha._$Behaviors$_._$Physics$_._$Separator$_._$Separate$_(u, e * s);
                    for (const f of u) Ha._$Behaviors$_._$Physics$_._$FreeVec2$_(f);
                    if (c.length) for (const d of c) {
                        for (const m of d) m.set_x(m.get_x() * h), m.set_y(m.get_y() * h);
                        const p = Ha._$Behaviors$_._$Physics$_._$CreatePolygonShape$_(d);
                        t.set_shape(p), this._$_CreateFixture$_(t), this._$_Destroy$_(p);
                        for (const C of d) Ha._$Behaviors$_._$Physics$_._$FreeVec2$_(C);
                    } else this._$_CreateBoundingBoxFixture$_(t, i, e, s);
                }
                _$_CreateTilemapFixtures$_(i) {
                    const r = this._$_worldScale$_, n = Ha._$Behaviors$_._$Physics$_._$GetVec2$_, h = Ha._$Behaviors$_._$Physics$_._$FreeVec2$_, s = [], o = (this._$_inst$_._$GetSdkInstance$_()._$GetAllCollisionRects$_(s), 
                    []);
                    for (let t = 0, e = s.length; t < e; ++t) {
                        const a = s[t], l = a._$GetRect$_(), u = a._$GetPoly$_();
                        if (u) {
                            let s = Xa.get(u);
                            if (!s) {
                                const c = u._$pointsArr$_(), f = u._$pointCount$_();
                                for (let t = 0; t < f; ++t) o.push(n(c[2 * t], c[2 * t + 1]));
                                const d = a._$GetTileId$_() & _a;
                                (d === Ya || d === Za || d === $a || d & Ya && d & Za && d & $a) && o.reverse(), 
                                s = Ha._$Behaviors$_._$Physics$_._$Separator$_._$Separate$_(o, l.width() * l.height()), 
                                Xa.set(u, s);
                                for (const p of o) h(p);
                                Ha._$clearArray$_(o);
                            }
                            for (let t = 0, e = s.length; t < e; ++t) {
                                const m = s[t];
                                for (let t = 0, e = m.length; t < e; ++t) o.push(n((l._$getLeft$_() + m[t].get_x()) * r, (l._$getTop$_() + m[t].get_y()) * r));
                                const C = Ha._$Behaviors$_._$Physics$_._$CreatePolygonShape$_(o);
                                i.set_shape(C), this._$_CreateFixture$_(i), this._$_Destroy$_(C);
                                for (const g of o) h(g);
                                Ha._$clearArray$_(o);
                            }
                        } else {
                            o.push(n(l._$getLeft$_() * r, l._$getTop$_() * r)), 
                            o.push(n(l._$getRight$_() * r, l._$getTop$_() * r)), 
                            o.push(n(l._$getRight$_() * r, l._$getBottom$_() * r)), 
                            o.push(n(l._$getLeft$_() * r, l._$getBottom$_() * r));
                            const S = Ha._$Behaviors$_._$Physics$_._$CreatePolygonShape$_(o);
                            i.set_shape(S), this._$_CreateFixture$_(i), this._$_Destroy$_(S);
                        }
                        for (const _ of o) h(_);
                        Ha._$clearArray$_(o);
                    }
                }
                _$_DestroyBody$_() {
                    this._$_body$_ && (this._$_DestroyMyJoints$_(), Va.delete(this._$_body$_), 
                    this._$_DestroyFixtures$_(), this._$_world$_.DestroyBody(this._$_body$_), 
                    this._$_body$_ = null);
                }
                _$_DestroyMyJoints$_() {
                    for (const t of this._$_myJoints$_) this._$_world$_.DestroyJoint(t);
                    Ha._$clearArray$_(this._$_myJoints$_);
                }
                _$_RecreateMyJoints$_() {
                    for (const t of this._$_myCreatedJoints$_) switch (t.type) {
                      case 0:
                        this._$_DoCreateDistanceJoint$_(...t.params);
                        break;

                      case 1:
                        this._$_DoCreateRevoluteJoint$_(...t.params);
                        break;

                      case 2:
                        this._$_DoCreateLimitedRevoluteJoint$_(...t.params);
                        break;

                      case 3:
                        this._$_DoCreatePrismaticJoint$_(...t.params);
                    }
                }
                _$_GetInstImagePoint$_(t) {
                    const e = this._$GetWorldInfo$_();
                    if (-1 === t) return [ e._$GetX$_(), e._$GetY$_() ];
                    if (0 === t && this._$_body$_) {
                        const s = this._$_body$_.GetWorldCenter();
                        return [ s.get_x() / this._$_worldScale$_, s.get_y() / this._$_worldScale$_ ];
                    }
                    return this._$_inst$_._$GetImagePoint$_(t);
                }
                _$_CreateDistanceJoint$_(t, e, s, i, r) {
                    if (this._$_isEnabled$_ && e && e !== this._$_inst$_) {
                        const n = Ha._$Behaviors$_._$Physics$_.Instance._$LookupBehInstFromInst$_(e);
                        n && n._$_IsEnabled$_() && (this._$_myCreatedJoints$_.push({
                            type: 0,
                            params: [ t, e._$GetUID$_(), s, i, r ]
                        }), this._$_DoCreateDistanceJoint$_(t, e._$GetUID$_(), s, i, r));
                    }
                }
                _$_DoCreateDistanceJoint$_(t, e, s, i, r) {
                    if (this._$_isEnabled$_) {
                        const n = this._$_runtime$_._$GetInstanceByUID$_(e);
                        if (n && n !== this._$_inst$_) {
                            const h = Ha._$Behaviors$_._$Physics$_.Instance._$LookupBehInstFromInst$_(n);
                            if (h && h._$_IsEnabled$_()) {
                                h._$_joiningMe$_.add(this._$_inst$_), this._$_UpdateBodyToMatchInstance$_(!1), 
                                h._$_UpdateBodyToMatchInstance$_(!1);
                                const [ o, a ] = this._$_GetInstImagePoint$_(t), [ l, u ] = n._$GetImagePoint$_(s), c = o - l, f = a - u, d = this._$_box2d$_.b2DistanceJointDef, p = this._$_worldScale$_, m = new d();
                                m.Initialize(this._$_body$_, h.GetBody(), b0(o * p, a * p), c0(l * p, u * p)), 
                                m.set_length(Math.hypot(c, f) * p), m.set_dampingRatio(i), 
                                m.set_frequencyHz(r), this._$_myJoints$_.push(this._$_world$_.CreateJoint(m)), 
                                this._$_Destroy$_(m);
                            }
                        }
                    }
                }
                _$_CreateRevoluteJoint$_(t, e) {
                    if (this._$_isEnabled$_ && e && e !== this._$_inst$_) {
                        const s = Ha._$Behaviors$_._$Physics$_.Instance._$LookupBehInstFromInst$_(e);
                        s && s._$_IsEnabled$_() && (this._$_myCreatedJoints$_.push({
                            type: 1,
                            params: [ t, e._$GetUID$_() ]
                        }), this._$_DoCreateRevoluteJoint$_(t, e._$GetUID$_()));
                    }
                }
                _$_DoCreateRevoluteJoint$_(t, e) {
                    if (this._$_isEnabled$_) {
                        const s = this._$_runtime$_._$GetInstanceByUID$_(e);
                        if (s && s !== this._$_inst$_) {
                            const i = Ha._$Behaviors$_._$Physics$_.Instance._$LookupBehInstFromInst$_(s);
                            if (i && i._$_IsEnabled$_()) {
                                i._$_joiningMe$_.add(this._$_inst$_), this._$_UpdateBodyToMatchInstance$_(!1), 
                                i._$_UpdateBodyToMatchInstance$_(!1);
                                const [ r, n ] = this._$_GetInstImagePoint$_(t), h = this._$_box2d$_.b2RevoluteJointDef, o = this._$_worldScale$_, a = new h();
                                a.Initialize(this._$_body$_, i.GetBody(), b0(r * o, n * o)), 
                                this._$_myJoints$_.push(this._$_world$_.CreateJoint(a)), 
                                this._$_Destroy$_(a);
                            }
                        }
                    }
                }
                _$_CreateLimitedRevoluteJoint$_(t, e, s, i) {
                    if (this._$_isEnabled$_ && e && e !== this._$_inst$_) {
                        const r = Ha._$Behaviors$_._$Physics$_.Instance._$LookupBehInstFromInst$_(e);
                        r && r._$_IsEnabled$_() && (s = Ha._$toDegrees$_(s), i = Ha._$toDegrees$_(i), 
                        this._$_myCreatedJoints$_.push({
                            type: 2,
                            params: [ t, e._$GetUID$_(), s, i ]
                        }), this._$_DoCreateLimitedRevoluteJoint$_(t, e._$GetUID$_(), s, i));
                    }
                }
                _$_DoCreateLimitedRevoluteJoint$_(t, e, s, i) {
                    if (this._$_isEnabled$_) {
                        const r = this._$_runtime$_._$GetInstanceByUID$_(e);
                        if (r && r !== this._$_inst$_) {
                            const n = Ha._$Behaviors$_._$Physics$_.Instance._$LookupBehInstFromInst$_(r);
                            if (n && n._$_IsEnabled$_()) {
                                n._$_joiningMe$_.add(this._$_inst$_), this._$_UpdateBodyToMatchInstance$_(!1), 
                                n._$_UpdateBodyToMatchInstance$_(!1);
                                const [ h, o ] = this._$_GetInstImagePoint$_(t), a = this._$_box2d$_.b2RevoluteJointDef, l = this._$_worldScale$_, u = new a();
                                u.Initialize(this._$_body$_, n.GetBody(), b0(h * l, o * l)), 
                                u.set_enableLimit(!0), u.set_lowerAngle(Ha._$toRadians$_(s)), 
                                u.set_upperAngle(Ha._$toRadians$_(i)), this._$_myJoints$_.push(this._$_world$_.CreateJoint(u)), 
                                this._$_Destroy$_(u);
                            }
                        }
                    }
                }
                _$_CreatePrismaticJoint$_(t, e, s, i, r, n, h, o, a) {
                    if (this._$_isEnabled$_ && e && e !== this._$_inst$_) {
                        const l = Ha._$Behaviors$_._$Physics$_.Instance._$LookupBehInstFromInst$_(e);
                        l && l._$_IsEnabled$_() && (s = Ha._$toDegrees$_(s), o = Ha._$toDegrees$_(o), 
                        this._$_myCreatedJoints$_.push({
                            type: 3,
                            params: [ t, e._$GetUID$_(), s, i, r, n, h, o, a ]
                        }), this._$_DoCreatePrismaticJoint$_(t, e._$GetUID$_(), s, i, r, n, h, o, a));
                    }
                }
                _$_DoCreatePrismaticJoint$_(t, e, s, i, r, n, h, o, a) {
                    if (this._$_isEnabled$_) {
                        const l = this._$_runtime$_._$GetInstanceByUID$_(e);
                        if (l && l !== this._$_inst$_) {
                            const u = Ha._$Behaviors$_._$Physics$_.Instance._$LookupBehInstFromInst$_(l);
                            if (u && u._$_IsEnabled$_()) {
                                u._$_joiningMe$_.add(this._$_inst$_), this._$_UpdateBodyToMatchInstance$_(!1), 
                                u._$_UpdateBodyToMatchInstance$_(!1);
                                const [ c, f ] = this._$_GetInstImagePoint$_(t), d = (s = Ha._$toRadians$_(s), 
                                Math.cos(s)), p = Math.sin(s), m = this._$_box2d$_.b2PrismaticJointDef, C = this._$_worldScale$_, g = new m();
                                g.Initialize(this._$_body$_, u.GetBody(), b0(c * C, f * C), c0(d, p)), 
                                g.set_enableLimit(!!i), g.set_lowerTranslation(r * C), 
                                g.set_upperTranslation(n * C), g.set_enableMotor(!!h), 
                                g.set_motorSpeed(Ha._$toRadians$_(o)), g.set_maxMotorForce(a), 
                                this._$_myJoints$_.push(this._$_world$_.CreateJoint(g)), 
                                this._$_Destroy$_(g);
                            }
                        }
                    }
                }
                _$_RemoveJoints$_() {
                    this._$_isEnabled$_ && (this._$_DestroyMyJoints$_(), Ha._$clearArray$_(this._$_myCreatedJoints$_), 
                    this._$_joiningMe$_.clear());
                }
                _$_RemoveOtherInstanceJointsToMe$_() {
                    for (const t of this._$_joiningMe$_) {
                        const e = Ha._$Behaviors$_._$Physics$_.Instance._$LookupBehInstFromInst$_(t);
                        if (!e || !e._$_IsEnabled$_()) return;
                        e._$_DestroyJointsForInstance$_(this._$_inst$_);
                    }
                    this._$_joiningMe$_.clear();
                }
                _$_OnInstanceDestroyed$_(t) {
                    this._$_DestroyJointsForInstance$_(t);
                }
                _$_DestroyJointsForInstance$_(t) {
                    let s = t._$GetUID$_(), i = 0;
                    for (let t = 0, e = this._$_myCreatedJoints$_.length; t < e; ++t) this._$_myCreatedJoints$_[i] = this._$_myCreatedJoints$_[t], 
                    i < this._$_myJoints$_.length && (this._$_myJoints$_[i] = this._$_myJoints$_[t]), 
                    this._$_myCreatedJoints$_[t].params[1] === s ? t < this._$_myJoints$_.length && this._$_world$_.DestroyJoint(this._$_myJoints$_[t]) : ++i;
                    Ha._$truncateArray$_(this._$_myCreatedJoints$_, i), i < this._$_myJoints$_.length && Ha._$truncateArray$_(this._$_myJoints$_, i), 
                    this._$_joiningMe$_.delete(t);
                }
                GetBody() {
                    return this._$_body$_;
                }
                static _$LookupBehInstFromBody$_(t) {
                    return Va.get(t) || null;
                }
                static _$LookupBehInstFromInst$_(t) {
                    return Wa.get(t) || null;
                }
                _$SaveToJson$_() {
                    const t = {
                        e: this._$_isEnabled$_,
                        im: this._$_isImmovable$_,
                        pr: this._$_preventRotation$_,
                        d: this._$_density$_,
                        fr: this._$_friction$_,
                        re: this._$_restitution$_,
                        ld: this._$_linearDamping$_,
                        ad: this._$_angularDamping$_,
                        b: this._$_isBullet$_,
                        mcj: this._$_myCreatedJoints$_
                    };
                    if (this._$_isEnabled$_) {
                        const e = this._$_body$_.GetLinearVelocity();
                        t.vx = e.get_x(), t.vy = e.get_y(), t.om = this._$_body$_.GetAngularVelocity();
                    }
                    return t;
                }
                _$_OnBeforeLoad$_() {
                    this._$_DestroyMyJoints$_(), Ha._$clearArray$_(this._$_myCreatedJoints$_), 
                    this._$_joiningMe$_.clear();
                }
                _$LoadFromJson$_(t) {
                    this._$_DestroyBody$_(), this._$_isEnabled$_ = t.e, t.hasOwnProperty("im") && (this._$_isImmovable$_ = !!t.im), 
                    this._$_preventRotation$_ = t.pr, this._$_density$_ = t.d, this._$_friction$_ = t.fr, 
                    this._$_restitution$_ = t.re, this._$_linearDamping$_ = t.ld, 
                    this._$_angularDamping$_ = t.ad, this._$_isBullet$_ = t.b, this._$_myCreatedJoints$_ = t.mcj;
                    const e = this._$GetWorldInfo$_();
                    this._$_lastKnownX$_ = e._$GetX$_(), this._$_lastKnownY$_ = e._$GetY$_(), 
                    this._$_lastKnownAngle$_ = e.GetAngle(), this._$_lastWidth$_ = e._$GetWidth$_(), 
                    this._$_lastHeight$_ = e._$GetHeight$_(), this._$_isEnabled$_ && (this._$_CreateBody$_(), 
                    this._$_body$_.SetLinearVelocity(b0(t.vx, t.vy)), this._$_body$_.SetAngularVelocity(t.om), 
                    0 === t.vx && 0 === t.vy && 0 === t.om || this._$_body$_.SetAwake(!0), 
                    this._$_myCreatedJoints$_ = t.mcj), this._$_isEnabled$_ ? this._$_StartTicking$_() : this._$_StopTicking$_();
                }
                _$_OnAfterLoad$_() {
                    this._$_isEnabled$_ && this._$_RecreateMyJoints$_();
                }
                _$Tick$_() {
                    if (this._$_isEnabled$_) {
                        let t = this._$_runtime$_, s = this._$GetBehavior$_(), i = 0;
                        0 === s._$GetSteppingMode$_() ? i = t._$GetTimeScale$_() / 60 : (i = t._$GetDt$_(this._$_inst$_)) > 1 / 30 && (i = 1 / 30);
                        const r = t._$GetTickCountNoSave$_();
                        if (r > s._$GetLastUpdateTick$_() && 0 < t._$GetTimeScale$_()) {
                            let t = this._$_runtime$_._$IsDebug$_(), e = 0;
                            t && (e = performance.now()), 0 !== i && this._$_world$_.Step(i, s._$GetVelocityIterations$_(), s._$GetPositionIterations$_()), 
                            this._$_world$_.ClearForces(), t && self.C3Debugger.AddPhysicsTime(performance.now() - e), 
                            s._$SetLastUpdateTick$_(r);
                        }
                        this._$_UpdateBodyToMatchInstance$_(!0);
                    }
                }
                _$_UpdateBodyToMatchInstance$_(t) {
                    let e = this._$_inst$_, s = e._$GetWorldInfo$_(), i = this._$_worldScale$_, r = (s._$GetWidth$_() === this._$_lastWidth$_ && s._$GetHeight$_() === this._$_lastHeight$_ && !s._$IsPhysicsBodyChanged$_() || this._$_CreateBody$_(), 
                    this._$_body$_), n = s._$GetX$_(), h = s._$GetY$_(), o = n - this._$_lastKnownX$_, a = h - this._$_lastKnownY$_, l = .001 < Math.abs(o) || .001 < Math.abs(a), u = s.GetAngle() !== this._$_lastKnownAngle$_, c = n, f = h;
                    if (2 === this._$_actualCollisionMask$_) {
                        const g = this._$_GetBoundingQuadExcludingMesh$_();
                        c = g._$midX$_(), f = g._$midY$_();
                    }
                    l ? (u ? r.SetTransform(b0(c * i, f * i), s.GetAngle()) : r.SetTransform(b0(c * i, f * i), r.GetAngle()), 
                    t && (r.SetLinearVelocity(b0(o, a)), this._$_lastTickOverride$_ = !0), 
                    r.SetAwake(!0)) : t && this._$_lastTickOverride$_ && (this._$_lastTickOverride$_ = !1, 
                    r.SetLinearVelocity(b0(0, 0)), r.SetTransform(b0(c * i, f * i), r.GetAngle())), 
                    !l && u && (r.SetTransform(r.GetPosition(), s.GetAngle()), r.SetAwake(!0));
                    const d = r.GetPosition(), p = d.get_x() / i, m = d.get_y() / i, C = r.GetAngle();
                    if ((p !== s._$GetX$_() || m !== s._$GetY$_() || C !== s.GetAngle()) && (s._$SetXY$_(p, m), 
                    s._$SetAngle$_(C), s._$SetBboxChanged$_(), 2 === this._$_actualCollisionMask$_)) {
                        const S = this._$_GetBoundingQuadExcludingMesh$_(), _ = S._$midX$_() - s._$GetX$_(), T = S._$midY$_() - s._$GetY$_();
                        0 == _ && 0 == T || (s._$OffsetXY$_(-_, -T), s._$SetBboxChanged$_());
                    }
                    this._$_lastKnownX$_ = s._$GetX$_(), this._$_lastKnownY$_ = s._$GetY$_(), 
                    this._$_lastKnownAngle$_ = s.GetAngle();
                }
                _$GetPropertyValueByIndex$_(t) {
                    switch (t) {
                      case Na:
                        return this._$_IsPreventRotate$_();

                      case Oa:
                        return this._$_GetDensity$_();

                      case Pa:
                        return this._$_GetFriction$_();

                      case Qa:
                        return this._$_GetElasticity$_();

                      case Ra:
                        return this._$_GetLinearDamping$_();

                      case Sa:
                        return this._$_GetAngularDamping$_();

                      case Ta:
                        return this._$_IsBullet$_();

                      case Ua:
                        return this._$_IsEnabled$_();
                    }
                }
                _$SetPropertyValueByIndex$_(t, e) {
                    switch (t) {
                      case Na:
                        this._$_SetPreventRotate$_(e);
                        break;

                      case Oa:
                        this._$_SetDensity$_(e);
                        break;

                      case Pa:
                        this._$_SetFriction$_(e);
                        break;

                      case Qa:
                        this._$_SetElasticity$_(e);
                        break;

                      case Ra:
                        this._$_SetLinearDamping$_(e);
                        break;

                      case Sa:
                        this._$_SetAngularDamping$_(e);
                        break;

                      case Ta:
                        this._$_SetBullet$_(e);
                        break;

                      case Ua:
                        this._$_SetEnabled$_(e);
                    }
                }
                _$_SetEnabled$_(t) {
                    t = !!t, this._$_isEnabled$_ && !t ? (this._$_RemoveOtherInstanceJointsToMe$_(), 
                    this._$_DestroyBody$_(), this._$_isEnabled$_ = !1, this._$_StopTicking$_()) : !this._$_isEnabled$_ && t && (this._$_isEnabled$_ = !0, 
                    this._$_CreateBody$_(), this._$_StartTicking$_());
                }
                _$_IsEnabled$_() {
                    return this._$_isEnabled$_;
                }
                _$GetDebuggerProperties$_() {
                    const t = "behaviors.physics", e = [ {
                        name: t + ".properties.enabled.name",
                        value: this._$_IsEnabled$_(),
                        _$onedit$_: t => this._$_SetEnabled$_(t)
                    }, {
                        name: t + ".properties.immovable.name",
                        value: this._$_IsImmovable$_(),
                        _$onedit$_: t => this._$_SetImmovable$_(t)
                    }, {
                        name: t + ".properties.density.name",
                        value: this._$_GetDensity$_(),
                        _$onedit$_: t => this._$_SetDensity$_(t)
                    }, {
                        name: t + ".properties.friction.name",
                        value: this._$_GetFriction$_(),
                        _$onedit$_: t => this._$_SetFriction$_(t)
                    }, {
                        name: t + ".properties.elasticity.name",
                        value: this._$_GetElasticity$_(),
                        _$onedit$_: t => this._$_SetElasticity$_(t)
                    }, {
                        name: t + ".properties.linear-damping.name",
                        value: this._$_GetLinearDamping$_(),
                        _$onedit$_: t => this._$_SetLinearDamping$_(t)
                    }, {
                        name: t + ".properties.angular-damping.name",
                        value: this._$_GetAngularDamping$_(),
                        _$onedit$_: t => this._$_SetAngularDamping$_(t)
                    } ];
                    return this._$_isEnabled$_ && (e.push({
                        name: t + ".debugger.is-sleeping",
                        value: !this._$_IsAwake$_()
                    }), e.push({
                        name: t + ".debugger.velocity-x",
                        value: this._$_GetVelocityX$_(),
                        _$onedit$_: t => this._$_SetVelocity$_(t, this._$_GetVelocityY$_())
                    }), e.push({
                        name: t + ".debugger.velocity-y",
                        value: this._$_GetVelocityY$_(),
                        _$onedit$_: t => this._$_SetVelocity$_(this._$_GetVelocityX$_(), t)
                    }), e.push({
                        name: t + ".debugger.angular-velocity",
                        value: Ha._$toDegrees$_(this._$_GetAngularVelocity$_()),
                        _$onedit$_: t => this._$_SetAngularVelocity$_(Ha._$toRadians$_(t))
                    }), e.push({
                        name: t + ".debugger.mass",
                        value: this._$_GetMass$_()
                    })), [ {
                        title: "$" + this._$GetBehaviorType$_()._$GetName$_(),
                        properties: e
                    } ];
                }
                _$_ApplyForce$_(t, e, s) {
                    const [ i, r ] = this._$_GetInstImagePoint$_(s);
                    this._$_DoApplyForce$_(t, e, i, r);
                }
                _$_ApplyForceToward$_(t, e, s, i) {
                    const [ r, n ] = this._$_GetInstImagePoint$_(i), h = Ha._$angleTo$_(r, n, e, s);
                    this._$_DoApplyForce$_(Math.cos(h) * t, Math.sin(h) * t, r, n);
                }
                _$_ApplyForceAtAngle$_(t, e, s) {
                    const [ i, r ] = this._$_GetInstImagePoint$_(s);
                    this._$_DoApplyForce$_(Math.cos(e) * t, Math.sin(e) * t, i, r);
                }
                _$_DoApplyForce$_(t, e, s, i) {
                    if (this._$_isEnabled$_) {
                        const r = this._$_worldScale$_;
                        this._$_body$_.ApplyForce(b0(t, e), c0(s * r, i * r), !0);
                    }
                }
                _$_ApplyImpulse$_(t, e, s) {
                    const [ i, r ] = this._$_GetInstImagePoint$_(s);
                    this._$_DoApplyImpulse$_(t, e, i, r);
                }
                _$_ApplyImpulseToward$_(t, e, s, i) {
                    const [ r, n ] = this._$_GetInstImagePoint$_(i), h = Ha._$angleTo$_(r, n, e, s);
                    this._$_DoApplyImpulse$_(Math.cos(h) * t, Math.sin(h) * t, r, n);
                }
                _$_ApplyImpulseAtAngle$_(t, e, s) {
                    const [ i, r ] = this._$_GetInstImagePoint$_(s);
                    this._$_DoApplyImpulse$_(Math.cos(e) * t, Math.sin(e) * t, i, r);
                }
                _$_DoApplyImpulse$_(t, e, s, i) {
                    if (this._$_isEnabled$_) {
                        const r = this._$_worldScale$_, n = (this._$_body$_.ApplyLinearImpulse(b0(t, e), c0(s * r, i * r), !0), 
                        this._$GetWorldInfo$_());
                        this._$_lastKnownX$_ = n._$GetX$_(), this._$_lastKnownY$_ = n._$GetY$_(), 
                        this._$_lastTickOverride$_ = !1;
                    }
                }
                _$_ApplyTorque$_(t) {
                    this._$_isEnabled$_ && this._$_body$_.ApplyTorque(t, !0);
                }
                _$_ApplyTorqueToAngle$_(t, e) {
                    const s = Ha._$angleClockwise$_(this._$GetWorldInfo$_().GetAngle(), e) ? -1 : 1;
                    this._$_ApplyTorque$_(t * s);
                }
                _$_ApplyTorqueToPosition$_(t, e, s) {
                    const i = this._$GetWorldInfo$_(), r = Ha._$angleTo$_(i._$GetX$_(), i._$GetY$_(), e, s), n = Ha._$angleClockwise$_(i.GetAngle(), r) ? -1 : 1;
                    this._$_ApplyTorque$_(t * n);
                }
                _$_SetAngularVelocity$_(t) {
                    this._$_isEnabled$_ && (this._$_body$_.SetAngularVelocity(t), 
                    this._$_body$_.SetAwake(!0));
                }
                _$_GetAngularVelocity$_() {
                    return this._$_isEnabled$_ ? this._$_body$_.GetAngularVelocity() : 0;
                }
                _$_SetVelocity$_(t, e) {
                    if (this._$_isEnabled$_) {
                        const s = this._$_worldScale$_, i = (this._$_body$_.SetLinearVelocity(b0(t * s, e * s)), 
                        this._$_body$_.SetAwake(!0), this._$GetWorldInfo$_());
                        this._$_lastKnownX$_ = i._$GetX$_(), this._$_lastKnownY$_ = i._$GetY$_(), 
                        this._$_lastTickOverride$_ = !1;
                    }
                }
                _$_GetVelocity$_() {
                    if (!this._$_isEnabled$_) return [ 0, 0 ];
                    const t = this._$_worldScale$_, e = this._$_body$_.GetLinearVelocity();
                    return [ e.get_x() / t, e.get_y() / t ];
                }
                _$_GetVelocityX$_() {
                    return this._$_isEnabled$_ ? this._$_body$_.GetLinearVelocity().get_x() / this._$_worldScale$_ : 0;
                }
                _$_GetVelocityY$_() {
                    return this._$_isEnabled$_ ? this._$_body$_.GetLinearVelocity().get_y() / this._$_worldScale$_ : 0;
                }
                _$_Teleport$_(t, e) {
                    if (this._$_isEnabled$_) {
                        const s = this._$_worldScale$_, i = (this._$_body$_.SetTransform(b0(t * s, e * s), this._$_body$_.GetAngle()), 
                        this._$GetWorldInfo$_());
                        i._$SetXY$_(t, e), i._$SetBboxChanged$_(), this._$_lastKnownX$_ = i._$GetX$_(), 
                        this._$_lastKnownY$_ = i._$GetY$_();
                    }
                }
                _$_SetDensity$_(t) {
                    if (this._$_isEnabled$_ && this._$_density$_ !== t) {
                        this._$_density$_ = t;
                        for (const e of this._$_fixtures$_) e.SetDensity(t);
                        this._$_body$_.ResetMassData();
                    }
                }
                _$_GetDensity$_() {
                    return this._$_isEnabled$_ ? this._$_density$_ : 0;
                }
                _$_SetFriction$_(t) {
                    if (this._$_isEnabled$_ && this._$_friction$_ !== t) {
                        this._$_friction$_ = t;
                        for (const e of this._$_fixtures$_) e.SetFriction(t);
                        if (this._$_body$_) for (let t = this._$_body$_.GetContactList(); this._$_box2d$_.getPointer(t); t = t.get_next()) {
                            const s = t.get_contact();
                            s && s.ResetFriction();
                        }
                    }
                }
                _$_GetFriction$_() {
                    return this._$_isEnabled$_ ? this._$_friction$_ : 0;
                }
                _$_SetElasticity$_(t) {
                    if (this._$_isEnabled$_ && this._$_restitution$_ !== t) {
                        this._$_restitution$_ = t;
                        for (const e of this._$_fixtures$_) e.SetRestitution(t);
                    }
                }
                _$_GetElasticity$_() {
                    return this._$_isEnabled$_ ? this._$_restitution$_ : 0;
                }
                _$_SetLinearDamping$_(t) {
                    this._$_isEnabled$_ && this._$_linearDamping$_ !== t && (this._$_linearDamping$_ = t, 
                    this._$_body$_.SetLinearDamping(t));
                }
                _$_GetLinearDamping$_() {
                    return this._$_isEnabled$_ ? this._$_linearDamping$_ : 0;
                }
                _$_SetAngularDamping$_(t) {
                    this._$_isEnabled$_ && this._$_angularDamping$_ !== t && (this._$_angularDamping$_ = t, 
                    this._$_body$_.SetAngularDamping(t));
                }
                _$_GetAngularDamping$_() {
                    return this._$_isEnabled$_ ? this._$_angularDamping$_ : 0;
                }
                _$_SetImmovable$_(t) {
                    this._$_isEnabled$_ && this._$_isImmovable$_ !== (t = !!t) && (this._$_isImmovable$_ = t, 
                    this._$_body$_.SetType(this._$_isImmovable$_ ? 0 : 2), this._$_body$_.SetAwake(!0));
                }
                _$_IsImmovable$_() {
                    return this._$_isImmovable$_;
                }
                _$_SetPreventRotate$_(t) {
                    this._$_isEnabled$_ && this._$_preventRotation$_ !== (t = !!t) && (this._$_preventRotation$_ = t, 
                    this._$_body$_.SetFixedRotation(this._$_preventRotation$_), 
                    this._$_body$_.SetAngularVelocity(0), this._$_body$_.SetAwake(!0));
                }
                _$_IsPreventRotate$_() {
                    return this._$_preventRotation$_;
                }
                _$_SetBullet$_(t) {
                    this._$_isEnabled$_ && this._$_isBullet$_ !== (t = !!t) && (this._$_isBullet$_ = t, 
                    this._$_body$_.SetBullet(this._$_isBullet$_), this._$_body$_.SetAwake(!0));
                }
                _$_IsBullet$_() {
                    return this._$_isBullet$_;
                }
                _$_SetAwake$_(t) {
                    this._$_isEnabled$_ && this._$_body$_.SetAwake(!!t);
                }
                _$_IsAwake$_() {
                    return !!this._$_isEnabled$_ && this._$_body$_.IsAwake();
                }
                _$_GetMass$_() {
                    return this._$_isEnabled$_ ? this._$_body$_.GetMass() / this._$_worldScale$_ : 0;
                }
                _$_GetCenterOfMassX$_() {
                    return this._$_isEnabled$_ ? this._$_body$_.GetWorldCenter().get_x() / this._$_worldScale$_ : 0;
                }
                _$_GetCenterOfMassY$_() {
                    return this._$_isEnabled$_ ? this._$_body$_.GetWorldCenter().get_y() / this._$_worldScale$_ : 0;
                }
                _$_GetCenterOfMass$_() {
                    if (!this._$_isEnabled$_) return [ 0, 0 ];
                    const t = this._$_body$_.GetWorldCenter(), e = this._$_worldScale$_;
                    return [ t.get_x() / e, t.get_y() / e ];
                }
                _$_GetContactCount$_() {
                    if (!this._$_isEnabled$_) return 0;
                    let e = 0;
                    for (let t = this._$_body$_.GetContactList(); this._$_box2d$_.getPointer(t); t = t.get_next()) {
                        const s = t.get_contact();
                        if (s) {
                            const i = s.GetManifold(), r = i.get_pointCount();
                            e += r;
                        }
                    }
                    return e;
                }
                _$_GetContactPositionAt$_(s) {
                    if (s = Math.floor(s), this._$_isEnabled$_) {
                        let e = 0;
                        for (let t = this._$_body$_.GetContactList(); this._$_box2d$_.getPointer(t); t = t.get_next()) {
                            const i = t.get_contact();
                            if (i) {
                                const r = i.GetManifold(), n = r.get_pointCount();
                                if (s >= e && s < e + n) {
                                    const h = s - e, o = this._$GetBehavior$_().GetWorldManifold(), a = (i.GetWorldManifold(o), 
                                    o.get_points(h));
                                    return [ a.get_x() / this._$_worldScale$_, a.get_y() / this._$_worldScale$_ ];
                                }
                                e += n;
                            }
                        }
                    }
                    return [ 0, 0 ];
                }
                _$GetScriptInterfaceClass$_() {
                    return self._$IPhysicsBehaviorInstance$_;
                }
            }, new WeakMap());
            self._$IPhysicsBehaviorInstance$_ = class extends Ja {
                constructor() {
                    super(), f0.set(this, Ja._$_GetInitInst$_()._$GetSdkInstance$_());
                }
                get isEnabled() {
                    return f0.get(this)._$_IsEnabled$_();
                }
                set isEnabled(t) {
                    f0.get(this)._$_SetEnabled$_(t);
                }
                _$applyForce$_(t, e, s = 0) {
                    Ia._$RequireFiniteNumber$_(t), Ia._$RequireFiniteNumber$_(e), 
                    f0.get(this)._$_ApplyForce$_(t, e, s);
                }
                _$applyForceTowardPosition$_(t, e, s, i = 0) {
                    Ia._$RequireFiniteNumber$_(t), Ia._$RequireFiniteNumber$_(e), 
                    Ia._$RequireFiniteNumber$_(s), f0.get(this)._$_ApplyForceToward$_(t, e, s, i);
                }
                _$applyForceAtAngle$_(t, e, s = 0) {
                    Ia._$RequireFiniteNumber$_(t), Ia._$RequireFiniteNumber$_(e), 
                    f0.get(this)._$_ApplyForceAtAngle$_(t, e, s);
                }
                _$applyImpulse$_(t, e, s = 0) {
                    Ia._$RequireFiniteNumber$_(t), Ia._$RequireFiniteNumber$_(e), 
                    f0.get(this)._$_ApplyImpulse$_(t, e, s);
                }
                _$applyImpulseTowardPosition$_(t, e, s, i = 0) {
                    Ia._$RequireFiniteNumber$_(t), Ia._$RequireFiniteNumber$_(e), 
                    Ia._$RequireFiniteNumber$_(s), f0.get(this)._$_ApplyImpulseToward$_(t, e, s, i);
                }
                _$applyImpulseAtAngle$_(t, e, s = 0) {
                    Ia._$RequireFiniteNumber$_(t), Ia._$RequireFiniteNumber$_(e), 
                    f0.get(this)._$_ApplyImpulseAtAngle$_(t, e, s);
                }
                _$applyTorque$_(t) {
                    Ia._$RequireFiniteNumber$_(t), f0.get(this)._$_ApplyTorque$_(t);
                }
                _$applyTorqueToAngle$_(t, e) {
                    Ia._$RequireFiniteNumber$_(t), Ia._$RequireFiniteNumber$_(e), 
                    f0.get(this)._$_ApplyTorqueToAngle$_(t, e);
                }
                _$applyTorqueToPosition$_(t, e, s) {
                    Ia._$RequireFiniteNumber$_(t), Ia._$RequireFiniteNumber$_(e), 
                    Ia._$RequireFiniteNumber$_(s), f0.get(this)._$_ApplyTorqueToPosition$_(t, e, s);
                }
                set angularVelocity(t) {
                    Ia._$RequireFiniteNumber$_(t), f0.get(this)._$_SetAngularVelocity$_(t);
                }
                get angularVelocity() {
                    return f0.get(this)._$_GetAngularVelocity$_();
                }
                setVelocity(t, e) {
                    Ia._$RequireFiniteNumber$_(t), Ia._$RequireFiniteNumber$_(e), 
                    f0.get(this)._$_SetVelocity$_(t, e);
                }
                _$getVelocityX$_() {
                    return f0.get(this)._$_GetVelocityX$_();
                }
                _$getVelocityY$_() {
                    return f0.get(this)._$_GetVelocityY$_();
                }
                _$getVelocity$_() {
                    return f0.get(this)._$_GetVelocity$_();
                }
                _$teleport$_(t, e) {
                    Ia._$RequireFiniteNumber$_(t), Ia._$RequireFiniteNumber$_(e), 
                    f0.get(this)._$_Teleport$_(t, e);
                }
                set _$density$_(t) {
                    Ia._$RequireFiniteNumber$_(t), f0.get(this)._$_SetDensity$_(t);
                }
                get _$density$_() {
                    return f0.get(this)._$_GetDensity$_();
                }
                set _$friction$_(t) {
                    Ia._$RequireFiniteNumber$_(t), f0.get(this)._$_SetFriction$_(t);
                }
                get _$friction$_() {
                    return f0.get(this)._$_GetFriction$_();
                }
                set _$elasticity$_(t) {
                    Ia._$RequireFiniteNumber$_(t), f0.get(this)._$_SetElasticity$_(t);
                }
                get _$elasticity$_() {
                    return f0.get(this)._$_GetElasticity$_();
                }
                set _$linearDamping$_(t) {
                    Ia._$RequireFiniteNumber$_(t), f0.get(this)._$_SetLinearDamping$_(t);
                }
                get _$linearDamping$_() {
                    return f0.get(this)._$_GetLinearDamping$_();
                }
                set _$angularDamping$_(t) {
                    Ia._$RequireFiniteNumber$_(t), f0.get(this)._$_SetAngularDamping$_(t);
                }
                get _$angularDamping$_() {
                    return f0.get(this)._$_GetAngularDamping$_();
                }
                set _$isImmovable$_(t) {
                    f0.get(this)._$_SetImmovable$_(t);
                }
                get _$isImmovable$_() {
                    return f0.get(this)._$_IsImmovable$_();
                }
                set _$isPreventRotation$_(t) {
                    f0.get(this)._$_SetPreventRotate$_(t);
                }
                get _$isPreventRotation$_() {
                    return f0.get(this)._$_IsPreventRotate$_();
                }
                set _$isBullet$_(t) {
                    f0.get(this)._$_SetBullet$_(t);
                }
                get _$isBullet$_() {
                    return f0.get(this)._$_IsBullet$_();
                }
                get _$mass$_() {
                    return f0.get(this)._$_GetMass$_();
                }
                _$getCenterOfMassX$_() {
                    return f0.get(this)._$_GetCenterOfMassX$_();
                }
                _$getCenterOfMassY$_() {
                    return f0.get(this)._$_GetCenterOfMassY$_();
                }
                _$getCenterOfMass$_() {
                    return f0.get(this)._$_GetCenterOfMass$_();
                }
                _$getContactCount$_() {
                    return f0.get(this)._$_GetContactCount$_();
                }
                _$getContactX$_(t) {
                    return Ia._$RequireFiniteNumber$_(t), f0.get(this)._$_GetContactPositionAt$_(t)[0];
                }
                _$getContactY$_(t) {
                    return Ia._$RequireFiniteNumber$_(t), f0.get(this)._$_GetContactPositionAt$_(t)[1];
                }
                _$getContact$_(t) {
                    return Ia._$RequireFiniteNumber$_(t), f0.get(this)._$_GetContactPositionAt$_(t);
                }
                set _$isAwake$_(t) {
                    f0.get(this)._$_SetAwake$_(!!t);
                }
                get _$isAwake$_() {
                    return f0.get(this)._$_IsAwake$_();
                }
                get _$isSleeping$_() {
                    return !f0.get(this)._$_IsAwake$_();
                }
                _$createDistanceJoint$_(t, e, s, i, r) {
                    Ia._$RequireFiniteNumber$_(i), Ia._$RequireFiniteNumber$_(r);
                    const n = UnwrapIWorldInstance2(this, e);
                    f0.get(this)._$_CreateDistanceJoint$_(t, n, s, i, r);
                }
                _$createRevoluteJoint$_(t, e) {
                    const s = UnwrapIWorldInstance2(this, e);
                    f0.get(this)._$_CreateRevoluteJoint$_(t, s);
                }
                _$createLimitedRevoluteJoint$_(t, e, s, i) {
                    Ia._$RequireFiniteNumber$_(s), Ia._$RequireFiniteNumber$_(i);
                    const r = UnwrapIWorldInstance2(this, e);
                    f0.get(this)._$_CreateLimitedRevoluteJoint$_(t, r, s, i);
                }
                _$createPrismaticJoint$_(t, e, s, i, r, n, h, o, a) {
                    const l = UnwrapIWorldInstance2(this, e);
                    f0.get(this)._$_CreatePrismaticJoint$_(t, l, s, i, r, n, h, o, a);
                }
                _$removeAllJoints$_() {
                    f0.get(this)._$_RemoveJoints$_();
                }
            };
        }
        {
            const we = self._$C3$_;
            we._$Behaviors$_._$Physics$_._$Cnds$_ = {
                _$IsSleeping$_() {
                    return !this._$_IsAwake$_();
                },
                _$IsImmovable$_() {
                    return this._$_IsImmovable$_();
                },
                _$CompareVelocity$_(t, e, s) {
                    if (!this._$_isEnabled$_) return !1;
                    let i = 0;
                    if (0 === t) i = this._$_GetVelocityX$_(); else if (1 === t) i = this._$_GetVelocityY$_(); else {
                        const [ r, n ] = this._$_GetVelocity$_();
                        i = Math.hypot(r, n);
                    }
                    return we.compare(i, e, s);
                },
                _$CompareAngularVelocity$_(t, e) {
                    if (!this._$_isEnabled$_) return !1;
                    const s = we._$toDegrees$_(this._$_GetAngularVelocity$_());
                    return we.compare(s, t, e);
                },
                _$CompareMass$_(t, e) {
                    if (!this._$_isEnabled$_) return !1;
                    const s = this._$_GetMass$_();
                    return we.compare(s, t, e);
                },
                _$IsEnabled$_() {
                    return this._$_IsEnabled$_();
                }
            };
        }
        {
            const Je = self._$C3$_;
            Je._$Behaviors$_._$Physics$_._$Acts$_ = {
                ApplyForce(t, e, s) {
                    this._$_ApplyForce$_(t, e, s);
                },
                _$ApplyForceToward$_(t, e, s, i) {
                    this._$_ApplyForceToward$_(t, e, s, i);
                },
                _$ApplyForceAtAngle$_(t, e, s) {
                    this._$_ApplyForceAtAngle$_(t, Je._$toRadians$_(e), s);
                },
                _$ApplyImpulse$_(t, e, s) {
                    this._$_ApplyImpulse$_(t, e, s);
                },
                _$ApplyImpulseToward$_(t, e, s, i) {
                    this._$_ApplyImpulseToward$_(t, e, s, i);
                },
                _$ApplyImpulseAtAngle$_(t, e, s) {
                    this._$_ApplyImpulseAtAngle$_(t, Je._$toRadians$_(e), s);
                },
                ApplyTorque(t) {
                    this._$_ApplyTorque$_(Je._$toRadians$_(t));
                },
                _$ApplyTorqueToAngle$_(t, e) {
                    this._$_ApplyTorqueToAngle$_(Je._$toRadians$_(t), Je._$toRadians$_(e));
                },
                _$ApplyTorqueToPosition$_(t, e, s) {
                    this._$_ApplyTorqueToPosition$_(Je._$toRadians$_(t), e, s);
                },
                SetAngularVelocity(t) {
                    this._$_SetAngularVelocity$_(Je._$toRadians$_(t));
                },
                _$CreateDistanceJoint$_(t, e, s, i, r) {
                    if (e) {
                        const n = e._$GetFirstPicked$_(this._$_inst$_);
                        this._$_CreateDistanceJoint$_(t, n, s, i, r);
                    }
                },
                _$CreateRevoluteJoint$_(t, e) {
                    if (e) {
                        const s = e._$GetFirstPicked$_(this._$_inst$_);
                        this._$_CreateRevoluteJoint$_(t, s);
                    }
                },
                _$CreateLimitedRevoluteJoint$_(t, e, s, i) {
                    if (e) {
                        const r = e._$GetFirstPicked$_(this._$_inst$_);
                        this._$_CreateLimitedRevoluteJoint$_(t, r, Je._$toRadians$_(s), Je._$toRadians$_(i));
                    }
                },
                _$CreatePrismaticJoint$_(t, e, s, i, r, n, h, o, a) {
                    if (e) {
                        const l = e._$GetFirstPicked$_(this._$_inst$_);
                        this._$_CreatePrismaticJoint$_(t, l, Je._$toRadians$_(s), i, r, n, h, Je._$toRadians$_(o), a);
                    }
                },
                _$RemoveJoints$_() {
                    this._$_RemoveJoints$_();
                },
                _$SetWorldGravity$_(t) {
                    this._$GetBehavior$_().SetGravity(t);
                },
                _$SetSteppingMode$_(t) {
                    this._$GetBehavior$_()._$SetSteppingMode$_(t);
                },
                _$SetIterations$_(t, e) {
                    this._$GetBehavior$_()._$SetIterations$_(t, e);
                },
                _$SetVelocity$_(t, e) {
                    this._$_SetVelocity$_(t, e);
                },
                _$Teleport$_(t, e) {
                    this._$_Teleport$_(t, e);
                },
                SetDensity(t) {
                    this._$_SetDensity$_(t);
                },
                SetFriction(t) {
                    this._$_SetFriction$_(t);
                },
                _$SetElasticity$_(t) {
                    this._$_SetElasticity$_(t);
                },
                SetLinearDamping(t) {
                    this._$_SetLinearDamping$_(t);
                },
                SetAngularDamping(t) {
                    this._$_SetAngularDamping$_(t);
                },
                _$SetImmovable$_(t) {
                    this._$_SetImmovable$_(t);
                },
                _$EnableCollisions$_(t, e) {
                    this._$GetBehavior$_()._$SetCollisionsEnabled$_(this._$GetObjectClass$_(), t, 0 !== e);
                },
                _$SetPreventRotate$_(t) {
                    this._$_SetPreventRotate$_(0 !== t);
                },
                SetBullet(t) {
                    this._$_SetBullet$_(0 !== t);
                },
                SetAwake(t) {
                    this._$_SetAwake$_(!!t);
                },
                _$SetEnabled$_(t) {
                    this._$_SetEnabled$_(0 !== t);
                }
            };
        }
        {
            const _4 = self._$C3$_;
            _4._$Behaviors$_._$Physics$_._$Exps$_ = {
                _$VelocityX$_() {
                    return this._$_GetVelocityX$_();
                },
                _$VelocityY$_() {
                    return this._$_GetVelocityY$_();
                },
                _$AngularVelocity$_() {
                    return _4._$toDegrees$_(this._$_GetAngularVelocity$_());
                },
                _$Mass$_() {
                    return this._$_GetMass$_();
                },
                _$CenterOfMassX$_() {
                    return this._$_GetCenterOfMassX$_();
                },
                _$CenterOfMassY$_() {
                    return this._$_GetCenterOfMassY$_();
                },
                _$Density$_() {
                    return this._$_GetDensity$_();
                },
                _$Friction$_() {
                    return this._$_GetFriction$_();
                },
                _$Elasticity$_() {
                    return this._$_GetElasticity$_();
                },
                _$LinearDamping$_() {
                    return this._$_GetLinearDamping$_();
                },
                _$AngularDamping$_() {
                    return this._$_GetAngularDamping$_();
                },
                _$ContactCount$_() {
                    return this._$_GetContactCount$_();
                },
                _$ContactXAt$_(t) {
                    return this._$_GetContactPositionAt$_(t)[0];
                },
                _$ContactYAt$_(t) {
                    return this._$_GetContactPositionAt$_(t)[1];
                }
            };
        }
        {
            let CloneVec22 = function(t) {
                return GetVec2(t.get_x(), t.get_y());
            }, SplitConvexPolysOver8Points2 = function(t) {
                const e = [];
                for (const s of t) s.length <= 8 ? e.push(s) : e.push.apply(e, SplitConvexPoly2(s));
                return e;
            }, SplitConvexPoly2 = function(s) {
                let i = [], r = (i.push(s.splice(0, 8)), i[0][0]), n = i[0][7];
                for (;s.length; ) {
                    let t = s.splice(0, Math.min(s.length, 6)), e = t.at(-1);
                    t.push(CloneVec22(r)), t.push(CloneVec22(n)), i.push(t), n = e;
                }
                return i;
            };
            CloneVec2 = CloneVec22, SplitConvexPolysOver8Points = SplitConvexPolysOver8Points2, 
            SplitConvexPoly = SplitConvexPoly2;
            const C33 = self._$C3$_, b2Separator = {}, GetVec2 = (C33._$Behaviors$_._$Physics$_._$Separator$_ = b2Separator, 
            C33._$Behaviors$_._$Physics$_._$GetVec2$_), FreeVec2 = C33._$Behaviors$_._$Physics$_._$FreeVec2$_;
            b2Separator._$det$_ = function(t, e, s, i, r, n) {
                return t * i + s * n + r * e - e * s - i * r - n * t;
            }, b2Separator._$hitRay$_ = function(t, e, s, i, r, n, h, o) {
                const a = r - t, l = n - e, u = s - t, c = i - e, f = h - r, d = o - n, p = c * f - u * d, m = (f * l - d * a) / p, C = t + m * u, g = e + m * c, S = b2Separator._$isOnSegment$_(s, i, t, e, C, g), _ = b2Separator._$isOnSegment$_(C, g, r, n, h, o);
                return S && _ ? GetVec2(C, g) : null;
            }, b2Separator._$isOnSegment$_ = function(t, e, s, i, r, n) {
                const h = t <= s + .1 && r - .1 <= t || s - .1 <= t && t <= r + .1, o = e <= i + .1 && n - .1 <= e || i - .1 <= e && e <= n + .1;
                return h && o && b2Separator._$isOnLine$_(t, e, s, i, r, n);
            }, b2Separator._$isOnLine$_ = function(t, e, s, i, r, n) {
                if (.1 < Math.abs(r - s)) {
                    const h = (n - i) / (r - s), o = h * (t - s) + i, a = Math.abs(o - e);
                    return a < .1;
                }
                return Math.abs(t - s) < .1;
            }, b2Separator._$pointsMatch$_ = function(t, e, s, i) {
                return Math.abs(s - t) < .1 && Math.abs(i - e) < .1;
            }, b2Separator._$Separate$_ = function(t, n) {
                let h = b2Separator._$calcShapes$_(t), o = [];
                for (let t = 0, e = h.length; t < e; ++t) {
                    let s = h[t], i = [], r = 0;
                    for (let t = 0, e = s.length; t < e; ++t) {
                        const a = s[t], l = s[(t + 1) % e];
                        r += a.get_x() * l.get_y() - a.get_y() * l.get_x(), i.push(GetVec2(a.get_x(), a.get_y()));
                    }
                    if ((r = Math.abs(r / 2)) >= .001 * n) o.push(i); else for (let t = 0, e = i.length; t < e; t++) FreeVec2(i[t]);
                }
                return o = SplitConvexPolysOver8Points2(o);
            }, b2Separator._$calcShapes$_ = function(t) {
                let e = [], s = 0, i, r = 0, n, h, o, a = 0, l, u, c, f, d, p, m, C, g, S, _ = 0, T = 0, y = 0, E = 0, A = [], I = [], M = !1, w = [], v = [], R = !1;
                for (v.push(t); v.length; ) {
                    for (i = (e = v[0]).length, M = !0, s = 0; s < i; s++) if (u = (l = s) < i - 1 ? s + 1 : s + 1 - i, 
                    c = s < i - 2 ? s + 2 : s + 2 - i, f = e[l], d = e[u], p = e[c], 
                    b2Separator._$det$_(f.get_x(), f.get_y(), d.get_x(), d.get_y(), p.get_x(), p.get_y()) < 0) {
                        for (M = !1, a = 1e9, r = 0; r < i; r++) r !== l && r !== u && (_ = r, 
                        T = r < i - 1 ? r + 1 : 0, m = e[_], C = e[T], g = b2Separator._$hitRay$_(f.get_x(), f.get_y(), d.get_x(), d.get_y(), m.get_x(), m.get_y(), C.get_x(), C.get_y())) && ((n = (h = d.get_x() - g.get_x()) * h + (o = d.get_y() - g.get_y()) * o) < a ? (E = _, 
                        y = T, S = g, a = n) : FreeVec2(g));
                        if (1e9 === a) return [];
                        for (A = [], I = [], _ = E, T = y, m = e[_], C = e[T], R = !1, 
                        b2Separator._$pointsMatch$_(S.get_x(), S.get_y(), C.get_x(), C.get_y()) || (A.push(S), 
                        R = !0), b2Separator._$pointsMatch$_(S.get_x(), S.get_y(), m.get_x(), m.get_y()) || (I.push(S), 
                        R = !0), R || FreeVec2(S), E = -1, y = l; ;) {
                            if (y === T) {
                                if (E < 0 || E >= i) return [];
                                b2Separator._$isOnSegment$_(C.get_x(), C.get_y(), e[E].get_x(), e[E].get_y(), f.get_x(), f.get_y()) || A.push(e[y]);
                                break;
                            }
                            A.push(e[y]), (E = y) - 1 < 0 ? y = i - 1 : y--;
                        }
                        for (A.reverse(), E = -1, y = u; ;) {
                            if (y === _) {
                                if (E < 0 || E >= i) return [];
                                y !== _ || b2Separator._$isOnSegment$_(m.get_x(), m.get_y(), e[E].get_x(), e[E].get_y(), d.get_x(), d.get_y()) || I.push(e[y]);
                                break;
                            }
                            I.push(e[y]), (E = y) + 1 > i - 1 ? y = 0 : y++;
                        }
                        v.push(A, I), v.shift();
                        break;
                    }
                    M && w.push(v.shift());
                }
                return w;
            };
        }
        {
            const a = self._$C3$_;
            a._$Behaviors$_._$jumpthru$_ = class extends a._$SDKBehaviorBase$_ {
                constructor(t) {
                    super(t);
                }
                _$Release$_() {
                    super._$Release$_();
                }
            };
        }
        {
            const d = self._$C3$_;
            d._$Behaviors$_._$jumpthru$_._$Type$_ = class extends d._$SDKBehaviorTypeBase$_ {
                constructor(t) {
                    super(t);
                }
                _$Release$_() {
                    super._$Release$_();
                }
                _$OnCreate$_() {}
            };
        }
        {
            const g = self._$C3$_, h = self._$IBehaviorInstance$_, i = 0, j = (g._$Behaviors$_._$jumpthru$_.Instance = class extends g._$SDKBehaviorInstanceBase$_ {
                constructor(t, e) {
                    super(t), this._$SetEnabled$_(!0), e && this._$SetEnabled$_(e[i]);
                }
                _$Release$_() {
                    super._$Release$_();
                }
                _$SetEnabled$_(t) {
                    this._$_inst$_._$_SetJumpthruEnabled$_(!!t);
                }
                _$IsEnabled$_() {
                    return this._$_inst$_._$_IsJumpthruEnabled$_();
                }
                _$SaveToJson$_() {
                    return {
                        e: this._$IsEnabled$_()
                    };
                }
                _$LoadFromJson$_(t) {
                    this._$SetEnabled$_(t.e);
                }
                _$GetPropertyValueByIndex$_(t) {
                    if (t === i) return this._$IsEnabled$_();
                }
                _$SetPropertyValueByIndex$_(t, e) {
                    t === i && this._$SetEnabled$_(e);
                }
                _$GetDebuggerProperties$_() {
                    return [ {
                        title: "$" + this._$GetBehaviorType$_()._$GetName$_(),
                        properties: [ {
                            name: "behaviors.jumpthru.properties.enabled.name",
                            value: this._$IsEnabled$_(),
                            _$onedit$_: t => this._$SetEnabled$_(t)
                        } ]
                    } ];
                }
                _$GetScriptInterfaceClass$_() {
                    return self._$IJumpthruBehaviorInstance$_;
                }
            }, new WeakMap());
            self._$IJumpthruBehaviorInstance$_ = class extends h {
                constructor() {
                    super(), j.set(this, h._$_GetInitInst$_()._$GetSdkInstance$_());
                }
                set isEnabled(t) {
                    j.get(this)._$SetEnabled$_(!!t);
                }
                get isEnabled() {
                    return j.get(this)._$IsEnabled$_();
                }
            };
        }
        {
            const v = self._$C3$_;
            v._$Behaviors$_._$jumpthru$_._$Cnds$_ = {
                _$IsEnabled$_() {
                    return this._$IsEnabled$_();
                }
            };
        }
        {
            const w = self._$C3$_;
            w._$Behaviors$_._$jumpthru$_._$Acts$_ = {
                _$SetEnabled$_(t) {
                    this._$SetEnabled$_(t);
                }
            };
        }
        {
            const y = self._$C3$_;
            y._$Behaviors$_._$jumpthru$_._$Exps$_ = {};
        }
        {
            const a = self._$C3$_;
            a._$Behaviors$_._$Pin$_ = class extends a._$SDKBehaviorBase$_ {
                constructor(t) {
                    super(t);
                }
                _$Release$_() {
                    super._$Release$_();
                }
            };
        }
        {
            const d = self._$C3$_;
            d._$Behaviors$_._$Pin$_._$Type$_ = class extends d._$SDKBehaviorTypeBase$_ {
                constructor(t) {
                    super(t);
                }
                _$Release$_() {
                    super._$Release$_();
                }
                _$OnCreate$_() {}
            };
        }
        {
            const g = self._$C3$_;
            g._$Behaviors$_._$Pin$_.Instance = class extends g._$SDKBehaviorInstanceBase$_ {
                constructor(t, e) {
                    super(t), this._$_pinInst$_ = null, this._$_pinUid$_ = -1, this._$_mode$_ = "", 
                    this._$_propSet$_ = new Set(), this._$_pinDist$_ = 0, this._$_pinAngle$_ = 0, 
                    this._$_pinImagePoint$_ = 0, this._$_dx$_ = 0, this._$_dy$_ = 0, 
                    this._$_dWidth$_ = 0, this._$_dHeight$_ = 0, this._$_dAngle$_ = 0, 
                    this._$_dz$_ = 0, this._$_lastKnownAngle$_ = 0, this._$_destroy$_ = !1, 
                    e && (this._$_destroy$_ = e[0]);
                    const s = this._$_runtime$_._$Dispatcher$_();
                    this._$_disposables$_ = new g._$CompositeDisposable$_(g._$Disposable$_._$From$_(s, "instancedestroy", t => this._$_OnInstanceDestroyed$_(t.instance)), g._$Disposable$_._$From$_(s, "afterload", t => this._$_OnAfterLoad$_()));
                }
                _$Release$_() {
                    this._$_pinInst$_ = null, super._$Release$_();
                }
                _$_SetPinInst$_(t) {
                    t ? (this._$_pinInst$_ = t, this._$_StartTicking2$_()) : (this._$_pinInst$_ = null, 
                    this._$_StopTicking2$_());
                }
                _$_Pin$_(t, e, s) {
                    if (t) {
                        const i = t._$GetFirstPicked$_(this._$_inst$_);
                        if (i) {
                            this._$_mode$_ = e, this._$_SetPinInst$_(i);
                            const r = this._$_inst$_._$GetWorldInfo$_(), n = i._$GetWorldInfo$_();
                            if ("properties" === this._$_mode$_) {
                                const h = this._$_propSet$_;
                                h.clear();
                                for (const o of s) h.add(o);
                                this._$_dx$_ = r._$GetX$_() - n._$GetX$_(), this._$_dy$_ = r._$GetY$_() - n._$GetY$_(), 
                                this._$_dAngle$_ = r.GetAngle() - n.GetAngle(), 
                                this._$_lastKnownAngle$_ = r.GetAngle(), this._$_dz$_ = r._$GetZElevation$_() - n._$GetZElevation$_(), 
                                h.has("x") && h.has("y") && (this._$_pinAngle$_ = g._$angleTo$_(n._$GetX$_(), n._$GetY$_(), r._$GetX$_(), r._$GetY$_()) - n.GetAngle(), 
                                this._$_pinDist$_ = g._$distanceTo$_(n._$GetX$_(), n._$GetY$_(), r._$GetX$_(), r._$GetY$_())), 
                                h.has("width-abs") ? this._$_dWidth$_ = r._$GetWidth$_() - n._$GetWidth$_() : h.has("width-scale") && (this._$_dWidth$_ = r._$GetWidth$_() / n._$GetWidth$_()), 
                                h.has("height-abs") ? this._$_dHeight$_ = r._$GetHeight$_() - n._$GetHeight$_() : h.has("height-scale") && (this._$_dHeight$_ = r._$GetHeight$_() / n._$GetHeight$_());
                            } else this._$_pinDist$_ = g._$distanceTo$_(n._$GetX$_(), n._$GetY$_(), r._$GetX$_(), r._$GetY$_());
                        }
                    }
                }
                _$SaveToJson$_() {
                    const t = this._$_propSet$_, e = this._$_mode$_, s = {
                        uid: this._$_pinInst$_ && !this._$_pinInst$_._$IsDestroyed$_() ? this._$_pinInst$_._$GetUID$_() : -1,
                        m: e,
                        d: this._$_destroy$_
                    };
                    return "rope" === e || "bar" === e ? s.pd = this._$_pinDist$_ : "properties" === e && (s.ps = [ ...this._$_propSet$_ ], 
                    t.has("imagepoint") ? s.ip = this._$_pinImagePoint$_ : t.has("x") && t.has("y") ? (s.pa = this._$_pinAngle$_, 
                    s.pd = this._$_pinDist$_) : (t.has("x") && (s.dx = this._$_dx$_), 
                    t.has("y") && (s.dy = this._$_dy$_)), t.has("angle") && (s.da = this._$_dAngle$_, 
                    s.lka = this._$_lastKnownAngle$_), (t.has("width-abs") || t.has("width-scale")) && (s.dw = this._$_dWidth$_), 
                    (t.has("height-abs") || t.has("height-scale")) && (s.dh = this._$_dHeight$_), 
                    t.has("z")) && (s.dz = this._$_dz$_), s;
                }
                _$LoadFromJson$_(t) {
                    const e = t.m, s = this._$_propSet$_;
                    if (s.clear(), this._$_pinUid$_ = t.uid, "number" == typeof e) this._$_LoadFromJson_Legacy$_(t); else if (this._$_mode$_ = e, 
                    t.hasOwnProperty("d") && (this._$_destroy$_ = !!t.d), "rope" === e || "bar" === e) this._$_pinDist$_ = t.pd; else if ("properties" === e) {
                        for (const i of t.ps) s.add(i);
                        s.has("imagepoint") ? this._$_pinImagePoint$_ = t.ip : s.has("x") && s.has("y") ? (this._$_pinAngle$_ = t.pa, 
                        this._$_pinDist$_ = t.pd) : (s.has("x") && (this._$_dx$_ = t.dx), 
                        s.has("y") && (this._$_dy$_ = t.dy)), s.has("angle") && (this._$_dAngle$_ = t.da, 
                        this._$_lastKnownAngle$_ = t.lka || 0), (s.has("width-abs") || s.has("width-scale")) && (this._$_dWidth$_ = t.dw), 
                        (s.has("height-abs") || s.has("height-scale")) && (this._$_dHeight$_ = t.dh), 
                        s.has("z") && (this._$_dz$_ = t.dz);
                    }
                }
                _$_LoadFromJson_Legacy$_(t) {
                    const e = this._$_propSet$_, s = t.msa, i = t.tsa, r = t.pa, n = t.pd, h = t.m;
                    switch (h) {
                      case 0:
                        this._$_mode$_ = "properties", e.add("x").add("y").add("angle"), 
                        this._$_pinAngle$_ = r, this._$_pinDist$_ = n, this._$_dAngle$_ = s - i, 
                        this._$_lastKnownAngle$_ = t.lka;
                        break;

                      case 1:
                        this._$_mode$_ = "properties", e.add("x").add("y"), this._$_pinAngle$_ = r, 
                        this._$_pinDist$_ = n;
                        break;

                      case 2:
                        this._$_mode$_ = "properties", e.add("angle"), this._$_dAngle$_ = s - i, 
                        this._$_lastKnownAngle$_ = t.lka;
                        break;

                      case 3:
                        this._$_mode$_ = "rope", this._$_pinDist$_ = t.pd;
                        break;

                      case 4:
                        this._$_mode$_ = "bar", this._$_pinDist$_ = t.pd;
                    }
                }
                _$_OnAfterLoad$_() {
                    -1 === this._$_pinUid$_ ? this._$_SetPinInst$_(null) : (this._$_SetPinInst$_(this._$_runtime$_._$GetInstanceByUID$_(this._$_pinUid$_)), 
                    this._$_pinUid$_ = -1);
                }
                _$_OnInstanceDestroyed$_(t) {
                    this._$_pinInst$_ === t && (this._$_SetPinInst$_(null), this._$_destroy$_) && this._$_runtime$_._$DestroyInstance$_(this._$_inst$_);
                }
                _$Tick2$_() {
                    const n = this._$_pinInst$_;
                    if (n && !n._$IsDestroyed$_()) {
                        let s = n._$GetWorldInfo$_(), t = this._$_inst$_, i = t._$GetWorldInfo$_(), e = this._$_mode$_, r = !1;
                        if ("rope" === e || "bar" === e) {
                            const h = g._$distanceTo$_(i._$GetX$_(), i._$GetY$_(), s._$GetX$_(), s._$GetY$_());
                            if (h > this._$_pinDist$_ || "bar" === e && h < this._$_pinDist$_) {
                                const o = g._$angleTo$_(s._$GetX$_(), s._$GetY$_(), i._$GetX$_(), i._$GetY$_());
                                i._$SetXY$_(s._$GetX$_() + Math.cos(o) * this._$_pinDist$_, s._$GetY$_() + Math.sin(o) * this._$_pinDist$_), 
                                r = !0;
                            }
                        } else {
                            let t = this._$_propSet$_, e = 0;
                            if (t.has("imagepoint")) {
                                const [ a, l ] = n._$GetImagePoint$_(this._$_pinImagePoint$_);
                                i._$EqualsXY$_(a, l) || (i._$SetXY$_(a, l), r = !0);
                            } else if (t.has("x") && t.has("y")) {
                                const u = s._$GetX$_() + Math.cos(s.GetAngle() + this._$_pinAngle$_) * this._$_pinDist$_, c = s._$GetY$_() + Math.sin(s.GetAngle() + this._$_pinAngle$_) * this._$_pinDist$_;
                                i._$EqualsXY$_(u, c) || (i._$SetXY$_(u, c), r = !0);
                            } else e = s._$GetX$_() + this._$_dx$_, t.has("x") && e !== i._$GetX$_() && (i._$SetX$_(e), 
                            r = !0), e = s._$GetY$_() + this._$_dy$_, t.has("y") && e !== i._$GetY$_() && (i._$SetY$_(e), 
                            r = !0);
                            t.has("angle") && (this._$_lastKnownAngle$_ !== i.GetAngle() && (this._$_dAngle$_ = g._$clampAngle$_(this._$_dAngle$_ + (i.GetAngle() - this._$_lastKnownAngle$_))), 
                            (e = g._$clampAngle$_(s.GetAngle() + this._$_dAngle$_)) !== i.GetAngle() && (i._$SetAngle$_(e), 
                            r = !0), this._$_lastKnownAngle$_ = i.GetAngle()), t.has("width-abs") && (e = s._$GetWidth$_() + this._$_dWidth$_) !== i._$GetWidth$_() && (i._$SetWidth$_(e), 
                            r = !0), t.has("width-scale") && (e = s._$GetWidth$_() * this._$_dWidth$_) !== i._$GetWidth$_() && (i._$SetWidth$_(e), 
                            r = !0), t.has("height-abs") && (e = s._$GetHeight$_() + this._$_dHeight$_) !== i._$GetHeight$_() && (i._$SetHeight$_(e), 
                            r = !0), t.has("height-scale") && (e = s._$GetHeight$_() * this._$_dHeight$_) !== i._$GetHeight$_() && (i._$SetHeight$_(e), 
                            r = !0), t.has("z") && (e = s._$GetZElevation$_() + this._$_dz$_) !== i._$GetZElevation$_() && (i._$SetZElevation$_(e), 
                            this._$_runtime$_._$UpdateRender$_());
                        }
                        r && i._$SetBboxChanged$_();
                    }
                }
                _$GetDebuggerProperties$_() {
                    const t = "behaviors.pin.debugger";
                    return [ {
                        title: "$" + this._$GetBehaviorType$_()._$GetName$_(),
                        properties: [ {
                            name: t + ".is-pinned",
                            value: !!this._$_pinInst$_
                        }, {
                            name: t + ".pinned-uid",
                            value: this._$_pinInst$_ ? this._$_pinInst$_._$GetUID$_() : 0
                        } ]
                    } ];
                }
            };
        }
        {
            const $ = self._$C3$_;
            $._$Behaviors$_._$Pin$_._$Cnds$_ = {
                _$IsPinned$_() {
                    return !!this._$_pinInst$_;
                },
                _$WillDestroy$_() {
                    return this._$_destroy$_;
                }
            };
        }
        {
            const _ = self._$C3$_;
            _._$Behaviors$_._$Pin$_._$Acts$_ = {
                _$PinByDistance$_(t, e) {
                    this._$_Pin$_(t, 0 === e ? "rope" : "bar");
                },
                _$PinByProperties$_(t, e, s, i, r, n, h) {
                    const o = [];
                    e && o.push("x"), s && o.push("y"), i && o.push("angle"), h && o.push("z"), 
                    1 === r ? o.push("width-abs") : 2 === r && o.push("width-scale"), 
                    1 === n ? o.push("height-abs") : 2 === n && o.push("height-scale"), 
                    0 !== o.length && this._$_Pin$_(t, "properties", o);
                },
                _$PinByImagePoint$_(t, e, s, i, r, n) {
                    const h = [ "imagepoint" ];
                    s && h.push("angle"), n && h.push("z"), 1 === i ? h.push("width-abs") : 2 === i && h.push("width-scale"), 
                    1 === r ? h.push("height-abs") : 2 === r && h.push("height-scale"), 
                    this._$_pinImagePoint$_ = e, this._$_Pin$_(t, "properties", h);
                },
                _$SetPinDistance$_(t) {
                    "rope" !== this._$_mode$_ && "bar" !== this._$_mode$_ || (this._$_pinDist$_ = Math.max(t, 0));
                },
                _$SetDestroy$_(t) {
                    this._$_destroy$_ = t;
                },
                _$Unpin$_() {
                    this._$_SetPinInst$_(null), this._$_mode$_ = "", this._$_propSet$_.clear(), 
                    this._$_pinImagePoint$_ = "";
                },
                _$Pin$_(t, e) {
                    switch (e) {
                      case 0:
                        this._$_Pin$_(t, "properties", [ "x", "y", "angle" ]);
                        break;

                      case 1:
                        this._$_Pin$_(t, "properties", [ "x", "y" ]);
                        break;

                      case 2:
                        this._$_Pin$_(t, "properties", [ "angle" ]);
                        break;

                      case 3:
                        this._$_Pin$_(t, "rope");
                        break;

                      case 4:
                        this._$_Pin$_(t, "bar");
                    }
                }
            };
        }
        {
            const va = self._$C3$_;
            va._$Behaviors$_._$Pin$_._$Exps$_ = {
                _$PinnedUID$_() {
                    return this._$_pinInst$_ ? this._$_pinInst$_._$GetUID$_() : -1;
                }
            };
        }
        {
            const a = self._$C3$_;
            a._$Behaviors$_._$DragnDrop$_ = class extends a._$SDKBehaviorBase$_ {
                constructor(t) {
                    super(t);
                    const e = this._$_runtime$_._$Dispatcher$_();
                    this._$_disposables$_ = new a._$CompositeDisposable$_(a._$Disposable$_._$From$_(e, "pointerdown", t => this._$_OnPointerDown$_(t.data)), a._$Disposable$_._$From$_(e, "pointermove", t => this._$_OnPointerMove$_(t.data)), a._$Disposable$_._$From$_(e, "pointerup", t => this._$_OnPointerUp$_(t.data, !1)), a._$Disposable$_._$From$_(e, "pointercancel", t => this._$_OnPointerUp$_(t.data, !0)));
                }
                _$Release$_() {
                    this._$_disposables$_._$Release$_(), this._$_disposables$_ = null, 
                    super._$Release$_();
                }
                _$_OnPointerDown$_(t) {
                    "mouse" === t.pointerType && 0 !== t.button || this._$_OnInputDown$_(t.pointerId.toString(), t.pageX - this._$_runtime$_._$GetCanvasClientX$_(), t.pageY - this._$_runtime$_._$GetCanvasClientY$_());
                }
                _$_OnPointerMove$_(t) {
                    0 != (1 & t.lastButtons) && 0 == (1 & t.buttons) ? this._$_OnInputUp$_(t.pointerId.toString()) : this._$_OnInputMove$_(t.pointerId.toString(), t.pageX - this._$_runtime$_._$GetCanvasClientX$_(), t.pageY - this._$_runtime$_._$GetCanvasClientY$_());
                }
                _$_OnPointerUp$_(t, e) {
                    "mouse" === t.pointerType && 0 !== t.button || this._$_OnInputUp$_(t.pointerId.toString());
                }
                async _$_OnInputDown$_(t, e, s) {
                    let i = this._$GetInstances$_(), r = null, n = null, h = 0, o = 0;
                    for (const l of i) {
                        const u = l._$GetBehaviorSdkInstanceFromCtor$_(a._$Behaviors$_._$DragnDrop$_);
                        if (u._$IsEnabled$_() && !u._$IsDragging$_() && !l._$IsDestroyed$_()) {
                            const c = l._$GetWorldInfo$_(), f = c._$GetLayer$_(), [ d, p ] = f._$CanvasCssToLayer$_(e, s, c._$GetTotalZElevation$_());
                            if (f._$IsSelfAndParentsInteractive$_() && c._$ContainsPoint$_(d, p)) if (r) {
                                const m = r._$GetWorldInfo$_();
                                (f._$GetIndex$_() > m._$GetLayer$_()._$GetIndex$_() || f._$GetIndex$_() === m._$GetLayer$_()._$GetIndex$_() && c._$GetZIndex$_() > m._$GetZIndex$_()) && (r = l, 
                                n = u, h = d, o = p);
                            } else r = l, n = u, h = d, o = p;
                        }
                    }
                    r && await n._$_OnDown$_(t, h, o);
                }
                _$_OnInputMove$_(t, e, s) {
                    const i = this._$GetInstances$_();
                    for (const r of i) {
                        const n = r._$GetBehaviorSdkInstanceFromCtor$_(a._$Behaviors$_._$DragnDrop$_);
                        if (n._$IsEnabled$_() && n._$IsDragging$_() && (!n._$IsDragging$_() || n._$GetDragSource$_() === t)) {
                            const h = r._$GetWorldInfo$_(), o = h._$GetLayer$_(), [ l, u ] = o._$CanvasCssToLayer$_(e, s, h._$GetTotalZElevation$_());
                            n._$_OnMove$_(l, u);
                        }
                    }
                }
                async _$_OnInputUp$_(t) {
                    const e = this._$GetInstances$_();
                    for (const s of e) {
                        const i = s._$GetBehaviorSdkInstanceFromCtor$_(a._$Behaviors$_._$DragnDrop$_);
                        i._$IsDragging$_() && i._$GetDragSource$_() === t && await i._$_OnUp$_();
                    }
                }
            };
        }
        {
            const P = self._$C3$_;
            P._$Behaviors$_._$DragnDrop$_._$Type$_ = class extends P._$SDKBehaviorTypeBase$_ {
                constructor(t) {
                    super(t);
                }
                _$Release$_() {
                    super._$Release$_();
                }
                _$OnCreate$_() {}
            };
        }
        {
            const S = self._$C3$_, T = self._$C3X$_, U = self._$IBehaviorInstance$_, V = 0, W = 1, X = (S._$Behaviors$_._$DragnDrop$_.Instance = class extends S._$SDKBehaviorInstanceBase$_ {
                constructor(t, e) {
                    super(t), this._$_isDragging$_ = !1, this._$_dx$_ = 0, this._$_dy$_ = 0, 
                    this._$_dragSource$_ = "<none>", this._$_axes$_ = 0, this._$_isEnabled$_ = !0, 
                    e && (this._$_axes$_ = e[V], this._$_isEnabled$_ = e[W]);
                }
                _$Release$_() {
                    super._$Release$_();
                }
                _$SaveToJson$_() {
                    return {
                        a: this._$_axes$_,
                        e: this._$_isEnabled$_
                    };
                }
                _$LoadFromJson$_(t) {
                    this._$_axes$_ = t.a, this._$_isEnabled$_ = t.e, this._$_isDragging$_ = !1;
                }
                _$_SetEnabled$_(t) {
                    this._$_isEnabled$_ = !!t, this._$_isEnabled$_ || (this._$_isDragging$_ = !1);
                }
                _$IsEnabled$_() {
                    return this._$_isEnabled$_;
                }
                _$_SetAxes$_(t) {
                    this._$_axes$_ = t;
                }
                _$_GetAxes$_() {
                    return this._$_axes$_;
                }
                _$_Drop$_() {
                    this._$_isDragging$_ && this._$_OnUp$_();
                }
                _$IsDragging$_() {
                    return this._$_isDragging$_;
                }
                _$GetDragSource$_() {
                    return this._$_dragSource$_;
                }
                async _$_OnDown$_(t, e, s) {
                    const i = this._$GetWorldInfo$_();
                    this._$_dx$_ = e - i._$GetX$_(), this._$_dy$_ = s - i._$GetY$_(), 
                    this._$_isDragging$_ = !0, this._$_dragSource$_ = t, this._$DispatchScriptEvent$_("dragstart"), 
                    await this._$TriggerAsync$_(S._$Behaviors$_._$DragnDrop$_._$Cnds$_._$OnDragStart$_);
                }
                _$_OnMove$_(t, e) {
                    const s = this._$GetWorldInfo$_(), i = t - this._$_dx$_, r = e - this._$_dy$_;
                    0 === this._$_axes$_ ? s._$GetX$_() === i && s._$GetY$_() === r || (s._$SetXY$_(i, r), 
                    s._$SetBboxChanged$_()) : 1 === this._$_axes$_ ? s._$GetX$_() !== i && (s._$SetX$_(i), 
                    s._$SetBboxChanged$_()) : 2 === this._$_axes$_ && s._$GetY$_() !== r && (s._$SetY$_(r), 
                    s._$SetBboxChanged$_());
                }
                async _$_OnUp$_() {
                    this._$_isDragging$_ = !1, this._$DispatchScriptEvent$_("drop"), 
                    await this._$TriggerAsync$_(S._$Behaviors$_._$DragnDrop$_._$Cnds$_._$OnDrop$_);
                }
                _$GetPropertyValueByIndex$_(t) {
                    switch (t) {
                      case V:
                        return this._$_GetAxes$_();

                      case W:
                        return this._$IsEnabled$_();
                    }
                }
                _$SetPropertyValueByIndex$_(t, e) {
                    switch (t) {
                      case V:
                        this._$_SetAxes$_(e);
                        break;

                      case W:
                        this._$_SetEnabled$_(!!e);
                    }
                }
                _$GetDebuggerProperties$_() {
                    let t = "behaviors.dragndrop", e = t + ".properties.axes", s = "";
                    return 0 === this._$_axes$_ ? s = e + ".items.both" : 1 === this._$_axes$_ ? s = e + ".items.horizontal-only" : 2 === this._$_axes$_ && (s = e + ".items.vertical-only"), 
                    [ {
                        title: "$" + this._$GetBehaviorType$_()._$GetName$_(),
                        properties: [ {
                            name: t + ".debugger.is-dragging",
                            value: this._$IsDragging$_()
                        }, {
                            name: e + ".name",
                            value: [ s ]
                        }, {
                            name: t + ".properties.enabled.name",
                            value: this._$IsEnabled$_(),
                            _$onedit$_: t => this._$_SetEnabled$_(t)
                        } ]
                    } ];
                }
                _$GetScriptInterfaceClass$_() {
                    return self._$IDragDropBehaviorInstance$_;
                }
            }, new WeakMap()), Y = [ "both", "horizontal", "vertical" ];
            self._$IDragDropBehaviorInstance$_ = class extends U {
                constructor() {
                    super(), X.set(this, U._$_GetInitInst$_()._$GetSdkInstance$_());
                }
                set axes(t) {
                    const e = Y.indexOf(t);
                    if (-1 === e) throw new Error("invalid axes");
                    X.get(this)._$_SetAxes$_(e);
                }
                get axes() {
                    return Y[X.get(this)._$_GetAxes$_()];
                }
                _$drop$_() {
                    X.get(this)._$_Drop$_();
                }
                get _$isDragging$_() {
                    return X.get(this)._$IsDragging$_();
                }
                get isEnabled() {
                    return X.get(this)._$IsEnabled$_();
                }
                set isEnabled(t) {
                    X.get(this)._$_SetEnabled$_(t);
                }
            };
        }
        {
            const xa = self._$C3$_;
            xa._$Behaviors$_._$DragnDrop$_._$Cnds$_ = {
                _$IsDragging$_() {
                    return this._$IsDragging$_();
                },
                _$OnDragStart$_() {
                    return !0;
                },
                _$OnDrop$_() {
                    return !0;
                },
                _$IsEnabled$_() {
                    return this._$IsEnabled$_();
                }
            };
        }
        {
            const ya = self._$C3$_;
            ya._$Behaviors$_._$DragnDrop$_._$Acts$_ = {
                _$SetEnabled$_(t) {
                    this._$_SetEnabled$_(!!t);
                },
                _$SetAxes$_(t) {
                    this._$_SetAxes$_(t);
                },
                _$Drop$_() {
                    this._$_Drop$_();
                }
            };
        }
        {
            const Ba = self._$C3$_;
            Ba._$Behaviors$_._$DragnDrop$_._$Exps$_ = {};
        }
        {
            let unaryminus2 = function(t) {
                return "number" == typeof t ? -t : t;
            }, bothNumbers2 = function(t, e) {
                return "number" == typeof t && "number" == typeof e;
            }, add2 = function(t, e) {
                return bothNumbers2(t, e) ? t + e : t;
            }, subtract2 = function(t, e) {
                return bothNumbers2(t, e) ? t - e : t;
            }, multiply2 = function(t, e) {
                return bothNumbers2(t, e) ? t * e : t;
            }, divide2 = function(t, e) {
                return bothNumbers2(t, e) ? t / e : t;
            }, mod2 = function(t, e) {
                return bothNumbers2(t, e) ? t % e : t;
            }, pow2 = function(t, e) {
                return bothNumbers2(t, e) ? Math.pow(t, e) : t;
            }, and2 = function(s, i) {
                if ("string" != typeof s && "string" != typeof i) return s && i ? 1 : 0;
                {
                    let t, e;
                    return t = "number" == typeof s ? (Math.round(1e10 * s) / 1e10).toString() : s, 
                    e = "number" == typeof i ? (Math.round(1e10 * i) / 1e10).toString() : i, 
                    t + e;
                }
            }, or2 = function(t, e) {
                return bothNumbers2(t, e) ? t || e ? 1 : 0 : t;
            };
            unaryminus = unaryminus2, bothNumbers = bothNumbers2, add = add2, subtract = subtract2, 
            multiply = multiply2, divide = divide2, mod = mod2, pow = pow2, and = and2, 
            or = or2;
            const C33 = self._$C3$_;
            self._$C3_ExpressionFuncs$_ = [ t => {
                const e = t._$_GetNode$_(0)._$GetVar$_();
                return () => e._$GetValue$_();
            }, () => 0, () => "", () => "Jugador11", () => "Eventos11", () => 152, () => 317, () => "Input11", () => "Teclado11", () => "Joystick6", () => -10, () => 10, () => "MOVIMIENTO-ANDROID-BOTONES8", () => "Jugador", () => "Eventos", () => 650, () => 1, () => 148, () => 770, () => "Input", () => "Teclado", () => "Joystick", () => "MOVIMIENTO-ANDROID-BOTONES", () => 2, () => "Jugador2", () => "Eventos2", () => 96.946408, () => 639.134271, () => "Input2", () => "Teclado2", () => "Joystick2", () => "MOVIMIENTO-ANDROID-BOTONES1", () => "Jugador3", () => "Eventos3", () => "Durmiendo", () => 5, () => "Input3", () => "Teclado3", () => "Joystick3", () => "MOVIMIENTO-ANDROID-BOTONES2", () => .1, () => 506, () => -5, () => 395, () => "Jugador4", () => "Eventos4", () => "Input4", () => "Teclado4", () => "Joystick4", () => "MOVIMIENTO-ANDROID-BOTONES3", () => 99.148231, () => 764.141387, () => "MOVIMIENTO-JOYSTICK", () => "MOVIMIENTO-ANDROID-BOTONES4", () => 3, () => "GameOverState", () => 99, () => "Jugador6", () => "Eventos6", t => {
                const e = t._$_GetNode$_(0)._$GetBoundMethod$_();
                return () => e();
            }, () => 29, () => 979.028782, () => "Input6", () => "Teclado6", () => "MOVIMIENTO-JOYSTICK2", () => "Verdadero", () => "TieneLlave", () => "Falso", () => "Default", () => "MOVIMIENTO-ANDROID-BOTONES5", () => 480, () => 400, () => "EFE", () => 25, () => 100, () => "GrupoPiedra1", () => 90, () => 2500, t => {
                const e = t._$_GetNode$_(0);
                return () => e._$ExpObject$_();
            }, () => 1312, () => 1344, () => 1280, () => 5e4, () => "GrupoPiedra2", () => 1396, () => 1348, () => "Jugador12", () => "Eventos12", () => "Input12", () => "Teclado12", () => "MOVIMIENTO-JOYSTICK3", () => "MOVIMIENTO-ANDROID-BOTONES9", () => 1800, () => 224, () => 512, () => "Jugador10", () => "Eventos10", () => 2600, () => "Input10", () => "Teclado10", () => "Joystick10", () => "LVL1p3secreto", () => 30, () => "cercadepilar", () => "MOVIMIENTO-ANDROID-BOTONES7", () => "pilar-rojo", () => 4, () => "conteobomba", () => 60, t => {
                const e = t._$_GetNode$_(0)._$GetVar$_(), s = t._$_GetNode$_(1)._$GetVar$_();
                return () => and2(and2(e._$GetValue$_(), ": "), s._$GetValue$_());
            }, () => -1, () => -1e3, () => "Jugador9", () => "Eventos9", () => 480.42296, () => 720.139182, () => "Input9", () => "Teclado9", () => "Joystick9", () => "LVL1p3", () => "MOVIMIENTO-ANDROID-BOTONES6", () => "Jugador13", () => "Eventos13", () => "Input13", () => "Teclado13", () => "Joystick11", () => "MOVIMIENTO-ANDROID-BOTONES10", () => 8, () => "A", () => "Animation 1", () => 23039, () => 16751872, () => "Animation 2", () => .5, () => "E", () => "NoActivado", () => "Activado", t => {
                const e = t._$_GetNode$_(0), s = t._$_GetNode$_(1);
                return () => Math.round(e._$ExpObject$_("end") - s._$ExpObject$_("start")) / 100;
            }, t => {
                const e = t._$_GetNode$_(0), s = t._$_GetNode$_(1), i = t._$_GetNode$_(2);
                return () => C33._$clamp$_(e._$ExpObject$_(), s._$ExpObject$_("start"), i._$ExpObject$_("end"));
            }, t => {
                const e = t._$_GetNode$_(0), s = t._$_GetNode$_(1);
                return () => e._$ExpObject$_() - s._$ExpObject$_("start");
            }, t => {
                const e = t._$_GetNode$_(0)._$GetVar$_(), s = t._$_GetNode$_(1)._$GetVar$_();
                return () => Math.round(e._$GetValue$_() / s._$GetValue$_()) / 100;
            }, t => {
                const e = t._$_GetNode$_(0)._$GetBoundMethod$_(), s = t._$_GetNode$_(1)._$GetVar$_();
                return () => 20 * e(s._$GetValue$_());
            }, () => "play", t => {
                const e = t._$_GetNode$_(0)._$GetVar$_();
                return () => and2(Math.round(100 * e._$GetValue$_()), " %");
            }, t => {
                const e = t._$_GetNode$_(0)._$GetVar$_();
                return () => and2(Math.round(e._$GetValue$_()), " db");
            }, () => "Jugador7", () => "Eventos7", () => 121, () => 805, () => "Input7", () => "Teclado7", () => "Joystick7", () => "Jugador8", () => "Eventos8", () => "Input8", () => "Teclado8", () => "Joystick8", () => "GameOver", () => "Sonido", () => -1e19, () => "Cursor", t => {
                const e = t._$_GetNode$_(0), s = t._$_GetNode$_(1), i = t._$_GetNode$_(2)._$GetBoundMethod$_();
                return () => e._$ExpObject$_(s._$ExpObject$_(i()));
            }, t => {
                const e = t._$_GetNode$_(0)._$GetBoundMethod$_(), s = t._$_GetNode$_(1)._$GetBoundMethod$_();
                return () => and2(0 === e() ? 1 : 0, 0 === s() ? 1 : 0);
            }, () => "PaintAndErase", () => "Lapiz", t => {
                const e = t._$_GetNode$_(0), s = t._$_GetNode$_(1)._$GetBoundMethod$_();
                return () => e._$ExpObject$_(s());
            }, () => "Borrador", t => {
                const e = t._$_GetNode$_(0), s = t._$_GetNode$_(1)._$GetVar$_();
                return () => e._$ExpObject$_(s._$GetValue$_());
            }, () => "UserInterface", () => "SizeGrow", () => 20, () => "SaveAndLoad", t => {
                const e = t._$_GetNode$_(0);
                return () => "Nivel guardado a: " + e._$ExpObject$_();
            }, t => {
                const e = t._$_GetNode$_(0);
                return () => "Slot de nivel cargado: " + e._$ExpObject$_();
            }, () => "El slot seleccionado esta vacio.", () => "Notifications", () => "HeightGrow", () => 80, () => .25, () => "HeightShrink", () => "CSS", () => "Particles", t => {
                const e = t._$_GetNode$_(0)._$GetBoundMethod$_();
                return () => e(0, 640);
            }, t => {
                const e = t._$_GetNode$_(0)._$GetBoundMethod$_();
                return () => e(0, 360);
            }, t => {
                const e = t._$_GetNode$_(0)._$GetBoundMethod$_();
                return () => e(0, 100);
            }, () => "Jugador5", () => "Eventos5", () => 85, () => 426, () => "Input5", () => "Teclado5", () => "Joystick5", () => "CreadorDeNiveles", () => "EditorDeNiveles", t => {
                const e = t._$_GetNode$_(0)._$GetBoundMethod$_();
                return () => e(1);
            }, () => "SaveSlot1" ];
        }
    }
}), import_c3runtime = __toESM(require_c3runtime()), C32 = self._$C3$_;

self._$C3_GetObjectRefTable$_ = function() {
    return [ C32._$Plugins$_._$Button$_, C32._$Plugins$_._$Sprite$_, C32._$Behaviors$_._$Platform$_, C32._$Behaviors$_._$scrollto$_, C32._$Plugins$_.gamepad, C32._$Plugins$_._$Mouse$_, C32._$Plugins$_._$Browser$_, C32._$Plugins$_.Keyboard, C32._$Plugins$_.Text, C32._$Plugins$_._$Spritefont2$_, C32._$Plugins$_.Touch, C32._$Behaviors$_.wrap, C32._$Behaviors$_._$Bullet$_, C32._$Plugins$_._$TiledBg$_, C32._$Behaviors$_._$Fade$_, C32._$Behaviors$_._$Tween$_, C32._$Plugins$_._$NinePatch$_, C32._$Behaviors$_._$Sin$_, C32._$Plugins$_._$List$_, C32._$Plugins$_._$Tilemap$_, C32._$Behaviors$_._$solid$_, C32._$Plugins$_._$LocalStorage$_, C32._$Plugins$_._$PlatformInfo$_, C32._$Plugins$_._$TextBox$_, C32._$Plugins$_._$Shape3D$_, C32._$Behaviors$_._$custom$_, C32._$Behaviors$_._$Physics$_, C32._$Behaviors$_._$jumpthru$_, C32._$Plugins$_._$sliderbar$_, C32._$Plugins$_.Audio, C32._$Plugins$_._$Dictionary$_, C32._$Behaviors$_._$Pin$_, C32._$Plugins$_.Geolocation, C32._$Plugins$_._$Timeline$_, C32._$Behaviors$_._$DragnDrop$_, C32._$Plugins$_._$Multiplayer$_, C32._$Plugins$_._$qrcode$_, C32._$Plugins$_._$iframe$_, C32._$Plugins$_.video, C32._$Plugins$_._$System$_._$Cnds$_._$OnLayoutStart$_, C32._$Plugins$_.Audio._$Acts$_.Play, C32._$Plugins$_._$System$_._$Cnds$_._$OnLayoutEnd$_, C32._$Plugins$_.Audio._$Acts$_._$StopAll$_, C32._$Plugins$_._$System$_._$Cnds$_._$IsGroupActive$_, C32._$Plugins$_._$Sprite$_._$Cnds$_._$OnCollision$_, C32._$Plugins$_._$Sprite$_._$Acts$_._$Destroy$_, C32._$Plugins$_._$Sprite$_._$Acts$_._$SetPos$_, C32._$Plugins$_._$System$_._$Acts$_._$GoToLayout$_, C32._$Plugins$_._$Sprite$_._$Cnds$_._$IsOutsideLayout$_, C32._$Plugins$_.Keyboard._$Cnds$_._$IsKeyDown$_, C32._$Plugins$_._$Sprite$_._$Acts$_._$SetMirrored$_, C32._$Behaviors$_._$Platform$_._$Acts$_._$SimulateControl$_, C32._$Behaviors$_._$Platform$_._$Acts$_._$FallThrough$_, C32._$Plugins$_.gamepad._$Cnds$_._$CompareAxis$_, C32._$Plugins$_.gamepad._$Cnds$_._$IsButtonDown$_, C32._$Plugins$_.Touch._$Cnds$_._$IsTouchingObject$_, C32._$Behaviors$_._$Platform$_._$Acts$_._$SetJumpStrength$_, C32._$Plugins$_._$Timeline$_._$Acts$_._$PlayTimeline$_, C32._$Plugins$_._$System$_._$Acts$_._$Wait$_, C32._$Plugins$_._$System$_._$Cnds$_._$CompareVar$_, C32._$Plugins$_._$Sprite$_._$Acts$_._$SetAnimFrame$_, C32._$Behaviors$_._$Pin$_._$Acts$_._$Pin$_, C32._$Plugins$_._$Sprite$_._$Acts$_._$SetAnim$_, C32._$Plugins$_._$Sprite$_._$Acts$_._$MoveForward$_, C32._$Plugins$_._$Sprite$_._$Cnds$_._$CompareX$_, C32._$Plugins$_.Keyboard._$Cnds$_._$OnKey$_, C32._$Plugins$_._$TiledBg$_._$Cnds$_._$IsOnScreen$_, C32._$Plugins$_._$TiledBg$_._$Acts$_._$SetVisible$_, C32._$Plugins$_._$Sprite$_._$Cnds$_._$IsOnScreen$_, C32._$Plugins$_._$Sprite$_._$Acts$_._$SetVisible$_, C32._$Plugins$_._$System$_._$Acts$_._$SetVar$_, C32._$Plugins$_._$System$_._$Acts$_._$SaveState$_, C32._$Plugins$_._$Sprite$_._$Cnds$_._$CompareY$_, C32._$Plugins$_._$System$_._$Exps$_._$layoutheight$_, C32._$Plugins$_._$Sprite$_._$Acts$_._$SetInstanceVar$_, C32._$Plugins$_._$Sprite$_._$Cnds$_._$IsAnimPlaying$_, C32._$Plugins$_._$System$_._$Acts$_._$SubVar$_, C32._$Plugins$_._$System$_._$Acts$_._$AddVar$_, C32._$Plugins$_._$System$_._$Acts$_._$SetLayerOpacity$_, C32._$Plugins$_._$Sprite$_._$Cnds$_._$IsOverlapping$_, C32._$Behaviors$_._$custom$_._$Acts$_._$SetAngleOfMotion$_, C32._$Behaviors$_._$custom$_._$Acts$_._$AcceleratePos$_, C32._$Plugins$_._$Sprite$_._$Exps$_._$X$_, C32._$Plugins$_._$Sprite$_._$Acts$_._$SetY$_, C32._$Behaviors$_._$custom$_._$Acts$_._$Stop$_, C32._$Plugins$_._$System$_._$Cnds$_._$EveryTick$_, C32._$Plugins$_.Text._$Acts$_._$SetText$_, C32._$Plugins$_._$Sprite$_._$Exps$_._$Y$_, C32._$Plugins$_.Text._$Acts$_._$SetVisible$_, C32._$Plugins$_.Audio._$Acts$_._$Stop$_, C32._$Plugins$_._$TiledBg$_._$Exps$_._$X$_, C32._$Plugins$_._$TiledBg$_._$Exps$_._$Y$_, C32._$Plugins$_.Audio._$Acts$_._$SetPaused$_, C32._$Plugins$_._$System$_._$Cnds$_._$Every$_, C32._$Plugins$_._$Button$_._$Cnds$_._$OnClicked$_, C32._$Plugins$_._$Sprite$_._$Cnds$_._$CompareInstanceVar$_, C32._$Plugins$_._$System$_._$Cnds$_._$Else$_, C32._$Plugins$_._$System$_._$Cnds$_._$CompareBoolVar$_, C32._$Plugins$_._$System$_._$Acts$_._$SetLayerBackground$_, C32._$Plugins$_.gamepad._$Cnds$_._$OnGamepadConnected$_, C32._$Plugins$_.gamepad._$Cnds$_._$OnGamepadDisconnected$_, C32._$Plugins$_._$Mouse$_._$Cnds$_._$OnObjectClicked$_, C32._$Plugins$_._$Button$_._$Acts$_._$SetVisible$_, C32._$Plugins$_._$Browser$_._$Acts$_._$CancelFullScreen$_, C32._$Plugins$_._$Browser$_._$Acts$_._$RequestFullScreen$_, C32._$Plugins$_._$System$_._$Acts$_._$SetBoolVar$_, C32._$Plugins$_._$Sprite$_._$Cnds$_._$CompareFrame$_, C32._$Plugins$_._$Sprite$_._$Exps$_._$ImagePointX$_, C32._$Behaviors$_._$DragnDrop$_._$Cnds$_._$IsDragging$_, C32._$Behaviors$_._$DragnDrop$_._$Cnds$_._$OnDrop$_, C32._$Plugins$_._$Sprite$_._$Acts$_._$SetX$_, C32._$Plugins$_._$System$_._$Exps$_.log10, C32._$Plugins$_.Audio._$Acts$_._$SetVolume$_, C32._$Behaviors$_._$DragnDrop$_._$Acts$_._$Drop$_, C32._$Behaviors$_._$DragnDrop$_._$Cnds$_._$OnDragStart$_, C32._$Plugins$_._$Shape3D$_._$Cnds$_._$OnCollision$_, C32._$Plugins$_._$Shape3D$_._$Cnds$_._$IsOutsideLayout$_, C32._$Plugins$_._$Shape3D$_._$Acts$_._$SetPos$_, C32._$Plugins$_.Touch._$Cnds$_._$OnTapGesture$_, C32._$Plugins$_._$System$_._$Acts$_._$LoadState$_, C32._$Plugins$_._$Timeline$_._$Cnds$_._$OnTimelineFinishedByTags$_, C32._$Plugins$_._$Browser$_._$Acts$_._$Close$_, C32._$Plugins$_._$Dictionary$_._$Acts$_._$AddKey$_, C32._$Plugins$_._$Dictionary$_._$Cnds$_._$CompareValue$_, C32._$Plugins$_._$System$_._$Acts$_._$SnapshotCanvas$_, C32._$Plugins$_._$TextBox$_._$Acts$_._$SetText$_, C32._$Plugins$_._$System$_._$Exps$_._$canvassnapshot$_, C32._$Plugins$_._$PlatformInfo$_._$Cnds$_._$IsOnMobile$_, C32._$Plugins$_._$NinePatch$_._$Acts$_._$SetPos$_, C32._$Plugins$_._$Tilemap$_._$Exps$_._$TileToPositionX$_, C32._$Plugins$_._$Tilemap$_._$Exps$_._$PositionToTileX$_, C32._$Plugins$_._$Mouse$_._$Exps$_._$X$_, C32._$Plugins$_._$Tilemap$_._$Exps$_._$TileToPositionY$_, C32._$Plugins$_._$Mouse$_._$Exps$_._$Y$_, C32._$Plugins$_._$System$_._$Cnds$_._$EvaluateExpression$_, C32._$Plugins$_._$NinePatch$_._$Acts$_._$SetVisible$_, C32._$Plugins$_._$Mouse$_._$Cnds$_._$IsButtonDown$_, C32._$Plugins$_._$List$_._$Cnds$_._$CompareSelectedText$_, C32._$Plugins$_._$Tilemap$_._$Cnds$_._$CompareTileAt$_, C32._$Plugins$_._$Tilemap$_._$Exps$_._$PositionToTileY$_, C32._$Plugins$_._$Tilemap$_._$Acts$_._$SetTile$_, C32._$Plugins$_._$System$_._$Acts$_._$CreateObject$_, C32._$Plugins$_._$NinePatch$_._$Exps$_._$X$_, C32._$Plugins$_._$NinePatch$_._$Exps$_._$Y$_, C32._$Plugins$_._$Tilemap$_._$Acts$_._$EraseTile$_, C32._$Plugins$_._$Sprite$_._$Cnds$_._$OnCreated$_, C32._$Plugins$_._$Sprite$_._$Acts$_._$SetSize$_, C32._$Behaviors$_._$Tween$_._$Acts$_._$TweenTwoProperties$_, C32._$Plugins$_._$LocalStorage$_._$Acts$_._$SetItem$_, C32._$Plugins$_._$List$_._$Exps$_._$SelectedText$_, C32._$Plugins$_._$Tilemap$_._$Exps$_._$TilesJSON$_, C32._$Plugins$_._$System$_._$Acts$_._$WaitForPreviousActions$_, C32._$Plugins$_._$LocalStorage$_._$Acts$_._$CheckItemExists$_, C32._$Plugins$_._$LocalStorage$_._$Cnds$_._$OnItemExists$_, C32._$Plugins$_._$LocalStorage$_._$Acts$_._$GetItem$_, C32._$Plugins$_._$LocalStorage$_._$Cnds$_._$OnItemGet$_, C32._$Plugins$_._$Tilemap$_._$Acts$_._$LoadFromJSON$_, C32._$Plugins$_._$LocalStorage$_._$Exps$_._$ItemValue$_, C32._$Plugins$_._$LocalStorage$_._$Cnds$_._$OnItemMissing$_, C32._$Plugins$_._$TiledBg$_._$Acts$_._$SetHeight$_, C32._$Behaviors$_._$Tween$_._$Acts$_._$TweenOneProperty$_, C32._$Plugins$_._$System$_._$Cnds$_._$Repeat$_, C32._$Plugins$_._$System$_._$Exps$_.random, C32._$Plugins$_._$Sprite$_._$Acts$_._$SetZElevation$_, C32._$Plugins$_.Audio._$Acts$_._$PlayByName$_, C32._$Plugins$_._$Tilemap$_._$Acts$_._$SetSize$_, C32._$Plugins$_._$System$_._$Exps$_._$layoutwidth$_, C32._$Plugins$_._$System$_._$Cnds$_._$OnLoadFinished$_, C32._$Plugins$_.Keyboard._$Cnds$_._$OnKeyReleased$_, C32._$Plugins$_._$System$_._$Exps$_._$viewportright$_, C32._$Plugins$_._$System$_._$Exps$_._$viewportbottom$_, C32._$Plugins$_.Text._$Acts$_._$Destroy$_ ];
}, self._$C3_JsPropNameTable$_ = [ {
    _$ElegirParte1$_: 0
}, {
    _$ElegirParte2$_: 0
}, {
    _$ElegirParte3$_: 0
}, {
    _$MultijugadorLocal$_: 0
}, {
    _$MultijugadorOnline$_: 0
}, {
    _$PSdFA$_: 0
}, {
    _$PAdFA$_: 0
}, {
    _$xd$_: 0
}, {
    _$checkboxEPICO$_: 0
}, {
    _$checkboxEPICO2$_: 0
}, {
    _$checkboxEPICO3$_: 0
}, {
    _$BotonElegirPartes$_: 0
}, {
    _$BotonIrAlTitulo$_: 0
}, {
    _$BotonAjustes$_: 0
}, {
    _$BotonCrearNivel$_: 0
}, {
    _$BotonIrAlMenu$_: 0
}, {
    _$BotonMultijugador$_: 0
}, {
    _$BotonJugarVersion25D$_: 0
}, {
    _$BotonMasAjustes$_: 0
}, {
    _$BotonActualizaciones$_: 0
}, {
    _$BotonSecreto1$_: 0
}, {
    _$IZQ$_: 0
}, {
    _$DER$_: 0
}, {
    _$Imagen_BotonElegirPartes$_: 0
}, {
    "_$Imagen_BotonrAlTitulo$_": 0
}, {
    "_$Imagen_BotonrAlTitulo2$_": 0
}, {
    _$Imagen_BotonJugar$_: 0
}, {
    _$Imagen_BotonAjustes$_: 0
}, {
    _$Imagen_BotonCrearNivel$_: 0
}, {
    E: 0
}, {
    _$Imagen_StickConectado$_: 0
}, {
    _$Boton_Generico$_: 0
}, {
    _$BotonJugarIMG$_: 0
}, {
    _$BotonSalirIMG$_: 0
}, {
    _$BotonAjustesIMG$_: 0
}, {
    _$BotonJugarVersionAntiguaIMG$_: 0
}, {
    _$BotonCreadorDeNivelesIMG$_: 0
}, {
    _$BotonIrAlTituloIMG$_: 0
}, {
    _$BotnActualizacionesIMG$_: 0
}, {
    _$TieneLlave$_: 0
}, {
    _$Vida$_: 0
}, {
    _$Platform$_: 0
}, {
    _$ScrollTo$_: 0
}, {
    _$BloqueAzul$_: 0
}, {
    _$TieneLLave$_: 0
}, {
    _$BloqueNaranja$_: 0
}, {
    _$BloqueAzulMano$_: 0
}, {
    _$BloqueNaranjaMano$_: 0
}, {
    _$BloqueDummy$_: 0
}, {
    _$Mando$_: 0
}, {
    _$Mouse$_: 0
}, {
    _$Navegador$_: 0
}, {
    _$Teclado$_: 0
}, {
    _$Texto$_: 0
}, {
    _$SPRITEFONT$_: 0
}, {
    Touch: 0
}, {
    _$Wrap$_: 0
}, {
    _$Bullet$_: 0
}, {
    _$AirParticle$_: 0
}, {
    _$Background$_: 0
}, {
    _$Fade$_: 0
}, {
    _$Tween$_: 0
}, {
    _$BlastEffect$_: 0
}, {
    _$Sine$_: 0
}, {
    _$Cursor$_: 0
}, {
    _$List$_: 0
}, {
    _$LoadButton$_: 0
}, {
    _$NotificationBox$_: 0
}, {
    _$NotificationText$_: 0
}, {
    _$SaveButton$_: 0
}, {
    _$Tool$_: 0
}, {
    _$Tutorial$_: 0
}, {
    _$Solid$_: 0
}, {
    _$World$_: 0
}, {
    _$LocalStorage$_: 0
}, {
    _$PlatformInfo$_: 0
}, {
    _$ColocarMeta$_: 0
}, {
    _$Metaaaa$_: 0
}, {
    _$LeMeta$_: 0
}, {
    _$Salir$_: 0
}, {
    _$Texto2$_: 0
}, {
    _$textoAnchoNivel$_: 0
}, {
    _$textoAltoNivel$_: 0
}, {
    _$xdwebiwabo$_: 0
}, {
    _$DesplazarHasta$_: 0
}, {
    _$Plataforma$_: 0
}, {
    _$BloqueAzul3DVIejo$_: 0
}, {
    _$BloqueAzul3DNuevo$_: 0
}, {
    "_$Slido$_": 0
}, {
    _$Piso3D$_: 0
}, {
    _$FanArt1$_: 0
}, {
    _$FanArt2$_: 0
}, {
    _$ImgSecretoP2_LVL3$_: 0
}, {
    _$LAVA$_: 0
}, {
    _$Personalizado$_: 0
}, {
    _$piedra$_: 0
}, {
    _$LAVA_COLISION$_: 0
}, {
    _$piedra2$_: 0
}, {
    _$VidasSpr$_: 0
}, {
    _$VidaTxt$_: 0
}, {
    _$A_Button$_: 0
}, {
    _$B_Button$_: 0
}, {
    _$DPAD$_: 0
}, {
    _$EXIT_BUTTON$_: 0
}, {
    _$MOV_DER$_: 0
}, {
    _$MOV_IZQ$_: 0
}, {
    _$SavingText$_: 0
}, {
    _$SolidTile$_: 0
}, {
    _$Physics$_: 0
}, {
    _$SolidTileCONFISICAS$_: 0
}, {
    _$BackgroundTile$_: 0
}, {
    _$BGTile$_: 0
}, {
    _$TiledBackground$_: 0
}, {
    _$GameOverTiled$_: 0
}, {
    _$Jumpthru$_: 0
}, {
    _$JumpThruTile$_: 0
}, {
    _$MovingSolidTile$_: 0
}, {
    _$SoildTileDESPAWN$_: 0
}, {
    _$SolidTile2$_: 0
}, {
    _$SolidTile3$_: 0
}, {
    _$SolidTileDORADO$_: 0
}, {
    _$SolidTileMASOSCURO$_: 0
}, {
    _$SolidTilePINCHO$_: 0
}, {
    _$SolidTileSPAWN$_: 0
}, {
    _$RedTile$_: 0
}, {
    _$Pincho$_: 0
}, {
    _$TextImages$_: 0
}, {
    _$ControlDeslizante$_: 0
}, {
    Audio: 0
}, {
    _$Diccionario$_: 0
}, {
    _$Llave$_: 0
}, {
    _$Puerta$_: 0
}, {
    _$invisible$_: 0
}, {
    _$Meta$_: 0
}, {
    _$Pasto$_: 0
}, {
    _$enemigo$_: 0
}, {
    _$Pin$_: 0
}, {
    _$enemigo_muere$_: 0
}, {
    _$Casita$_: 0
}, {
    _$Cama$_: 0
}, {
    _$Moneda$_: 0
}, {
    "_$Geolocalizacin$_": 0
}, {
    _$FlechaQueMiraAbajo$_: 0
}, {
    _$SpriteCuidado$_: 0
}, {
    Text: 0
}, {
    _$PaStOoOoOo$_: 0
}, {
    _$VerdaderaMeta$_: 0
}, {
    _$PisoInvisible$_: 0
}, {
    _$ParedInvisible$_: 0
}, {
    _$BloqueAzulBrazos$_: 0
}, {
    _$Text2$_: 0
}, {
    _$YaCollecionado$_: 0
}, {
    "1UP": 0
}, {
    _$Desconocido$_: 0
}, {
    _$OtraAyuda$_: 0
}, {
    _$la_ayuda_xdd$_: 0
}, {
    _$Flecha$_: 0
}, {
    _$EasterEgg1$_: 0
}, {
    _$PuertaEasterEgg1$_: 0
}, {
    _$Vidas$_: 0
}, {
    _$BloqueAzulVidas$_: 0
}, {
    _$comoJugar$_: 0
}, {
    _$xdTEMP$_: 0
}, {
    _$TextInput$_: 0
}, {
    _$FondoEnMosaico$_: 0
}, {
    _$FondoXD$_: 0
}, {
    _$MapaDeTeselas$_: 0
}, {
    _$Sprite2$_: 0
}, {
    _$goofyBackground$_: 0
}, {
    _$comoJugar2$_: 0
}, {
    _$Sprite$_: 0
}, {
    "_$ControladorDeLaLneaDeTiempo$_": 0
}, {
    _$DragDrop$_: 0
}, {
    _$thumb$_: 0
}, {
    _$txtSlider$_: 0
}, {
    _$txtVolume$_: 0
}, {
    track: 0
}, {
    _$enemigo_circulo$_: 0
}, {
    _$SECRETO3$_: 0
}, {
    _$PICHA_SECRETO3$_: 0
}, {
    _$spring$_: 0
}, {
    _$enemigo2$_: 0
}, {
    _$pillarrojosecreto$_: 0
}, {
    _$CONTADOR_P3_SECRETO2$_: 0
}, {
    _$pillarrojosecreto_spawn$_: 0
}, {
    _$Multijugador$_: 0
}, {
    _$EscaleraESCALON$_: 0
}, {
    _$QRCode$_: 0
}, {
    _$Text3$_: 0
}, {
    _$BlogUpdates$_: 0
}, {
    _$enemigo3$_: 0
}, {
    _$Video$_: 0
}, {
    _$BOMBA_ACTIVA$_: 0
}, {
    _$TIEMPOCONTADORSECRETOP3MINUTOS$_: 0
}, {
    _$TIEMPOCONTADORSECRETOP3SEGUNDOS$_: 0
}, {
    _$GAMEOVER_SECRETOP3$_: 0
}, {
    _$TeclaYaPresionada$_: 0
}, {
    _$ModoEpicoActivado$_: 0
}, {
    _$ModoHalloweenActivado$_: 0
}, {
    _$ModoClasicoActivado$_: 0
}, {
    _$varVolume$_: 0
}, {
    _$sliderValue$_: 0
}, {
    _$tindex$_: 0
}, {
    _$sindex$_: 0
}, {
    _$BETA_ACTIVO$_: 0
}, {
    _$VIDAS_BLQAZUL$_: 0
}, {
    _$PositionX$_: 0
}, {
    _$PositionY$_: 0
}, {
    _$Message$_: 0
} ], self._$InstanceType$_ = {
    _$ElegirParte1$_: class extends self._$IButtonInstance$_ {},
    _$ElegirParte2$_: class extends self._$IButtonInstance$_ {},
    _$ElegirParte3$_: class extends self._$IButtonInstance$_ {},
    _$MultijugadorLocal$_: class extends self._$IButtonInstance$_ {},
    _$MultijugadorOnline$_: class extends self._$IButtonInstance$_ {},
    _$PSdFA$_: class extends self._$IButtonInstance$_ {},
    _$PAdFA$_: class extends self._$IButtonInstance$_ {},
    _$xd$_: class extends self._$IButtonInstance$_ {},
    _$checkboxEPICO$_: class extends self._$ISpriteInstance$_ {},
    _$checkboxEPICO2$_: class extends self._$ISpriteInstance$_ {},
    _$checkboxEPICO3$_: class extends self._$ISpriteInstance$_ {},
    _$BotonElegirPartes$_: class extends self._$IButtonInstance$_ {},
    _$BotonIrAlTitulo$_: class extends self._$IButtonInstance$_ {},
    _$BotonAjustes$_: class extends self._$IButtonInstance$_ {},
    _$BotonCrearNivel$_: class extends self._$IButtonInstance$_ {},
    _$BotonIrAlMenu$_: class extends self._$IButtonInstance$_ {},
    _$BotonMultijugador$_: class extends self._$IButtonInstance$_ {},
    _$BotonJugarVersion25D$_: class extends self._$IButtonInstance$_ {},
    _$BotonMasAjustes$_: class extends self._$IButtonInstance$_ {},
    _$BotonActualizaciones$_: class extends self._$IButtonInstance$_ {},
    _$BotonSecreto1$_: class extends self._$IButtonInstance$_ {},
    _$IZQ$_: class extends self._$ISpriteInstance$_ {},
    _$DER$_: class extends self._$ISpriteInstance$_ {},
    _$Imagen_BotonElegirPartes$_: class extends self._$ISpriteInstance$_ {},
    "_$Imagen_BotonrAlTitulo$_": class extends self._$ISpriteInstance$_ {},
    "_$Imagen_BotonrAlTitulo2$_": class extends self._$ISpriteInstance$_ {},
    _$Imagen_BotonJugar$_: class extends self._$ISpriteInstance$_ {},
    _$Imagen_BotonAjustes$_: class extends self._$ISpriteInstance$_ {},
    _$Imagen_BotonCrearNivel$_: class extends self._$ISpriteInstance$_ {},
    E: class extends self._$ISpriteInstance$_ {},
    _$Imagen_StickConectado$_: class extends self._$ISpriteInstance$_ {},
    _$Boton_Generico$_: class extends self._$ISpriteInstance$_ {},
    _$BotonJugarIMG$_: class extends self._$ISpriteInstance$_ {},
    _$BotonSalirIMG$_: class extends self._$ISpriteInstance$_ {},
    _$BotonAjustesIMG$_: class extends self._$ISpriteInstance$_ {},
    _$BotonJugarVersionAntiguaIMG$_: class extends self._$ISpriteInstance$_ {},
    _$BotonCreadorDeNivelesIMG$_: class extends self._$ISpriteInstance$_ {},
    _$BotonIrAlTituloIMG$_: class extends self._$ISpriteInstance$_ {},
    _$BotnActualizacionesIMG$_: class extends self._$ISpriteInstance$_ {},
    _$BloqueAzul$_: class extends self._$ISpriteInstance$_ {},
    _$BloqueNaranja$_: class extends self._$ISpriteInstance$_ {},
    _$BloqueAzulMano$_: class extends self._$ISpriteInstance$_ {},
    _$BloqueNaranjaMano$_: class extends self._$ISpriteInstance$_ {},
    _$BloqueDummy$_: class extends self._$ISpriteInstance$_ {},
    _$Mando$_: class extends self._$IInstance$_ {},
    _$Mouse$_: class extends self._$IInstance$_ {},
    _$Navegador$_: class extends self._$IInstance$_ {},
    _$Teclado$_: class extends self._$IInstance$_ {},
    _$Texto$_: class extends self._$ITextInstance$_ {},
    _$SPRITEFONT$_: class extends self._$ISpriteFontInstance$_ {},
    Touch: class extends self._$IInstance$_ {},
    _$AirParticle$_: class extends self._$ISpriteInstance$_ {},
    _$Background$_: class extends self._$ITiledBackgroundInstance$_ {},
    _$BlastEffect$_: class extends self._$ISpriteInstance$_ {},
    _$Cursor$_: class extends self._$IWorldInstance$_ {},
    _$List$_: class extends self._$IListInstance$_ {},
    _$LoadButton$_: class extends self._$IButtonInstance$_ {},
    _$NotificationBox$_: class extends self._$ITiledBackgroundInstance$_ {},
    _$NotificationText$_: class extends self._$ITextInstance$_ {},
    _$SaveButton$_: class extends self._$IButtonInstance$_ {},
    _$Tool$_: class extends self._$IListInstance$_ {},
    _$Tutorial$_: class extends self._$ITextInstance$_ {},
    _$World$_: class extends self._$ITilemapInstance$_ {},
    _$LocalStorage$_: class extends self._$IInstance$_ {},
    _$PlatformInfo$_: class extends self._$IInstance$_ {},
    _$ColocarMeta$_: class extends self._$ISpriteInstance$_ {},
    _$Metaaaa$_: class extends self._$ISpriteInstance$_ {},
    _$LeMeta$_: class extends self._$ITilemapInstance$_ {},
    _$Salir$_: class extends self._$IButtonInstance$_ {},
    _$Texto2$_: class extends self._$ITextInstance$_ {},
    _$textoAnchoNivel$_: class extends self._$ITextInputInstance$_ {},
    _$textoAltoNivel$_: class extends self._$ITextInputInstance$_ {},
    _$xdwebiwabo$_: class extends self._$ITiledBackgroundInstance$_ {},
    _$BloqueAzul3DVIejo$_: class extends self._$I3DShapeInstance$_ {},
    _$BloqueAzul3DNuevo$_: class extends self._$I3DShapeInstance$_ {},
    _$Piso3D$_: class extends self._$I3DShapeInstance$_ {},
    _$FanArt1$_: class extends self._$ISpriteInstance$_ {},
    _$FanArt2$_: class extends self._$ISpriteInstance$_ {},
    _$ImgSecretoP2_LVL3$_: class extends self._$ISpriteInstance$_ {},
    _$LAVA$_: class extends self._$ISpriteInstance$_ {},
    _$piedra$_: class extends self._$ISpriteInstance$_ {},
    _$LAVA_COLISION$_: class extends self._$ISpriteInstance$_ {},
    _$piedra2$_: class extends self._$ISpriteInstance$_ {},
    _$VidasSpr$_: class extends self._$ISpriteInstance$_ {},
    _$VidaTxt$_: class extends self._$ITextInstance$_ {},
    _$A_Button$_: class extends self._$ISpriteInstance$_ {},
    _$B_Button$_: class extends self._$ISpriteInstance$_ {},
    _$DPAD$_: class extends self._$ISpriteInstance$_ {},
    _$EXIT_BUTTON$_: class extends self._$ISpriteInstance$_ {},
    _$MOV_DER$_: class extends self._$ISpriteInstance$_ {},
    _$MOV_IZQ$_: class extends self._$ISpriteInstance$_ {},
    _$SavingText$_: class extends self._$ITextInstance$_ {},
    _$SolidTile$_: class extends self._$ITiledBackgroundInstance$_ {},
    _$SolidTileCONFISICAS$_: class extends self._$ITiledBackgroundInstance$_ {},
    _$BackgroundTile$_: class extends self._$ITiledBackgroundInstance$_ {},
    _$BGTile$_: class extends self._$ITiledBackgroundInstance$_ {},
    _$TiledBackground$_: class extends self._$ITiledBackgroundInstance$_ {},
    _$GameOverTiled$_: class extends self._$ITiledBackgroundInstance$_ {},
    _$JumpThruTile$_: class extends self._$ITiledBackgroundInstance$_ {},
    _$MovingSolidTile$_: class extends self._$ITiledBackgroundInstance$_ {},
    _$SoildTileDESPAWN$_: class extends self._$ITiledBackgroundInstance$_ {},
    _$SolidTile2$_: class extends self._$ITiledBackgroundInstance$_ {},
    _$SolidTile3$_: class extends self._$ITiledBackgroundInstance$_ {},
    _$SolidTileDORADO$_: class extends self._$ITiledBackgroundInstance$_ {},
    _$SolidTileMASOSCURO$_: class extends self._$ITiledBackgroundInstance$_ {},
    _$SolidTilePINCHO$_: class extends self._$ITiledBackgroundInstance$_ {},
    _$SolidTileSPAWN$_: class extends self._$ITiledBackgroundInstance$_ {},
    _$RedTile$_: class extends self._$ITiledBackgroundInstance$_ {},
    _$Pincho$_: class extends self._$ISpriteInstance$_ {},
    _$TextImages$_: class extends self._$ISpriteInstance$_ {},
    _$ControlDeslizante$_: class extends self._$ISliderBarInstance$_ {},
    Audio: class extends self._$IInstance$_ {},
    _$Diccionario$_: class extends self._$IDictionaryInstance$_ {},
    _$Llave$_: class extends self._$ISpriteInstance$_ {},
    _$Puerta$_: class extends self._$ISpriteInstance$_ {},
    _$invisible$_: class extends self._$ISpriteInstance$_ {},
    _$Meta$_: class extends self._$ISpriteInstance$_ {},
    _$Pasto$_: class extends self._$ISpriteInstance$_ {},
    _$enemigo$_: class extends self._$ISpriteInstance$_ {},
    _$enemigo_muere$_: class extends self._$ISpriteInstance$_ {},
    _$Casita$_: class extends self._$ISpriteInstance$_ {},
    _$Cama$_: class extends self._$ISpriteInstance$_ {},
    _$Moneda$_: class extends self._$ISpriteInstance$_ {},
    "_$Geolocalizacin$_": class extends self._$IInstance$_ {},
    _$FlechaQueMiraAbajo$_: class extends self._$ISpriteInstance$_ {},
    _$SpriteCuidado$_: class extends self._$ISpriteInstance$_ {},
    Text: class extends self._$ITextInstance$_ {},
    _$PaStOoOoOo$_: class extends self._$ISpriteInstance$_ {},
    _$VerdaderaMeta$_: class extends self._$ISpriteInstance$_ {},
    _$PisoInvisible$_: class extends self._$ISpriteInstance$_ {},
    _$ParedInvisible$_: class extends self._$ISpriteInstance$_ {},
    _$BloqueAzulBrazos$_: class extends self._$ISpriteInstance$_ {},
    _$Text2$_: class extends self._$ITextInstance$_ {},
    _$_1UP$_: class extends self._$ISpriteInstance$_ {},
    _$Desconocido$_: class extends self._$ISpriteInstance$_ {},
    _$OtraAyuda$_: class extends self._$ITextInstance$_ {},
    _$la_ayuda_xdd$_: class extends self._$ITextInputInstance$_ {},
    _$Flecha$_: class extends self._$ISpriteInstance$_ {},
    _$EasterEgg1$_: class extends self._$ISpriteInstance$_ {},
    _$PuertaEasterEgg1$_: class extends self._$ISpriteInstance$_ {},
    _$Vidas$_: class extends self._$ITextInstance$_ {},
    _$BloqueAzulVidas$_: class extends self._$ISpriteInstance$_ {},
    _$comoJugar$_: class extends self._$ISpriteInstance$_ {},
    _$xdTEMP$_: class extends self._$ISpriteInstance$_ {},
    _$TextInput$_: class extends self._$ITextInputInstance$_ {},
    _$FondoEnMosaico$_: class extends self._$ITiledBackgroundInstance$_ {},
    _$FondoXD$_: class extends self._$ISpriteInstance$_ {},
    _$MapaDeTeselas$_: class extends self._$ITilemapInstance$_ {},
    _$Sprite2$_: class extends self._$ISpriteInstance$_ {},
    _$goofyBackground$_: class extends self._$ISpriteInstance$_ {},
    _$comoJugar2$_: class extends self._$ISpriteInstance$_ {},
    _$Sprite$_: class extends self._$ISpriteInstance$_ {},
    "_$ControladorDeLaLneaDeTiempo$_": class extends self._$IInstance$_ {},
    _$thumb$_: class extends self._$ISpriteInstance$_ {},
    _$txtSlider$_: class extends self._$ITextInstance$_ {},
    _$txtVolume$_: class extends self._$ITextInstance$_ {},
    track: class extends self._$ISpriteInstance$_ {},
    _$enemigo_circulo$_: class extends self._$ISpriteInstance$_ {},
    _$SECRETO3$_: class extends self._$ISpriteInstance$_ {},
    _$PICHA_SECRETO3$_: class extends self._$ISpriteInstance$_ {},
    _$spring$_: class extends self._$ISpriteInstance$_ {},
    _$enemigo2$_: class extends self._$ISpriteInstance$_ {},
    _$pillarrojosecreto$_: class extends self._$ISpriteInstance$_ {},
    _$CONTADOR_P3_SECRETO2$_: class extends self._$ITextInstance$_ {},
    _$pillarrojosecreto_spawn$_: class extends self._$ISpriteInstance$_ {},
    _$Multijugador$_: class extends self._$IInstance$_ {},
    _$EscaleraESCALON$_: class extends self._$ISpriteInstance$_ {},
    _$QRCode$_: class extends self._$IQRCodeInstance$_ {},
    _$Text3$_: class extends self._$ITextInstance$_ {},
    _$BlogUpdates$_: class extends self._$IIframeInstance$_ {},
    _$enemigo3$_: class extends self._$ISpriteInstance$_ {},
    _$Video$_: class extends self._$IWorldInstance$_ {}
};